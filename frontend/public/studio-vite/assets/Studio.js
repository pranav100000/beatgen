var bT = Object.defineProperty;
var _T = (e, t, n) => t in e ? bT(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var xe = (e, t, n) => _T(e, typeof t != "symbol" ? t + "" : t, n);
function ST(e, t) {
  for (var n = 0; n < t.length; n++) {
    const r = t[n];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const i in r)
        if (i !== "default" && !(i in e)) {
          const s = Object.getOwnPropertyDescriptor(r, i);
          s && Object.defineProperty(e, i, s.get ? s : {
            enumerable: !0,
            get: () => r[i]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
var Kg = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function hh(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function xT(e) {
  if (Object.prototype.hasOwnProperty.call(e, "__esModule")) return e;
  var t = e.default;
  if (typeof t == "function") {
    var n = function r() {
      return this instanceof r ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    n.prototype = t.prototype;
  } else n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(e).forEach(function(r) {
    var i = Object.getOwnPropertyDescriptor(e, r);
    Object.defineProperty(n, r, i.get ? i : {
      enumerable: !0,
      get: function() {
        return e[r];
      }
    });
  }), n;
}
var lg = { exports: {} }, Uu = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var uv;
function TT() {
  if (uv) return Uu;
  uv = 1;
  var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.fragment");
  function n(r, i, s) {
    var l = null;
    if (s !== void 0 && (l = "" + s), i.key !== void 0 && (l = "" + i.key), "key" in i) {
      s = {};
      for (var c in i)
        c !== "key" && (s[c] = i[c]);
    } else s = i;
    return i = s.ref, {
      $$typeof: e,
      type: r,
      key: l,
      ref: i !== void 0 ? i : null,
      props: s
    };
  }
  return Uu.Fragment = t, Uu.jsx = n, Uu.jsxs = n, Uu;
}
var dv;
function CT() {
  return dv || (dv = 1, lg.exports = TT()), lg.exports;
}
var W = CT(), cg = { exports: {} }, Ne = {};
/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hv;
function wT() {
  if (hv) return Ne;
  hv = 1;
  var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), s = Symbol.for("react.consumer"), l = Symbol.for("react.context"), c = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), d = Symbol.for("react.memo"), h = Symbol.for("react.lazy"), p = Symbol.iterator;
  function v(V) {
    return V === null || typeof V != "object" ? null : (V = p && V[p] || V["@@iterator"], typeof V == "function" ? V : null);
  }
  var m = {
    isMounted: function() {
      return !1;
    },
    enqueueForceUpdate: function() {
    },
    enqueueReplaceState: function() {
    },
    enqueueSetState: function() {
    }
  }, g = Object.assign, b = {};
  function x(V, Z, ct) {
    this.props = V, this.context = Z, this.refs = b, this.updater = ct || m;
  }
  x.prototype.isReactComponent = {}, x.prototype.setState = function(V, Z) {
    if (typeof V != "object" && typeof V != "function" && V != null)
      throw Error(
        "takes an object of state variables to update or a function which returns an object of state variables."
      );
    this.updater.enqueueSetState(this, V, Z, "setState");
  }, x.prototype.forceUpdate = function(V) {
    this.updater.enqueueForceUpdate(this, V, "forceUpdate");
  };
  function w() {
  }
  w.prototype = x.prototype;
  function T(V, Z, ct) {
    this.props = V, this.context = Z, this.refs = b, this.updater = ct || m;
  }
  var S = T.prototype = new w();
  S.constructor = T, g(S, x.prototype), S.isPureReactComponent = !0;
  var C = Array.isArray, E = { H: null, A: null, T: null, S: null }, O = Object.prototype.hasOwnProperty;
  function B(V, Z, ct, et, rt, st) {
    return ct = st.ref, {
      $$typeof: e,
      type: V,
      key: Z,
      ref: ct !== void 0 ? ct : null,
      props: st
    };
  }
  function N(V, Z) {
    return B(
      V.type,
      Z,
      void 0,
      void 0,
      void 0,
      V.props
    );
  }
  function L(V) {
    return typeof V == "object" && V !== null && V.$$typeof === e;
  }
  function k(V) {
    var Z = { "=": "=0", ":": "=2" };
    return "$" + V.replace(/[=:]/g, function(ct) {
      return Z[ct];
    });
  }
  var F = /\/+/g;
  function G(V, Z) {
    return typeof V == "object" && V !== null && V.key != null ? k("" + V.key) : Z.toString(36);
  }
  function M() {
  }
  function j(V) {
    switch (V.status) {
      case "fulfilled":
        return V.value;
      case "rejected":
        throw V.reason;
      default:
        switch (typeof V.status == "string" ? V.then(M, M) : (V.status = "pending", V.then(
          function(Z) {
            V.status === "pending" && (V.status = "fulfilled", V.value = Z);
          },
          function(Z) {
            V.status === "pending" && (V.status = "rejected", V.reason = Z);
          }
        )), V.status) {
          case "fulfilled":
            return V.value;
          case "rejected":
            throw V.reason;
        }
    }
    throw V;
  }
  function D(V, Z, ct, et, rt) {
    var st = typeof V;
    (st === "undefined" || st === "boolean") && (V = null);
    var yt = !1;
    if (V === null) yt = !0;
    else
      switch (st) {
        case "bigint":
        case "string":
        case "number":
          yt = !0;
          break;
        case "object":
          switch (V.$$typeof) {
            case e:
            case t:
              yt = !0;
              break;
            case h:
              return yt = V._init, D(
                yt(V._payload),
                Z,
                ct,
                et,
                rt
              );
          }
      }
    if (yt)
      return rt = rt(V), yt = et === "" ? "." + G(V, 0) : et, C(rt) ? (ct = "", yt != null && (ct = yt.replace(F, "$&/") + "/"), D(rt, Z, ct, "", function(ot) {
        return ot;
      })) : rt != null && (L(rt) && (rt = N(
        rt,
        ct + (rt.key == null || V && V.key === rt.key ? "" : ("" + rt.key).replace(
          F,
          "$&/"
        ) + "/") + yt
      )), Z.push(rt)), 1;
    yt = 0;
    var J = et === "" ? "." : et + ":";
    if (C(V))
      for (var tt = 0; tt < V.length; tt++)
        et = V[tt], st = J + G(et, tt), yt += D(
          et,
          Z,
          ct,
          st,
          rt
        );
    else if (tt = v(V), typeof tt == "function")
      for (V = tt.call(V), tt = 0; !(et = V.next()).done; )
        et = et.value, st = J + G(et, tt++), yt += D(
          et,
          Z,
          ct,
          st,
          rt
        );
    else if (st === "object") {
      if (typeof V.then == "function")
        return D(
          j(V),
          Z,
          ct,
          et,
          rt
        );
      throw Z = String(V), Error(
        "Objects are not valid as a React child (found: " + (Z === "[object Object]" ? "object with keys {" + Object.keys(V).join(", ") + "}" : Z) + "). If you meant to render a collection of children, use an array instead."
      );
    }
    return yt;
  }
  function z(V, Z, ct) {
    if (V == null) return V;
    var et = [], rt = 0;
    return D(V, et, "", "", function(st) {
      return Z.call(ct, st, rt++);
    }), et;
  }
  function H(V) {
    if (V._status === -1) {
      var Z = V._result;
      Z = Z(), Z.then(
        function(ct) {
          (V._status === 0 || V._status === -1) && (V._status = 1, V._result = ct);
        },
        function(ct) {
          (V._status === 0 || V._status === -1) && (V._status = 2, V._result = ct);
        }
      ), V._status === -1 && (V._status = 0, V._result = Z);
    }
    if (V._status === 1) return V._result.default;
    throw V._result;
  }
  var X = typeof reportError == "function" ? reportError : function(V) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var Z = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof V == "object" && V !== null && typeof V.message == "string" ? String(V.message) : String(V),
        error: V
      });
      if (!window.dispatchEvent(Z)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", V);
      return;
    }
    console.error(V);
  };
  function Y() {
  }
  return Ne.Children = {
    map: z,
    forEach: function(V, Z, ct) {
      z(
        V,
        function() {
          Z.apply(this, arguments);
        },
        ct
      );
    },
    count: function(V) {
      var Z = 0;
      return z(V, function() {
        Z++;
      }), Z;
    },
    toArray: function(V) {
      return z(V, function(Z) {
        return Z;
      }) || [];
    },
    only: function(V) {
      if (!L(V))
        throw Error(
          "React.Children.only expected to receive a single React element child."
        );
      return V;
    }
  }, Ne.Component = x, Ne.Fragment = n, Ne.Profiler = i, Ne.PureComponent = T, Ne.StrictMode = r, Ne.Suspense = u, Ne.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = E, Ne.act = function() {
    throw Error("act(...) is not supported in production builds of React.");
  }, Ne.cache = function(V) {
    return function() {
      return V.apply(null, arguments);
    };
  }, Ne.cloneElement = function(V, Z, ct) {
    if (V == null)
      throw Error(
        "The argument must be a React element, but you passed " + V + "."
      );
    var et = g({}, V.props), rt = V.key, st = void 0;
    if (Z != null)
      for (yt in Z.ref !== void 0 && (st = void 0), Z.key !== void 0 && (rt = "" + Z.key), Z)
        !O.call(Z, yt) || yt === "key" || yt === "__self" || yt === "__source" || yt === "ref" && Z.ref === void 0 || (et[yt] = Z[yt]);
    var yt = arguments.length - 2;
    if (yt === 1) et.children = ct;
    else if (1 < yt) {
      for (var J = Array(yt), tt = 0; tt < yt; tt++)
        J[tt] = arguments[tt + 2];
      et.children = J;
    }
    return B(V.type, rt, void 0, void 0, st, et);
  }, Ne.createContext = function(V) {
    return V = {
      $$typeof: l,
      _currentValue: V,
      _currentValue2: V,
      _threadCount: 0,
      Provider: null,
      Consumer: null
    }, V.Provider = V, V.Consumer = {
      $$typeof: s,
      _context: V
    }, V;
  }, Ne.createElement = function(V, Z, ct) {
    var et, rt = {}, st = null;
    if (Z != null)
      for (et in Z.key !== void 0 && (st = "" + Z.key), Z)
        O.call(Z, et) && et !== "key" && et !== "__self" && et !== "__source" && (rt[et] = Z[et]);
    var yt = arguments.length - 2;
    if (yt === 1) rt.children = ct;
    else if (1 < yt) {
      for (var J = Array(yt), tt = 0; tt < yt; tt++)
        J[tt] = arguments[tt + 2];
      rt.children = J;
    }
    if (V && V.defaultProps)
      for (et in yt = V.defaultProps, yt)
        rt[et] === void 0 && (rt[et] = yt[et]);
    return B(V, st, void 0, void 0, null, rt);
  }, Ne.createRef = function() {
    return { current: null };
  }, Ne.forwardRef = function(V) {
    return { $$typeof: c, render: V };
  }, Ne.isValidElement = L, Ne.lazy = function(V) {
    return {
      $$typeof: h,
      _payload: { _status: -1, _result: V },
      _init: H
    };
  }, Ne.memo = function(V, Z) {
    return {
      $$typeof: d,
      type: V,
      compare: Z === void 0 ? null : Z
    };
  }, Ne.startTransition = function(V) {
    var Z = E.T, ct = {};
    E.T = ct;
    try {
      var et = V(), rt = E.S;
      rt !== null && rt(ct, et), typeof et == "object" && et !== null && typeof et.then == "function" && et.then(Y, X);
    } catch (st) {
      X(st);
    } finally {
      E.T = Z;
    }
  }, Ne.unstable_useCacheRefresh = function() {
    return E.H.useCacheRefresh();
  }, Ne.use = function(V) {
    return E.H.use(V);
  }, Ne.useActionState = function(V, Z, ct) {
    return E.H.useActionState(V, Z, ct);
  }, Ne.useCallback = function(V, Z) {
    return E.H.useCallback(V, Z);
  }, Ne.useContext = function(V) {
    return E.H.useContext(V);
  }, Ne.useDebugValue = function() {
  }, Ne.useDeferredValue = function(V, Z) {
    return E.H.useDeferredValue(V, Z);
  }, Ne.useEffect = function(V, Z) {
    return E.H.useEffect(V, Z);
  }, Ne.useId = function() {
    return E.H.useId();
  }, Ne.useImperativeHandle = function(V, Z, ct) {
    return E.H.useImperativeHandle(V, Z, ct);
  }, Ne.useInsertionEffect = function(V, Z) {
    return E.H.useInsertionEffect(V, Z);
  }, Ne.useLayoutEffect = function(V, Z) {
    return E.H.useLayoutEffect(V, Z);
  }, Ne.useMemo = function(V, Z) {
    return E.H.useMemo(V, Z);
  }, Ne.useOptimistic = function(V, Z) {
    return E.H.useOptimistic(V, Z);
  }, Ne.useReducer = function(V, Z, ct) {
    return E.H.useReducer(V, Z, ct);
  }, Ne.useRef = function(V) {
    return E.H.useRef(V);
  }, Ne.useState = function(V) {
    return E.H.useState(V);
  }, Ne.useSyncExternalStore = function(V, Z, ct) {
    return E.H.useSyncExternalStore(
      V,
      Z,
      ct
    );
  }, Ne.useTransition = function() {
    return E.H.useTransition();
  }, Ne.version = "19.0.0", Ne;
}
var fv;
function O0() {
  return fv || (fv = 1, cg.exports = wT()), cg.exports;
}
var K = O0();
const ke = /* @__PURE__ */ hh(K), Yg = /* @__PURE__ */ ST({
  __proto__: null,
  default: ke
}, [K]), Jd = {
  black: "#000",
  white: "#fff"
}, pc = {
  300: "#e57373",
  400: "#ef5350",
  500: "#f44336",
  700: "#d32f2f",
  800: "#c62828"
}, mc = {
  50: "#f3e5f5",
  200: "#ce93d8",
  300: "#ba68c8",
  400: "#ab47bc",
  500: "#9c27b0",
  700: "#7b1fa2"
}, gc = {
  50: "#e3f2fd",
  200: "#90caf9",
  400: "#42a5f5",
  700: "#1976d2",
  800: "#1565c0"
}, yc = {
  300: "#4fc3f7",
  400: "#29b6f6",
  500: "#03a9f4",
  700: "#0288d1",
  900: "#01579b"
}, vc = {
  300: "#81c784",
  400: "#66bb6a",
  500: "#4caf50",
  700: "#388e3c",
  800: "#2e7d32",
  900: "#1b5e20"
}, Vu = {
  300: "#ffb74d",
  400: "#ffa726",
  500: "#ff9800",
  700: "#f57c00",
  900: "#e65100"
}, ET = {
  50: "#fafafa",
  100: "#f5f5f5",
  200: "#eeeeee",
  300: "#e0e0e0",
  400: "#bdbdbd",
  500: "#9e9e9e",
  600: "#757575",
  700: "#616161",
  800: "#424242",
  900: "#212121",
  A100: "#f5f5f5",
  A200: "#eeeeee",
  A400: "#bdbdbd",
  A700: "#616161"
};
function go(e, ...t) {
  const n = new URL(`https://mui.com/production-error/?code=${e}`);
  return t.forEach((r) => n.searchParams.append("args[]", r)), `Minified MUI error #${e}; visit ${n} for the full message.`;
}
const Ep = "$$material";
function Qf() {
  return Qf = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Qf.apply(null, arguments);
}
function AT(e) {
  if (e.sheet)
    return e.sheet;
  for (var t = 0; t < document.styleSheets.length; t++)
    if (document.styleSheets[t].ownerNode === e)
      return document.styleSheets[t];
}
function kT(e) {
  var t = document.createElement("style");
  return t.setAttribute("data-emotion", e.key), e.nonce !== void 0 && t.setAttribute("nonce", e.nonce), t.appendChild(document.createTextNode("")), t.setAttribute("data-s", ""), t;
}
var RT = /* @__PURE__ */ function() {
  function e(n) {
    var r = this;
    this._insertTag = function(i) {
      var s;
      r.tags.length === 0 ? r.insertionPoint ? s = r.insertionPoint.nextSibling : r.prepend ? s = r.container.firstChild : s = r.before : s = r.tags[r.tags.length - 1].nextSibling, r.container.insertBefore(i, s), r.tags.push(i);
    }, this.isSpeedy = n.speedy === void 0 ? !0 : n.speedy, this.tags = [], this.ctr = 0, this.nonce = n.nonce, this.key = n.key, this.container = n.container, this.prepend = n.prepend, this.insertionPoint = n.insertionPoint, this.before = null;
  }
  var t = e.prototype;
  return t.hydrate = function(r) {
    r.forEach(this._insertTag);
  }, t.insert = function(r) {
    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(kT(this));
    var i = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var s = AT(i);
      try {
        s.insertRule(r, s.cssRules.length);
      } catch {
      }
    } else
      i.appendChild(document.createTextNode(r));
    this.ctr++;
  }, t.flush = function() {
    this.tags.forEach(function(r) {
      var i;
      return (i = r.parentNode) == null ? void 0 : i.removeChild(r);
    }), this.tags = [], this.ctr = 0;
  }, e;
}(), Br = "-ms-", Zf = "-moz-", rn = "-webkit-", z_ = "comm", N0 = "rule", P0 = "decl", MT = "@import", U_ = "@keyframes", OT = "@layer", NT = Math.abs, Ap = String.fromCharCode, PT = Object.assign;
function DT(e, t) {
  return wr(e, 0) ^ 45 ? (((t << 2 ^ wr(e, 0)) << 2 ^ wr(e, 1)) << 2 ^ wr(e, 2)) << 2 ^ wr(e, 3) : 0;
}
function V_(e) {
  return e.trim();
}
function IT(e, t) {
  return (e = t.exec(e)) ? e[0] : e;
}
function sn(e, t, n) {
  return e.replace(t, n);
}
function Xg(e, t) {
  return e.indexOf(t);
}
function wr(e, t) {
  return e.charCodeAt(t) | 0;
}
function th(e, t, n) {
  return e.slice(t, n);
}
function Es(e) {
  return e.length;
}
function D0(e) {
  return e.length;
}
function bf(e, t) {
  return t.push(e), e;
}
function BT(e, t) {
  return e.map(t).join("");
}
var kp = 1, Dc = 1, G_ = 0, si = 0, tr = 0, Xc = "";
function Rp(e, t, n, r, i, s, l) {
  return { value: e, root: t, parent: n, type: r, props: i, children: s, line: kp, column: Dc, length: l, return: "" };
}
function Gu(e, t) {
  return PT(Rp("", null, null, "", null, null, 0), e, { length: -e.length }, t);
}
function FT() {
  return tr;
}
function jT() {
  return tr = si > 0 ? wr(Xc, --si) : 0, Dc--, tr === 10 && (Dc = 1, kp--), tr;
}
function Ci() {
  return tr = si < G_ ? wr(Xc, si++) : 0, Dc++, tr === 10 && (Dc = 1, kp++), tr;
}
function Ms() {
  return wr(Xc, si);
}
function Vf() {
  return si;
}
function fh(e, t) {
  return th(Xc, e, t);
}
function eh(e) {
  switch (e) {
    // \0 \t \n \r \s whitespace token
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    // ! + , / > @ ~ isolate token
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    // ; { } breakpoint token
    case 59:
    case 123:
    case 125:
      return 4;
    // : accompanied token
    case 58:
      return 3;
    // " ' ( [ opening delimit token
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    // ) ] closing delimit token
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function q_(e) {
  return kp = Dc = 1, G_ = Es(Xc = e), si = 0, [];
}
function H_(e) {
  return Xc = "", e;
}
function Gf(e) {
  return V_(fh(si - 1, Qg(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function LT(e) {
  for (; (tr = Ms()) && tr < 33; )
    Ci();
  return eh(e) > 2 || eh(tr) > 3 ? "" : " ";
}
function zT(e, t) {
  for (; --t && Ci() && !(tr < 48 || tr > 102 || tr > 57 && tr < 65 || tr > 70 && tr < 97); )
    ;
  return fh(e, Vf() + (t < 6 && Ms() == 32 && Ci() == 32));
}
function Qg(e) {
  for (; Ci(); )
    switch (tr) {
      // ] ) " '
      case e:
        return si;
      // " '
      case 34:
      case 39:
        e !== 34 && e !== 39 && Qg(tr);
        break;
      // (
      case 40:
        e === 41 && Qg(e);
        break;
      // \
      case 92:
        Ci();
        break;
    }
  return si;
}
function UT(e, t) {
  for (; Ci() && e + tr !== 57; )
    if (e + tr === 84 && Ms() === 47)
      break;
  return "/*" + fh(t, si - 1) + "*" + Ap(e === 47 ? e : Ci());
}
function VT(e) {
  for (; !eh(Ms()); )
    Ci();
  return fh(e, si);
}
function GT(e) {
  return H_(qf("", null, null, null, [""], e = q_(e), 0, [0], e));
}
function qf(e, t, n, r, i, s, l, c, u) {
  for (var d = 0, h = 0, p = l, v = 0, m = 0, g = 0, b = 1, x = 1, w = 1, T = 0, S = "", C = i, E = s, O = r, B = S; x; )
    switch (g = T, T = Ci()) {
      // (
      case 40:
        if (g != 108 && wr(B, p - 1) == 58) {
          Xg(B += sn(Gf(T), "&", "&\f"), "&\f") != -1 && (w = -1);
          break;
        }
      // " ' [
      case 34:
      case 39:
      case 91:
        B += Gf(T);
        break;
      // \t \n \r \s
      case 9:
      case 10:
      case 13:
      case 32:
        B += LT(g);
        break;
      // \
      case 92:
        B += zT(Vf() - 1, 7);
        continue;
      // /
      case 47:
        switch (Ms()) {
          case 42:
          case 47:
            bf(qT(UT(Ci(), Vf()), t, n), u);
            break;
          default:
            B += "/";
        }
        break;
      // {
      case 123 * b:
        c[d++] = Es(B) * w;
      // } ; \0
      case 125 * b:
      case 59:
      case 0:
        switch (T) {
          // \0 }
          case 0:
          case 125:
            x = 0;
          // ;
          case 59 + h:
            w == -1 && (B = sn(B, /\f/g, "")), m > 0 && Es(B) - p && bf(m > 32 ? mv(B + ";", r, n, p - 1) : mv(sn(B, " ", "") + ";", r, n, p - 2), u);
            break;
          // @ ;
          case 59:
            B += ";";
          // { rule/at-rule
          default:
            if (bf(O = pv(B, t, n, d, h, i, c, S, C = [], E = [], p), s), T === 123)
              if (h === 0)
                qf(B, t, O, O, C, s, p, c, E);
              else
                switch (v === 99 && wr(B, 3) === 110 ? 100 : v) {
                  // d l m s
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    qf(e, O, O, r && bf(pv(e, O, O, 0, 0, i, c, S, i, C = [], p), E), i, E, p, c, r ? C : E);
                    break;
                  default:
                    qf(B, O, O, O, [""], E, 0, c, E);
                }
        }
        d = h = m = 0, b = w = 1, S = B = "", p = l;
        break;
      // :
      case 58:
        p = 1 + Es(B), m = g;
      default:
        if (b < 1) {
          if (T == 123)
            --b;
          else if (T == 125 && b++ == 0 && jT() == 125)
            continue;
        }
        switch (B += Ap(T), T * b) {
          // &
          case 38:
            w = h > 0 ? 1 : (B += "\f", -1);
            break;
          // ,
          case 44:
            c[d++] = (Es(B) - 1) * w, w = 1;
            break;
          // @
          case 64:
            Ms() === 45 && (B += Gf(Ci())), v = Ms(), h = p = Es(S = B += VT(Vf())), T++;
            break;
          // -
          case 45:
            g === 45 && Es(B) == 2 && (b = 0);
        }
    }
  return s;
}
function pv(e, t, n, r, i, s, l, c, u, d, h) {
  for (var p = i - 1, v = i === 0 ? s : [""], m = D0(v), g = 0, b = 0, x = 0; g < r; ++g)
    for (var w = 0, T = th(e, p + 1, p = NT(b = l[g])), S = e; w < m; ++w)
      (S = V_(b > 0 ? v[w] + " " + T : sn(T, /&\f/g, v[w]))) && (u[x++] = S);
  return Rp(e, t, n, i === 0 ? N0 : c, u, d, h);
}
function qT(e, t, n) {
  return Rp(e, t, n, z_, Ap(FT()), th(e, 2, -2), 0);
}
function mv(e, t, n, r) {
  return Rp(e, t, n, P0, th(e, 0, r), th(e, r + 1, -1), r);
}
function Mc(e, t) {
  for (var n = "", r = D0(e), i = 0; i < r; i++)
    n += t(e[i], i, e, t) || "";
  return n;
}
function HT(e, t, n, r) {
  switch (e.type) {
    case OT:
      if (e.children.length) break;
    case MT:
    case P0:
      return e.return = e.return || e.value;
    case z_:
      return "";
    case U_:
      return e.return = e.value + "{" + Mc(e.children, r) + "}";
    case N0:
      e.value = e.props.join(",");
  }
  return Es(n = Mc(e.children, r)) ? e.return = e.value + "{" + n + "}" : "";
}
function WT(e) {
  var t = D0(e);
  return function(n, r, i, s) {
    for (var l = "", c = 0; c < t; c++)
      l += e[c](n, r, i, s) || "";
    return l;
  };
}
function $T(e) {
  return function(t) {
    t.root || (t = t.return) && e(t);
  };
}
function W_(e) {
  var t = /* @__PURE__ */ Object.create(null);
  return function(n) {
    return t[n] === void 0 && (t[n] = e(n)), t[n];
  };
}
var KT = function(t, n, r) {
  for (var i = 0, s = 0; i = s, s = Ms(), i === 38 && s === 12 && (n[r] = 1), !eh(s); )
    Ci();
  return fh(t, si);
}, YT = function(t, n) {
  var r = -1, i = 44;
  do
    switch (eh(i)) {
      case 0:
        i === 38 && Ms() === 12 && (n[r] = 1), t[r] += KT(si - 1, n, r);
        break;
      case 2:
        t[r] += Gf(i);
        break;
      case 4:
        if (i === 44) {
          t[++r] = Ms() === 58 ? "&\f" : "", n[r] = t[r].length;
          break;
        }
      // fallthrough
      default:
        t[r] += Ap(i);
    }
  while (i = Ci());
  return t;
}, XT = function(t, n) {
  return H_(YT(q_(t), n));
}, gv = /* @__PURE__ */ new WeakMap(), QT = function(t) {
  if (!(t.type !== "rule" || !t.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  t.length < 1)) {
    for (var n = t.value, r = t.parent, i = t.column === r.column && t.line === r.line; r.type !== "rule"; )
      if (r = r.parent, !r) return;
    if (!(t.props.length === 1 && n.charCodeAt(0) !== 58 && !gv.get(r)) && !i) {
      gv.set(t, !0);
      for (var s = [], l = XT(n, s), c = r.props, u = 0, d = 0; u < l.length; u++)
        for (var h = 0; h < c.length; h++, d++)
          t.props[d] = s[u] ? l[u].replace(/&\f/g, c[h]) : c[h] + " " + l[u];
    }
  }
}, ZT = function(t) {
  if (t.type === "decl") {
    var n = t.value;
    // charcode for l
    n.charCodeAt(0) === 108 && // charcode for b
    n.charCodeAt(2) === 98 && (t.return = "", t.value = "");
  }
};
function $_(e, t) {
  switch (DT(e, t)) {
    // color-adjust
    case 5103:
      return rn + "print-" + e + e;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return rn + e + e;
    // appearance, user-select, transform, hyphens, text-size-adjust
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return rn + e + Zf + e + Br + e + e;
    // flex, flex-direction
    case 6828:
    case 4268:
      return rn + e + Br + e + e;
    // order
    case 6165:
      return rn + e + Br + "flex-" + e + e;
    // align-items
    case 5187:
      return rn + e + sn(e, /(\w+).+(:[^]+)/, rn + "box-$1$2" + Br + "flex-$1$2") + e;
    // align-self
    case 5443:
      return rn + e + Br + "flex-item-" + sn(e, /flex-|-self/, "") + e;
    // align-content
    case 4675:
      return rn + e + Br + "flex-line-pack" + sn(e, /align-content|flex-|-self/, "") + e;
    // flex-shrink
    case 5548:
      return rn + e + Br + sn(e, "shrink", "negative") + e;
    // flex-basis
    case 5292:
      return rn + e + Br + sn(e, "basis", "preferred-size") + e;
    // flex-grow
    case 6060:
      return rn + "box-" + sn(e, "-grow", "") + rn + e + Br + sn(e, "grow", "positive") + e;
    // transition
    case 4554:
      return rn + sn(e, /([^-])(transform)/g, "$1" + rn + "$2") + e;
    // cursor
    case 6187:
      return sn(sn(sn(e, /(zoom-|grab)/, rn + "$1"), /(image-set)/, rn + "$1"), e, "") + e;
    // background, background-image
    case 5495:
    case 3959:
      return sn(e, /(image-set\([^]*)/, rn + "$1$`$1");
    // justify-content
    case 4968:
      return sn(sn(e, /(.+:)(flex-)?(.*)/, rn + "box-pack:$3" + Br + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + rn + e + e;
    // (margin|padding)-inline-(start|end)
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return sn(e, /(.+)-inline(.+)/, rn + "$1$2") + e;
    // (min|max)?(width|height|inline-size|block-size)
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (Es(e) - 1 - t > 6) switch (wr(e, t + 1)) {
        // (m)ax-content, (m)in-content
        case 109:
          if (wr(e, t + 4) !== 45) break;
        // (f)ill-available, (f)it-content
        case 102:
          return sn(e, /(.+:)(.+)-([^]+)/, "$1" + rn + "$2-$3$1" + Zf + (wr(e, t + 3) == 108 ? "$3" : "$2-$3")) + e;
        // (s)tretch
        case 115:
          return ~Xg(e, "stretch") ? $_(sn(e, "stretch", "fill-available"), t) + e : e;
      }
      break;
    // position: sticky
    case 4949:
      if (wr(e, t + 1) !== 115) break;
    // display: (flex|inline-flex)
    case 6444:
      switch (wr(e, Es(e) - 3 - (~Xg(e, "!important") && 10))) {
        // stic(k)y
        case 107:
          return sn(e, ":", ":" + rn) + e;
        // (inline-)?fl(e)x
        case 101:
          return sn(e, /(.+:)([^;!]+)(;|!.+)?/, "$1" + rn + (wr(e, 14) === 45 ? "inline-" : "") + "box$3$1" + rn + "$2$3$1" + Br + "$2box$3") + e;
      }
      break;
    // writing-mode
    case 5936:
      switch (wr(e, t + 11)) {
        // vertical-l(r)
        case 114:
          return rn + e + Br + sn(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
        // vertical-r(l)
        case 108:
          return rn + e + Br + sn(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
        // horizontal(-)tb
        case 45:
          return rn + e + Br + sn(e, /[svh]\w+-[tblr]{2}/, "lr") + e;
      }
      return rn + e + Br + e + e;
  }
  return e;
}
var JT = function(t, n, r, i) {
  if (t.length > -1 && !t.return) switch (t.type) {
    case P0:
      t.return = $_(t.value, t.length);
      break;
    case U_:
      return Mc([Gu(t, {
        value: sn(t.value, "@", "@" + rn)
      })], i);
    case N0:
      if (t.length) return BT(t.props, function(s) {
        switch (IT(s, /(::plac\w+|:read-\w+)/)) {
          // :read-(only|write)
          case ":read-only":
          case ":read-write":
            return Mc([Gu(t, {
              props: [sn(s, /:(read-\w+)/, ":" + Zf + "$1")]
            })], i);
          // :placeholder
          case "::placeholder":
            return Mc([Gu(t, {
              props: [sn(s, /:(plac\w+)/, ":" + rn + "input-$1")]
            }), Gu(t, {
              props: [sn(s, /:(plac\w+)/, ":" + Zf + "$1")]
            }), Gu(t, {
              props: [sn(s, /:(plac\w+)/, Br + "input-$1")]
            })], i);
        }
        return "";
      });
  }
}, t3 = [JT], e3 = function(t) {
  var n = t.key;
  if (n === "css") {
    var r = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(r, function(b) {
      var x = b.getAttribute("data-emotion");
      x.indexOf(" ") !== -1 && (document.head.appendChild(b), b.setAttribute("data-s", ""));
    });
  }
  var i = t.stylisPlugins || t3, s = {}, l, c = [];
  l = t.container || document.head, Array.prototype.forEach.call(
    // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll('style[data-emotion^="' + n + ' "]'),
    function(b) {
      for (var x = b.getAttribute("data-emotion").split(" "), w = 1; w < x.length; w++)
        s[x[w]] = !0;
      c.push(b);
    }
  );
  var u, d = [QT, ZT];
  {
    var h, p = [HT, $T(function(b) {
      h.insert(b);
    })], v = WT(d.concat(i, p)), m = function(x) {
      return Mc(GT(x), v);
    };
    u = function(x, w, T, S) {
      h = T, m(x ? x + "{" + w.styles + "}" : w.styles), S && (g.inserted[w.name] = !0);
    };
  }
  var g = {
    key: n,
    sheet: new RT({
      key: n,
      container: l,
      nonce: t.nonce,
      speedy: t.speedy,
      prepend: t.prepend,
      insertionPoint: t.insertionPoint
    }),
    nonce: t.nonce,
    inserted: s,
    registered: {},
    insert: u
  };
  return g.sheet.hydrate(c), g;
}, ug = { exports: {} }, ln = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var yv;
function n3() {
  if (yv) return ln;
  yv = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, i = e ? Symbol.for("react.strict_mode") : 60108, s = e ? Symbol.for("react.profiler") : 60114, l = e ? Symbol.for("react.provider") : 60109, c = e ? Symbol.for("react.context") : 60110, u = e ? Symbol.for("react.async_mode") : 60111, d = e ? Symbol.for("react.concurrent_mode") : 60111, h = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, v = e ? Symbol.for("react.suspense_list") : 60120, m = e ? Symbol.for("react.memo") : 60115, g = e ? Symbol.for("react.lazy") : 60116, b = e ? Symbol.for("react.block") : 60121, x = e ? Symbol.for("react.fundamental") : 60117, w = e ? Symbol.for("react.responder") : 60118, T = e ? Symbol.for("react.scope") : 60119;
  function S(E) {
    if (typeof E == "object" && E !== null) {
      var O = E.$$typeof;
      switch (O) {
        case t:
          switch (E = E.type, E) {
            case u:
            case d:
            case r:
            case s:
            case i:
            case p:
              return E;
            default:
              switch (E = E && E.$$typeof, E) {
                case c:
                case h:
                case g:
                case m:
                case l:
                  return E;
                default:
                  return O;
              }
          }
        case n:
          return O;
      }
    }
  }
  function C(E) {
    return S(E) === d;
  }
  return ln.AsyncMode = u, ln.ConcurrentMode = d, ln.ContextConsumer = c, ln.ContextProvider = l, ln.Element = t, ln.ForwardRef = h, ln.Fragment = r, ln.Lazy = g, ln.Memo = m, ln.Portal = n, ln.Profiler = s, ln.StrictMode = i, ln.Suspense = p, ln.isAsyncMode = function(E) {
    return C(E) || S(E) === u;
  }, ln.isConcurrentMode = C, ln.isContextConsumer = function(E) {
    return S(E) === c;
  }, ln.isContextProvider = function(E) {
    return S(E) === l;
  }, ln.isElement = function(E) {
    return typeof E == "object" && E !== null && E.$$typeof === t;
  }, ln.isForwardRef = function(E) {
    return S(E) === h;
  }, ln.isFragment = function(E) {
    return S(E) === r;
  }, ln.isLazy = function(E) {
    return S(E) === g;
  }, ln.isMemo = function(E) {
    return S(E) === m;
  }, ln.isPortal = function(E) {
    return S(E) === n;
  }, ln.isProfiler = function(E) {
    return S(E) === s;
  }, ln.isStrictMode = function(E) {
    return S(E) === i;
  }, ln.isSuspense = function(E) {
    return S(E) === p;
  }, ln.isValidElementType = function(E) {
    return typeof E == "string" || typeof E == "function" || E === r || E === d || E === s || E === i || E === p || E === v || typeof E == "object" && E !== null && (E.$$typeof === g || E.$$typeof === m || E.$$typeof === l || E.$$typeof === c || E.$$typeof === h || E.$$typeof === x || E.$$typeof === w || E.$$typeof === T || E.$$typeof === b);
  }, ln.typeOf = S, ln;
}
var vv;
function r3() {
  return vv || (vv = 1, ug.exports = n3()), ug.exports;
}
var dg, bv;
function i3() {
  if (bv) return dg;
  bv = 1;
  var e = r3(), t = {
    childContextTypes: !0,
    contextType: !0,
    contextTypes: !0,
    defaultProps: !0,
    displayName: !0,
    getDefaultProps: !0,
    getDerivedStateFromError: !0,
    getDerivedStateFromProps: !0,
    mixins: !0,
    propTypes: !0,
    type: !0
  }, n = {
    name: !0,
    length: !0,
    prototype: !0,
    caller: !0,
    callee: !0,
    arguments: !0,
    arity: !0
  }, r = {
    $$typeof: !0,
    render: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0
  }, i = {
    $$typeof: !0,
    compare: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0,
    type: !0
  }, s = {};
  s[e.ForwardRef] = r, s[e.Memo] = i;
  function l(g) {
    return e.isMemo(g) ? i : s[g.$$typeof] || t;
  }
  var c = Object.defineProperty, u = Object.getOwnPropertyNames, d = Object.getOwnPropertySymbols, h = Object.getOwnPropertyDescriptor, p = Object.getPrototypeOf, v = Object.prototype;
  function m(g, b, x) {
    if (typeof b != "string") {
      if (v) {
        var w = p(b);
        w && w !== v && m(g, w, x);
      }
      var T = u(b);
      d && (T = T.concat(d(b)));
      for (var S = l(g), C = l(b), E = 0; E < T.length; ++E) {
        var O = T[E];
        if (!n[O] && !(x && x[O]) && !(C && C[O]) && !(S && S[O])) {
          var B = h(b, O);
          try {
            c(g, O, B);
          } catch {
          }
        }
      }
    }
    return g;
  }
  return dg = m, dg;
}
i3();
var s3 = !0;
function K_(e, t, n) {
  var r = "";
  return n.split(" ").forEach(function(i) {
    e[i] !== void 0 ? t.push(e[i] + ";") : i && (r += i + " ");
  }), r;
}
var I0 = function(t, n, r) {
  var i = t.key + "-" + n.name;
  // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  (r === !1 || // we need to always store it if we're in compat mode and
  // in node since emotion-server relies on whether a style is in
  // the registered cache to know whether a style is global or not
  // also, note that this check will be dead code eliminated in the browser
  s3 === !1) && t.registered[i] === void 0 && (t.registered[i] = n.styles);
}, B0 = function(t, n, r) {
  I0(t, n, r);
  var i = t.key + "-" + n.name;
  if (t.inserted[n.name] === void 0) {
    var s = n;
    do
      t.insert(n === s ? "." + i : "", s, t.sheet, !0), s = s.next;
    while (s !== void 0);
  }
};
function o3(e) {
  for (var t = 0, n, r = 0, i = e.length; i >= 4; ++r, i -= 4)
    n = e.charCodeAt(r) & 255 | (e.charCodeAt(++r) & 255) << 8 | (e.charCodeAt(++r) & 255) << 16 | (e.charCodeAt(++r) & 255) << 24, n = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= /* k >>> r: */
    n >>> 24, t = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  switch (i) {
    case 3:
      t ^= (e.charCodeAt(r + 2) & 255) << 16;
    case 2:
      t ^= (e.charCodeAt(r + 1) & 255) << 8;
    case 1:
      t ^= e.charCodeAt(r) & 255, t = /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  }
  return t ^= t >>> 13, t = /* Math.imul(h, m): */
  (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
}
var a3 = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, l3 = /[A-Z]|^ms/g, c3 = /_EMO_([^_]+?)_([^]*?)_EMO_/g, Y_ = function(t) {
  return t.charCodeAt(1) === 45;
}, _v = function(t) {
  return t != null && typeof t != "boolean";
}, hg = /* @__PURE__ */ W_(function(e) {
  return Y_(e) ? e : e.replace(l3, "-$&").toLowerCase();
}), Sv = function(t, n) {
  switch (t) {
    case "animation":
    case "animationName":
      if (typeof n == "string")
        return n.replace(c3, function(r, i, s) {
          return As = {
            name: i,
            styles: s,
            next: As
          }, i;
        });
  }
  return a3[t] !== 1 && !Y_(t) && typeof n == "number" && n !== 0 ? n + "px" : n;
};
function nh(e, t, n) {
  if (n == null)
    return "";
  var r = n;
  if (r.__emotion_styles !== void 0)
    return r;
  switch (typeof n) {
    case "boolean":
      return "";
    case "object": {
      var i = n;
      if (i.anim === 1)
        return As = {
          name: i.name,
          styles: i.styles,
          next: As
        }, i.name;
      var s = n;
      if (s.styles !== void 0) {
        var l = s.next;
        if (l !== void 0)
          for (; l !== void 0; )
            As = {
              name: l.name,
              styles: l.styles,
              next: As
            }, l = l.next;
        var c = s.styles + ";";
        return c;
      }
      return u3(e, t, n);
    }
    case "function": {
      if (e !== void 0) {
        var u = As, d = n(e);
        return As = u, nh(e, t, d);
      }
      break;
    }
  }
  var h = n;
  if (t == null)
    return h;
  var p = t[h];
  return p !== void 0 ? p : h;
}
function u3(e, t, n) {
  var r = "";
  if (Array.isArray(n))
    for (var i = 0; i < n.length; i++)
      r += nh(e, t, n[i]) + ";";
  else
    for (var s in n) {
      var l = n[s];
      if (typeof l != "object") {
        var c = l;
        t != null && t[c] !== void 0 ? r += s + "{" + t[c] + "}" : _v(c) && (r += hg(s) + ":" + Sv(s, c) + ";");
      } else if (Array.isArray(l) && typeof l[0] == "string" && (t == null || t[l[0]] === void 0))
        for (var u = 0; u < l.length; u++)
          _v(l[u]) && (r += hg(s) + ":" + Sv(s, l[u]) + ";");
      else {
        var d = nh(e, t, l);
        switch (s) {
          case "animation":
          case "animationName": {
            r += hg(s) + ":" + d + ";";
            break;
          }
          default:
            r += s + "{" + d + "}";
        }
      }
    }
  return r;
}
var xv = /label:\s*([^\s;{]+)\s*(;|$)/g, As;
function ph(e, t, n) {
  if (e.length === 1 && typeof e[0] == "object" && e[0] !== null && e[0].styles !== void 0)
    return e[0];
  var r = !0, i = "";
  As = void 0;
  var s = e[0];
  if (s == null || s.raw === void 0)
    r = !1, i += nh(n, t, s);
  else {
    var l = s;
    i += l[0];
  }
  for (var c = 1; c < e.length; c++)
    if (i += nh(n, t, e[c]), r) {
      var u = s;
      i += u[c];
    }
  xv.lastIndex = 0;
  for (var d = "", h; (h = xv.exec(i)) !== null; )
    d += "-" + h[1];
  var p = o3(i) + d;
  return {
    name: p,
    styles: i,
    next: As
  };
}
var d3 = function(t) {
  return t();
}, X_ = Yg.useInsertionEffect ? Yg.useInsertionEffect : !1, Q_ = X_ || d3, Tv = X_ || K.useLayoutEffect, Z_ = /* @__PURE__ */ K.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement < "u" ? /* @__PURE__ */ e3({
    key: "css"
  }) : null
);
Z_.Provider;
var F0 = function(t) {
  return /* @__PURE__ */ K.forwardRef(function(n, r) {
    var i = K.useContext(Z_);
    return t(n, i, r);
  });
}, Mp = /* @__PURE__ */ K.createContext({}), j0 = {}.hasOwnProperty, Zg = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", h3 = function(t, n) {
  var r = {};
  for (var i in n)
    j0.call(n, i) && (r[i] = n[i]);
  return r[Zg] = t, r;
}, f3 = function(t) {
  var n = t.cache, r = t.serialized, i = t.isStringTag;
  return I0(n, r, i), Q_(function() {
    return B0(n, r, i);
  }), null;
}, p3 = /* @__PURE__ */ F0(function(e, t, n) {
  var r = e.css;
  typeof r == "string" && t.registered[r] !== void 0 && (r = t.registered[r]);
  var i = e[Zg], s = [r], l = "";
  typeof e.className == "string" ? l = K_(t.registered, s, e.className) : e.className != null && (l = e.className + " ");
  var c = ph(s, void 0, K.useContext(Mp));
  l += t.key + "-" + c.name;
  var u = {};
  for (var d in e)
    j0.call(e, d) && d !== "css" && d !== Zg && (u[d] = e[d]);
  return u.className = l, n && (u.ref = n), /* @__PURE__ */ K.createElement(K.Fragment, null, /* @__PURE__ */ K.createElement(f3, {
    cache: t,
    serialized: c,
    isStringTag: typeof i == "string"
  }), /* @__PURE__ */ K.createElement(i, u));
}), m3 = p3, Cv = function(t, n) {
  var r = arguments;
  if (n == null || !j0.call(n, "css"))
    return K.createElement.apply(void 0, r);
  var i = r.length, s = new Array(i);
  s[0] = m3, s[1] = h3(t, n);
  for (var l = 2; l < i; l++)
    s[l] = r[l];
  return K.createElement.apply(null, s);
};
(function(e) {
  var t;
  t || (t = e.JSX || (e.JSX = {}));
})(Cv || (Cv = {}));
var g3 = /* @__PURE__ */ F0(function(e, t) {
  var n = e.styles, r = ph([n], void 0, K.useContext(Mp)), i = K.useRef();
  return Tv(function() {
    var s = t.key + "-global", l = new t.sheet.constructor({
      key: s,
      nonce: t.sheet.nonce,
      container: t.sheet.container,
      speedy: t.sheet.isSpeedy
    }), c = !1, u = document.querySelector('style[data-emotion="' + s + " " + r.name + '"]');
    return t.sheet.tags.length && (l.before = t.sheet.tags[0]), u !== null && (c = !0, u.setAttribute("data-emotion", s), l.hydrate([u])), i.current = [l, c], function() {
      l.flush();
    };
  }, [t]), Tv(function() {
    var s = i.current, l = s[0], c = s[1];
    if (c) {
      s[1] = !1;
      return;
    }
    if (r.next !== void 0 && B0(t, r.next, !0), l.tags.length) {
      var u = l.tags[l.tags.length - 1].nextElementSibling;
      l.before = u, l.flush();
    }
    t.insert("", r, l, !1);
  }, [t, r.name]), null;
});
function L0() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return ph(t);
}
function mh() {
  var e = L0.apply(void 0, arguments), t = "animation-" + e.name;
  return {
    name: t,
    styles: "@keyframes " + t + "{" + e.styles + "}",
    anim: 1,
    toString: function() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
}
var y3 = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, v3 = /* @__PURE__ */ W_(
  function(e) {
    return y3.test(e) || e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) < 91;
  }
  /* Z+1 */
), b3 = v3, _3 = function(t) {
  return t !== "theme";
}, wv = function(t) {
  return typeof t == "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  t.charCodeAt(0) > 96 ? b3 : _3;
}, Ev = function(t, n, r) {
  var i;
  if (n) {
    var s = n.shouldForwardProp;
    i = t.__emotion_forwardProp && s ? function(l) {
      return t.__emotion_forwardProp(l) && s(l);
    } : s;
  }
  return typeof i != "function" && r && (i = t.__emotion_forwardProp), i;
}, S3 = function(t) {
  var n = t.cache, r = t.serialized, i = t.isStringTag;
  return I0(n, r, i), Q_(function() {
    return B0(n, r, i);
  }), null;
}, x3 = function e(t, n) {
  var r = t.__emotion_real === t, i = r && t.__emotion_base || t, s, l;
  n !== void 0 && (s = n.label, l = n.target);
  var c = Ev(t, n, r), u = c || wv(i), d = !u("as");
  return function() {
    var h = arguments, p = r && t.__emotion_styles !== void 0 ? t.__emotion_styles.slice(0) : [];
    if (s !== void 0 && p.push("label:" + s + ";"), h[0] == null || h[0].raw === void 0)
      p.push.apply(p, h);
    else {
      var v = h[0];
      p.push(v[0]);
      for (var m = h.length, g = 1; g < m; g++)
        p.push(h[g], v[g]);
    }
    var b = F0(function(x, w, T) {
      var S = d && x.as || i, C = "", E = [], O = x;
      if (x.theme == null) {
        O = {};
        for (var B in x)
          O[B] = x[B];
        O.theme = K.useContext(Mp);
      }
      typeof x.className == "string" ? C = K_(w.registered, E, x.className) : x.className != null && (C = x.className + " ");
      var N = ph(p.concat(E), w.registered, O);
      C += w.key + "-" + N.name, l !== void 0 && (C += " " + l);
      var L = d && c === void 0 ? wv(S) : u, k = {};
      for (var F in x)
        d && F === "as" || L(F) && (k[F] = x[F]);
      return k.className = C, T && (k.ref = T), /* @__PURE__ */ K.createElement(K.Fragment, null, /* @__PURE__ */ K.createElement(S3, {
        cache: w,
        serialized: N,
        isStringTag: typeof S == "string"
      }), /* @__PURE__ */ K.createElement(S, k));
    });
    return b.displayName = s !== void 0 ? s : "Styled(" + (typeof i == "string" ? i : i.displayName || i.name || "Component") + ")", b.defaultProps = t.defaultProps, b.__emotion_real = b, b.__emotion_base = i, b.__emotion_styles = p, b.__emotion_forwardProp = c, Object.defineProperty(b, "toString", {
      value: function() {
        return "." + l;
      }
    }), b.withComponent = function(x, w) {
      var T = e(x, Qf({}, n, w, {
        shouldForwardProp: Ev(b, w, !0)
      }));
      return T.apply(void 0, p);
    }, b;
  };
}, T3 = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
], Jg = x3.bind(null);
T3.forEach(function(e) {
  Jg[e] = Jg(e);
});
function C3(e) {
  return e == null || Object.keys(e).length === 0;
}
function w3(e) {
  const {
    styles: t,
    defaultTheme: n = {}
  } = e, r = typeof t == "function" ? (i) => t(C3(i) ? n : i) : t;
  return /* @__PURE__ */ W.jsx(g3, {
    styles: r
  });
}
/**
 * @mui/styled-engine v6.4.8
 *
 * @license MIT
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
function J_(e, t) {
  return Jg(e, t);
}
function E3(e, t) {
  Array.isArray(e.__emotion_styles) && (e.__emotion_styles = t(e.__emotion_styles));
}
const Av = [];
function kv(e) {
  return Av[0] = e, ph(Av);
}
var fg = { exports: {} }, pn = {};
/**
 * @license React
 * react-is.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Rv;
function A3() {
  if (Rv) return pn;
  Rv = 1;
  var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), s = Symbol.for("react.consumer"), l = Symbol.for("react.context"), c = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), d = Symbol.for("react.suspense_list"), h = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), v = Symbol.for("react.offscreen"), m = Symbol.for("react.client.reference");
  function g(b) {
    if (typeof b == "object" && b !== null) {
      var x = b.$$typeof;
      switch (x) {
        case e:
          switch (b = b.type, b) {
            case n:
            case i:
            case r:
            case u:
            case d:
              return b;
            default:
              switch (b = b && b.$$typeof, b) {
                case l:
                case c:
                case p:
                case h:
                  return b;
                case s:
                  return b;
                default:
                  return x;
              }
          }
        case t:
          return x;
      }
    }
  }
  return pn.ContextConsumer = s, pn.ContextProvider = l, pn.Element = e, pn.ForwardRef = c, pn.Fragment = n, pn.Lazy = p, pn.Memo = h, pn.Portal = t, pn.Profiler = i, pn.StrictMode = r, pn.Suspense = u, pn.SuspenseList = d, pn.isContextConsumer = function(b) {
    return g(b) === s;
  }, pn.isContextProvider = function(b) {
    return g(b) === l;
  }, pn.isElement = function(b) {
    return typeof b == "object" && b !== null && b.$$typeof === e;
  }, pn.isForwardRef = function(b) {
    return g(b) === c;
  }, pn.isFragment = function(b) {
    return g(b) === n;
  }, pn.isLazy = function(b) {
    return g(b) === p;
  }, pn.isMemo = function(b) {
    return g(b) === h;
  }, pn.isPortal = function(b) {
    return g(b) === t;
  }, pn.isProfiler = function(b) {
    return g(b) === i;
  }, pn.isStrictMode = function(b) {
    return g(b) === r;
  }, pn.isSuspense = function(b) {
    return g(b) === u;
  }, pn.isSuspenseList = function(b) {
    return g(b) === d;
  }, pn.isValidElementType = function(b) {
    return typeof b == "string" || typeof b == "function" || b === n || b === i || b === r || b === u || b === d || b === v || typeof b == "object" && b !== null && (b.$$typeof === p || b.$$typeof === h || b.$$typeof === l || b.$$typeof === s || b.$$typeof === c || b.$$typeof === m || b.getModuleId !== void 0);
  }, pn.typeOf = g, pn;
}
var Mv;
function k3() {
  return Mv || (Mv = 1, fg.exports = /* @__PURE__ */ A3()), fg.exports;
}
var tS = /* @__PURE__ */ k3();
function Rs(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function eS(e) {
  if (/* @__PURE__ */ K.isValidElement(e) || tS.isValidElementType(e) || !Rs(e))
    return e;
  const t = {};
  return Object.keys(e).forEach((n) => {
    t[n] = eS(e[n]);
  }), t;
}
function Fr(e, t, n = {
  clone: !0
}) {
  const r = n.clone ? {
    ...e
  } : e;
  return Rs(e) && Rs(t) && Object.keys(t).forEach((i) => {
    /* @__PURE__ */ K.isValidElement(t[i]) || tS.isValidElementType(t[i]) ? r[i] = t[i] : Rs(t[i]) && // Avoid prototype pollution
    Object.prototype.hasOwnProperty.call(e, i) && Rs(e[i]) ? r[i] = Fr(e[i], t[i], n) : n.clone ? r[i] = Rs(t[i]) ? eS(t[i]) : t[i] : r[i] = t[i];
  }), r;
}
const R3 = (e) => {
  const t = Object.keys(e).map((n) => ({
    key: n,
    val: e[n]
  })) || [];
  return t.sort((n, r) => n.val - r.val), t.reduce((n, r) => ({
    ...n,
    [r.key]: r.val
  }), {});
};
function M3(e) {
  const {
    // The breakpoint **start** at this value.
    // For instance with the first breakpoint xs: [xs, sm).
    values: t = {
      xs: 0,
      // phone
      sm: 600,
      // tablet
      md: 900,
      // small laptop
      lg: 1200,
      // desktop
      xl: 1536
      // large screen
    },
    unit: n = "px",
    step: r = 5,
    ...i
  } = e, s = R3(t), l = Object.keys(s);
  function c(v) {
    return `@media (min-width:${typeof t[v] == "number" ? t[v] : v}${n})`;
  }
  function u(v) {
    return `@media (max-width:${(typeof t[v] == "number" ? t[v] : v) - r / 100}${n})`;
  }
  function d(v, m) {
    const g = l.indexOf(m);
    return `@media (min-width:${typeof t[v] == "number" ? t[v] : v}${n}) and (max-width:${(g !== -1 && typeof t[l[g]] == "number" ? t[l[g]] : m) - r / 100}${n})`;
  }
  function h(v) {
    return l.indexOf(v) + 1 < l.length ? d(v, l[l.indexOf(v) + 1]) : c(v);
  }
  function p(v) {
    const m = l.indexOf(v);
    return m === 0 ? c(l[1]) : m === l.length - 1 ? u(l[m]) : d(v, l[l.indexOf(v) + 1]).replace("@media", "@media not all and");
  }
  return {
    keys: l,
    values: s,
    up: c,
    down: u,
    between: d,
    only: h,
    not: p,
    unit: n,
    ...i
  };
}
function O3(e, t) {
  if (!e.containerQueries)
    return t;
  const n = Object.keys(t).filter((r) => r.startsWith("@container")).sort((r, i) => {
    var l, c;
    const s = /min-width:\s*([0-9.]+)/;
    return +(((l = r.match(s)) == null ? void 0 : l[1]) || 0) - +(((c = i.match(s)) == null ? void 0 : c[1]) || 0);
  });
  return n.length ? n.reduce((r, i) => {
    const s = t[i];
    return delete r[i], r[i] = s, r;
  }, {
    ...t
  }) : t;
}
function N3(e, t) {
  return t === "@" || t.startsWith("@") && (e.some((n) => t.startsWith(`@${n}`)) || !!t.match(/^@\d/));
}
function P3(e, t) {
  const n = t.match(/^@([^/]+)?\/?(.+)?$/);
  if (!n)
    return null;
  const [, r, i] = n, s = Number.isNaN(+r) ? r || 0 : +r;
  return e.containerQueries(i).up(s);
}
function D3(e) {
  const t = (s, l) => s.replace("@media", l ? `@container ${l}` : "@container");
  function n(s, l) {
    s.up = (...c) => t(e.breakpoints.up(...c), l), s.down = (...c) => t(e.breakpoints.down(...c), l), s.between = (...c) => t(e.breakpoints.between(...c), l), s.only = (...c) => t(e.breakpoints.only(...c), l), s.not = (...c) => {
      const u = t(e.breakpoints.not(...c), l);
      return u.includes("not all and") ? u.replace("not all and ", "").replace("min-width:", "width<").replace("max-width:", "width>").replace("and", "or") : u;
    };
  }
  const r = {}, i = (s) => (n(r, s), r);
  return n(i), {
    ...e,
    containerQueries: i
  };
}
const I3 = {
  borderRadius: 4
};
function $d(e, t) {
  return t ? Fr(e, t, {
    clone: !1
    // No need to clone deep, it's way faster.
  }) : e;
}
const Op = {
  xs: 0,
  // phone
  sm: 600,
  // tablet
  md: 900,
  // small laptop
  lg: 1200,
  // desktop
  xl: 1536
  // large screen
}, Ov = {
  // Sorted ASC by size. That's important.
  // It can't be configured as it's used statically for propTypes.
  keys: ["xs", "sm", "md", "lg", "xl"],
  up: (e) => `@media (min-width:${Op[e]}px)`
}, B3 = {
  containerQueries: (e) => ({
    up: (t) => {
      let n = typeof t == "number" ? t : Op[t] || t;
      return typeof n == "number" && (n = `${n}px`), e ? `@container ${e} (min-width:${n})` : `@container (min-width:${n})`;
    }
  })
};
function yo(e, t, n) {
  const r = e.theme || {};
  if (Array.isArray(t)) {
    const s = r.breakpoints || Ov;
    return t.reduce((l, c, u) => (l[s.up(s.keys[u])] = n(t[u]), l), {});
  }
  if (typeof t == "object") {
    const s = r.breakpoints || Ov;
    return Object.keys(t).reduce((l, c) => {
      if (N3(s.keys, c)) {
        const u = P3(r.containerQueries ? r : B3, c);
        u && (l[u] = n(t[c], c));
      } else if (Object.keys(s.values || Op).includes(c)) {
        const u = s.up(c);
        l[u] = n(t[c], c);
      } else {
        const u = c;
        l[u] = t[u];
      }
      return l;
    }, {});
  }
  return n(t);
}
function F3(e = {}) {
  var n;
  return ((n = e.keys) == null ? void 0 : n.reduce((r, i) => {
    const s = e.up(i);
    return r[s] = {}, r;
  }, {})) || {};
}
function j3(e, t) {
  return e.reduce((n, r) => {
    const i = n[r];
    return (!i || Object.keys(i).length === 0) && delete n[r], n;
  }, t);
}
function pe(e) {
  if (typeof e != "string")
    throw new Error(go(7));
  return e.charAt(0).toUpperCase() + e.slice(1);
}
function Np(e, t, n = !0) {
  if (!t || typeof t != "string")
    return null;
  if (e && e.vars && n) {
    const r = `vars.${t}`.split(".").reduce((i, s) => i && i[s] ? i[s] : null, e);
    if (r != null)
      return r;
  }
  return t.split(".").reduce((r, i) => r && r[i] != null ? r[i] : null, e);
}
function Jf(e, t, n, r = n) {
  let i;
  return typeof e == "function" ? i = e(n) : Array.isArray(e) ? i = e[n] || r : i = Np(e, n) || r, t && (i = t(i, r, e)), i;
}
function Kn(e) {
  const {
    prop: t,
    cssProperty: n = e.prop,
    themeKey: r,
    transform: i
  } = e, s = (l) => {
    if (l[t] == null)
      return null;
    const c = l[t], u = l.theme, d = Np(u, r) || {};
    return yo(l, c, (p) => {
      let v = Jf(d, i, p);
      return p === v && typeof p == "string" && (v = Jf(d, i, `${t}${p === "default" ? "" : pe(p)}`, p)), n === !1 ? v : {
        [n]: v
      };
    });
  };
  return s.propTypes = {}, s.filterProps = [t], s;
}
function L3(e) {
  const t = {};
  return (n) => (t[n] === void 0 && (t[n] = e(n)), t[n]);
}
const z3 = {
  m: "margin",
  p: "padding"
}, U3 = {
  t: "Top",
  r: "Right",
  b: "Bottom",
  l: "Left",
  x: ["Left", "Right"],
  y: ["Top", "Bottom"]
}, Nv = {
  marginX: "mx",
  marginY: "my",
  paddingX: "px",
  paddingY: "py"
}, V3 = L3((e) => {
  if (e.length > 2)
    if (Nv[e])
      e = Nv[e];
    else
      return [e];
  const [t, n] = e.split(""), r = z3[t], i = U3[n] || "";
  return Array.isArray(i) ? i.map((s) => r + s) : [r + i];
}), z0 = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"], U0 = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
[...z0, ...U0];
function gh(e, t, n, r) {
  const i = Np(e, t, !0) ?? n;
  return typeof i == "number" || typeof i == "string" ? (s) => typeof s == "string" ? s : typeof i == "string" ? `calc(${s} * ${i})` : i * s : Array.isArray(i) ? (s) => {
    if (typeof s == "string")
      return s;
    const l = Math.abs(s), c = i[l];
    return s >= 0 ? c : typeof c == "number" ? -c : `-${c}`;
  } : typeof i == "function" ? i : () => {
  };
}
function V0(e) {
  return gh(e, "spacing", 8);
}
function yh(e, t) {
  return typeof t == "string" || t == null ? t : e(t);
}
function G3(e, t) {
  return (n) => e.reduce((r, i) => (r[i] = yh(t, n), r), {});
}
function q3(e, t, n, r) {
  if (!t.includes(n))
    return null;
  const i = V3(n), s = G3(i, r), l = e[n];
  return yo(e, l, s);
}
function nS(e, t) {
  const n = V0(e.theme);
  return Object.keys(e).map((r) => q3(e, t, r, n)).reduce($d, {});
}
function zn(e) {
  return nS(e, z0);
}
zn.propTypes = {};
zn.filterProps = z0;
function Un(e) {
  return nS(e, U0);
}
Un.propTypes = {};
Un.filterProps = U0;
function rS(e = 8, t = V0({
  spacing: e
})) {
  if (e.mui)
    return e;
  const n = (...r) => (r.length === 0 ? [1] : r).map((s) => {
    const l = t(s);
    return typeof l == "number" ? `${l}px` : l;
  }).join(" ");
  return n.mui = !0, n;
}
function Pp(...e) {
  const t = e.reduce((r, i) => (i.filterProps.forEach((s) => {
    r[s] = i;
  }), r), {}), n = (r) => Object.keys(r).reduce((i, s) => t[s] ? $d(i, t[s](r)) : i, {});
  return n.propTypes = {}, n.filterProps = e.reduce((r, i) => r.concat(i.filterProps), []), n;
}
function zi(e) {
  return typeof e != "number" ? e : `${e}px solid`;
}
function Wi(e, t) {
  return Kn({
    prop: e,
    themeKey: "borders",
    transform: t
  });
}
const H3 = Wi("border", zi), W3 = Wi("borderTop", zi), $3 = Wi("borderRight", zi), K3 = Wi("borderBottom", zi), Y3 = Wi("borderLeft", zi), X3 = Wi("borderColor"), Q3 = Wi("borderTopColor"), Z3 = Wi("borderRightColor"), J3 = Wi("borderBottomColor"), tC = Wi("borderLeftColor"), eC = Wi("outline", zi), nC = Wi("outlineColor"), Dp = (e) => {
  if (e.borderRadius !== void 0 && e.borderRadius !== null) {
    const t = gh(e.theme, "shape.borderRadius", 4), n = (r) => ({
      borderRadius: yh(t, r)
    });
    return yo(e, e.borderRadius, n);
  }
  return null;
};
Dp.propTypes = {};
Dp.filterProps = ["borderRadius"];
Pp(H3, W3, $3, K3, Y3, X3, Q3, Z3, J3, tC, Dp, eC, nC);
const Ip = (e) => {
  if (e.gap !== void 0 && e.gap !== null) {
    const t = gh(e.theme, "spacing", 8), n = (r) => ({
      gap: yh(t, r)
    });
    return yo(e, e.gap, n);
  }
  return null;
};
Ip.propTypes = {};
Ip.filterProps = ["gap"];
const Bp = (e) => {
  if (e.columnGap !== void 0 && e.columnGap !== null) {
    const t = gh(e.theme, "spacing", 8), n = (r) => ({
      columnGap: yh(t, r)
    });
    return yo(e, e.columnGap, n);
  }
  return null;
};
Bp.propTypes = {};
Bp.filterProps = ["columnGap"];
const Fp = (e) => {
  if (e.rowGap !== void 0 && e.rowGap !== null) {
    const t = gh(e.theme, "spacing", 8), n = (r) => ({
      rowGap: yh(t, r)
    });
    return yo(e, e.rowGap, n);
  }
  return null;
};
Fp.propTypes = {};
Fp.filterProps = ["rowGap"];
const rC = Kn({
  prop: "gridColumn"
}), iC = Kn({
  prop: "gridRow"
}), sC = Kn({
  prop: "gridAutoFlow"
}), oC = Kn({
  prop: "gridAutoColumns"
}), aC = Kn({
  prop: "gridAutoRows"
}), lC = Kn({
  prop: "gridTemplateColumns"
}), cC = Kn({
  prop: "gridTemplateRows"
}), uC = Kn({
  prop: "gridTemplateAreas"
}), dC = Kn({
  prop: "gridArea"
});
Pp(Ip, Bp, Fp, rC, iC, sC, oC, aC, lC, cC, uC, dC);
function Oc(e, t) {
  return t === "grey" ? t : e;
}
const hC = Kn({
  prop: "color",
  themeKey: "palette",
  transform: Oc
}), fC = Kn({
  prop: "bgcolor",
  cssProperty: "backgroundColor",
  themeKey: "palette",
  transform: Oc
}), pC = Kn({
  prop: "backgroundColor",
  themeKey: "palette",
  transform: Oc
});
Pp(hC, fC, pC);
function Ti(e) {
  return e <= 1 && e !== 0 ? `${e * 100}%` : e;
}
const mC = Kn({
  prop: "width",
  transform: Ti
}), G0 = (e) => {
  if (e.maxWidth !== void 0 && e.maxWidth !== null) {
    const t = (n) => {
      var i, s, l, c, u;
      const r = ((l = (s = (i = e.theme) == null ? void 0 : i.breakpoints) == null ? void 0 : s.values) == null ? void 0 : l[n]) || Op[n];
      return r ? ((u = (c = e.theme) == null ? void 0 : c.breakpoints) == null ? void 0 : u.unit) !== "px" ? {
        maxWidth: `${r}${e.theme.breakpoints.unit}`
      } : {
        maxWidth: r
      } : {
        maxWidth: Ti(n)
      };
    };
    return yo(e, e.maxWidth, t);
  }
  return null;
};
G0.filterProps = ["maxWidth"];
const gC = Kn({
  prop: "minWidth",
  transform: Ti
}), yC = Kn({
  prop: "height",
  transform: Ti
}), vC = Kn({
  prop: "maxHeight",
  transform: Ti
}), bC = Kn({
  prop: "minHeight",
  transform: Ti
});
Kn({
  prop: "size",
  cssProperty: "width",
  transform: Ti
});
Kn({
  prop: "size",
  cssProperty: "height",
  transform: Ti
});
const _C = Kn({
  prop: "boxSizing"
});
Pp(mC, G0, gC, yC, vC, bC, _C);
const vh = {
  // borders
  border: {
    themeKey: "borders",
    transform: zi
  },
  borderTop: {
    themeKey: "borders",
    transform: zi
  },
  borderRight: {
    themeKey: "borders",
    transform: zi
  },
  borderBottom: {
    themeKey: "borders",
    transform: zi
  },
  borderLeft: {
    themeKey: "borders",
    transform: zi
  },
  borderColor: {
    themeKey: "palette"
  },
  borderTopColor: {
    themeKey: "palette"
  },
  borderRightColor: {
    themeKey: "palette"
  },
  borderBottomColor: {
    themeKey: "palette"
  },
  borderLeftColor: {
    themeKey: "palette"
  },
  outline: {
    themeKey: "borders",
    transform: zi
  },
  outlineColor: {
    themeKey: "palette"
  },
  borderRadius: {
    themeKey: "shape.borderRadius",
    style: Dp
  },
  // palette
  color: {
    themeKey: "palette",
    transform: Oc
  },
  bgcolor: {
    themeKey: "palette",
    cssProperty: "backgroundColor",
    transform: Oc
  },
  backgroundColor: {
    themeKey: "palette",
    transform: Oc
  },
  // spacing
  p: {
    style: Un
  },
  pt: {
    style: Un
  },
  pr: {
    style: Un
  },
  pb: {
    style: Un
  },
  pl: {
    style: Un
  },
  px: {
    style: Un
  },
  py: {
    style: Un
  },
  padding: {
    style: Un
  },
  paddingTop: {
    style: Un
  },
  paddingRight: {
    style: Un
  },
  paddingBottom: {
    style: Un
  },
  paddingLeft: {
    style: Un
  },
  paddingX: {
    style: Un
  },
  paddingY: {
    style: Un
  },
  paddingInline: {
    style: Un
  },
  paddingInlineStart: {
    style: Un
  },
  paddingInlineEnd: {
    style: Un
  },
  paddingBlock: {
    style: Un
  },
  paddingBlockStart: {
    style: Un
  },
  paddingBlockEnd: {
    style: Un
  },
  m: {
    style: zn
  },
  mt: {
    style: zn
  },
  mr: {
    style: zn
  },
  mb: {
    style: zn
  },
  ml: {
    style: zn
  },
  mx: {
    style: zn
  },
  my: {
    style: zn
  },
  margin: {
    style: zn
  },
  marginTop: {
    style: zn
  },
  marginRight: {
    style: zn
  },
  marginBottom: {
    style: zn
  },
  marginLeft: {
    style: zn
  },
  marginX: {
    style: zn
  },
  marginY: {
    style: zn
  },
  marginInline: {
    style: zn
  },
  marginInlineStart: {
    style: zn
  },
  marginInlineEnd: {
    style: zn
  },
  marginBlock: {
    style: zn
  },
  marginBlockStart: {
    style: zn
  },
  marginBlockEnd: {
    style: zn
  },
  // display
  displayPrint: {
    cssProperty: !1,
    transform: (e) => ({
      "@media print": {
        display: e
      }
    })
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  // flexbox
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  // grid
  gap: {
    style: Ip
  },
  rowGap: {
    style: Fp
  },
  columnGap: {
    style: Bp
  },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  // positions
  position: {},
  zIndex: {
    themeKey: "zIndex"
  },
  top: {},
  right: {},
  bottom: {},
  left: {},
  // shadows
  boxShadow: {
    themeKey: "shadows"
  },
  // sizing
  width: {
    transform: Ti
  },
  maxWidth: {
    style: G0
  },
  minWidth: {
    transform: Ti
  },
  height: {
    transform: Ti
  },
  maxHeight: {
    transform: Ti
  },
  minHeight: {
    transform: Ti
  },
  boxSizing: {},
  // typography
  font: {
    themeKey: "font"
  },
  fontFamily: {
    themeKey: "typography"
  },
  fontSize: {
    themeKey: "typography"
  },
  fontStyle: {
    themeKey: "typography"
  },
  fontWeight: {
    themeKey: "typography"
  },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: {
    cssProperty: !1,
    themeKey: "typography"
  }
};
function SC(...e) {
  const t = e.reduce((r, i) => r.concat(Object.keys(i)), []), n = new Set(t);
  return e.every((r) => n.size === Object.keys(r).length);
}
function xC(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function TC() {
  function e(n, r, i, s) {
    const l = {
      [n]: r,
      theme: i
    }, c = s[n];
    if (!c)
      return {
        [n]: r
      };
    const {
      cssProperty: u = n,
      themeKey: d,
      transform: h,
      style: p
    } = c;
    if (r == null)
      return null;
    if (d === "typography" && r === "inherit")
      return {
        [n]: r
      };
    const v = Np(i, d) || {};
    return p ? p(l) : yo(l, r, (g) => {
      let b = Jf(v, h, g);
      return g === b && typeof g == "string" && (b = Jf(v, h, `${n}${g === "default" ? "" : pe(g)}`, g)), u === !1 ? b : {
        [u]: b
      };
    });
  }
  function t(n) {
    const {
      sx: r,
      theme: i = {}
    } = n || {};
    if (!r)
      return null;
    const s = i.unstable_sxConfig ?? vh;
    function l(c) {
      let u = c;
      if (typeof c == "function")
        u = c(i);
      else if (typeof c != "object")
        return c;
      if (!u)
        return null;
      const d = F3(i.breakpoints), h = Object.keys(d);
      let p = d;
      return Object.keys(u).forEach((v) => {
        const m = xC(u[v], i);
        if (m != null)
          if (typeof m == "object")
            if (s[v])
              p = $d(p, e(v, m, i, s));
            else {
              const g = yo({
                theme: i
              }, m, (b) => ({
                [v]: b
              }));
              SC(g, m) ? p[v] = t({
                sx: m,
                theme: i
              }) : p = $d(p, g);
            }
          else
            p = $d(p, e(v, m, i, s));
      }), O3(i, j3(h, p));
    }
    return Array.isArray(r) ? r.map(l) : l(r);
  }
  return t;
}
const hl = TC();
hl.filterProps = ["sx"];
function CC(e, t) {
  var r;
  const n = this;
  if (n.vars) {
    if (!((r = n.colorSchemes) != null && r[e]) || typeof n.getColorSchemeSelector != "function")
      return {};
    let i = n.getColorSchemeSelector(e);
    return i === "&" ? t : ((i.includes("data-") || i.includes(".")) && (i = `*:where(${i.replace(/\s*&$/, "")}) &`), {
      [i]: t
    });
  }
  return n.palette.mode === e ? t : {};
}
function q0(e = {}, ...t) {
  const {
    breakpoints: n = {},
    palette: r = {},
    spacing: i,
    shape: s = {},
    ...l
  } = e, c = M3(n), u = rS(i);
  let d = Fr({
    breakpoints: c,
    direction: "ltr",
    components: {},
    // Inject component definitions.
    palette: {
      mode: "light",
      ...r
    },
    spacing: u,
    shape: {
      ...I3,
      ...s
    }
  }, l);
  return d = D3(d), d.applyStyles = CC, d = t.reduce((h, p) => Fr(h, p), d), d.unstable_sxConfig = {
    ...vh,
    ...l == null ? void 0 : l.unstable_sxConfig
  }, d.unstable_sx = function(p) {
    return hl({
      sx: p,
      theme: this
    });
  }, d;
}
function wC(e) {
  return Object.keys(e).length === 0;
}
function EC(e = null) {
  const t = K.useContext(Mp);
  return !t || wC(t) ? e : t;
}
const AC = q0();
function H0(e = AC) {
  return EC(e);
}
function kC({
  styles: e,
  themeId: t,
  defaultTheme: n = {}
}) {
  const r = H0(n), i = typeof e == "function" ? e(t && r[t] || r) : e;
  return /* @__PURE__ */ W.jsx(w3, {
    styles: i
  });
}
const RC = (e) => {
  var r;
  const t = {
    systemProps: {},
    otherProps: {}
  }, n = ((r = e == null ? void 0 : e.theme) == null ? void 0 : r.unstable_sxConfig) ?? vh;
  return Object.keys(e).forEach((i) => {
    n[i] ? t.systemProps[i] = e[i] : t.otherProps[i] = e[i];
  }), t;
};
function iS(e) {
  const {
    sx: t,
    ...n
  } = e, {
    systemProps: r,
    otherProps: i
  } = RC(n);
  let s;
  return Array.isArray(t) ? s = [r, ...t] : typeof t == "function" ? s = (...l) => {
    const c = t(...l);
    return Rs(c) ? {
      ...r,
      ...c
    } : r;
  } : s = {
    ...r,
    ...t
  }, {
    ...i,
    sx: s
  };
}
const Pv = (e) => e, MC = () => {
  let e = Pv;
  return {
    configure(t) {
      e = t;
    },
    generate(t) {
      return e(t);
    },
    reset() {
      e = Pv;
    }
  };
}, sS = MC();
function oS(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number") r += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var i = e.length;
    for (t = 0; t < i; t++) e[t] && (n = oS(e[t])) && (r && (r += " "), r += n);
  } else for (n in e) e[n] && (r && (r += " "), r += n);
  return r;
}
function ge() {
  for (var e, t, n = 0, r = "", i = arguments.length; n < i; n++) (e = arguments[n]) && (t = oS(e)) && (r && (r += " "), r += t);
  return r;
}
function OC(e = {}) {
  const {
    themeId: t,
    defaultTheme: n,
    defaultClassName: r = "MuiBox-root",
    generateClassName: i
  } = e, s = J_("div", {
    shouldForwardProp: (c) => c !== "theme" && c !== "sx" && c !== "as"
  })(hl);
  return /* @__PURE__ */ K.forwardRef(function(u, d) {
    const h = H0(n), {
      className: p,
      component: v = "div",
      ...m
    } = iS(u);
    return /* @__PURE__ */ W.jsx(s, {
      as: v,
      ref: d,
      className: ge(p, i ? i(r) : r),
      theme: t && h[t] || h,
      ...m
    });
  });
}
const NC = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  open: "open",
  readOnly: "readOnly",
  required: "required",
  selected: "selected"
};
function Qe(e, t, n = "Mui") {
  const r = NC[t];
  return r ? `${n}-${r}` : `${sS.generate(e)}-${t}`;
}
function Xe(e, t, n = "Mui") {
  const r = {};
  return t.forEach((i) => {
    r[i] = Qe(e, i, n);
  }), r;
}
function aS(e) {
  const {
    variants: t,
    ...n
  } = e, r = {
    variants: t,
    style: kv(n),
    isProcessed: !0
  };
  return r.style === n || t && t.forEach((i) => {
    typeof i.style != "function" && (i.style = kv(i.style));
  }), r;
}
const PC = q0();
function pg(e) {
  return e !== "ownerState" && e !== "theme" && e !== "sx" && e !== "as";
}
function DC(e) {
  return e ? (t, n) => n[e] : null;
}
function IC(e, t, n) {
  e.theme = jC(e.theme) ? n : e.theme[t] || e.theme;
}
function Hf(e, t) {
  const n = typeof t == "function" ? t(e) : t;
  if (Array.isArray(n))
    return n.flatMap((r) => Hf(e, r));
  if (Array.isArray(n == null ? void 0 : n.variants)) {
    let r;
    if (n.isProcessed)
      r = n.style;
    else {
      const {
        variants: i,
        ...s
      } = n;
      r = s;
    }
    return lS(e, n.variants, [r]);
  }
  return n != null && n.isProcessed ? n.style : n;
}
function lS(e, t, n = []) {
  var i;
  let r;
  t: for (let s = 0; s < t.length; s += 1) {
    const l = t[s];
    if (typeof l.props == "function") {
      if (r ?? (r = {
        ...e,
        ...e.ownerState,
        ownerState: e.ownerState
      }), !l.props(r))
        continue;
    } else
      for (const c in l.props)
        if (e[c] !== l.props[c] && ((i = e.ownerState) == null ? void 0 : i[c]) !== l.props[c])
          continue t;
    typeof l.style == "function" ? (r ?? (r = {
      ...e,
      ...e.ownerState,
      ownerState: e.ownerState
    }), n.push(l.style(r))) : n.push(l.style);
  }
  return n;
}
function BC(e = {}) {
  const {
    themeId: t,
    defaultTheme: n = PC,
    rootShouldForwardProp: r = pg,
    slotShouldForwardProp: i = pg
  } = e;
  function s(c) {
    IC(c, t, n);
  }
  return (c, u = {}) => {
    E3(c, (E) => E.filter((O) => O !== hl));
    const {
      name: d,
      slot: h,
      skipVariantsResolver: p,
      skipSx: v,
      // TODO v6: remove `lowercaseFirstLetter()` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      overridesResolver: m = DC(zC(h)),
      ...g
    } = u, b = p !== void 0 ? p : (
      // TODO v6: remove `Root` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      h && h !== "Root" && h !== "root" || !1
    ), x = v || !1;
    let w = pg;
    h === "Root" || h === "root" ? w = r : h ? w = i : LC(c) && (w = void 0);
    const T = J_(c, {
      shouldForwardProp: w,
      label: FC(),
      ...g
    }), S = (E) => {
      if (typeof E == "function" && E.__emotion_real !== E)
        return function(B) {
          return Hf(B, E);
        };
      if (Rs(E)) {
        const O = aS(E);
        return O.variants ? function(N) {
          return Hf(N, O);
        } : O.style;
      }
      return E;
    }, C = (...E) => {
      const O = [], B = E.map(S), N = [];
      if (O.push(s), d && m && N.push(function(G) {
        var z, H;
        const j = (H = (z = G.theme.components) == null ? void 0 : z[d]) == null ? void 0 : H.styleOverrides;
        if (!j)
          return null;
        const D = {};
        for (const X in j)
          D[X] = Hf(G, j[X]);
        return m(G, D);
      }), d && !b && N.push(function(G) {
        var D, z;
        const M = G.theme, j = (z = (D = M == null ? void 0 : M.components) == null ? void 0 : D[d]) == null ? void 0 : z.variants;
        return j ? lS(G, j) : null;
      }), x || N.push(hl), Array.isArray(B[0])) {
        const F = B.shift(), G = new Array(O.length).fill(""), M = new Array(N.length).fill("");
        let j;
        j = [...G, ...F, ...M], j.raw = [...G, ...F.raw, ...M], O.unshift(j);
      }
      const L = [...O, ...B, ...N], k = T(...L);
      return c.muiName && (k.muiName = c.muiName), k;
    };
    return T.withConfig && (C.withConfig = T.withConfig), C;
  };
}
function FC(e, t) {
  return void 0;
}
function jC(e) {
  for (const t in e)
    return !1;
  return !0;
}
function LC(e) {
  return typeof e == "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  e.charCodeAt(0) > 96;
}
function zC(e) {
  return e && e.charAt(0).toLowerCase() + e.slice(1);
}
function rh(e, t) {
  const n = {
    ...t
  };
  for (const r in e)
    if (Object.prototype.hasOwnProperty.call(e, r)) {
      const i = r;
      if (i === "components" || i === "slots")
        n[i] = {
          ...e[i],
          ...n[i]
        };
      else if (i === "componentsProps" || i === "slotProps") {
        const s = e[i], l = t[i];
        if (!l)
          n[i] = s || {};
        else if (!s)
          n[i] = l;
        else {
          n[i] = {
            ...l
          };
          for (const c in s)
            if (Object.prototype.hasOwnProperty.call(s, c)) {
              const u = c;
              n[i][u] = rh(s[u], l[u]);
            }
        }
      } else n[i] === void 0 && (n[i] = e[i]);
    }
  return n;
}
const ls = typeof window < "u" ? K.useLayoutEffect : K.useEffect;
function xc(e, t = Number.MIN_SAFE_INTEGER, n = Number.MAX_SAFE_INTEGER) {
  return Math.max(t, Math.min(e, n));
}
function W0(e, t = 0, n = 1) {
  return xc(e, t, n);
}
function UC(e) {
  e = e.slice(1);
  const t = new RegExp(`.{1,${e.length >= 6 ? 2 : 1}}`, "g");
  let n = e.match(t);
  return n && n[0].length === 1 && (n = n.map((r) => r + r)), n ? `rgb${n.length === 4 ? "a" : ""}(${n.map((r, i) => i < 3 ? parseInt(r, 16) : Math.round(parseInt(r, 16) / 255 * 1e3) / 1e3).join(", ")})` : "";
}
function na(e) {
  if (e.type)
    return e;
  if (e.charAt(0) === "#")
    return na(UC(e));
  const t = e.indexOf("("), n = e.substring(0, t);
  if (!["rgb", "rgba", "hsl", "hsla", "color"].includes(n))
    throw new Error(go(9, e));
  let r = e.substring(t + 1, e.length - 1), i;
  if (n === "color") {
    if (r = r.split(" "), i = r.shift(), r.length === 4 && r[3].charAt(0) === "/" && (r[3] = r[3].slice(1)), !["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].includes(i))
      throw new Error(go(10, i));
  } else
    r = r.split(",");
  return r = r.map((s) => parseFloat(s)), {
    type: n,
    values: r,
    colorSpace: i
  };
}
const VC = (e) => {
  const t = na(e);
  return t.values.slice(0, 3).map((n, r) => t.type.includes("hsl") && r !== 0 ? `${n}%` : n).join(" ");
}, Gd = (e, t) => {
  try {
    return VC(e);
  } catch {
    return e;
  }
};
function jp(e) {
  const {
    type: t,
    colorSpace: n
  } = e;
  let {
    values: r
  } = e;
  return t.includes("rgb") ? r = r.map((i, s) => s < 3 ? parseInt(i, 10) : i) : t.includes("hsl") && (r[1] = `${r[1]}%`, r[2] = `${r[2]}%`), t.includes("color") ? r = `${n} ${r.join(" ")}` : r = `${r.join(", ")}`, `${t}(${r})`;
}
function cS(e) {
  e = na(e);
  const {
    values: t
  } = e, n = t[0], r = t[1] / 100, i = t[2] / 100, s = r * Math.min(i, 1 - i), l = (d, h = (d + n / 30) % 12) => i - s * Math.max(Math.min(h - 3, 9 - h, 1), -1);
  let c = "rgb";
  const u = [Math.round(l(0) * 255), Math.round(l(8) * 255), Math.round(l(4) * 255)];
  return e.type === "hsla" && (c += "a", u.push(t[3])), jp({
    type: c,
    values: u
  });
}
function t0(e) {
  e = na(e);
  let t = e.type === "hsl" || e.type === "hsla" ? na(cS(e)).values : e.values;
  return t = t.map((n) => (e.type !== "color" && (n /= 255), n <= 0.03928 ? n / 12.92 : ((n + 0.055) / 1.055) ** 2.4)), Number((0.2126 * t[0] + 0.7152 * t[1] + 0.0722 * t[2]).toFixed(3));
}
function GC(e, t) {
  const n = t0(e), r = t0(t);
  return (Math.max(n, r) + 0.05) / (Math.min(n, r) + 0.05);
}
function xn(e, t) {
  return e = na(e), t = W0(t), (e.type === "rgb" || e.type === "hsl") && (e.type += "a"), e.type === "color" ? e.values[3] = `/${t}` : e.values[3] = t, jp(e);
}
function _f(e, t, n) {
  try {
    return xn(e, t);
  } catch {
    return e;
  }
}
function ih(e, t) {
  if (e = na(e), t = W0(t), e.type.includes("hsl"))
    e.values[2] *= 1 - t;
  else if (e.type.includes("rgb") || e.type.includes("color"))
    for (let n = 0; n < 3; n += 1)
      e.values[n] *= 1 - t;
  return jp(e);
}
function yn(e, t, n) {
  try {
    return ih(e, t);
  } catch {
    return e;
  }
}
function sh(e, t) {
  if (e = na(e), t = W0(t), e.type.includes("hsl"))
    e.values[2] += (100 - e.values[2]) * t;
  else if (e.type.includes("rgb"))
    for (let n = 0; n < 3; n += 1)
      e.values[n] += (255 - e.values[n]) * t;
  else if (e.type.includes("color"))
    for (let n = 0; n < 3; n += 1)
      e.values[n] += (1 - e.values[n]) * t;
  return jp(e);
}
function vn(e, t, n) {
  try {
    return sh(e, t);
  } catch {
    return e;
  }
}
function qC(e, t = 0.15) {
  return t0(e) > 0.5 ? ih(e, t) : sh(e, t);
}
function Sf(e, t, n) {
  try {
    return qC(e, t);
  } catch {
    return e;
  }
}
function Dv(...e) {
  return e.reduce((t, n) => n == null ? t : function(...i) {
    t.apply(this, i), n.apply(this, i);
  }, () => {
  });
}
function uS(e, t = 166) {
  let n;
  function r(...i) {
    const s = () => {
      e.apply(this, i);
    };
    clearTimeout(n), n = setTimeout(s, t);
  }
  return r.clear = () => {
    clearTimeout(n);
  }, r;
}
function mg(e, t) {
  var n, r, i;
  return /* @__PURE__ */ K.isValidElement(e) && t.indexOf(
    // For server components `muiName` is avaialble in element.type._payload.value.muiName
    // relevant info - https://github.com/facebook/react/blob/2807d781a08db8e9873687fccc25c0f12b4fb3d4/packages/react/src/ReactLazy.js#L45
    // eslint-disable-next-line no-underscore-dangle
    e.type.muiName ?? ((i = (r = (n = e.type) == null ? void 0 : n._payload) == null ? void 0 : r.value) == null ? void 0 : i.muiName)
  ) !== -1;
}
function Er(e) {
  return e && e.ownerDocument || document;
}
function vo(e) {
  return Er(e).defaultView || window;
}
function e0(e, t) {
  typeof e == "function" ? e(t) : e && (e.current = t);
}
let Iv = 0;
function HC(e) {
  const [t, n] = K.useState(e), r = e || t;
  return K.useEffect(() => {
    t == null && (Iv += 1, n(`mui-${Iv}`));
  }, [t]), r;
}
const WC = {
  ...Yg
}, Bv = WC.useId;
function bh(e) {
  if (Bv !== void 0) {
    const t = Bv();
    return e ?? t;
  }
  return HC(e);
}
function tp({
  controlled: e,
  default: t,
  name: n,
  state: r = "value"
}) {
  const {
    current: i
  } = K.useRef(e !== void 0), [s, l] = K.useState(t), c = i ? e : s, u = K.useCallback((d) => {
    i || l(d);
  }, []);
  return [c, u];
}
function Vi(e) {
  const t = K.useRef(e);
  return ls(() => {
    t.current = e;
  }), K.useRef((...n) => (
    // @ts-expect-error hide `this`
    (0, t.current)(...n)
  )).current;
}
function ar(...e) {
  return K.useMemo(() => e.every((t) => t == null) ? null : (t) => {
    e.forEach((n) => {
      e0(n, t);
    });
  }, e);
}
const Fv = {};
function dS(e, t) {
  const n = K.useRef(Fv);
  return n.current === Fv && (n.current = e(t)), n;
}
const $C = [];
function KC(e) {
  K.useEffect(e, $C);
}
class Lp {
  constructor() {
    xe(this, "currentId", null);
    xe(this, "clear", () => {
      this.currentId !== null && (clearTimeout(this.currentId), this.currentId = null);
    });
    xe(this, "disposeEffect", () => this.clear);
  }
  static create() {
    return new Lp();
  }
  /**
   * Executes `fn` after `delay`, clearing any previously scheduled call.
   */
  start(t, n) {
    this.clear(), this.currentId = setTimeout(() => {
      this.currentId = null, n();
    }, t);
  }
}
function Ec() {
  const e = dS(Lp.create).current;
  return KC(e.disposeEffect), e;
}
function Ic(e) {
  try {
    return e.matches(":focus-visible");
  } catch {
  }
  return !1;
}
function hS(e = window) {
  const t = e.document.documentElement.clientWidth;
  return e.innerWidth - t;
}
function YC(e) {
  return K.Children.toArray(e).filter((t) => /* @__PURE__ */ K.isValidElement(t));
}
const XC = {
  border: 0,
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "absolute",
  whiteSpace: "nowrap",
  width: "1px"
};
function Ze(e, t, n = void 0) {
  const r = {};
  for (const i in e) {
    const s = e[i];
    let l = "", c = !0;
    for (let u = 0; u < s.length; u += 1) {
      const d = s[u];
      d && (l += (c === !0 ? "" : " ") + t(d), c = !1, n && n[d] && (l += " " + n[d]));
    }
    r[i] = l;
  }
  return r;
}
function QC(e) {
  return typeof e == "string";
}
function fS(e, t, n) {
  return e === void 0 || QC(e) ? t : {
    ...t,
    ownerState: {
      ...t.ownerState,
      ...n
    }
  };
}
function Kd(e, t = []) {
  if (e === void 0)
    return {};
  const n = {};
  return Object.keys(e).filter((r) => r.match(/^on[A-Z]/) && typeof e[r] == "function" && !t.includes(r)).forEach((r) => {
    n[r] = e[r];
  }), n;
}
function jv(e) {
  if (e === void 0)
    return {};
  const t = {};
  return Object.keys(e).filter((n) => !(n.match(/^on[A-Z]/) && typeof e[n] == "function")).forEach((n) => {
    t[n] = e[n];
  }), t;
}
function pS(e) {
  const {
    getSlotProps: t,
    additionalProps: n,
    externalSlotProps: r,
    externalForwardedProps: i,
    className: s
  } = e;
  if (!t) {
    const m = ge(n == null ? void 0 : n.className, s, i == null ? void 0 : i.className, r == null ? void 0 : r.className), g = {
      ...n == null ? void 0 : n.style,
      ...i == null ? void 0 : i.style,
      ...r == null ? void 0 : r.style
    }, b = {
      ...n,
      ...i,
      ...r
    };
    return m.length > 0 && (b.className = m), Object.keys(g).length > 0 && (b.style = g), {
      props: b,
      internalRef: void 0
    };
  }
  const l = Kd({
    ...i,
    ...r
  }), c = jv(r), u = jv(i), d = t(l), h = ge(d == null ? void 0 : d.className, n == null ? void 0 : n.className, s, i == null ? void 0 : i.className, r == null ? void 0 : r.className), p = {
    ...d == null ? void 0 : d.style,
    ...n == null ? void 0 : n.style,
    ...i == null ? void 0 : i.style,
    ...r == null ? void 0 : r.style
  }, v = {
    ...d,
    ...n,
    ...u,
    ...c
  };
  return h.length > 0 && (v.className = h), Object.keys(p).length > 0 && (v.style = p), {
    props: v,
    internalRef: d.ref
  };
}
function mS(e, t, n) {
  return typeof e == "function" ? e(t, n) : e;
}
function ws(e) {
  var p;
  const {
    elementType: t,
    externalSlotProps: n,
    ownerState: r,
    skipResolvingSlotProps: i = !1,
    ...s
  } = e, l = i ? {} : mS(n, r), {
    props: c,
    internalRef: u
  } = pS({
    ...s,
    externalSlotProps: l
  }), d = ar(u, l == null ? void 0 : l.ref, (p = e.additionalProps) == null ? void 0 : p.ref);
  return fS(t, {
    ...c,
    ref: d
  }, r);
}
function Qc(e) {
  var t;
  return parseInt(K.version, 10) >= 19 ? ((t = e == null ? void 0 : e.props) == null ? void 0 : t.ref) || null : (e == null ? void 0 : e.ref) || null;
}
const ZC = /* @__PURE__ */ K.createContext(), zp = () => K.useContext(ZC) ?? !1, JC = /* @__PURE__ */ K.createContext(void 0);
function tw(e) {
  const {
    theme: t,
    name: n,
    props: r
  } = e;
  if (!t || !t.components || !t.components[n])
    return r;
  const i = t.components[n];
  return i.defaultProps ? rh(i.defaultProps, r) : !i.styleOverrides && !i.variants ? rh(i, r) : r;
}
function ew({
  props: e,
  name: t
}) {
  const n = K.useContext(JC);
  return tw({
    props: e,
    name: t,
    theme: {
      components: n
    }
  });
}
const Lv = {
  theme: void 0
};
function nw(e) {
  let t, n;
  return function(i) {
    let s = t;
    return (s === void 0 || i.theme !== n) && (Lv.theme = i.theme, s = aS(e(Lv)), t = s, n = i.theme), s;
  };
}
function rw(e = "") {
  function t(...r) {
    if (!r.length)
      return "";
    const i = r[0];
    return typeof i == "string" && !i.match(/(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/) ? `, var(--${e ? `${e}-` : ""}${i}${t(...r.slice(1))})` : `, ${i}`;
  }
  return (r, ...i) => `var(--${e ? `${e}-` : ""}${r}${t(...i)})`;
}
const zv = (e, t, n, r = []) => {
  let i = e;
  t.forEach((s, l) => {
    l === t.length - 1 ? Array.isArray(i) ? i[Number(s)] = n : i && typeof i == "object" && (i[s] = n) : i && typeof i == "object" && (i[s] || (i[s] = r.includes(s) ? [] : {}), i = i[s]);
  });
}, iw = (e, t, n) => {
  function r(i, s = [], l = []) {
    Object.entries(i).forEach(([c, u]) => {
      (!n || n && !n([...s, c])) && u != null && (typeof u == "object" && Object.keys(u).length > 0 ? r(u, [...s, c], Array.isArray(u) ? [...l, c] : l) : t([...s, c], u, l));
    });
  }
  r(e);
}, sw = (e, t) => typeof t == "number" ? ["lineHeight", "fontWeight", "opacity", "zIndex"].some((r) => e.includes(r)) || e[e.length - 1].toLowerCase().includes("opacity") ? t : `${t}px` : t;
function gg(e, t) {
  const {
    prefix: n,
    shouldSkipGeneratingVar: r
  } = t || {}, i = {}, s = {}, l = {};
  return iw(
    e,
    (c, u, d) => {
      if ((typeof u == "string" || typeof u == "number") && (!r || !r(c, u))) {
        const h = `--${n ? `${n}-` : ""}${c.join("-")}`, p = sw(c, u);
        Object.assign(i, {
          [h]: p
        }), zv(s, c, `var(${h})`, d), zv(l, c, `var(${h}, ${p})`, d);
      }
    },
    (c) => c[0] === "vars"
    // skip 'vars/*' paths
  ), {
    css: i,
    vars: s,
    varsWithDefaults: l
  };
}
function ow(e, t = {}) {
  const {
    getSelector: n = x,
    disableCssColorScheme: r,
    colorSchemeSelector: i
  } = t, {
    colorSchemes: s = {},
    components: l,
    defaultColorScheme: c = "light",
    ...u
  } = e, {
    vars: d,
    css: h,
    varsWithDefaults: p
  } = gg(u, t);
  let v = p;
  const m = {}, {
    [c]: g,
    ...b
  } = s;
  if (Object.entries(b || {}).forEach(([S, C]) => {
    const {
      vars: E,
      css: O,
      varsWithDefaults: B
    } = gg(C, t);
    v = Fr(v, B), m[S] = {
      css: O,
      vars: E
    };
  }), g) {
    const {
      css: S,
      vars: C,
      varsWithDefaults: E
    } = gg(g, t);
    v = Fr(v, E), m[c] = {
      css: S,
      vars: C
    };
  }
  function x(S, C) {
    var O, B;
    let E = i;
    if (i === "class" && (E = ".%s"), i === "data" && (E = "[data-%s]"), i != null && i.startsWith("data-") && !i.includes("%s") && (E = `[${i}="%s"]`), S) {
      if (E === "media")
        return e.defaultColorScheme === S ? ":root" : {
          [`@media (prefers-color-scheme: ${((B = (O = s[S]) == null ? void 0 : O.palette) == null ? void 0 : B.mode) || S})`]: {
            ":root": C
          }
        };
      if (E)
        return e.defaultColorScheme === S ? `:root, ${E.replace("%s", String(S))}` : E.replace("%s", String(S));
    }
    return ":root";
  }
  return {
    vars: v,
    generateThemeVars: () => {
      let S = {
        ...d
      };
      return Object.entries(m).forEach(([, {
        vars: C
      }]) => {
        S = Fr(S, C);
      }), S;
    },
    generateStyleSheets: () => {
      var N, L;
      const S = [], C = e.defaultColorScheme || "light";
      function E(k, F) {
        Object.keys(F).length && S.push(typeof k == "string" ? {
          [k]: {
            ...F
          }
        } : k);
      }
      E(n(void 0, {
        ...h
      }), h);
      const {
        [C]: O,
        ...B
      } = m;
      if (O) {
        const {
          css: k
        } = O, F = (L = (N = s[C]) == null ? void 0 : N.palette) == null ? void 0 : L.mode, G = !r && F ? {
          colorScheme: F,
          ...k
        } : {
          ...k
        };
        E(n(C, {
          ...G
        }), G);
      }
      return Object.entries(B).forEach(([k, {
        css: F
      }]) => {
        var j, D;
        const G = (D = (j = s[k]) == null ? void 0 : j.palette) == null ? void 0 : D.mode, M = !r && G ? {
          colorScheme: G,
          ...F
        } : {
          ...F
        };
        E(n(k, {
          ...M
        }), M);
      }), S;
    }
  };
}
function aw(e) {
  return function(n) {
    return e === "media" ? `@media (prefers-color-scheme: ${n})` : e ? e.startsWith("data-") && !e.includes("%s") ? `[${e}="${n}"] &` : e === "class" ? `.${n} &` : e === "data" ? `[data-${n}] &` : `${e.replace("%s", n)} &` : "&";
  };
}
function gS() {
  return {
    // The colors used to style the text.
    text: {
      // The most important text.
      primary: "rgba(0, 0, 0, 0.87)",
      // Secondary text.
      secondary: "rgba(0, 0, 0, 0.6)",
      // Disabled text have even lower visual prominence.
      disabled: "rgba(0, 0, 0, 0.38)"
    },
    // The color used to divide different elements.
    divider: "rgba(0, 0, 0, 0.12)",
    // The background colors used to style the surfaces.
    // Consistency between these values is important.
    background: {
      paper: Jd.white,
      default: Jd.white
    },
    // The colors used to style the action elements.
    action: {
      // The color of an active action like an icon button.
      active: "rgba(0, 0, 0, 0.54)",
      // The color of an hovered action.
      hover: "rgba(0, 0, 0, 0.04)",
      hoverOpacity: 0.04,
      // The color of a selected action.
      selected: "rgba(0, 0, 0, 0.08)",
      selectedOpacity: 0.08,
      // The color of a disabled action.
      disabled: "rgba(0, 0, 0, 0.26)",
      // The background color of a disabled action.
      disabledBackground: "rgba(0, 0, 0, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(0, 0, 0, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.12
    }
  };
}
const lw = gS();
function yS() {
  return {
    text: {
      primary: Jd.white,
      secondary: "rgba(255, 255, 255, 0.7)",
      disabled: "rgba(255, 255, 255, 0.5)",
      icon: "rgba(255, 255, 255, 0.5)"
    },
    divider: "rgba(255, 255, 255, 0.12)",
    background: {
      paper: "#121212",
      default: "#121212"
    },
    action: {
      active: Jd.white,
      hover: "rgba(255, 255, 255, 0.08)",
      hoverOpacity: 0.08,
      selected: "rgba(255, 255, 255, 0.16)",
      selectedOpacity: 0.16,
      disabled: "rgba(255, 255, 255, 0.3)",
      disabledBackground: "rgba(255, 255, 255, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(255, 255, 255, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.24
    }
  };
}
const Uv = yS();
function Vv(e, t, n, r) {
  const i = r.light || r, s = r.dark || r * 1.5;
  e[t] || (e.hasOwnProperty(n) ? e[t] = e[n] : t === "light" ? e.light = sh(e.main, i) : t === "dark" && (e.dark = ih(e.main, s)));
}
function cw(e = "light") {
  return e === "dark" ? {
    main: gc[200],
    light: gc[50],
    dark: gc[400]
  } : {
    main: gc[700],
    light: gc[400],
    dark: gc[800]
  };
}
function uw(e = "light") {
  return e === "dark" ? {
    main: mc[200],
    light: mc[50],
    dark: mc[400]
  } : {
    main: mc[500],
    light: mc[300],
    dark: mc[700]
  };
}
function dw(e = "light") {
  return e === "dark" ? {
    main: pc[500],
    light: pc[300],
    dark: pc[700]
  } : {
    main: pc[700],
    light: pc[400],
    dark: pc[800]
  };
}
function hw(e = "light") {
  return e === "dark" ? {
    main: yc[400],
    light: yc[300],
    dark: yc[700]
  } : {
    main: yc[700],
    light: yc[500],
    dark: yc[900]
  };
}
function fw(e = "light") {
  return e === "dark" ? {
    main: vc[400],
    light: vc[300],
    dark: vc[700]
  } : {
    main: vc[800],
    light: vc[500],
    dark: vc[900]
  };
}
function pw(e = "light") {
  return e === "dark" ? {
    main: Vu[400],
    light: Vu[300],
    dark: Vu[700]
  } : {
    main: "#ed6c02",
    // closest to orange[800] that pass 3:1.
    light: Vu[500],
    dark: Vu[900]
  };
}
function $0(e) {
  const {
    mode: t = "light",
    contrastThreshold: n = 3,
    tonalOffset: r = 0.2,
    ...i
  } = e, s = e.primary || cw(t), l = e.secondary || uw(t), c = e.error || dw(t), u = e.info || hw(t), d = e.success || fw(t), h = e.warning || pw(t);
  function p(b) {
    return GC(b, Uv.text.primary) >= n ? Uv.text.primary : lw.text.primary;
  }
  const v = ({
    color: b,
    name: x,
    mainShade: w = 500,
    lightShade: T = 300,
    darkShade: S = 700
  }) => {
    if (b = {
      ...b
    }, !b.main && b[w] && (b.main = b[w]), !b.hasOwnProperty("main"))
      throw new Error(go(11, x ? ` (${x})` : "", w));
    if (typeof b.main != "string")
      throw new Error(go(12, x ? ` (${x})` : "", JSON.stringify(b.main)));
    return Vv(b, "light", T, r), Vv(b, "dark", S, r), b.contrastText || (b.contrastText = p(b.main)), b;
  };
  let m;
  return t === "light" ? m = gS() : t === "dark" && (m = yS()), Fr({
    // A collection of common colors.
    common: {
      ...Jd
    },
    // prevent mutable object.
    // The palette mode, can be light or dark.
    mode: t,
    // The colors used to represent primary interface elements for a user.
    primary: v({
      color: s,
      name: "primary"
    }),
    // The colors used to represent secondary interface elements for a user.
    secondary: v({
      color: l,
      name: "secondary",
      mainShade: "A400",
      lightShade: "A200",
      darkShade: "A700"
    }),
    // The colors used to represent interface elements that the user should be made aware of.
    error: v({
      color: c,
      name: "error"
    }),
    // The colors used to represent potentially dangerous actions or important messages.
    warning: v({
      color: h,
      name: "warning"
    }),
    // The colors used to present information to the user that is neutral and not necessarily important.
    info: v({
      color: u,
      name: "info"
    }),
    // The colors used to indicate the successful completion of an action that user triggered.
    success: v({
      color: d,
      name: "success"
    }),
    // The grey colors.
    grey: ET,
    // Used by `getContrastText()` to maximize the contrast between
    // the background and the text.
    contrastThreshold: n,
    // Takes a background color and returns the text color that maximizes the contrast.
    getContrastText: p,
    // Generate a rich color object.
    augmentColor: v,
    // Used by the functions below to shift a color's luminance by approximately
    // two indexes within its tonal palette.
    // E.g., shift from Red 500 to Red 300 or Red 700.
    tonalOffset: r,
    // The light and dark mode object.
    ...m
  }, i);
}
function mw(e) {
  const t = {};
  return Object.entries(e).forEach((r) => {
    const [i, s] = r;
    typeof s == "object" && (t[i] = `${s.fontStyle ? `${s.fontStyle} ` : ""}${s.fontVariant ? `${s.fontVariant} ` : ""}${s.fontWeight ? `${s.fontWeight} ` : ""}${s.fontStretch ? `${s.fontStretch} ` : ""}${s.fontSize || ""}${s.lineHeight ? `/${s.lineHeight} ` : ""}${s.fontFamily || ""}`);
  }), t;
}
function gw(e, t) {
  return {
    toolbar: {
      minHeight: 56,
      [e.up("xs")]: {
        "@media (orientation: landscape)": {
          minHeight: 48
        }
      },
      [e.up("sm")]: {
        minHeight: 64
      }
    },
    ...t
  };
}
function yw(e) {
  return Math.round(e * 1e5) / 1e5;
}
const Gv = {
  textTransform: "uppercase"
}, qv = '"Roboto", "Helvetica", "Arial", sans-serif';
function vw(e, t) {
  const {
    fontFamily: n = qv,
    // The default font size of the Material Specification.
    fontSize: r = 14,
    // px
    fontWeightLight: i = 300,
    fontWeightRegular: s = 400,
    fontWeightMedium: l = 500,
    fontWeightBold: c = 700,
    // Tell MUI what's the font-size on the html element.
    // 16px is the default font-size used by browsers.
    htmlFontSize: u = 16,
    // Apply the CSS properties to all the variants.
    allVariants: d,
    pxToRem: h,
    ...p
  } = typeof t == "function" ? t(e) : t, v = r / 14, m = h || ((x) => `${x / u * v}rem`), g = (x, w, T, S, C) => ({
    fontFamily: n,
    fontWeight: x,
    fontSize: m(w),
    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
    lineHeight: T,
    // The letter spacing was designed for the Roboto font-family. Using the same letter-spacing
    // across font-families can cause issues with the kerning.
    ...n === qv ? {
      letterSpacing: `${yw(S / w)}em`
    } : {},
    ...C,
    ...d
  }), b = {
    h1: g(i, 96, 1.167, -1.5),
    h2: g(i, 60, 1.2, -0.5),
    h3: g(s, 48, 1.167, 0),
    h4: g(s, 34, 1.235, 0.25),
    h5: g(s, 24, 1.334, 0),
    h6: g(l, 20, 1.6, 0.15),
    subtitle1: g(s, 16, 1.75, 0.15),
    subtitle2: g(l, 14, 1.57, 0.1),
    body1: g(s, 16, 1.5, 0.15),
    body2: g(s, 14, 1.43, 0.15),
    button: g(l, 14, 1.75, 0.4, Gv),
    caption: g(s, 12, 1.66, 0.4),
    overline: g(s, 12, 2.66, 1, Gv),
    // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
    inherit: {
      fontFamily: "inherit",
      fontWeight: "inherit",
      fontSize: "inherit",
      lineHeight: "inherit",
      letterSpacing: "inherit"
    }
  };
  return Fr({
    htmlFontSize: u,
    pxToRem: m,
    fontFamily: n,
    fontSize: r,
    fontWeightLight: i,
    fontWeightRegular: s,
    fontWeightMedium: l,
    fontWeightBold: c,
    ...b
  }, p, {
    clone: !1
    // No need to clone deep
  });
}
const bw = 0.2, _w = 0.14, Sw = 0.12;
function Mn(...e) {
  return [`${e[0]}px ${e[1]}px ${e[2]}px ${e[3]}px rgba(0,0,0,${bw})`, `${e[4]}px ${e[5]}px ${e[6]}px ${e[7]}px rgba(0,0,0,${_w})`, `${e[8]}px ${e[9]}px ${e[10]}px ${e[11]}px rgba(0,0,0,${Sw})`].join(",");
}
const xw = ["none", Mn(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), Mn(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), Mn(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), Mn(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), Mn(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), Mn(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), Mn(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), Mn(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), Mn(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), Mn(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), Mn(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), Mn(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), Mn(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), Mn(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), Mn(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), Mn(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), Mn(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), Mn(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), Mn(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), Mn(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), Mn(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), Mn(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), Mn(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), Mn(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)], Tw = {
  // This is the most common easing curve.
  easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: "cubic-bezier(0.4, 0, 1, 1)",
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
}, Cw = {
  shortest: 150,
  shorter: 200,
  short: 250,
  // most basic recommended timing
  standard: 300,
  // this is to be used in complex animations
  complex: 375,
  // recommended when something is entering screen
  enteringScreen: 225,
  // recommended when something is leaving screen
  leavingScreen: 195
};
function Hv(e) {
  return `${Math.round(e)}ms`;
}
function ww(e) {
  if (!e)
    return 0;
  const t = e / 36;
  return Math.min(Math.round((4 + 15 * t ** 0.25 + t / 5) * 10), 3e3);
}
function Ew(e) {
  const t = {
    ...Tw,
    ...e.easing
  }, n = {
    ...Cw,
    ...e.duration
  };
  return {
    getAutoHeightDuration: ww,
    create: (i = ["all"], s = {}) => {
      const {
        duration: l = n.standard,
        easing: c = t.easeInOut,
        delay: u = 0,
        ...d
      } = s;
      return (Array.isArray(i) ? i : [i]).map((h) => `${h} ${typeof l == "string" ? l : Hv(l)} ${c} ${typeof u == "string" ? u : Hv(u)}`).join(",");
    },
    ...e,
    easing: t,
    duration: n
  };
}
const Aw = {
  mobileStepper: 1e3,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
};
function kw(e) {
  return Rs(e) || typeof e > "u" || typeof e == "string" || typeof e == "boolean" || typeof e == "number" || Array.isArray(e);
}
function vS(e = {}) {
  const t = {
    ...e
  };
  function n(r) {
    const i = Object.entries(r);
    for (let s = 0; s < i.length; s++) {
      const [l, c] = i[s];
      !kw(c) || l.startsWith("unstable_") ? delete r[l] : Rs(c) && (r[l] = {
        ...c
      }, n(r[l]));
    }
  }
  return n(t), `import { unstable_createBreakpoints as createBreakpoints, createTransitions } from '@mui/material/styles';

const theme = ${JSON.stringify(t, null, 2)};

theme.breakpoints = createBreakpoints(theme.breakpoints || {});
theme.transitions = createTransitions(theme.transitions || {});

export default theme;`;
}
function n0(e = {}, ...t) {
  const {
    breakpoints: n,
    mixins: r = {},
    spacing: i,
    palette: s = {},
    transitions: l = {},
    typography: c = {},
    shape: u,
    ...d
  } = e;
  if (e.vars && // The error should throw only for the root theme creation because user is not allowed to use a custom node `vars`.
  // `generateThemeVars` is the closest identifier for checking that the `options` is a result of `createTheme` with CSS variables so that user can create new theme for nested ThemeProvider.
  e.generateThemeVars === void 0)
    throw new Error(go(20));
  const h = $0(s), p = q0(e);
  let v = Fr(p, {
    mixins: gw(p.breakpoints, r),
    palette: h,
    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
    shadows: xw.slice(),
    typography: vw(h, c),
    transitions: Ew(l),
    zIndex: {
      ...Aw
    }
  });
  return v = Fr(v, d), v = t.reduce((m, g) => Fr(m, g), v), v.unstable_sxConfig = {
    ...vh,
    ...d == null ? void 0 : d.unstable_sxConfig
  }, v.unstable_sx = function(g) {
    return hl({
      sx: g,
      theme: this
    });
  }, v.toRuntimeSource = vS, v;
}
function r0(e) {
  let t;
  return e < 1 ? t = 5.11916 * e ** 2 : t = 4.5 * Math.log(e + 1) + 2, Math.round(t * 10) / 1e3;
}
const Rw = [...Array(25)].map((e, t) => {
  if (t === 0)
    return "none";
  const n = r0(t);
  return `linear-gradient(rgba(255 255 255 / ${n}), rgba(255 255 255 / ${n}))`;
});
function bS(e) {
  return {
    inputPlaceholder: e === "dark" ? 0.5 : 0.42,
    inputUnderline: e === "dark" ? 0.7 : 0.42,
    switchTrackDisabled: e === "dark" ? 0.2 : 0.12,
    switchTrack: e === "dark" ? 0.3 : 0.38
  };
}
function _S(e) {
  return e === "dark" ? Rw : [];
}
function Mw(e) {
  const {
    palette: t = {
      mode: "light"
    },
    // need to cast to avoid module augmentation test
    opacity: n,
    overlays: r,
    ...i
  } = e, s = $0(t);
  return {
    palette: s,
    opacity: {
      ...bS(s.mode),
      ...n
    },
    overlays: r || _S(s.mode),
    ...i
  };
}
function Ow(e) {
  var t;
  return !!e[0].match(/(cssVarPrefix|colorSchemeSelector|rootSelector|typography|mixins|breakpoints|direction|transitions)/) || !!e[0].match(/sxConfig$/) || // ends with sxConfig
  e[0] === "palette" && !!((t = e[1]) != null && t.match(/(mode|contrastThreshold|tonalOffset)/));
}
const Nw = (e) => [...[...Array(25)].map((t, n) => `--${e ? `${e}-` : ""}overlays-${n}`), `--${e ? `${e}-` : ""}palette-AppBar-darkBg`, `--${e ? `${e}-` : ""}palette-AppBar-darkColor`], Pw = (e) => (t, n) => {
  const r = e.rootSelector || ":root", i = e.colorSchemeSelector;
  let s = i;
  if (i === "class" && (s = ".%s"), i === "data" && (s = "[data-%s]"), i != null && i.startsWith("data-") && !i.includes("%s") && (s = `[${i}="%s"]`), e.defaultColorScheme === t) {
    if (t === "dark") {
      const l = {};
      return Nw(e.cssVarPrefix).forEach((c) => {
        l[c] = n[c], delete n[c];
      }), s === "media" ? {
        [r]: n,
        "@media (prefers-color-scheme: dark)": {
          [r]: l
        }
      } : s ? {
        [s.replace("%s", t)]: l,
        [`${r}, ${s.replace("%s", t)}`]: n
      } : {
        [r]: {
          ...n,
          ...l
        }
      };
    }
    if (s && s !== "media")
      return `${r}, ${s.replace("%s", String(t))}`;
  } else if (t) {
    if (s === "media")
      return {
        [`@media (prefers-color-scheme: ${String(t)})`]: {
          [r]: n
        }
      };
    if (s)
      return s.replace("%s", String(t));
  }
  return r;
};
function Dw(e, t) {
  t.forEach((n) => {
    e[n] || (e[n] = {});
  });
}
function Ot(e, t, n) {
  !e[t] && n && (e[t] = n);
}
function qd(e) {
  return typeof e != "string" || !e.startsWith("hsl") ? e : cS(e);
}
function oo(e, t) {
  `${t}Channel` in e || (e[`${t}Channel`] = Gd(qd(e[t])));
}
function Iw(e) {
  return typeof e == "number" ? `${e}px` : typeof e == "string" || typeof e == "function" || Array.isArray(e) ? e : "8px";
}
const Ts = (e) => {
  try {
    return e();
  } catch {
  }
}, Bw = (e = "mui") => rw(e);
function yg(e, t, n, r) {
  if (!t)
    return;
  t = t === !0 ? {} : t;
  const i = r === "dark" ? "dark" : "light";
  if (!n) {
    e[r] = Mw({
      ...t,
      palette: {
        mode: i,
        ...t == null ? void 0 : t.palette
      }
    });
    return;
  }
  const {
    palette: s,
    ...l
  } = n0({
    ...n,
    palette: {
      mode: i,
      ...t == null ? void 0 : t.palette
    }
  });
  return e[r] = {
    ...t,
    palette: s,
    opacity: {
      ...bS(i),
      ...t == null ? void 0 : t.opacity
    },
    overlays: (t == null ? void 0 : t.overlays) || _S(i)
  }, l;
}
function Fw(e = {}, ...t) {
  const {
    colorSchemes: n = {
      light: !0
    },
    defaultColorScheme: r,
    disableCssColorScheme: i = !1,
    cssVarPrefix: s = "mui",
    shouldSkipGeneratingVar: l = Ow,
    colorSchemeSelector: c = n.light && n.dark ? "media" : void 0,
    rootSelector: u = ":root",
    ...d
  } = e, h = Object.keys(n)[0], p = r || (n.light && h !== "light" ? "light" : h), v = Bw(s), {
    [p]: m,
    light: g,
    dark: b,
    ...x
  } = n, w = {
    ...x
  };
  let T = m;
  if ((p === "dark" && !("dark" in n) || p === "light" && !("light" in n)) && (T = !0), !T)
    throw new Error(go(21, p));
  const S = yg(w, T, d, p);
  g && !w.light && yg(w, g, void 0, "light"), b && !w.dark && yg(w, b, void 0, "dark");
  let C = {
    defaultColorScheme: p,
    ...S,
    cssVarPrefix: s,
    colorSchemeSelector: c,
    rootSelector: u,
    getCssVar: v,
    colorSchemes: w,
    font: {
      ...mw(S.typography),
      ...S.font
    },
    spacing: Iw(d.spacing)
  };
  Object.keys(C.colorSchemes).forEach((L) => {
    const k = C.colorSchemes[L].palette, F = (G) => {
      const M = G.split("-"), j = M[1], D = M[2];
      return v(G, k[j][D]);
    };
    if (k.mode === "light" && (Ot(k.common, "background", "#fff"), Ot(k.common, "onBackground", "#000")), k.mode === "dark" && (Ot(k.common, "background", "#000"), Ot(k.common, "onBackground", "#fff")), Dw(k, ["Alert", "AppBar", "Avatar", "Button", "Chip", "FilledInput", "LinearProgress", "Skeleton", "Slider", "SnackbarContent", "SpeedDialAction", "StepConnector", "StepContent", "Switch", "TableCell", "Tooltip"]), k.mode === "light") {
      Ot(k.Alert, "errorColor", yn(k.error.light, 0.6)), Ot(k.Alert, "infoColor", yn(k.info.light, 0.6)), Ot(k.Alert, "successColor", yn(k.success.light, 0.6)), Ot(k.Alert, "warningColor", yn(k.warning.light, 0.6)), Ot(k.Alert, "errorFilledBg", F("palette-error-main")), Ot(k.Alert, "infoFilledBg", F("palette-info-main")), Ot(k.Alert, "successFilledBg", F("palette-success-main")), Ot(k.Alert, "warningFilledBg", F("palette-warning-main")), Ot(k.Alert, "errorFilledColor", Ts(() => k.getContrastText(k.error.main))), Ot(k.Alert, "infoFilledColor", Ts(() => k.getContrastText(k.info.main))), Ot(k.Alert, "successFilledColor", Ts(() => k.getContrastText(k.success.main))), Ot(k.Alert, "warningFilledColor", Ts(() => k.getContrastText(k.warning.main))), Ot(k.Alert, "errorStandardBg", vn(k.error.light, 0.9)), Ot(k.Alert, "infoStandardBg", vn(k.info.light, 0.9)), Ot(k.Alert, "successStandardBg", vn(k.success.light, 0.9)), Ot(k.Alert, "warningStandardBg", vn(k.warning.light, 0.9)), Ot(k.Alert, "errorIconColor", F("palette-error-main")), Ot(k.Alert, "infoIconColor", F("palette-info-main")), Ot(k.Alert, "successIconColor", F("palette-success-main")), Ot(k.Alert, "warningIconColor", F("palette-warning-main")), Ot(k.AppBar, "defaultBg", F("palette-grey-100")), Ot(k.Avatar, "defaultBg", F("palette-grey-400")), Ot(k.Button, "inheritContainedBg", F("palette-grey-300")), Ot(k.Button, "inheritContainedHoverBg", F("palette-grey-A100")), Ot(k.Chip, "defaultBorder", F("palette-grey-400")), Ot(k.Chip, "defaultAvatarColor", F("palette-grey-700")), Ot(k.Chip, "defaultIconColor", F("palette-grey-700")), Ot(k.FilledInput, "bg", "rgba(0, 0, 0, 0.06)"), Ot(k.FilledInput, "hoverBg", "rgba(0, 0, 0, 0.09)"), Ot(k.FilledInput, "disabledBg", "rgba(0, 0, 0, 0.12)"), Ot(k.LinearProgress, "primaryBg", vn(k.primary.main, 0.62)), Ot(k.LinearProgress, "secondaryBg", vn(k.secondary.main, 0.62)), Ot(k.LinearProgress, "errorBg", vn(k.error.main, 0.62)), Ot(k.LinearProgress, "infoBg", vn(k.info.main, 0.62)), Ot(k.LinearProgress, "successBg", vn(k.success.main, 0.62)), Ot(k.LinearProgress, "warningBg", vn(k.warning.main, 0.62)), Ot(k.Skeleton, "bg", `rgba(${F("palette-text-primaryChannel")} / 0.11)`), Ot(k.Slider, "primaryTrack", vn(k.primary.main, 0.62)), Ot(k.Slider, "secondaryTrack", vn(k.secondary.main, 0.62)), Ot(k.Slider, "errorTrack", vn(k.error.main, 0.62)), Ot(k.Slider, "infoTrack", vn(k.info.main, 0.62)), Ot(k.Slider, "successTrack", vn(k.success.main, 0.62)), Ot(k.Slider, "warningTrack", vn(k.warning.main, 0.62));
      const G = Sf(k.background.default, 0.8);
      Ot(k.SnackbarContent, "bg", G), Ot(k.SnackbarContent, "color", Ts(() => k.getContrastText(G))), Ot(k.SpeedDialAction, "fabHoverBg", Sf(k.background.paper, 0.15)), Ot(k.StepConnector, "border", F("palette-grey-400")), Ot(k.StepContent, "border", F("palette-grey-400")), Ot(k.Switch, "defaultColor", F("palette-common-white")), Ot(k.Switch, "defaultDisabledColor", F("palette-grey-100")), Ot(k.Switch, "primaryDisabledColor", vn(k.primary.main, 0.62)), Ot(k.Switch, "secondaryDisabledColor", vn(k.secondary.main, 0.62)), Ot(k.Switch, "errorDisabledColor", vn(k.error.main, 0.62)), Ot(k.Switch, "infoDisabledColor", vn(k.info.main, 0.62)), Ot(k.Switch, "successDisabledColor", vn(k.success.main, 0.62)), Ot(k.Switch, "warningDisabledColor", vn(k.warning.main, 0.62)), Ot(k.TableCell, "border", vn(_f(k.divider, 1), 0.88)), Ot(k.Tooltip, "bg", _f(k.grey[700], 0.92));
    }
    if (k.mode === "dark") {
      Ot(k.Alert, "errorColor", vn(k.error.light, 0.6)), Ot(k.Alert, "infoColor", vn(k.info.light, 0.6)), Ot(k.Alert, "successColor", vn(k.success.light, 0.6)), Ot(k.Alert, "warningColor", vn(k.warning.light, 0.6)), Ot(k.Alert, "errorFilledBg", F("palette-error-dark")), Ot(k.Alert, "infoFilledBg", F("palette-info-dark")), Ot(k.Alert, "successFilledBg", F("palette-success-dark")), Ot(k.Alert, "warningFilledBg", F("palette-warning-dark")), Ot(k.Alert, "errorFilledColor", Ts(() => k.getContrastText(k.error.dark))), Ot(k.Alert, "infoFilledColor", Ts(() => k.getContrastText(k.info.dark))), Ot(k.Alert, "successFilledColor", Ts(() => k.getContrastText(k.success.dark))), Ot(k.Alert, "warningFilledColor", Ts(() => k.getContrastText(k.warning.dark))), Ot(k.Alert, "errorStandardBg", yn(k.error.light, 0.9)), Ot(k.Alert, "infoStandardBg", yn(k.info.light, 0.9)), Ot(k.Alert, "successStandardBg", yn(k.success.light, 0.9)), Ot(k.Alert, "warningStandardBg", yn(k.warning.light, 0.9)), Ot(k.Alert, "errorIconColor", F("palette-error-main")), Ot(k.Alert, "infoIconColor", F("palette-info-main")), Ot(k.Alert, "successIconColor", F("palette-success-main")), Ot(k.Alert, "warningIconColor", F("palette-warning-main")), Ot(k.AppBar, "defaultBg", F("palette-grey-900")), Ot(k.AppBar, "darkBg", F("palette-background-paper")), Ot(k.AppBar, "darkColor", F("palette-text-primary")), Ot(k.Avatar, "defaultBg", F("palette-grey-600")), Ot(k.Button, "inheritContainedBg", F("palette-grey-800")), Ot(k.Button, "inheritContainedHoverBg", F("palette-grey-700")), Ot(k.Chip, "defaultBorder", F("palette-grey-700")), Ot(k.Chip, "defaultAvatarColor", F("palette-grey-300")), Ot(k.Chip, "defaultIconColor", F("palette-grey-300")), Ot(k.FilledInput, "bg", "rgba(255, 255, 255, 0.09)"), Ot(k.FilledInput, "hoverBg", "rgba(255, 255, 255, 0.13)"), Ot(k.FilledInput, "disabledBg", "rgba(255, 255, 255, 0.12)"), Ot(k.LinearProgress, "primaryBg", yn(k.primary.main, 0.5)), Ot(k.LinearProgress, "secondaryBg", yn(k.secondary.main, 0.5)), Ot(k.LinearProgress, "errorBg", yn(k.error.main, 0.5)), Ot(k.LinearProgress, "infoBg", yn(k.info.main, 0.5)), Ot(k.LinearProgress, "successBg", yn(k.success.main, 0.5)), Ot(k.LinearProgress, "warningBg", yn(k.warning.main, 0.5)), Ot(k.Skeleton, "bg", `rgba(${F("palette-text-primaryChannel")} / 0.13)`), Ot(k.Slider, "primaryTrack", yn(k.primary.main, 0.5)), Ot(k.Slider, "secondaryTrack", yn(k.secondary.main, 0.5)), Ot(k.Slider, "errorTrack", yn(k.error.main, 0.5)), Ot(k.Slider, "infoTrack", yn(k.info.main, 0.5)), Ot(k.Slider, "successTrack", yn(k.success.main, 0.5)), Ot(k.Slider, "warningTrack", yn(k.warning.main, 0.5));
      const G = Sf(k.background.default, 0.98);
      Ot(k.SnackbarContent, "bg", G), Ot(k.SnackbarContent, "color", Ts(() => k.getContrastText(G))), Ot(k.SpeedDialAction, "fabHoverBg", Sf(k.background.paper, 0.15)), Ot(k.StepConnector, "border", F("palette-grey-600")), Ot(k.StepContent, "border", F("palette-grey-600")), Ot(k.Switch, "defaultColor", F("palette-grey-300")), Ot(k.Switch, "defaultDisabledColor", F("palette-grey-600")), Ot(k.Switch, "primaryDisabledColor", yn(k.primary.main, 0.55)), Ot(k.Switch, "secondaryDisabledColor", yn(k.secondary.main, 0.55)), Ot(k.Switch, "errorDisabledColor", yn(k.error.main, 0.55)), Ot(k.Switch, "infoDisabledColor", yn(k.info.main, 0.55)), Ot(k.Switch, "successDisabledColor", yn(k.success.main, 0.55)), Ot(k.Switch, "warningDisabledColor", yn(k.warning.main, 0.55)), Ot(k.TableCell, "border", yn(_f(k.divider, 1), 0.68)), Ot(k.Tooltip, "bg", _f(k.grey[700], 0.92));
    }
    oo(k.background, "default"), oo(k.background, "paper"), oo(k.common, "background"), oo(k.common, "onBackground"), oo(k, "divider"), Object.keys(k).forEach((G) => {
      const M = k[G];
      G !== "tonalOffset" && M && typeof M == "object" && (M.main && Ot(k[G], "mainChannel", Gd(qd(M.main))), M.light && Ot(k[G], "lightChannel", Gd(qd(M.light))), M.dark && Ot(k[G], "darkChannel", Gd(qd(M.dark))), M.contrastText && Ot(k[G], "contrastTextChannel", Gd(qd(M.contrastText))), G === "text" && (oo(k[G], "primary"), oo(k[G], "secondary")), G === "action" && (M.active && oo(k[G], "active"), M.selected && oo(k[G], "selected")));
    });
  }), C = t.reduce((L, k) => Fr(L, k), C);
  const E = {
    prefix: s,
    disableCssColorScheme: i,
    shouldSkipGeneratingVar: l,
    getSelector: Pw(C)
  }, {
    vars: O,
    generateThemeVars: B,
    generateStyleSheets: N
  } = ow(C, E);
  return C.vars = O, Object.entries(C.colorSchemes[C.defaultColorScheme]).forEach(([L, k]) => {
    C[L] = k;
  }), C.generateThemeVars = B, C.generateStyleSheets = N, C.generateSpacing = function() {
    return rS(d.spacing, V0(this));
  }, C.getColorSchemeSelector = aw(c), C.spacing = C.generateSpacing(), C.shouldSkipGeneratingVar = l, C.unstable_sxConfig = {
    ...vh,
    ...d == null ? void 0 : d.unstable_sxConfig
  }, C.unstable_sx = function(k) {
    return hl({
      sx: k,
      theme: this
    });
  }, C.toRuntimeSource = vS, C;
}
function Wv(e, t, n) {
  e.colorSchemes && n && (e.colorSchemes[t] = {
    ...n !== !0 && n,
    palette: $0({
      ...n === !0 ? {} : n.palette,
      mode: t
    })
    // cast type to skip module augmentation test
  });
}
function SS(e = {}, ...t) {
  const {
    palette: n,
    cssVariables: r = !1,
    colorSchemes: i = n ? void 0 : {
      light: !0
    },
    defaultColorScheme: s = n == null ? void 0 : n.mode,
    ...l
  } = e, c = s || "light", u = i == null ? void 0 : i[c], d = {
    ...i,
    ...n ? {
      [c]: {
        ...typeof u != "boolean" && u,
        palette: n
      }
    } : void 0
  };
  if (r === !1) {
    if (!("colorSchemes" in e))
      return n0(e, ...t);
    let h = n;
    "palette" in e || d[c] && (d[c] !== !0 ? h = d[c].palette : c === "dark" && (h = {
      mode: "dark"
    }));
    const p = n0({
      ...e,
      palette: h
    }, ...t);
    return p.defaultColorScheme = c, p.colorSchemes = d, p.palette.mode === "light" && (p.colorSchemes.light = {
      ...d.light !== !0 && d.light,
      palette: p.palette
    }, Wv(p, "dark", d.dark)), p.palette.mode === "dark" && (p.colorSchemes.dark = {
      ...d.dark !== !0 && d.dark,
      palette: p.palette
    }, Wv(p, "light", d.light)), p;
  }
  return !n && !("light" in d) && c === "light" && (d.light = !0), Fw({
    ...l,
    colorSchemes: d,
    defaultColorScheme: c,
    ...typeof r != "boolean" && r
  }, ...t);
}
const K0 = SS();
function Up() {
  const e = H0(K0);
  return e[Ep] || e;
}
function Vp(e) {
  return e !== "ownerState" && e !== "theme" && e !== "sx" && e !== "as";
}
const $i = (e) => Vp(e) && e !== "classes", he = BC({
  themeId: Ep,
  defaultTheme: K0,
  rootShouldForwardProp: $i
});
function jw(e) {
  return /* @__PURE__ */ W.jsx(kC, {
    ...e,
    defaultTheme: K0,
    themeId: Ep
  });
}
function Lw(e) {
  return function(n) {
    return (
      // Pigment CSS `globalCss` support callback with theme inside an object but `GlobalStyles` support theme as a callback value.
      /* @__PURE__ */ W.jsx(jw, {
        styles: typeof e == "function" ? (r) => e({
          theme: r,
          ...n
        }) : e
      })
    );
  };
}
function zw() {
  return iS;
}
const He = nw;
function nn(e) {
  return ew(e);
}
function Uw(e) {
  return Qe("MuiSvgIcon", e);
}
Xe("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
const Vw = (e) => {
  const {
    color: t,
    fontSize: n,
    classes: r
  } = e, i = {
    root: ["root", t !== "inherit" && `color${pe(t)}`, `fontSize${pe(n)}`]
  };
  return Ze(i, Uw, r);
}, Gw = he("svg", {
  name: "MuiSvgIcon",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.color !== "inherit" && t[`color${pe(n.color)}`], t[`fontSize${pe(n.fontSize)}`]];
  }
})(He(({
  theme: e
}) => {
  var t, n, r, i, s, l, c, u, d, h, p, v, m, g;
  return {
    userSelect: "none",
    width: "1em",
    height: "1em",
    display: "inline-block",
    flexShrink: 0,
    transition: (i = (t = e.transitions) == null ? void 0 : t.create) == null ? void 0 : i.call(t, "fill", {
      duration: (r = (n = (e.vars ?? e).transitions) == null ? void 0 : n.duration) == null ? void 0 : r.shorter
    }),
    variants: [
      {
        props: (b) => !b.hasSvgAsChild,
        style: {
          // the <svg> will define the property that has `currentColor`
          // for example heroicons uses fill="none" and stroke="currentColor"
          fill: "currentColor"
        }
      },
      {
        props: {
          fontSize: "inherit"
        },
        style: {
          fontSize: "inherit"
        }
      },
      {
        props: {
          fontSize: "small"
        },
        style: {
          fontSize: ((l = (s = e.typography) == null ? void 0 : s.pxToRem) == null ? void 0 : l.call(s, 20)) || "1.25rem"
        }
      },
      {
        props: {
          fontSize: "medium"
        },
        style: {
          fontSize: ((u = (c = e.typography) == null ? void 0 : c.pxToRem) == null ? void 0 : u.call(c, 24)) || "1.5rem"
        }
      },
      {
        props: {
          fontSize: "large"
        },
        style: {
          fontSize: ((h = (d = e.typography) == null ? void 0 : d.pxToRem) == null ? void 0 : h.call(d, 35)) || "2.1875rem"
        }
      },
      // TODO v5 deprecate color prop, v6 remove for sx
      ...Object.entries((e.vars ?? e).palette).filter(([, b]) => b && b.main).map(([b]) => {
        var x, w;
        return {
          props: {
            color: b
          },
          style: {
            color: (w = (x = (e.vars ?? e).palette) == null ? void 0 : x[b]) == null ? void 0 : w.main
          }
        };
      }),
      {
        props: {
          color: "action"
        },
        style: {
          color: (v = (p = (e.vars ?? e).palette) == null ? void 0 : p.action) == null ? void 0 : v.active
        }
      },
      {
        props: {
          color: "disabled"
        },
        style: {
          color: (g = (m = (e.vars ?? e).palette) == null ? void 0 : m.action) == null ? void 0 : g.disabled
        }
      },
      {
        props: {
          color: "inherit"
        },
        style: {
          color: void 0
        }
      }
    ]
  };
})), i0 = /* @__PURE__ */ K.forwardRef(function(t, n) {
  const r = nn({
    props: t,
    name: "MuiSvgIcon"
  }), {
    children: i,
    className: s,
    color: l = "inherit",
    component: c = "svg",
    fontSize: u = "medium",
    htmlColor: d,
    inheritViewBox: h = !1,
    titleAccess: p,
    viewBox: v = "0 0 24 24",
    ...m
  } = r, g = /* @__PURE__ */ K.isValidElement(i) && i.type === "svg", b = {
    ...r,
    color: l,
    component: c,
    fontSize: u,
    instanceFontSize: t.fontSize,
    inheritViewBox: h,
    viewBox: v,
    hasSvgAsChild: g
  }, x = {};
  h || (x.viewBox = v);
  const w = Vw(b);
  return /* @__PURE__ */ W.jsxs(Gw, {
    as: c,
    className: ge(w.root, s),
    focusable: "false",
    color: d,
    "aria-hidden": p ? void 0 : !0,
    role: p ? "img" : void 0,
    ref: n,
    ...x,
    ...m,
    ...g && i.props,
    ownerState: b,
    children: [g ? i.props.children : i, p ? /* @__PURE__ */ W.jsx("title", {
      children: p
    }) : null]
  });
});
i0.muiName = "SvgIcon";
function zr(e, t) {
  function n(r, i) {
    return /* @__PURE__ */ W.jsx(i0, {
      "data-testid": `${t}Icon`,
      ref: i,
      ...r,
      children: e
    });
  }
  return n.muiName = i0.muiName, /* @__PURE__ */ K.memo(/* @__PURE__ */ K.forwardRef(n));
}
function qw(e, t) {
  if (!e)
    return t;
  if (typeof e == "function" || typeof t == "function")
    return (i) => {
      const s = typeof t == "function" ? t(i) : t, l = typeof e == "function" ? e({
        ...i,
        ...s
      }) : e, c = ge(i == null ? void 0 : i.className, s == null ? void 0 : s.className, l == null ? void 0 : l.className);
      return {
        ...s,
        ...l,
        ...!!c && {
          className: c
        },
        ...(s == null ? void 0 : s.style) && (l == null ? void 0 : l.style) && {
          style: {
            ...s.style,
            ...l.style
          }
        },
        ...(s == null ? void 0 : s.sx) && (l == null ? void 0 : l.sx) && {
          sx: [...Array.isArray(s.sx) ? s.sx : [s.sx], ...Array.isArray(l.sx) ? l.sx : [l.sx]]
        }
      };
    };
  const n = t, r = ge(n == null ? void 0 : n.className, e == null ? void 0 : e.className);
  return {
    ...t,
    ...e,
    ...!!r && {
      className: r
    },
    ...(n == null ? void 0 : n.style) && (e == null ? void 0 : e.style) && {
      style: {
        ...n.style,
        ...e.style
      }
    },
    ...(n == null ? void 0 : n.sx) && (e == null ? void 0 : e.sx) && {
      sx: [...Array.isArray(n.sx) ? n.sx : [n.sx], ...Array.isArray(e.sx) ? e.sx : [e.sx]]
    }
  };
}
function xS(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
function s0(e, t) {
  return s0 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, r) {
    return n.__proto__ = r, n;
  }, s0(e, t);
}
function TS(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, s0(e, t);
}
var vg = { exports: {} }, Ir = {};
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var $v;
function Hw() {
  if ($v) return Ir;
  $v = 1;
  var e = O0();
  function t(u) {
    var d = "https://react.dev/errors/" + u;
    if (1 < arguments.length) {
      d += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var h = 2; h < arguments.length; h++)
        d += "&args[]=" + encodeURIComponent(arguments[h]);
    }
    return "Minified React error #" + u + "; visit " + d + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function n() {
  }
  var r = {
    d: {
      f: n,
      r: function() {
        throw Error(t(522));
      },
      D: n,
      C: n,
      L: n,
      m: n,
      X: n,
      S: n,
      M: n
    },
    p: 0,
    findDOMNode: null
  }, i = Symbol.for("react.portal");
  function s(u, d, h) {
    var p = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
      $$typeof: i,
      key: p == null ? null : "" + p,
      children: u,
      containerInfo: d,
      implementation: h
    };
  }
  var l = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  function c(u, d) {
    if (u === "font") return "";
    if (typeof d == "string")
      return d === "use-credentials" ? d : "";
  }
  return Ir.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = r, Ir.createPortal = function(u, d) {
    var h = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!d || d.nodeType !== 1 && d.nodeType !== 9 && d.nodeType !== 11)
      throw Error(t(299));
    return s(u, d, null, h);
  }, Ir.flushSync = function(u) {
    var d = l.T, h = r.p;
    try {
      if (l.T = null, r.p = 2, u) return u();
    } finally {
      l.T = d, r.p = h, r.d.f();
    }
  }, Ir.preconnect = function(u, d) {
    typeof u == "string" && (d ? (d = d.crossOrigin, d = typeof d == "string" ? d === "use-credentials" ? d : "" : void 0) : d = null, r.d.C(u, d));
  }, Ir.prefetchDNS = function(u) {
    typeof u == "string" && r.d.D(u);
  }, Ir.preinit = function(u, d) {
    if (typeof u == "string" && d && typeof d.as == "string") {
      var h = d.as, p = c(h, d.crossOrigin), v = typeof d.integrity == "string" ? d.integrity : void 0, m = typeof d.fetchPriority == "string" ? d.fetchPriority : void 0;
      h === "style" ? r.d.S(
        u,
        typeof d.precedence == "string" ? d.precedence : void 0,
        {
          crossOrigin: p,
          integrity: v,
          fetchPriority: m
        }
      ) : h === "script" && r.d.X(u, {
        crossOrigin: p,
        integrity: v,
        fetchPriority: m,
        nonce: typeof d.nonce == "string" ? d.nonce : void 0
      });
    }
  }, Ir.preinitModule = function(u, d) {
    if (typeof u == "string")
      if (typeof d == "object" && d !== null) {
        if (d.as == null || d.as === "script") {
          var h = c(
            d.as,
            d.crossOrigin
          );
          r.d.M(u, {
            crossOrigin: h,
            integrity: typeof d.integrity == "string" ? d.integrity : void 0,
            nonce: typeof d.nonce == "string" ? d.nonce : void 0
          });
        }
      } else d == null && r.d.M(u);
  }, Ir.preload = function(u, d) {
    if (typeof u == "string" && typeof d == "object" && d !== null && typeof d.as == "string") {
      var h = d.as, p = c(h, d.crossOrigin);
      r.d.L(u, h, {
        crossOrigin: p,
        integrity: typeof d.integrity == "string" ? d.integrity : void 0,
        nonce: typeof d.nonce == "string" ? d.nonce : void 0,
        type: typeof d.type == "string" ? d.type : void 0,
        fetchPriority: typeof d.fetchPriority == "string" ? d.fetchPriority : void 0,
        referrerPolicy: typeof d.referrerPolicy == "string" ? d.referrerPolicy : void 0,
        imageSrcSet: typeof d.imageSrcSet == "string" ? d.imageSrcSet : void 0,
        imageSizes: typeof d.imageSizes == "string" ? d.imageSizes : void 0,
        media: typeof d.media == "string" ? d.media : void 0
      });
    }
  }, Ir.preloadModule = function(u, d) {
    if (typeof u == "string")
      if (d) {
        var h = c(d.as, d.crossOrigin);
        r.d.m(u, {
          as: typeof d.as == "string" && d.as !== "script" ? d.as : void 0,
          crossOrigin: h,
          integrity: typeof d.integrity == "string" ? d.integrity : void 0
        });
      } else r.d.m(u);
  }, Ir.requestFormReset = function(u) {
    r.d.r(u);
  }, Ir.unstable_batchedUpdates = function(u, d) {
    return u(d);
  }, Ir.useFormState = function(u, d, h) {
    return l.H.useFormState(u, d, h);
  }, Ir.useFormStatus = function() {
    return l.H.useHostTransitionStatus();
  }, Ir.version = "19.0.0", Ir;
}
var Kv;
function Ww() {
  if (Kv) return vg.exports;
  Kv = 1;
  function e() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (t) {
        console.error(t);
      }
  }
  return e(), vg.exports = Hw(), vg.exports;
}
var CS = Ww();
const xf = /* @__PURE__ */ hh(CS), Yv = {
  disabled: !1
}, ep = ke.createContext(null);
var $w = function(t) {
  return t.scrollTop;
}, Hd = "unmounted", el = "exited", nl = "entering", Tc = "entered", o0 = "exiting", Fs = /* @__PURE__ */ function(e) {
  TS(t, e);
  function t(r, i) {
    var s;
    s = e.call(this, r, i) || this;
    var l = i, c = l && !l.isMounting ? r.enter : r.appear, u;
    return s.appearStatus = null, r.in ? c ? (u = el, s.appearStatus = nl) : u = Tc : r.unmountOnExit || r.mountOnEnter ? u = Hd : u = el, s.state = {
      status: u
    }, s.nextCallback = null, s;
  }
  t.getDerivedStateFromProps = function(i, s) {
    var l = i.in;
    return l && s.status === Hd ? {
      status: el
    } : null;
  };
  var n = t.prototype;
  return n.componentDidMount = function() {
    this.updateStatus(!0, this.appearStatus);
  }, n.componentDidUpdate = function(i) {
    var s = null;
    if (i !== this.props) {
      var l = this.state.status;
      this.props.in ? l !== nl && l !== Tc && (s = nl) : (l === nl || l === Tc) && (s = o0);
    }
    this.updateStatus(!1, s);
  }, n.componentWillUnmount = function() {
    this.cancelNextCallback();
  }, n.getTimeouts = function() {
    var i = this.props.timeout, s, l, c;
    return s = l = c = i, i != null && typeof i != "number" && (s = i.exit, l = i.enter, c = i.appear !== void 0 ? i.appear : l), {
      exit: s,
      enter: l,
      appear: c
    };
  }, n.updateStatus = function(i, s) {
    if (i === void 0 && (i = !1), s !== null)
      if (this.cancelNextCallback(), s === nl) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var l = this.props.nodeRef ? this.props.nodeRef.current : xf.findDOMNode(this);
          l && $w(l);
        }
        this.performEnter(i);
      } else
        this.performExit();
    else this.props.unmountOnExit && this.state.status === el && this.setState({
      status: Hd
    });
  }, n.performEnter = function(i) {
    var s = this, l = this.props.enter, c = this.context ? this.context.isMounting : i, u = this.props.nodeRef ? [c] : [xf.findDOMNode(this), c], d = u[0], h = u[1], p = this.getTimeouts(), v = c ? p.appear : p.enter;
    if (!i && !l || Yv.disabled) {
      this.safeSetState({
        status: Tc
      }, function() {
        s.props.onEntered(d);
      });
      return;
    }
    this.props.onEnter(d, h), this.safeSetState({
      status: nl
    }, function() {
      s.props.onEntering(d, h), s.onTransitionEnd(v, function() {
        s.safeSetState({
          status: Tc
        }, function() {
          s.props.onEntered(d, h);
        });
      });
    });
  }, n.performExit = function() {
    var i = this, s = this.props.exit, l = this.getTimeouts(), c = this.props.nodeRef ? void 0 : xf.findDOMNode(this);
    if (!s || Yv.disabled) {
      this.safeSetState({
        status: el
      }, function() {
        i.props.onExited(c);
      });
      return;
    }
    this.props.onExit(c), this.safeSetState({
      status: o0
    }, function() {
      i.props.onExiting(c), i.onTransitionEnd(l.exit, function() {
        i.safeSetState({
          status: el
        }, function() {
          i.props.onExited(c);
        });
      });
    });
  }, n.cancelNextCallback = function() {
    this.nextCallback !== null && (this.nextCallback.cancel(), this.nextCallback = null);
  }, n.safeSetState = function(i, s) {
    s = this.setNextCallback(s), this.setState(i, s);
  }, n.setNextCallback = function(i) {
    var s = this, l = !0;
    return this.nextCallback = function(c) {
      l && (l = !1, s.nextCallback = null, i(c));
    }, this.nextCallback.cancel = function() {
      l = !1;
    }, this.nextCallback;
  }, n.onTransitionEnd = function(i, s) {
    this.setNextCallback(s);
    var l = this.props.nodeRef ? this.props.nodeRef.current : xf.findDOMNode(this), c = i == null && !this.props.addEndListener;
    if (!l || c) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var u = this.props.nodeRef ? [this.nextCallback] : [l, this.nextCallback], d = u[0], h = u[1];
      this.props.addEndListener(d, h);
    }
    i != null && setTimeout(this.nextCallback, i);
  }, n.render = function() {
    var i = this.state.status;
    if (i === Hd)
      return null;
    var s = this.props, l = s.children;
    s.in, s.mountOnEnter, s.unmountOnExit, s.appear, s.enter, s.exit, s.timeout, s.addEndListener, s.onEnter, s.onEntering, s.onEntered, s.onExit, s.onExiting, s.onExited, s.nodeRef;
    var c = xS(s, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      /* @__PURE__ */ ke.createElement(ep.Provider, {
        value: null
      }, typeof l == "function" ? l(i, c) : ke.cloneElement(ke.Children.only(l), c))
    );
  }, t;
}(ke.Component);
Fs.contextType = ep;
Fs.propTypes = {};
function bc() {
}
Fs.defaultProps = {
  in: !1,
  mountOnEnter: !1,
  unmountOnExit: !1,
  appear: !1,
  enter: !0,
  exit: !0,
  onEnter: bc,
  onEntering: bc,
  onEntered: bc,
  onExit: bc,
  onExiting: bc,
  onExited: bc
};
Fs.UNMOUNTED = Hd;
Fs.EXITED = el;
Fs.ENTERING = nl;
Fs.ENTERED = Tc;
Fs.EXITING = o0;
function Kw(e) {
  if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function Y0(e, t) {
  var n = function(s) {
    return t && K.isValidElement(s) ? t(s) : s;
  }, r = /* @__PURE__ */ Object.create(null);
  return e && K.Children.map(e, function(i) {
    return i;
  }).forEach(function(i) {
    r[i.key] = n(i);
  }), r;
}
function Yw(e, t) {
  e = e || {}, t = t || {};
  function n(h) {
    return h in t ? t[h] : e[h];
  }
  var r = /* @__PURE__ */ Object.create(null), i = [];
  for (var s in e)
    s in t ? i.length && (r[s] = i, i = []) : i.push(s);
  var l, c = {};
  for (var u in t) {
    if (r[u])
      for (l = 0; l < r[u].length; l++) {
        var d = r[u][l];
        c[r[u][l]] = n(d);
      }
    c[u] = n(u);
  }
  for (l = 0; l < i.length; l++)
    c[i[l]] = n(i[l]);
  return c;
}
function sl(e, t, n) {
  return n[t] != null ? n[t] : e.props[t];
}
function Xw(e, t) {
  return Y0(e.children, function(n) {
    return K.cloneElement(n, {
      onExited: t.bind(null, n),
      in: !0,
      appear: sl(n, "appear", e),
      enter: sl(n, "enter", e),
      exit: sl(n, "exit", e)
    });
  });
}
function Qw(e, t, n) {
  var r = Y0(e.children), i = Yw(t, r);
  return Object.keys(i).forEach(function(s) {
    var l = i[s];
    if (K.isValidElement(l)) {
      var c = s in t, u = s in r, d = t[s], h = K.isValidElement(d) && !d.props.in;
      u && (!c || h) ? i[s] = K.cloneElement(l, {
        onExited: n.bind(null, l),
        in: !0,
        exit: sl(l, "exit", e),
        enter: sl(l, "enter", e)
      }) : !u && c && !h ? i[s] = K.cloneElement(l, {
        in: !1
      }) : u && c && K.isValidElement(d) && (i[s] = K.cloneElement(l, {
        onExited: n.bind(null, l),
        in: d.props.in,
        exit: sl(l, "exit", e),
        enter: sl(l, "enter", e)
      }));
    }
  }), i;
}
var Zw = Object.values || function(e) {
  return Object.keys(e).map(function(t) {
    return e[t];
  });
}, Jw = {
  component: "div",
  childFactory: function(t) {
    return t;
  }
}, X0 = /* @__PURE__ */ function(e) {
  TS(t, e);
  function t(r, i) {
    var s;
    s = e.call(this, r, i) || this;
    var l = s.handleExited.bind(Kw(s));
    return s.state = {
      contextValue: {
        isMounting: !0
      },
      handleExited: l,
      firstRender: !0
    }, s;
  }
  var n = t.prototype;
  return n.componentDidMount = function() {
    this.mounted = !0, this.setState({
      contextValue: {
        isMounting: !1
      }
    });
  }, n.componentWillUnmount = function() {
    this.mounted = !1;
  }, t.getDerivedStateFromProps = function(i, s) {
    var l = s.children, c = s.handleExited, u = s.firstRender;
    return {
      children: u ? Xw(i, c) : Qw(i, l, c),
      firstRender: !1
    };
  }, n.handleExited = function(i, s) {
    var l = Y0(this.props.children);
    i.key in l || (i.props.onExited && i.props.onExited(s), this.mounted && this.setState(function(c) {
      var u = Qf({}, c.children);
      return delete u[i.key], {
        children: u
      };
    }));
  }, n.render = function() {
    var i = this.props, s = i.component, l = i.childFactory, c = xS(i, ["component", "childFactory"]), u = this.state.contextValue, d = Zw(this.state.children).map(l);
    return delete c.appear, delete c.enter, delete c.exit, s === null ? /* @__PURE__ */ ke.createElement(ep.Provider, {
      value: u
    }, d) : /* @__PURE__ */ ke.createElement(ep.Provider, {
      value: u
    }, /* @__PURE__ */ ke.createElement(s, c, d));
  }, t;
}(ke.Component);
X0.propTypes = {};
X0.defaultProps = Jw;
const wS = (e) => e.scrollTop;
function np(e, t) {
  const {
    timeout: n,
    easing: r,
    style: i = {}
  } = e;
  return {
    duration: i.transitionDuration ?? (typeof n == "number" ? n : n[t.mode] || 0),
    easing: i.transitionTimingFunction ?? (typeof r == "object" ? r[t.mode] : r),
    delay: i.transitionDelay
  };
}
function t6(e) {
  return Qe("MuiPaper", e);
}
Xe("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
const e6 = (e) => {
  const {
    square: t,
    elevation: n,
    variant: r,
    classes: i
  } = e, s = {
    root: ["root", r, !t && "rounded", r === "elevation" && `elevation${n}`]
  };
  return Ze(s, t6, i);
}, n6 = he("div", {
  name: "MuiPaper",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, t[n.variant], !n.square && t.rounded, n.variant === "elevation" && t[`elevation${n.elevation}`]];
  }
})(He(({
  theme: e
}) => ({
  backgroundColor: (e.vars || e).palette.background.paper,
  color: (e.vars || e).palette.text.primary,
  transition: e.transitions.create("box-shadow"),
  variants: [{
    props: ({
      ownerState: t
    }) => !t.square,
    style: {
      borderRadius: e.shape.borderRadius
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      border: `1px solid ${(e.vars || e).palette.divider}`
    }
  }, {
    props: {
      variant: "elevation"
    },
    style: {
      boxShadow: "var(--Paper-shadow)",
      backgroundImage: "var(--Paper-overlay)"
    }
  }]
}))), r6 = /* @__PURE__ */ K.forwardRef(function(t, n) {
  var m;
  const r = nn({
    props: t,
    name: "MuiPaper"
  }), i = Up(), {
    className: s,
    component: l = "div",
    elevation: c = 1,
    square: u = !1,
    variant: d = "elevation",
    ...h
  } = r, p = {
    ...r,
    component: l,
    elevation: c,
    square: u,
    variant: d
  }, v = e6(p);
  return /* @__PURE__ */ W.jsx(n6, {
    as: l,
    ownerState: p,
    className: ge(v.root, s),
    ref: n,
    ...h,
    style: {
      ...d === "elevation" && {
        "--Paper-shadow": (i.vars || i).shadows[c],
        ...i.vars && {
          "--Paper-overlay": (m = i.vars.overlays) == null ? void 0 : m[c]
        },
        ...!i.vars && i.palette.mode === "dark" && {
          "--Paper-overlay": `linear-gradient(${xn("#fff", r0(c))}, ${xn("#fff", r0(c))})`
        }
      },
      ...h.style
    }
  });
});
function $n(e, t) {
  const {
    className: n,
    elementType: r,
    ownerState: i,
    externalForwardedProps: s,
    internalForwardedProps: l,
    shouldForwardComponentProp: c = !1,
    ...u
  } = t, {
    component: d,
    slots: h = {
      [e]: void 0
    },
    slotProps: p = {
      [e]: void 0
    },
    ...v
  } = s, m = h[e] || r, g = mS(p[e], i), {
    props: {
      component: b,
      ...x
    },
    internalRef: w
  } = pS({
    className: n,
    ...u,
    externalForwardedProps: e === "root" ? v : void 0,
    externalSlotProps: g
  }), T = ar(w, g == null ? void 0 : g.ref, t.ref), S = e === "root" ? b || d : b, C = fS(m, {
    ...e === "root" && !d && !h[e] && l,
    ...e !== "root" && !h[e] && l,
    ...x,
    ...S && !c && {
      as: S
    },
    ...S && c && {
      component: S
    },
    ref: T
  }, i);
  return [m, C];
}
class rp {
  constructor() {
    xe(this, "mountEffect", () => {
      this.shouldMount && !this.didMount && this.ref.current !== null && (this.didMount = !0, this.mounted.resolve());
    });
    this.ref = {
      current: null
    }, this.mounted = null, this.didMount = !1, this.shouldMount = !1, this.setShouldMount = null;
  }
  /** React ref to the ripple instance */
  /** If the ripple component should be mounted */
  /** Promise that resolves when the ripple component is mounted */
  /** If the ripple component has been mounted */
  /** React state hook setter */
  static create() {
    return new rp();
  }
  static use() {
    const t = dS(rp.create).current, [n, r] = K.useState(!1);
    return t.shouldMount = n, t.setShouldMount = r, K.useEffect(t.mountEffect, [n]), t;
  }
  mount() {
    return this.mounted || (this.mounted = s6(), this.shouldMount = !0, this.setShouldMount(this.shouldMount)), this.mounted;
  }
  /* Ripple API */
  start(...t) {
    this.mount().then(() => {
      var n;
      return (n = this.ref.current) == null ? void 0 : n.start(...t);
    });
  }
  stop(...t) {
    this.mount().then(() => {
      var n;
      return (n = this.ref.current) == null ? void 0 : n.stop(...t);
    });
  }
  pulsate(...t) {
    this.mount().then(() => {
      var n;
      return (n = this.ref.current) == null ? void 0 : n.pulsate(...t);
    });
  }
}
function i6() {
  return rp.use();
}
function s6() {
  let e, t;
  const n = new Promise((r, i) => {
    e = r, t = i;
  });
  return n.resolve = e, n.reject = t, n;
}
function o6(e) {
  const {
    className: t,
    classes: n,
    pulsate: r = !1,
    rippleX: i,
    rippleY: s,
    rippleSize: l,
    in: c,
    onExited: u,
    timeout: d
  } = e, [h, p] = K.useState(!1), v = ge(t, n.ripple, n.rippleVisible, r && n.ripplePulsate), m = {
    width: l,
    height: l,
    top: -(l / 2) + s,
    left: -(l / 2) + i
  }, g = ge(n.child, h && n.childLeaving, r && n.childPulsate);
  return !c && !h && p(!0), K.useEffect(() => {
    if (!c && u != null) {
      const b = setTimeout(u, d);
      return () => {
        clearTimeout(b);
      };
    }
  }, [u, c, d]), /* @__PURE__ */ W.jsx("span", {
    className: v,
    style: m,
    children: /* @__PURE__ */ W.jsx("span", {
      className: g
    })
  });
}
const Li = Xe("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]), a0 = 550, a6 = 80, l6 = mh`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`, c6 = mh`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`, u6 = mh`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`, d6 = he("span", {
  name: "MuiTouchRipple",
  slot: "Root"
})({
  overflow: "hidden",
  pointerEvents: "none",
  position: "absolute",
  zIndex: 0,
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  borderRadius: "inherit"
}), h6 = he(o6, {
  name: "MuiTouchRipple",
  slot: "Ripple"
})`
  opacity: 0;
  position: absolute;

  &.${Li.rippleVisible} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${l6};
    animation-duration: ${a0}ms;
    animation-timing-function: ${({
  theme: e
}) => e.transitions.easing.easeInOut};
  }

  &.${Li.ripplePulsate} {
    animation-duration: ${({
  theme: e
}) => e.transitions.duration.shorter}ms;
  }

  & .${Li.child} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${Li.childLeaving} {
    opacity: 0;
    animation-name: ${c6};
    animation-duration: ${a0}ms;
    animation-timing-function: ${({
  theme: e
}) => e.transitions.easing.easeInOut};
  }

  & .${Li.childPulsate} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${u6};
    animation-duration: 2500ms;
    animation-timing-function: ${({
  theme: e
}) => e.transitions.easing.easeInOut};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`, f6 = /* @__PURE__ */ K.forwardRef(function(t, n) {
  const r = nn({
    props: t,
    name: "MuiTouchRipple"
  }), {
    center: i = !1,
    classes: s = {},
    className: l,
    ...c
  } = r, [u, d] = K.useState([]), h = K.useRef(0), p = K.useRef(null);
  K.useEffect(() => {
    p.current && (p.current(), p.current = null);
  }, [u]);
  const v = K.useRef(!1), m = Ec(), g = K.useRef(null), b = K.useRef(null), x = K.useCallback((C) => {
    const {
      pulsate: E,
      rippleX: O,
      rippleY: B,
      rippleSize: N,
      cb: L
    } = C;
    d((k) => [...k, /* @__PURE__ */ W.jsx(h6, {
      classes: {
        ripple: ge(s.ripple, Li.ripple),
        rippleVisible: ge(s.rippleVisible, Li.rippleVisible),
        ripplePulsate: ge(s.ripplePulsate, Li.ripplePulsate),
        child: ge(s.child, Li.child),
        childLeaving: ge(s.childLeaving, Li.childLeaving),
        childPulsate: ge(s.childPulsate, Li.childPulsate)
      },
      timeout: a0,
      pulsate: E,
      rippleX: O,
      rippleY: B,
      rippleSize: N
    }, h.current)]), h.current += 1, p.current = L;
  }, [s]), w = K.useCallback((C = {}, E = {}, O = () => {
  }) => {
    const {
      pulsate: B = !1,
      center: N = i || E.pulsate,
      fakeElement: L = !1
      // For test purposes
    } = E;
    if ((C == null ? void 0 : C.type) === "mousedown" && v.current) {
      v.current = !1;
      return;
    }
    (C == null ? void 0 : C.type) === "touchstart" && (v.current = !0);
    const k = L ? null : b.current, F = k ? k.getBoundingClientRect() : {
      width: 0,
      height: 0,
      left: 0,
      top: 0
    };
    let G, M, j;
    if (N || C === void 0 || C.clientX === 0 && C.clientY === 0 || !C.clientX && !C.touches)
      G = Math.round(F.width / 2), M = Math.round(F.height / 2);
    else {
      const {
        clientX: D,
        clientY: z
      } = C.touches && C.touches.length > 0 ? C.touches[0] : C;
      G = Math.round(D - F.left), M = Math.round(z - F.top);
    }
    if (N)
      j = Math.sqrt((2 * F.width ** 2 + F.height ** 2) / 3), j % 2 === 0 && (j += 1);
    else {
      const D = Math.max(Math.abs((k ? k.clientWidth : 0) - G), G) * 2 + 2, z = Math.max(Math.abs((k ? k.clientHeight : 0) - M), M) * 2 + 2;
      j = Math.sqrt(D ** 2 + z ** 2);
    }
    C != null && C.touches ? g.current === null && (g.current = () => {
      x({
        pulsate: B,
        rippleX: G,
        rippleY: M,
        rippleSize: j,
        cb: O
      });
    }, m.start(a6, () => {
      g.current && (g.current(), g.current = null);
    })) : x({
      pulsate: B,
      rippleX: G,
      rippleY: M,
      rippleSize: j,
      cb: O
    });
  }, [i, x, m]), T = K.useCallback(() => {
    w({}, {
      pulsate: !0
    });
  }, [w]), S = K.useCallback((C, E) => {
    if (m.clear(), (C == null ? void 0 : C.type) === "touchend" && g.current) {
      g.current(), g.current = null, m.start(0, () => {
        S(C, E);
      });
      return;
    }
    g.current = null, d((O) => O.length > 0 ? O.slice(1) : O), p.current = E;
  }, [m]);
  return K.useImperativeHandle(n, () => ({
    pulsate: T,
    start: w,
    stop: S
  }), [T, w, S]), /* @__PURE__ */ W.jsx(d6, {
    className: ge(Li.root, s.root, l),
    ref: b,
    ...c,
    children: /* @__PURE__ */ W.jsx(X0, {
      component: null,
      exit: !0,
      children: u
    })
  });
});
function p6(e) {
  return Qe("MuiButtonBase", e);
}
const m6 = Xe("MuiButtonBase", ["root", "disabled", "focusVisible"]), g6 = (e) => {
  const {
    disabled: t,
    focusVisible: n,
    focusVisibleClassName: r,
    classes: i
  } = e, l = Ze({
    root: ["root", t && "disabled", n && "focusVisible"]
  }, p6, i);
  return n && r && (l.root += ` ${r}`), l;
}, y6 = he("button", {
  name: "MuiButtonBase",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  position: "relative",
  boxSizing: "border-box",
  WebkitTapHighlightColor: "transparent",
  backgroundColor: "transparent",
  // Reset default value
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  border: 0,
  margin: 0,
  // Remove the margin in Safari
  borderRadius: 0,
  padding: 0,
  // Remove the padding in Firefox
  cursor: "pointer",
  userSelect: "none",
  verticalAlign: "middle",
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // Reset
  textDecoration: "none",
  // So we take precedent over the style of a native <a /> element.
  color: "inherit",
  "&::-moz-focus-inner": {
    borderStyle: "none"
    // Remove Firefox dotted outline.
  },
  [`&.${m6.disabled}`]: {
    pointerEvents: "none",
    // Disable link interactions
    cursor: "default"
  },
  "@media print": {
    colorAdjust: "exact"
  }
}), Gp = /* @__PURE__ */ K.forwardRef(function(t, n) {
  const r = nn({
    props: t,
    name: "MuiButtonBase"
  }), {
    action: i,
    centerRipple: s = !1,
    children: l,
    className: c,
    component: u = "button",
    disabled: d = !1,
    disableRipple: h = !1,
    disableTouchRipple: p = !1,
    focusRipple: v = !1,
    focusVisibleClassName: m,
    LinkComponent: g = "a",
    onBlur: b,
    onClick: x,
    onContextMenu: w,
    onDragLeave: T,
    onFocus: S,
    onFocusVisible: C,
    onKeyDown: E,
    onKeyUp: O,
    onMouseDown: B,
    onMouseLeave: N,
    onMouseUp: L,
    onTouchEnd: k,
    onTouchMove: F,
    onTouchStart: G,
    tabIndex: M = 0,
    TouchRippleProps: j,
    touchRippleRef: D,
    type: z,
    ...H
  } = r, X = K.useRef(null), Y = i6(), V = ar(Y.ref, D), [Z, ct] = K.useState(!1);
  d && Z && ct(!1), K.useImperativeHandle(i, () => ({
    focusVisible: () => {
      ct(!0), X.current.focus();
    }
  }), []);
  const et = Y.shouldMount && !h && !d;
  K.useEffect(() => {
    Z && v && !h && Y.pulsate();
  }, [h, v, Z, Y]);
  const rt = ao(Y, "start", B, p), st = ao(Y, "stop", w, p), yt = ao(Y, "stop", T, p), J = ao(Y, "stop", L, p), tt = ao(Y, "stop", (Lt) => {
    Z && Lt.preventDefault(), N && N(Lt);
  }, p), ot = ao(Y, "start", G, p), Tt = ao(Y, "stop", k, p), Ct = ao(Y, "stop", F, p), bt = ao(Y, "stop", (Lt) => {
    Ic(Lt.target) || ct(!1), b && b(Lt);
  }, !1), Ht = Vi((Lt) => {
    X.current || (X.current = Lt.currentTarget), Ic(Lt.target) && (ct(!0), C && C(Lt)), S && S(Lt);
  }), $t = () => {
    const Lt = X.current;
    return u && u !== "button" && !(Lt.tagName === "A" && Lt.href);
  }, wt = Vi((Lt) => {
    v && !Lt.repeat && Z && Lt.key === " " && Y.stop(Lt, () => {
      Y.start(Lt);
    }), Lt.target === Lt.currentTarget && $t() && Lt.key === " " && Lt.preventDefault(), E && E(Lt), Lt.target === Lt.currentTarget && $t() && Lt.key === "Enter" && !d && (Lt.preventDefault(), x && x(Lt));
  }), Wt = Vi((Lt) => {
    v && Lt.key === " " && Z && !Lt.defaultPrevented && Y.stop(Lt, () => {
      Y.pulsate(Lt);
    }), O && O(Lt), x && Lt.target === Lt.currentTarget && $t() && Lt.key === " " && !Lt.defaultPrevented && x(Lt);
  });
  let Ut = u;
  Ut === "button" && (H.href || H.to) && (Ut = g);
  const ne = {};
  Ut === "button" ? (ne.type = z === void 0 ? "button" : z, ne.disabled = d) : (!H.href && !H.to && (ne.role = "button"), d && (ne["aria-disabled"] = d));
  const ce = ar(n, X), re = {
    ...r,
    centerRipple: s,
    component: u,
    disabled: d,
    disableRipple: h,
    disableTouchRipple: p,
    focusRipple: v,
    tabIndex: M,
    focusVisible: Z
  }, le = g6(re);
  return /* @__PURE__ */ W.jsxs(y6, {
    as: Ut,
    className: ge(le.root, c),
    ownerState: re,
    onBlur: bt,
    onClick: x,
    onContextMenu: st,
    onFocus: Ht,
    onKeyDown: wt,
    onKeyUp: Wt,
    onMouseDown: rt,
    onMouseLeave: tt,
    onMouseUp: J,
    onDragLeave: yt,
    onTouchEnd: Tt,
    onTouchMove: Ct,
    onTouchStart: ot,
    ref: ce,
    tabIndex: d ? -1 : M,
    type: z,
    ...ne,
    ...H,
    children: [l, et ? /* @__PURE__ */ W.jsx(f6, {
      ref: V,
      center: s,
      ...j
    }) : null]
  });
});
function ao(e, t, n, r = !1) {
  return Vi((i) => (n && n(i), r || e[t](i), !0));
}
function v6(e) {
  return typeof e.main == "string";
}
function b6(e, t = []) {
  if (!v6(e))
    return !1;
  for (const n of t)
    if (!e.hasOwnProperty(n) || typeof e[n] != "string")
      return !1;
  return !0;
}
function Ei(e = []) {
  return ([, t]) => t && b6(t, e);
}
function _6(e) {
  return Qe("MuiCircularProgress", e);
}
Xe("MuiCircularProgress", ["root", "determinate", "indeterminate", "colorPrimary", "colorSecondary", "svg", "circle", "circleDeterminate", "circleIndeterminate", "circleDisableShrink"]);
const $o = 44, l0 = mh`
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
`, c0 = mh`
  0% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: 0;
  }

  50% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -15px;
  }

  100% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: -126px;
  }
`, S6 = typeof l0 != "string" ? L0`
        animation: ${l0} 1.4s linear infinite;
      ` : null, x6 = typeof c0 != "string" ? L0`
        animation: ${c0} 1.4s ease-in-out infinite;
      ` : null, T6 = (e) => {
  const {
    classes: t,
    variant: n,
    color: r,
    disableShrink: i
  } = e, s = {
    root: ["root", n, `color${pe(r)}`],
    svg: ["svg"],
    circle: ["circle", `circle${pe(n)}`, i && "circleDisableShrink"]
  };
  return Ze(s, _6, t);
}, C6 = he("span", {
  name: "MuiCircularProgress",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, t[n.variant], t[`color${pe(n.color)}`]];
  }
})(He(({
  theme: e
}) => ({
  display: "inline-block",
  variants: [{
    props: {
      variant: "determinate"
    },
    style: {
      transition: e.transitions.create("transform")
    }
  }, {
    props: {
      variant: "indeterminate"
    },
    style: S6 || {
      animation: `${l0} 1.4s linear infinite`
    }
  }, ...Object.entries(e.palette).filter(Ei()).map(([t]) => ({
    props: {
      color: t
    },
    style: {
      color: (e.vars || e).palette[t].main
    }
  }))]
}))), w6 = he("svg", {
  name: "MuiCircularProgress",
  slot: "Svg",
  overridesResolver: (e, t) => t.svg
})({
  display: "block"
  // Keeps the progress centered
}), E6 = he("circle", {
  name: "MuiCircularProgress",
  slot: "Circle",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.circle, t[`circle${pe(n.variant)}`], n.disableShrink && t.circleDisableShrink];
  }
})(He(({
  theme: e
}) => ({
  stroke: "currentColor",
  variants: [{
    props: {
      variant: "determinate"
    },
    style: {
      transition: e.transitions.create("stroke-dashoffset")
    }
  }, {
    props: {
      variant: "indeterminate"
    },
    style: {
      // Some default value that looks fine waiting for the animation to kicks in.
      strokeDasharray: "80px, 200px",
      strokeDashoffset: 0
      // Add the unit to fix a Edge 16 and below bug.
    }
  }, {
    props: ({
      ownerState: t
    }) => t.variant === "indeterminate" && !t.disableShrink,
    style: x6 || {
      // At runtime for Pigment CSS, `bufferAnimation` will be null and the generated keyframe will be used.
      animation: `${c0} 1.4s ease-in-out infinite`
    }
  }]
}))), ES = /* @__PURE__ */ K.forwardRef(function(t, n) {
  const r = nn({
    props: t,
    name: "MuiCircularProgress"
  }), {
    className: i,
    color: s = "primary",
    disableShrink: l = !1,
    size: c = 40,
    style: u,
    thickness: d = 3.6,
    value: h = 0,
    variant: p = "indeterminate",
    ...v
  } = r, m = {
    ...r,
    color: s,
    disableShrink: l,
    size: c,
    thickness: d,
    value: h,
    variant: p
  }, g = T6(m), b = {}, x = {}, w = {};
  if (p === "determinate") {
    const T = 2 * Math.PI * (($o - d) / 2);
    b.strokeDasharray = T.toFixed(3), w["aria-valuenow"] = Math.round(h), b.strokeDashoffset = `${((100 - h) / 100 * T).toFixed(3)}px`, x.transform = "rotate(-90deg)";
  }
  return /* @__PURE__ */ W.jsx(C6, {
    className: ge(g.root, i),
    style: {
      width: c,
      height: c,
      ...x,
      ...u
    },
    ownerState: m,
    ref: n,
    role: "progressbar",
    ...w,
    ...v,
    children: /* @__PURE__ */ W.jsx(w6, {
      className: g.svg,
      ownerState: m,
      viewBox: `${$o / 2} ${$o / 2} ${$o} ${$o}`,
      children: /* @__PURE__ */ W.jsx(E6, {
        className: g.circle,
        style: b,
        ownerState: m,
        cx: $o,
        cy: $o,
        r: ($o - d) / 2,
        fill: "none",
        strokeWidth: d
      })
    })
  });
});
function A6(e) {
  return Qe("MuiIconButton", e);
}
const Xv = Xe("MuiIconButton", ["root", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "edgeStart", "edgeEnd", "sizeSmall", "sizeMedium", "sizeLarge", "loading", "loadingIndicator", "loadingWrapper"]), k6 = (e) => {
  const {
    classes: t,
    disabled: n,
    color: r,
    edge: i,
    size: s,
    loading: l
  } = e, c = {
    root: ["root", l && "loading", n && "disabled", r !== "default" && `color${pe(r)}`, i && `edge${pe(i)}`, `size${pe(s)}`],
    loadingIndicator: ["loadingIndicator"],
    loadingWrapper: ["loadingWrapper"]
  };
  return Ze(c, A6, t);
}, R6 = he(Gp, {
  name: "MuiIconButton",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.loading && t.loading, n.color !== "default" && t[`color${pe(n.color)}`], n.edge && t[`edge${pe(n.edge)}`], t[`size${pe(n.size)}`]];
  }
})(He(({
  theme: e
}) => ({
  textAlign: "center",
  flex: "0 0 auto",
  fontSize: e.typography.pxToRem(24),
  padding: 8,
  borderRadius: "50%",
  color: (e.vars || e).palette.action.active,
  transition: e.transitions.create("background-color", {
    duration: e.transitions.duration.shortest
  }),
  variants: [{
    props: (t) => !t.disableRipple,
    style: {
      "--IconButton-hoverBg": e.vars ? `rgba(${e.vars.palette.action.activeChannel} / ${e.vars.palette.action.hoverOpacity})` : xn(e.palette.action.active, e.palette.action.hoverOpacity),
      "&:hover": {
        backgroundColor: "var(--IconButton-hoverBg)",
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    }
  }, {
    props: {
      edge: "start"
    },
    style: {
      marginLeft: -12
    }
  }, {
    props: {
      edge: "start",
      size: "small"
    },
    style: {
      marginLeft: -3
    }
  }, {
    props: {
      edge: "end"
    },
    style: {
      marginRight: -12
    }
  }, {
    props: {
      edge: "end",
      size: "small"
    },
    style: {
      marginRight: -3
    }
  }]
})), He(({
  theme: e
}) => ({
  variants: [{
    props: {
      color: "inherit"
    },
    style: {
      color: "inherit"
    }
  }, ...Object.entries(e.palette).filter(Ei()).map(([t]) => ({
    props: {
      color: t
    },
    style: {
      color: (e.vars || e).palette[t].main
    }
  })), ...Object.entries(e.palette).filter(Ei()).map(([t]) => ({
    props: {
      color: t
    },
    style: {
      "--IconButton-hoverBg": e.vars ? `rgba(${(e.vars || e).palette[t].mainChannel} / ${e.vars.palette.action.hoverOpacity})` : xn((e.vars || e).palette[t].main, e.palette.action.hoverOpacity)
    }
  })), {
    props: {
      size: "small"
    },
    style: {
      padding: 5,
      fontSize: e.typography.pxToRem(18)
    }
  }, {
    props: {
      size: "large"
    },
    style: {
      padding: 12,
      fontSize: e.typography.pxToRem(28)
    }
  }],
  [`&.${Xv.disabled}`]: {
    backgroundColor: "transparent",
    color: (e.vars || e).palette.action.disabled
  },
  [`&.${Xv.loading}`]: {
    color: "transparent"
  }
}))), M6 = he("span", {
  name: "MuiIconButton",
  slot: "LoadingIndicator",
  overridesResolver: (e, t) => t.loadingIndicator
})(({
  theme: e
}) => ({
  display: "none",
  position: "absolute",
  visibility: "visible",
  top: "50%",
  left: "50%",
  transform: "translate(-50%, -50%)",
  color: (e.vars || e).palette.action.disabled,
  variants: [{
    props: {
      loading: !0
    },
    style: {
      display: "flex"
    }
  }]
})), Qo = /* @__PURE__ */ K.forwardRef(function(t, n) {
  const r = nn({
    props: t,
    name: "MuiIconButton"
  }), {
    edge: i = !1,
    children: s,
    className: l,
    color: c = "default",
    disabled: u = !1,
    disableFocusRipple: d = !1,
    size: h = "medium",
    id: p,
    loading: v = null,
    loadingIndicator: m,
    ...g
  } = r, b = bh(p), x = m ?? /* @__PURE__ */ W.jsx(ES, {
    "aria-labelledby": b,
    color: "inherit",
    size: 16
  }), w = {
    ...r,
    edge: i,
    color: c,
    disabled: u,
    disableFocusRipple: d,
    loading: v,
    loadingIndicator: x,
    size: h
  }, T = k6(w);
  return /* @__PURE__ */ W.jsxs(R6, {
    id: v ? b : p,
    className: ge(T.root, l),
    centerRipple: !0,
    focusRipple: !d,
    disabled: u || v,
    ref: n,
    ...g,
    ownerState: w,
    children: [typeof v == "boolean" && // use plain HTML span to minimize the runtime overhead
    /* @__PURE__ */ W.jsx("span", {
      className: T.loadingWrapper,
      style: {
        display: "contents"
      },
      children: /* @__PURE__ */ W.jsx(M6, {
        className: T.loadingIndicator,
        ownerState: w,
        children: v && x
      })
    }), s]
  });
});
function O6(e) {
  return Qe("MuiTypography", e);
}
const Qv = Xe("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]), N6 = {
  primary: !0,
  secondary: !0,
  error: !0,
  info: !0,
  success: !0,
  warning: !0,
  textPrimary: !0,
  textSecondary: !0,
  textDisabled: !0
}, P6 = zw(), D6 = (e) => {
  const {
    align: t,
    gutterBottom: n,
    noWrap: r,
    paragraph: i,
    variant: s,
    classes: l
  } = e, c = {
    root: ["root", s, e.align !== "inherit" && `align${pe(t)}`, n && "gutterBottom", r && "noWrap", i && "paragraph"]
  };
  return Ze(c, O6, l);
}, I6 = he("span", {
  name: "MuiTypography",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.variant && t[n.variant], n.align !== "inherit" && t[`align${pe(n.align)}`], n.noWrap && t.noWrap, n.gutterBottom && t.gutterBottom, n.paragraph && t.paragraph];
  }
})(He(({
  theme: e
}) => {
  var t;
  return {
    margin: 0,
    variants: [{
      props: {
        variant: "inherit"
      },
      style: {
        // Some elements, like <button> on Chrome have default font that doesn't inherit, reset this.
        font: "inherit",
        lineHeight: "inherit",
        letterSpacing: "inherit"
      }
    }, ...Object.entries(e.typography).filter(([n, r]) => n !== "inherit" && r && typeof r == "object").map(([n, r]) => ({
      props: {
        variant: n
      },
      style: r
    })), ...Object.entries(e.palette).filter(Ei()).map(([n]) => ({
      props: {
        color: n
      },
      style: {
        color: (e.vars || e).palette[n].main
      }
    })), ...Object.entries(((t = e.palette) == null ? void 0 : t.text) || {}).filter(([, n]) => typeof n == "string").map(([n]) => ({
      props: {
        color: `text${pe(n)}`
      },
      style: {
        color: (e.vars || e).palette.text[n]
      }
    })), {
      props: ({
        ownerState: n
      }) => n.align !== "inherit",
      style: {
        textAlign: "var(--Typography-textAlign)"
      }
    }, {
      props: ({
        ownerState: n
      }) => n.noWrap,
      style: {
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap"
      }
    }, {
      props: ({
        ownerState: n
      }) => n.gutterBottom,
      style: {
        marginBottom: "0.35em"
      }
    }, {
      props: ({
        ownerState: n
      }) => n.paragraph,
      style: {
        marginBottom: 16
      }
    }]
  };
})), Zv = {
  h1: "h1",
  h2: "h2",
  h3: "h3",
  h4: "h4",
  h5: "h5",
  h6: "h6",
  subtitle1: "h6",
  subtitle2: "h6",
  body1: "p",
  body2: "p",
  inherit: "p"
}, Hr = /* @__PURE__ */ K.forwardRef(function(t, n) {
  const {
    color: r,
    ...i
  } = nn({
    props: t,
    name: "MuiTypography"
  }), s = !N6[r], l = P6({
    ...i,
    ...s && {
      color: r
    }
  }), {
    align: c = "inherit",
    className: u,
    component: d,
    gutterBottom: h = !1,
    noWrap: p = !1,
    paragraph: v = !1,
    variant: m = "body1",
    variantMapping: g = Zv,
    ...b
  } = l, x = {
    ...l,
    align: c,
    color: r,
    className: u,
    component: d,
    gutterBottom: h,
    noWrap: p,
    paragraph: v,
    variant: m,
    variantMapping: g
  }, w = d || (v ? "p" : g[m] || Zv[m]) || "span", T = D6(x);
  return /* @__PURE__ */ W.jsx(I6, {
    as: w,
    ref: n,
    className: ge(T.root, u),
    ...b,
    ownerState: x,
    style: {
      ...c !== "inherit" && {
        "--Typography-textAlign": c
      },
      ...b.style
    }
  });
});
var ni = "top", qi = "bottom", Hi = "right", ri = "left", Q0 = "auto", _h = [ni, qi, Hi, ri], Bc = "start", oh = "end", B6 = "clippingParents", AS = "viewport", qu = "popper", F6 = "reference", Jv = /* @__PURE__ */ _h.reduce(function(e, t) {
  return e.concat([t + "-" + Bc, t + "-" + oh]);
}, []), kS = /* @__PURE__ */ [].concat(_h, [Q0]).reduce(function(e, t) {
  return e.concat([t, t + "-" + Bc, t + "-" + oh]);
}, []), j6 = "beforeRead", L6 = "read", z6 = "afterRead", U6 = "beforeMain", V6 = "main", G6 = "afterMain", q6 = "beforeWrite", H6 = "write", W6 = "afterWrite", $6 = [j6, L6, z6, U6, V6, G6, q6, H6, W6];
function Ds(e) {
  return e ? (e.nodeName || "").toLowerCase() : null;
}
function Ai(e) {
  if (e == null)
    return window;
  if (e.toString() !== "[object Window]") {
    var t = e.ownerDocument;
    return t && t.defaultView || window;
  }
  return e;
}
function fl(e) {
  var t = Ai(e).Element;
  return e instanceof t || e instanceof Element;
}
function Gi(e) {
  var t = Ai(e).HTMLElement;
  return e instanceof t || e instanceof HTMLElement;
}
function Z0(e) {
  if (typeof ShadowRoot > "u")
    return !1;
  var t = Ai(e).ShadowRoot;
  return e instanceof t || e instanceof ShadowRoot;
}
function K6(e) {
  var t = e.state;
  Object.keys(t.elements).forEach(function(n) {
    var r = t.styles[n] || {}, i = t.attributes[n] || {}, s = t.elements[n];
    !Gi(s) || !Ds(s) || (Object.assign(s.style, r), Object.keys(i).forEach(function(l) {
      var c = i[l];
      c === !1 ? s.removeAttribute(l) : s.setAttribute(l, c === !0 ? "" : c);
    }));
  });
}
function Y6(e) {
  var t = e.state, n = {
    popper: {
      position: t.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(t.elements.popper.style, n.popper), t.styles = n, t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow), function() {
    Object.keys(t.elements).forEach(function(r) {
      var i = t.elements[r], s = t.attributes[r] || {}, l = Object.keys(t.styles.hasOwnProperty(r) ? t.styles[r] : n[r]), c = l.reduce(function(u, d) {
        return u[d] = "", u;
      }, {});
      !Gi(i) || !Ds(i) || (Object.assign(i.style, c), Object.keys(s).forEach(function(u) {
        i.removeAttribute(u);
      }));
    });
  };
}
const X6 = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: K6,
  effect: Y6,
  requires: ["computeStyles"]
};
function Os(e) {
  return e.split("-")[0];
}
var cl = Math.max, ip = Math.min, Fc = Math.round;
function u0() {
  var e = navigator.userAgentData;
  return e != null && e.brands && Array.isArray(e.brands) ? e.brands.map(function(t) {
    return t.brand + "/" + t.version;
  }).join(" ") : navigator.userAgent;
}
function RS() {
  return !/^((?!chrome|android).)*safari/i.test(u0());
}
function jc(e, t, n) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  var r = e.getBoundingClientRect(), i = 1, s = 1;
  t && Gi(e) && (i = e.offsetWidth > 0 && Fc(r.width) / e.offsetWidth || 1, s = e.offsetHeight > 0 && Fc(r.height) / e.offsetHeight || 1);
  var l = fl(e) ? Ai(e) : window, c = l.visualViewport, u = !RS() && n, d = (r.left + (u && c ? c.offsetLeft : 0)) / i, h = (r.top + (u && c ? c.offsetTop : 0)) / s, p = r.width / i, v = r.height / s;
  return {
    width: p,
    height: v,
    top: h,
    right: d + p,
    bottom: h + v,
    left: d,
    x: d,
    y: h
  };
}
function J0(e) {
  var t = jc(e), n = e.offsetWidth, r = e.offsetHeight;
  return Math.abs(t.width - n) <= 1 && (n = t.width), Math.abs(t.height - r) <= 1 && (r = t.height), {
    x: e.offsetLeft,
    y: e.offsetTop,
    width: n,
    height: r
  };
}
function MS(e, t) {
  var n = t.getRootNode && t.getRootNode();
  if (e.contains(t))
    return !0;
  if (n && Z0(n)) {
    var r = t;
    do {
      if (r && e.isSameNode(r))
        return !0;
      r = r.parentNode || r.host;
    } while (r);
  }
  return !1;
}
function bo(e) {
  return Ai(e).getComputedStyle(e);
}
function Q6(e) {
  return ["table", "td", "th"].indexOf(Ds(e)) >= 0;
}
function sa(e) {
  return ((fl(e) ? e.ownerDocument : (
    // $FlowFixMe[prop-missing]
    e.document
  )) || window.document).documentElement;
}
function qp(e) {
  return Ds(e) === "html" ? e : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    e.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    e.parentNode || // DOM Element detected
    (Z0(e) ? e.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    sa(e)
  );
}
function tb(e) {
  return !Gi(e) || // https://github.com/popperjs/popper-core/issues/837
  bo(e).position === "fixed" ? null : e.offsetParent;
}
function Z6(e) {
  var t = /firefox/i.test(u0()), n = /Trident/i.test(u0());
  if (n && Gi(e)) {
    var r = bo(e);
    if (r.position === "fixed")
      return null;
  }
  var i = qp(e);
  for (Z0(i) && (i = i.host); Gi(i) && ["html", "body"].indexOf(Ds(i)) < 0; ) {
    var s = bo(i);
    if (s.transform !== "none" || s.perspective !== "none" || s.contain === "paint" || ["transform", "perspective"].indexOf(s.willChange) !== -1 || t && s.willChange === "filter" || t && s.filter && s.filter !== "none")
      return i;
    i = i.parentNode;
  }
  return null;
}
function Sh(e) {
  for (var t = Ai(e), n = tb(e); n && Q6(n) && bo(n).position === "static"; )
    n = tb(n);
  return n && (Ds(n) === "html" || Ds(n) === "body" && bo(n).position === "static") ? t : n || Z6(e) || t;
}
function ty(e) {
  return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y";
}
function Yd(e, t, n) {
  return cl(e, ip(t, n));
}
function J6(e, t, n) {
  var r = Yd(e, t, n);
  return r > n ? n : r;
}
function OS() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function NS(e) {
  return Object.assign({}, OS(), e);
}
function PS(e, t) {
  return t.reduce(function(n, r) {
    return n[r] = e, n;
  }, {});
}
var t8 = function(t, n) {
  return t = typeof t == "function" ? t(Object.assign({}, n.rects, {
    placement: n.placement
  })) : t, NS(typeof t != "number" ? t : PS(t, _h));
};
function e8(e) {
  var t, n = e.state, r = e.name, i = e.options, s = n.elements.arrow, l = n.modifiersData.popperOffsets, c = Os(n.placement), u = ty(c), d = [ri, Hi].indexOf(c) >= 0, h = d ? "height" : "width";
  if (!(!s || !l)) {
    var p = t8(i.padding, n), v = J0(s), m = u === "y" ? ni : ri, g = u === "y" ? qi : Hi, b = n.rects.reference[h] + n.rects.reference[u] - l[u] - n.rects.popper[h], x = l[u] - n.rects.reference[u], w = Sh(s), T = w ? u === "y" ? w.clientHeight || 0 : w.clientWidth || 0 : 0, S = b / 2 - x / 2, C = p[m], E = T - v[h] - p[g], O = T / 2 - v[h] / 2 + S, B = Yd(C, O, E), N = u;
    n.modifiersData[r] = (t = {}, t[N] = B, t.centerOffset = B - O, t);
  }
}
function n8(e) {
  var t = e.state, n = e.options, r = n.element, i = r === void 0 ? "[data-popper-arrow]" : r;
  i != null && (typeof i == "string" && (i = t.elements.popper.querySelector(i), !i) || MS(t.elements.popper, i) && (t.elements.arrow = i));
}
const r8 = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: e8,
  effect: n8,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function Lc(e) {
  return e.split("-")[1];
}
var i8 = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function s8(e, t) {
  var n = e.x, r = e.y, i = t.devicePixelRatio || 1;
  return {
    x: Fc(n * i) / i || 0,
    y: Fc(r * i) / i || 0
  };
}
function eb(e) {
  var t, n = e.popper, r = e.popperRect, i = e.placement, s = e.variation, l = e.offsets, c = e.position, u = e.gpuAcceleration, d = e.adaptive, h = e.roundOffsets, p = e.isFixed, v = l.x, m = v === void 0 ? 0 : v, g = l.y, b = g === void 0 ? 0 : g, x = typeof h == "function" ? h({
    x: m,
    y: b
  }) : {
    x: m,
    y: b
  };
  m = x.x, b = x.y;
  var w = l.hasOwnProperty("x"), T = l.hasOwnProperty("y"), S = ri, C = ni, E = window;
  if (d) {
    var O = Sh(n), B = "clientHeight", N = "clientWidth";
    if (O === Ai(n) && (O = sa(n), bo(O).position !== "static" && c === "absolute" && (B = "scrollHeight", N = "scrollWidth")), O = O, i === ni || (i === ri || i === Hi) && s === oh) {
      C = qi;
      var L = p && O === E && E.visualViewport ? E.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        O[B]
      );
      b -= L - r.height, b *= u ? 1 : -1;
    }
    if (i === ri || (i === ni || i === qi) && s === oh) {
      S = Hi;
      var k = p && O === E && E.visualViewport ? E.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        O[N]
      );
      m -= k - r.width, m *= u ? 1 : -1;
    }
  }
  var F = Object.assign({
    position: c
  }, d && i8), G = h === !0 ? s8({
    x: m,
    y: b
  }, Ai(n)) : {
    x: m,
    y: b
  };
  if (m = G.x, b = G.y, u) {
    var M;
    return Object.assign({}, F, (M = {}, M[C] = T ? "0" : "", M[S] = w ? "0" : "", M.transform = (E.devicePixelRatio || 1) <= 1 ? "translate(" + m + "px, " + b + "px)" : "translate3d(" + m + "px, " + b + "px, 0)", M));
  }
  return Object.assign({}, F, (t = {}, t[C] = T ? b + "px" : "", t[S] = w ? m + "px" : "", t.transform = "", t));
}
function o8(e) {
  var t = e.state, n = e.options, r = n.gpuAcceleration, i = r === void 0 ? !0 : r, s = n.adaptive, l = s === void 0 ? !0 : s, c = n.roundOffsets, u = c === void 0 ? !0 : c, d = {
    placement: Os(t.placement),
    variation: Lc(t.placement),
    popper: t.elements.popper,
    popperRect: t.rects.popper,
    gpuAcceleration: i,
    isFixed: t.options.strategy === "fixed"
  };
  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, eb(Object.assign({}, d, {
    offsets: t.modifiersData.popperOffsets,
    position: t.options.strategy,
    adaptive: l,
    roundOffsets: u
  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, eb(Object.assign({}, d, {
    offsets: t.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: u
  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-placement": t.placement
  });
}
const a8 = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: o8,
  data: {}
};
var Tf = {
  passive: !0
};
function l8(e) {
  var t = e.state, n = e.instance, r = e.options, i = r.scroll, s = i === void 0 ? !0 : i, l = r.resize, c = l === void 0 ? !0 : l, u = Ai(t.elements.popper), d = [].concat(t.scrollParents.reference, t.scrollParents.popper);
  return s && d.forEach(function(h) {
    h.addEventListener("scroll", n.update, Tf);
  }), c && u.addEventListener("resize", n.update, Tf), function() {
    s && d.forEach(function(h) {
      h.removeEventListener("scroll", n.update, Tf);
    }), c && u.removeEventListener("resize", n.update, Tf);
  };
}
const c8 = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: l8,
  data: {}
};
var u8 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function Wf(e) {
  return e.replace(/left|right|bottom|top/g, function(t) {
    return u8[t];
  });
}
var d8 = {
  start: "end",
  end: "start"
};
function nb(e) {
  return e.replace(/start|end/g, function(t) {
    return d8[t];
  });
}
function ey(e) {
  var t = Ai(e), n = t.pageXOffset, r = t.pageYOffset;
  return {
    scrollLeft: n,
    scrollTop: r
  };
}
function ny(e) {
  return jc(sa(e)).left + ey(e).scrollLeft;
}
function h8(e, t) {
  var n = Ai(e), r = sa(e), i = n.visualViewport, s = r.clientWidth, l = r.clientHeight, c = 0, u = 0;
  if (i) {
    s = i.width, l = i.height;
    var d = RS();
    (d || !d && t === "fixed") && (c = i.offsetLeft, u = i.offsetTop);
  }
  return {
    width: s,
    height: l,
    x: c + ny(e),
    y: u
  };
}
function f8(e) {
  var t, n = sa(e), r = ey(e), i = (t = e.ownerDocument) == null ? void 0 : t.body, s = cl(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0), l = cl(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0), c = -r.scrollLeft + ny(e), u = -r.scrollTop;
  return bo(i || n).direction === "rtl" && (c += cl(n.clientWidth, i ? i.clientWidth : 0) - s), {
    width: s,
    height: l,
    x: c,
    y: u
  };
}
function ry(e) {
  var t = bo(e), n = t.overflow, r = t.overflowX, i = t.overflowY;
  return /auto|scroll|overlay|hidden/.test(n + i + r);
}
function DS(e) {
  return ["html", "body", "#document"].indexOf(Ds(e)) >= 0 ? e.ownerDocument.body : Gi(e) && ry(e) ? e : DS(qp(e));
}
function Xd(e, t) {
  var n;
  t === void 0 && (t = []);
  var r = DS(e), i = r === ((n = e.ownerDocument) == null ? void 0 : n.body), s = Ai(r), l = i ? [s].concat(s.visualViewport || [], ry(r) ? r : []) : r, c = t.concat(l);
  return i ? c : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    c.concat(Xd(qp(l)))
  );
}
function d0(e) {
  return Object.assign({}, e, {
    left: e.x,
    top: e.y,
    right: e.x + e.width,
    bottom: e.y + e.height
  });
}
function p8(e, t) {
  var n = jc(e, !1, t === "fixed");
  return n.top = n.top + e.clientTop, n.left = n.left + e.clientLeft, n.bottom = n.top + e.clientHeight, n.right = n.left + e.clientWidth, n.width = e.clientWidth, n.height = e.clientHeight, n.x = n.left, n.y = n.top, n;
}
function rb(e, t, n) {
  return t === AS ? d0(h8(e, n)) : fl(t) ? p8(t, n) : d0(f8(sa(e)));
}
function m8(e) {
  var t = Xd(qp(e)), n = ["absolute", "fixed"].indexOf(bo(e).position) >= 0, r = n && Gi(e) ? Sh(e) : e;
  return fl(r) ? t.filter(function(i) {
    return fl(i) && MS(i, r) && Ds(i) !== "body";
  }) : [];
}
function g8(e, t, n, r) {
  var i = t === "clippingParents" ? m8(e) : [].concat(t), s = [].concat(i, [n]), l = s[0], c = s.reduce(function(u, d) {
    var h = rb(e, d, r);
    return u.top = cl(h.top, u.top), u.right = ip(h.right, u.right), u.bottom = ip(h.bottom, u.bottom), u.left = cl(h.left, u.left), u;
  }, rb(e, l, r));
  return c.width = c.right - c.left, c.height = c.bottom - c.top, c.x = c.left, c.y = c.top, c;
}
function IS(e) {
  var t = e.reference, n = e.element, r = e.placement, i = r ? Os(r) : null, s = r ? Lc(r) : null, l = t.x + t.width / 2 - n.width / 2, c = t.y + t.height / 2 - n.height / 2, u;
  switch (i) {
    case ni:
      u = {
        x: l,
        y: t.y - n.height
      };
      break;
    case qi:
      u = {
        x: l,
        y: t.y + t.height
      };
      break;
    case Hi:
      u = {
        x: t.x + t.width,
        y: c
      };
      break;
    case ri:
      u = {
        x: t.x - n.width,
        y: c
      };
      break;
    default:
      u = {
        x: t.x,
        y: t.y
      };
  }
  var d = i ? ty(i) : null;
  if (d != null) {
    var h = d === "y" ? "height" : "width";
    switch (s) {
      case Bc:
        u[d] = u[d] - (t[h] / 2 - n[h] / 2);
        break;
      case oh:
        u[d] = u[d] + (t[h] / 2 - n[h] / 2);
        break;
    }
  }
  return u;
}
function ah(e, t) {
  t === void 0 && (t = {});
  var n = t, r = n.placement, i = r === void 0 ? e.placement : r, s = n.strategy, l = s === void 0 ? e.strategy : s, c = n.boundary, u = c === void 0 ? B6 : c, d = n.rootBoundary, h = d === void 0 ? AS : d, p = n.elementContext, v = p === void 0 ? qu : p, m = n.altBoundary, g = m === void 0 ? !1 : m, b = n.padding, x = b === void 0 ? 0 : b, w = NS(typeof x != "number" ? x : PS(x, _h)), T = v === qu ? F6 : qu, S = e.rects.popper, C = e.elements[g ? T : v], E = g8(fl(C) ? C : C.contextElement || sa(e.elements.popper), u, h, l), O = jc(e.elements.reference), B = IS({
    reference: O,
    element: S,
    placement: i
  }), N = d0(Object.assign({}, S, B)), L = v === qu ? N : O, k = {
    top: E.top - L.top + w.top,
    bottom: L.bottom - E.bottom + w.bottom,
    left: E.left - L.left + w.left,
    right: L.right - E.right + w.right
  }, F = e.modifiersData.offset;
  if (v === qu && F) {
    var G = F[i];
    Object.keys(k).forEach(function(M) {
      var j = [Hi, qi].indexOf(M) >= 0 ? 1 : -1, D = [ni, qi].indexOf(M) >= 0 ? "y" : "x";
      k[M] += G[D] * j;
    });
  }
  return k;
}
function y8(e, t) {
  t === void 0 && (t = {});
  var n = t, r = n.placement, i = n.boundary, s = n.rootBoundary, l = n.padding, c = n.flipVariations, u = n.allowedAutoPlacements, d = u === void 0 ? kS : u, h = Lc(r), p = h ? c ? Jv : Jv.filter(function(g) {
    return Lc(g) === h;
  }) : _h, v = p.filter(function(g) {
    return d.indexOf(g) >= 0;
  });
  v.length === 0 && (v = p);
  var m = v.reduce(function(g, b) {
    return g[b] = ah(e, {
      placement: b,
      boundary: i,
      rootBoundary: s,
      padding: l
    })[Os(b)], g;
  }, {});
  return Object.keys(m).sort(function(g, b) {
    return m[g] - m[b];
  });
}
function v8(e) {
  if (Os(e) === Q0)
    return [];
  var t = Wf(e);
  return [nb(e), t, nb(t)];
}
function b8(e) {
  var t = e.state, n = e.options, r = e.name;
  if (!t.modifiersData[r]._skip) {
    for (var i = n.mainAxis, s = i === void 0 ? !0 : i, l = n.altAxis, c = l === void 0 ? !0 : l, u = n.fallbackPlacements, d = n.padding, h = n.boundary, p = n.rootBoundary, v = n.altBoundary, m = n.flipVariations, g = m === void 0 ? !0 : m, b = n.allowedAutoPlacements, x = t.options.placement, w = Os(x), T = w === x, S = u || (T || !g ? [Wf(x)] : v8(x)), C = [x].concat(S).reduce(function(rt, st) {
      return rt.concat(Os(st) === Q0 ? y8(t, {
        placement: st,
        boundary: h,
        rootBoundary: p,
        padding: d,
        flipVariations: g,
        allowedAutoPlacements: b
      }) : st);
    }, []), E = t.rects.reference, O = t.rects.popper, B = /* @__PURE__ */ new Map(), N = !0, L = C[0], k = 0; k < C.length; k++) {
      var F = C[k], G = Os(F), M = Lc(F) === Bc, j = [ni, qi].indexOf(G) >= 0, D = j ? "width" : "height", z = ah(t, {
        placement: F,
        boundary: h,
        rootBoundary: p,
        altBoundary: v,
        padding: d
      }), H = j ? M ? Hi : ri : M ? qi : ni;
      E[D] > O[D] && (H = Wf(H));
      var X = Wf(H), Y = [];
      if (s && Y.push(z[G] <= 0), c && Y.push(z[H] <= 0, z[X] <= 0), Y.every(function(rt) {
        return rt;
      })) {
        L = F, N = !1;
        break;
      }
      B.set(F, Y);
    }
    if (N)
      for (var V = g ? 3 : 1, Z = function(st) {
        var yt = C.find(function(J) {
          var tt = B.get(J);
          if (tt)
            return tt.slice(0, st).every(function(ot) {
              return ot;
            });
        });
        if (yt)
          return L = yt, "break";
      }, ct = V; ct > 0; ct--) {
        var et = Z(ct);
        if (et === "break") break;
      }
    t.placement !== L && (t.modifiersData[r]._skip = !0, t.placement = L, t.reset = !0);
  }
}
const _8 = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: b8,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function ib(e, t, n) {
  return n === void 0 && (n = {
    x: 0,
    y: 0
  }), {
    top: e.top - t.height - n.y,
    right: e.right - t.width + n.x,
    bottom: e.bottom - t.height + n.y,
    left: e.left - t.width - n.x
  };
}
function sb(e) {
  return [ni, Hi, qi, ri].some(function(t) {
    return e[t] >= 0;
  });
}
function S8(e) {
  var t = e.state, n = e.name, r = t.rects.reference, i = t.rects.popper, s = t.modifiersData.preventOverflow, l = ah(t, {
    elementContext: "reference"
  }), c = ah(t, {
    altBoundary: !0
  }), u = ib(l, r), d = ib(c, i, s), h = sb(u), p = sb(d);
  t.modifiersData[n] = {
    referenceClippingOffsets: u,
    popperEscapeOffsets: d,
    isReferenceHidden: h,
    hasPopperEscaped: p
  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-reference-hidden": h,
    "data-popper-escaped": p
  });
}
const x8 = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: S8
};
function T8(e, t, n) {
  var r = Os(e), i = [ri, ni].indexOf(r) >= 0 ? -1 : 1, s = typeof n == "function" ? n(Object.assign({}, t, {
    placement: e
  })) : n, l = s[0], c = s[1];
  return l = l || 0, c = (c || 0) * i, [ri, Hi].indexOf(r) >= 0 ? {
    x: c,
    y: l
  } : {
    x: l,
    y: c
  };
}
function C8(e) {
  var t = e.state, n = e.options, r = e.name, i = n.offset, s = i === void 0 ? [0, 0] : i, l = kS.reduce(function(h, p) {
    return h[p] = T8(p, t.rects, s), h;
  }, {}), c = l[t.placement], u = c.x, d = c.y;
  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += u, t.modifiersData.popperOffsets.y += d), t.modifiersData[r] = l;
}
const w8 = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: C8
};
function E8(e) {
  var t = e.state, n = e.name;
  t.modifiersData[n] = IS({
    reference: t.rects.reference,
    element: t.rects.popper,
    placement: t.placement
  });
}
const A8 = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: E8,
  data: {}
};
function k8(e) {
  return e === "x" ? "y" : "x";
}
function R8(e) {
  var t = e.state, n = e.options, r = e.name, i = n.mainAxis, s = i === void 0 ? !0 : i, l = n.altAxis, c = l === void 0 ? !1 : l, u = n.boundary, d = n.rootBoundary, h = n.altBoundary, p = n.padding, v = n.tether, m = v === void 0 ? !0 : v, g = n.tetherOffset, b = g === void 0 ? 0 : g, x = ah(t, {
    boundary: u,
    rootBoundary: d,
    padding: p,
    altBoundary: h
  }), w = Os(t.placement), T = Lc(t.placement), S = !T, C = ty(w), E = k8(C), O = t.modifiersData.popperOffsets, B = t.rects.reference, N = t.rects.popper, L = typeof b == "function" ? b(Object.assign({}, t.rects, {
    placement: t.placement
  })) : b, k = typeof L == "number" ? {
    mainAxis: L,
    altAxis: L
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, L), F = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, G = {
    x: 0,
    y: 0
  };
  if (O) {
    if (s) {
      var M, j = C === "y" ? ni : ri, D = C === "y" ? qi : Hi, z = C === "y" ? "height" : "width", H = O[C], X = H + x[j], Y = H - x[D], V = m ? -N[z] / 2 : 0, Z = T === Bc ? B[z] : N[z], ct = T === Bc ? -N[z] : -B[z], et = t.elements.arrow, rt = m && et ? J0(et) : {
        width: 0,
        height: 0
      }, st = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : OS(), yt = st[j], J = st[D], tt = Yd(0, B[z], rt[z]), ot = S ? B[z] / 2 - V - tt - yt - k.mainAxis : Z - tt - yt - k.mainAxis, Tt = S ? -B[z] / 2 + V + tt + J + k.mainAxis : ct + tt + J + k.mainAxis, Ct = t.elements.arrow && Sh(t.elements.arrow), bt = Ct ? C === "y" ? Ct.clientTop || 0 : Ct.clientLeft || 0 : 0, Ht = (M = F == null ? void 0 : F[C]) != null ? M : 0, $t = H + ot - Ht - bt, wt = H + Tt - Ht, Wt = Yd(m ? ip(X, $t) : X, H, m ? cl(Y, wt) : Y);
      O[C] = Wt, G[C] = Wt - H;
    }
    if (c) {
      var Ut, ne = C === "x" ? ni : ri, ce = C === "x" ? qi : Hi, re = O[E], le = E === "y" ? "height" : "width", Lt = re + x[ne], ye = re - x[ce], be = [ni, ri].indexOf(w) !== -1, Nt = (Ut = F == null ? void 0 : F[E]) != null ? Ut : 0, Bt = be ? Lt : re - B[le] - N[le] - Nt + k.altAxis, Rt = be ? re + B[le] + N[le] - Nt - k.altAxis : ye, Dt = m && be ? J6(Bt, re, Rt) : Yd(m ? Bt : Lt, re, m ? Rt : ye);
      O[E] = Dt, G[E] = Dt - re;
    }
    t.modifiersData[r] = G;
  }
}
const M8 = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: R8,
  requiresIfExists: ["offset"]
};
function O8(e) {
  return {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  };
}
function N8(e) {
  return e === Ai(e) || !Gi(e) ? ey(e) : O8(e);
}
function P8(e) {
  var t = e.getBoundingClientRect(), n = Fc(t.width) / e.offsetWidth || 1, r = Fc(t.height) / e.offsetHeight || 1;
  return n !== 1 || r !== 1;
}
function D8(e, t, n) {
  n === void 0 && (n = !1);
  var r = Gi(t), i = Gi(t) && P8(t), s = sa(t), l = jc(e, i, n), c = {
    scrollLeft: 0,
    scrollTop: 0
  }, u = {
    x: 0,
    y: 0
  };
  return (r || !r && !n) && ((Ds(t) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  ry(s)) && (c = N8(t)), Gi(t) ? (u = jc(t, !0), u.x += t.clientLeft, u.y += t.clientTop) : s && (u.x = ny(s))), {
    x: l.left + c.scrollLeft - u.x,
    y: l.top + c.scrollTop - u.y,
    width: l.width,
    height: l.height
  };
}
function I8(e) {
  var t = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), r = [];
  e.forEach(function(s) {
    t.set(s.name, s);
  });
  function i(s) {
    n.add(s.name);
    var l = [].concat(s.requires || [], s.requiresIfExists || []);
    l.forEach(function(c) {
      if (!n.has(c)) {
        var u = t.get(c);
        u && i(u);
      }
    }), r.push(s);
  }
  return e.forEach(function(s) {
    n.has(s.name) || i(s);
  }), r;
}
function B8(e) {
  var t = I8(e);
  return $6.reduce(function(n, r) {
    return n.concat(t.filter(function(i) {
      return i.phase === r;
    }));
  }, []);
}
function F8(e) {
  var t;
  return function() {
    return t || (t = new Promise(function(n) {
      Promise.resolve().then(function() {
        t = void 0, n(e());
      });
    })), t;
  };
}
function j8(e) {
  var t = e.reduce(function(n, r) {
    var i = n[r.name];
    return n[r.name] = i ? Object.assign({}, i, r, {
      options: Object.assign({}, i.options, r.options),
      data: Object.assign({}, i.data, r.data)
    }) : r, n;
  }, {});
  return Object.keys(t).map(function(n) {
    return t[n];
  });
}
var ob = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function ab() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return !t.some(function(r) {
    return !(r && typeof r.getBoundingClientRect == "function");
  });
}
function L8(e) {
  e === void 0 && (e = {});
  var t = e, n = t.defaultModifiers, r = n === void 0 ? [] : n, i = t.defaultOptions, s = i === void 0 ? ob : i;
  return function(c, u, d) {
    d === void 0 && (d = s);
    var h = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, ob, s),
      modifiersData: {},
      elements: {
        reference: c,
        popper: u
      },
      attributes: {},
      styles: {}
    }, p = [], v = !1, m = {
      state: h,
      setOptions: function(w) {
        var T = typeof w == "function" ? w(h.options) : w;
        b(), h.options = Object.assign({}, s, h.options, T), h.scrollParents = {
          reference: fl(c) ? Xd(c) : c.contextElement ? Xd(c.contextElement) : [],
          popper: Xd(u)
        };
        var S = B8(j8([].concat(r, h.options.modifiers)));
        return h.orderedModifiers = S.filter(function(C) {
          return C.enabled;
        }), g(), m.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!v) {
          var w = h.elements, T = w.reference, S = w.popper;
          if (ab(T, S)) {
            h.rects = {
              reference: D8(T, Sh(S), h.options.strategy === "fixed"),
              popper: J0(S)
            }, h.reset = !1, h.placement = h.options.placement, h.orderedModifiers.forEach(function(k) {
              return h.modifiersData[k.name] = Object.assign({}, k.data);
            });
            for (var C = 0; C < h.orderedModifiers.length; C++) {
              if (h.reset === !0) {
                h.reset = !1, C = -1;
                continue;
              }
              var E = h.orderedModifiers[C], O = E.fn, B = E.options, N = B === void 0 ? {} : B, L = E.name;
              typeof O == "function" && (h = O({
                state: h,
                options: N,
                name: L,
                instance: m
              }) || h);
            }
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: F8(function() {
        return new Promise(function(x) {
          m.forceUpdate(), x(h);
        });
      }),
      destroy: function() {
        b(), v = !0;
      }
    };
    if (!ab(c, u))
      return m;
    m.setOptions(d).then(function(x) {
      !v && d.onFirstUpdate && d.onFirstUpdate(x);
    });
    function g() {
      h.orderedModifiers.forEach(function(x) {
        var w = x.name, T = x.options, S = T === void 0 ? {} : T, C = x.effect;
        if (typeof C == "function") {
          var E = C({
            state: h,
            name: w,
            instance: m,
            options: S
          }), O = function() {
          };
          p.push(E || O);
        }
      });
    }
    function b() {
      p.forEach(function(x) {
        return x();
      }), p = [];
    }
    return m;
  };
}
var z8 = [c8, A8, a8, X6, w8, _8, M8, r8, x8], U8 = /* @__PURE__ */ L8({
  defaultModifiers: z8
});
function V8(e) {
  return typeof e == "function" ? e() : e;
}
const BS = /* @__PURE__ */ K.forwardRef(function(t, n) {
  const {
    children: r,
    container: i,
    disablePortal: s = !1
  } = t, [l, c] = K.useState(null), u = ar(/* @__PURE__ */ K.isValidElement(r) ? Qc(r) : null, n);
  if (ls(() => {
    s || c(V8(i) || document.body);
  }, [i, s]), ls(() => {
    if (l && !s)
      return e0(n, l), () => {
        e0(n, null);
      };
  }, [n, l, s]), s) {
    if (/* @__PURE__ */ K.isValidElement(r)) {
      const d = {
        ref: u
      };
      return /* @__PURE__ */ K.cloneElement(r, d);
    }
    return r;
  }
  return l && /* @__PURE__ */ CS.createPortal(r, l);
});
function G8(e) {
  return Qe("MuiPopper", e);
}
Xe("MuiPopper", ["root"]);
function q8(e, t) {
  if (t === "ltr")
    return e;
  switch (e) {
    case "bottom-end":
      return "bottom-start";
    case "bottom-start":
      return "bottom-end";
    case "top-end":
      return "top-start";
    case "top-start":
      return "top-end";
    default:
      return e;
  }
}
function h0(e) {
  return typeof e == "function" ? e() : e;
}
function H8(e) {
  return e.nodeType !== void 0;
}
const W8 = (e) => {
  const {
    classes: t
  } = e;
  return Ze({
    root: ["root"]
  }, G8, t);
}, $8 = {}, K8 = /* @__PURE__ */ K.forwardRef(function(t, n) {
  const {
    anchorEl: r,
    children: i,
    direction: s,
    disablePortal: l,
    modifiers: c,
    open: u,
    placement: d,
    popperOptions: h,
    popperRef: p,
    slotProps: v = {},
    slots: m = {},
    TransitionProps: g,
    // @ts-ignore internal logic
    ownerState: b,
    // prevent from spreading to DOM, it can come from the parent component e.g. Select.
    ...x
  } = t, w = K.useRef(null), T = ar(w, n), S = K.useRef(null), C = ar(S, p), E = K.useRef(C);
  ls(() => {
    E.current = C;
  }, [C]), K.useImperativeHandle(p, () => S.current, []);
  const O = q8(d, s), [B, N] = K.useState(O), [L, k] = K.useState(h0(r));
  K.useEffect(() => {
    S.current && S.current.forceUpdate();
  }), K.useEffect(() => {
    r && k(h0(r));
  }, [r]), ls(() => {
    if (!L || !u)
      return;
    const D = (X) => {
      N(X.placement);
    };
    let z = [{
      name: "preventOverflow",
      options: {
        altBoundary: l
      }
    }, {
      name: "flip",
      options: {
        altBoundary: l
      }
    }, {
      name: "onUpdate",
      enabled: !0,
      phase: "afterWrite",
      fn: ({
        state: X
      }) => {
        D(X);
      }
    }];
    c != null && (z = z.concat(c)), h && h.modifiers != null && (z = z.concat(h.modifiers));
    const H = U8(L, w.current, {
      placement: O,
      ...h,
      modifiers: z
    });
    return E.current(H), () => {
      H.destroy(), E.current(null);
    };
  }, [L, l, c, u, h, O]);
  const F = {
    placement: B
  };
  g !== null && (F.TransitionProps = g);
  const G = W8(t), M = m.root ?? "div", j = ws({
    elementType: M,
    externalSlotProps: v.root,
    externalForwardedProps: x,
    additionalProps: {
      role: "tooltip",
      ref: T
    },
    ownerState: t,
    className: G.root
  });
  return /* @__PURE__ */ W.jsx(M, {
    ...j,
    children: typeof i == "function" ? i(F) : i
  });
}), Y8 = /* @__PURE__ */ K.forwardRef(function(t, n) {
  const {
    anchorEl: r,
    children: i,
    container: s,
    direction: l = "ltr",
    disablePortal: c = !1,
    keepMounted: u = !1,
    modifiers: d,
    open: h,
    placement: p = "bottom",
    popperOptions: v = $8,
    popperRef: m,
    style: g,
    transition: b = !1,
    slotProps: x = {},
    slots: w = {},
    ...T
  } = t, [S, C] = K.useState(!0), E = () => {
    C(!1);
  }, O = () => {
    C(!0);
  };
  if (!u && !h && (!b || S))
    return null;
  let B;
  if (s)
    B = s;
  else if (r) {
    const k = h0(r);
    B = k && H8(k) ? Er(k).body : Er(null).body;
  }
  const N = !h && u && (!b || S) ? "none" : void 0, L = b ? {
    in: h,
    onEnter: E,
    onExited: O
  } : void 0;
  return /* @__PURE__ */ W.jsx(BS, {
    disablePortal: c,
    container: B,
    children: /* @__PURE__ */ W.jsx(K8, {
      anchorEl: r,
      direction: l,
      disablePortal: c,
      modifiers: d,
      ref: n,
      open: b ? !S : h,
      placement: p,
      popperOptions: v,
      popperRef: m,
      slotProps: x,
      slots: w,
      ...T,
      style: {
        // Prevents scroll issue, waiting for Popper.js to add this style once initiated.
        position: "fixed",
        // Fix Popper.js display issue
        top: 0,
        left: 0,
        display: N,
        ...g
      },
      TransitionProps: L,
      children: i
    })
  });
}), X8 = he(Y8, {
  name: "MuiPopper",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({}), FS = /* @__PURE__ */ K.forwardRef(function(t, n) {
  const r = zp(), i = nn({
    props: t,
    name: "MuiPopper"
  }), {
    anchorEl: s,
    component: l,
    components: c,
    componentsProps: u,
    container: d,
    disablePortal: h,
    keepMounted: p,
    modifiers: v,
    open: m,
    placement: g,
    popperOptions: b,
    popperRef: x,
    transition: w,
    slots: T,
    slotProps: S,
    ...C
  } = i, E = (T == null ? void 0 : T.root) ?? (c == null ? void 0 : c.Root), O = {
    anchorEl: s,
    container: d,
    disablePortal: h,
    keepMounted: p,
    modifiers: v,
    open: m,
    placement: g,
    popperOptions: b,
    popperRef: x,
    transition: w,
    ...C
  };
  return /* @__PURE__ */ W.jsx(X8, {
    as: l,
    direction: r ? "rtl" : "ltr",
    slots: {
      root: E
    },
    slotProps: S ?? u,
    ...O,
    ref: n
  });
});
function Cf(e) {
  return parseInt(e, 10) || 0;
}
const Q8 = {
  shadow: {
    // Visibility needed to hide the extra text area on iPads
    visibility: "hidden",
    // Remove from the content flow
    position: "absolute",
    // Ignore the scrollbar width
    overflow: "hidden",
    height: 0,
    top: 0,
    left: 0,
    // Create a new layer, increase the isolation of the computed values
    transform: "translateZ(0)"
  }
};
function Z8(e) {
  for (const t in e)
    return !1;
  return !0;
}
function lb(e) {
  return Z8(e) || e.outerHeightStyle === 0 && !e.overflowing;
}
const J8 = /* @__PURE__ */ K.forwardRef(function(t, n) {
  const {
    onChange: r,
    maxRows: i,
    minRows: s = 1,
    style: l,
    value: c,
    ...u
  } = t, {
    current: d
  } = K.useRef(c != null), h = K.useRef(null), p = ar(n, h), v = K.useRef(null), m = K.useRef(null), g = K.useCallback(() => {
    const S = h.current, C = m.current;
    if (!S || !C)
      return;
    const O = vo(S).getComputedStyle(S);
    if (O.width === "0px")
      return {
        outerHeightStyle: 0,
        overflowing: !1
      };
    C.style.width = O.width, C.value = S.value || t.placeholder || "x", C.value.slice(-1) === `
` && (C.value += " ");
    const B = O.boxSizing, N = Cf(O.paddingBottom) + Cf(O.paddingTop), L = Cf(O.borderBottomWidth) + Cf(O.borderTopWidth), k = C.scrollHeight;
    C.value = "x";
    const F = C.scrollHeight;
    let G = k;
    s && (G = Math.max(Number(s) * F, G)), i && (G = Math.min(Number(i) * F, G)), G = Math.max(G, F);
    const M = G + (B === "border-box" ? N + L : 0), j = Math.abs(G - k) <= 1;
    return {
      outerHeightStyle: M,
      overflowing: j
    };
  }, [i, s, t.placeholder]), b = Vi(() => {
    const S = h.current, C = g();
    if (!S || !C || lb(C))
      return !1;
    const E = C.outerHeightStyle;
    return v.current != null && v.current !== E;
  }), x = K.useCallback(() => {
    const S = h.current, C = g();
    if (!S || !C || lb(C))
      return;
    const E = C.outerHeightStyle;
    v.current !== E && (v.current = E, S.style.height = `${E}px`), S.style.overflow = C.overflowing ? "hidden" : "";
  }, [g]), w = K.useRef(-1);
  ls(() => {
    const S = uS(x), C = h == null ? void 0 : h.current;
    if (!C)
      return;
    const E = vo(C);
    E.addEventListener("resize", S);
    let O;
    return typeof ResizeObserver < "u" && (O = new ResizeObserver(() => {
      b() && (O.unobserve(C), cancelAnimationFrame(w.current), x(), w.current = requestAnimationFrame(() => {
        O.observe(C);
      }));
    }), O.observe(C)), () => {
      S.clear(), cancelAnimationFrame(w.current), E.removeEventListener("resize", S), O && O.disconnect();
    };
  }, [g, x, b]), ls(() => {
    x();
  });
  const T = (S) => {
    d || x(), r && r(S);
  };
  return /* @__PURE__ */ W.jsxs(K.Fragment, {
    children: [/* @__PURE__ */ W.jsx("textarea", {
      value: c,
      onChange: T,
      ref: p,
      rows: s,
      style: l,
      ...u
    }), /* @__PURE__ */ W.jsx("textarea", {
      "aria-hidden": !0,
      className: t.className,
      readOnly: !0,
      ref: m,
      tabIndex: -1,
      style: {
        ...Q8.shadow,
        ...l,
        paddingTop: 0,
        paddingBottom: 0
      }
    })]
  });
});
function ul(e) {
  return typeof e == "string";
}
function Zc({
  props: e,
  states: t,
  muiFormControl: n
}) {
  return t.reduce((r, i) => (r[i] = e[i], n && typeof e[i] > "u" && (r[i] = n[i]), r), {});
}
const iy = /* @__PURE__ */ K.createContext(void 0);
function Jc() {
  return K.useContext(iy);
}
function cb(e) {
  return e != null && !(Array.isArray(e) && e.length === 0);
}
function sp(e, t = !1) {
  return e && (cb(e.value) && e.value !== "" || t && cb(e.defaultValue) && e.defaultValue !== "");
}
function tE(e) {
  return e.startAdornment;
}
function eE(e) {
  return Qe("MuiInputBase", e);
}
const zc = Xe("MuiInputBase", ["root", "formControl", "focused", "disabled", "adornedStart", "adornedEnd", "error", "sizeSmall", "multiline", "colorSecondary", "fullWidth", "hiddenLabel", "readOnly", "input", "inputSizeSmall", "inputMultiline", "inputTypeSearch", "inputAdornedStart", "inputAdornedEnd", "inputHiddenLabel"]);
var ub;
const Hp = (e, t) => {
  const {
    ownerState: n
  } = e;
  return [t.root, n.formControl && t.formControl, n.startAdornment && t.adornedStart, n.endAdornment && t.adornedEnd, n.error && t.error, n.size === "small" && t.sizeSmall, n.multiline && t.multiline, n.color && t[`color${pe(n.color)}`], n.fullWidth && t.fullWidth, n.hiddenLabel && t.hiddenLabel];
}, Wp = (e, t) => {
  const {
    ownerState: n
  } = e;
  return [t.input, n.size === "small" && t.inputSizeSmall, n.multiline && t.inputMultiline, n.type === "search" && t.inputTypeSearch, n.startAdornment && t.inputAdornedStart, n.endAdornment && t.inputAdornedEnd, n.hiddenLabel && t.inputHiddenLabel];
}, nE = (e) => {
  const {
    classes: t,
    color: n,
    disabled: r,
    error: i,
    endAdornment: s,
    focused: l,
    formControl: c,
    fullWidth: u,
    hiddenLabel: d,
    multiline: h,
    readOnly: p,
    size: v,
    startAdornment: m,
    type: g
  } = e, b = {
    root: ["root", `color${pe(n)}`, r && "disabled", i && "error", u && "fullWidth", l && "focused", c && "formControl", v && v !== "medium" && `size${pe(v)}`, h && "multiline", m && "adornedStart", s && "adornedEnd", d && "hiddenLabel", p && "readOnly"],
    input: ["input", r && "disabled", g === "search" && "inputTypeSearch", h && "inputMultiline", v === "small" && "inputSizeSmall", d && "inputHiddenLabel", m && "inputAdornedStart", s && "inputAdornedEnd", p && "readOnly"]
  };
  return Ze(b, eE, t);
}, $p = he("div", {
  name: "MuiInputBase",
  slot: "Root",
  overridesResolver: Hp
})(He(({
  theme: e
}) => ({
  ...e.typography.body1,
  color: (e.vars || e).palette.text.primary,
  lineHeight: "1.4375em",
  // 23px
  boxSizing: "border-box",
  // Prevent padding issue with fullWidth.
  position: "relative",
  cursor: "text",
  display: "inline-flex",
  alignItems: "center",
  [`&.${zc.disabled}`]: {
    color: (e.vars || e).palette.text.disabled,
    cursor: "default"
  },
  variants: [{
    props: ({
      ownerState: t
    }) => t.multiline,
    style: {
      padding: "4px 0 5px"
    }
  }, {
    props: ({
      ownerState: t,
      size: n
    }) => t.multiline && n === "small",
    style: {
      paddingTop: 1
    }
  }, {
    props: ({
      ownerState: t
    }) => t.fullWidth,
    style: {
      width: "100%"
    }
  }]
}))), Kp = he("input", {
  name: "MuiInputBase",
  slot: "Input",
  overridesResolver: Wp
})(He(({
  theme: e
}) => {
  const t = e.palette.mode === "light", n = {
    color: "currentColor",
    ...e.vars ? {
      opacity: e.vars.opacity.inputPlaceholder
    } : {
      opacity: t ? 0.42 : 0.5
    },
    transition: e.transitions.create("opacity", {
      duration: e.transitions.duration.shorter
    })
  }, r = {
    opacity: "0 !important"
  }, i = e.vars ? {
    opacity: e.vars.opacity.inputPlaceholder
  } : {
    opacity: t ? 0.42 : 0.5
  };
  return {
    font: "inherit",
    letterSpacing: "inherit",
    color: "currentColor",
    padding: "4px 0 5px",
    border: 0,
    boxSizing: "content-box",
    background: "none",
    height: "1.4375em",
    // Reset 23pxthe native input line-height
    margin: 0,
    // Reset for Safari
    WebkitTapHighlightColor: "transparent",
    display: "block",
    // Make the flex item shrink with Firefox
    minWidth: 0,
    width: "100%",
    "&::-webkit-input-placeholder": n,
    "&::-moz-placeholder": n,
    // Firefox 19+
    "&::-ms-input-placeholder": n,
    // Edge
    "&:focus": {
      outline: 0
    },
    // Reset Firefox invalid required input style
    "&:invalid": {
      boxShadow: "none"
    },
    "&::-webkit-search-decoration": {
      // Remove the padding when type=search.
      WebkitAppearance: "none"
    },
    // Show and hide the placeholder logic
    [`label[data-shrink=false] + .${zc.formControl} &`]: {
      "&::-webkit-input-placeholder": r,
      "&::-moz-placeholder": r,
      // Firefox 19+
      "&::-ms-input-placeholder": r,
      // Edge
      "&:focus::-webkit-input-placeholder": i,
      "&:focus::-moz-placeholder": i,
      // Firefox 19+
      "&:focus::-ms-input-placeholder": i
      // Edge
    },
    [`&.${zc.disabled}`]: {
      opacity: 1,
      // Reset iOS opacity
      WebkitTextFillColor: (e.vars || e).palette.text.disabled
      // Fix opacity Safari bug
    },
    variants: [{
      props: ({
        ownerState: s
      }) => !s.disableInjectingGlobalStyles,
      style: {
        animationName: "mui-auto-fill-cancel",
        animationDuration: "10ms",
        "&:-webkit-autofill": {
          animationDuration: "5000s",
          animationName: "mui-auto-fill"
        }
      }
    }, {
      props: {
        size: "small"
      },
      style: {
        paddingTop: 1
      }
    }, {
      props: ({
        ownerState: s
      }) => s.multiline,
      style: {
        height: "auto",
        resize: "none",
        padding: 0,
        paddingTop: 0
      }
    }, {
      props: {
        type: "search"
      },
      style: {
        MozAppearance: "textfield"
        // Improve type search style.
      }
    }]
  };
})), db = Lw({
  "@keyframes mui-auto-fill": {
    from: {
      display: "block"
    }
  },
  "@keyframes mui-auto-fill-cancel": {
    from: {
      display: "block"
    }
  }
}), sy = /* @__PURE__ */ K.forwardRef(function(t, n) {
  const r = nn({
    props: t,
    name: "MuiInputBase"
  }), {
    "aria-describedby": i,
    autoComplete: s,
    autoFocus: l,
    className: c,
    color: u,
    components: d = {},
    componentsProps: h = {},
    defaultValue: p,
    disabled: v,
    disableInjectingGlobalStyles: m,
    endAdornment: g,
    error: b,
    fullWidth: x = !1,
    id: w,
    inputComponent: T = "input",
    inputProps: S = {},
    inputRef: C,
    margin: E,
    maxRows: O,
    minRows: B,
    multiline: N = !1,
    name: L,
    onBlur: k,
    onChange: F,
    onClick: G,
    onFocus: M,
    onKeyDown: j,
    onKeyUp: D,
    placeholder: z,
    readOnly: H,
    renderSuffix: X,
    rows: Y,
    size: V,
    slotProps: Z = {},
    slots: ct = {},
    startAdornment: et,
    type: rt = "text",
    value: st,
    ...yt
  } = r, J = S.value != null ? S.value : st, {
    current: tt
  } = K.useRef(J != null), ot = K.useRef(), Tt = K.useCallback((Vt) => {
  }, []), Ct = ar(ot, C, S.ref, Tt), [bt, Ht] = K.useState(!1), $t = Jc(), wt = Zc({
    props: r,
    muiFormControl: $t,
    states: ["color", "disabled", "error", "hiddenLabel", "size", "required", "filled"]
  });
  wt.focused = $t ? $t.focused : bt, K.useEffect(() => {
    !$t && v && bt && (Ht(!1), k && k());
  }, [$t, v, bt, k]);
  const Wt = $t && $t.onFilled, Ut = $t && $t.onEmpty, ne = K.useCallback((Vt) => {
    sp(Vt) ? Wt && Wt() : Ut && Ut();
  }, [Wt, Ut]);
  ls(() => {
    tt && ne({
      value: J
    });
  }, [J, ne, tt]);
  const ce = (Vt) => {
    M && M(Vt), S.onFocus && S.onFocus(Vt), $t && $t.onFocus ? $t.onFocus(Vt) : Ht(!0);
  }, re = (Vt) => {
    k && k(Vt), S.onBlur && S.onBlur(Vt), $t && $t.onBlur ? $t.onBlur(Vt) : Ht(!1);
  }, le = (Vt, ...Yt) => {
    if (!tt) {
      const ee = Vt.target || ot.current;
      if (ee == null)
        throw new Error(go(1));
      ne({
        value: ee.value
      });
    }
    S.onChange && S.onChange(Vt, ...Yt), F && F(Vt, ...Yt);
  };
  K.useEffect(() => {
    ne(ot.current);
  }, []);
  const Lt = (Vt) => {
    ot.current && Vt.currentTarget === Vt.target && ot.current.focus(), G && G(Vt);
  };
  let ye = T, be = S;
  N && ye === "input" && (Y ? be = {
    type: void 0,
    minRows: Y,
    maxRows: Y,
    ...be
  } : be = {
    type: void 0,
    maxRows: O,
    minRows: B,
    ...be
  }, ye = J8);
  const Nt = (Vt) => {
    ne(Vt.animationName === "mui-auto-fill-cancel" ? ot.current : {
      value: "x"
    });
  };
  K.useEffect(() => {
    $t && $t.setAdornedStart(!!et);
  }, [$t, et]);
  const Bt = {
    ...r,
    color: wt.color || "primary",
    disabled: wt.disabled,
    endAdornment: g,
    error: wt.error,
    focused: wt.focused,
    formControl: $t,
    fullWidth: x,
    hiddenLabel: wt.hiddenLabel,
    multiline: N,
    size: wt.size,
    startAdornment: et,
    type: rt
  }, Rt = nE(Bt), Dt = ct.root || d.Root || $p, jt = Z.root || h.root || {}, Ft = ct.input || d.Input || Kp;
  return be = {
    ...be,
    ...Z.input ?? h.input
  }, /* @__PURE__ */ W.jsxs(K.Fragment, {
    children: [!m && typeof db == "function" && // For Emotion/Styled-components, InputGlobalStyles will be a function
    // For Pigment CSS, this has no effect because the InputGlobalStyles will be null.
    (ub || (ub = /* @__PURE__ */ W.jsx(db, {}))), /* @__PURE__ */ W.jsxs(Dt, {
      ...jt,
      ref: n,
      onClick: Lt,
      ...yt,
      ...!ul(Dt) && {
        ownerState: {
          ...Bt,
          ...jt.ownerState
        }
      },
      className: ge(Rt.root, jt.className, c, H && "MuiInputBase-readOnly"),
      children: [et, /* @__PURE__ */ W.jsx(iy.Provider, {
        value: null,
        children: /* @__PURE__ */ W.jsx(Ft, {
          "aria-invalid": wt.error,
          "aria-describedby": i,
          autoComplete: s,
          autoFocus: l,
          defaultValue: p,
          disabled: wt.disabled,
          id: w,
          onAnimationStart: Nt,
          name: L,
          placeholder: z,
          readOnly: H,
          required: wt.required,
          rows: Y,
          value: J,
          onKeyDown: j,
          onKeyUp: D,
          type: rt,
          ...be,
          ...!ul(Ft) && {
            as: ye,
            ownerState: {
              ...Bt,
              ...be.ownerState
            }
          },
          ref: Ct,
          className: ge(Rt.input, be.className, H && "MuiInputBase-readOnly"),
          onBlur: re,
          onChange: le,
          onFocus: ce
        })
      }), g, X ? X({
        ...wt,
        startAdornment: et
      }) : null]
    })]
  });
});
function rE(e) {
  return Qe("MuiInput", e);
}
const Hu = {
  ...zc,
  ...Xe("MuiInput", ["root", "underline", "input"])
};
function iE(e) {
  return Qe("MuiOutlinedInput", e);
}
const Cs = {
  ...zc,
  ...Xe("MuiOutlinedInput", ["root", "notchedOutline", "input"])
};
function sE(e) {
  return Qe("MuiFilledInput", e);
}
const Ya = {
  ...zc,
  ...Xe("MuiFilledInput", ["root", "underline", "input", "adornedStart", "adornedEnd", "sizeSmall", "multiline", "hiddenLabel"])
}, oE = zr(/* @__PURE__ */ W.jsx("path", {
  d: "M7 10l5 5 5-5z"
}), "ArrowDropDown"), aE = {
  entering: {
    opacity: 1
  },
  entered: {
    opacity: 1
  }
}, lE = /* @__PURE__ */ K.forwardRef(function(t, n) {
  const r = Up(), i = {
    enter: r.transitions.duration.enteringScreen,
    exit: r.transitions.duration.leavingScreen
  }, {
    addEndListener: s,
    appear: l = !0,
    children: c,
    easing: u,
    in: d,
    onEnter: h,
    onEntered: p,
    onEntering: v,
    onExit: m,
    onExited: g,
    onExiting: b,
    style: x,
    timeout: w = i,
    // eslint-disable-next-line react/prop-types
    TransitionComponent: T = Fs,
    ...S
  } = t, C = K.useRef(null), E = ar(C, Qc(c), n), O = (j) => (D) => {
    if (j) {
      const z = C.current;
      D === void 0 ? j(z) : j(z, D);
    }
  }, B = O(v), N = O((j, D) => {
    wS(j);
    const z = np({
      style: x,
      timeout: w,
      easing: u
    }, {
      mode: "enter"
    });
    j.style.webkitTransition = r.transitions.create("opacity", z), j.style.transition = r.transitions.create("opacity", z), h && h(j, D);
  }), L = O(p), k = O(b), F = O((j) => {
    const D = np({
      style: x,
      timeout: w,
      easing: u
    }, {
      mode: "exit"
    });
    j.style.webkitTransition = r.transitions.create("opacity", D), j.style.transition = r.transitions.create("opacity", D), m && m(j);
  }), G = O(g), M = (j) => {
    s && s(C.current, j);
  };
  return /* @__PURE__ */ W.jsx(T, {
    appear: l,
    in: d,
    nodeRef: C,
    onEnter: N,
    onEntered: L,
    onEntering: B,
    onExit: F,
    onExited: G,
    onExiting: k,
    addEndListener: M,
    timeout: w,
    ...S,
    children: (j, {
      ownerState: D,
      ...z
    }) => /* @__PURE__ */ K.cloneElement(c, {
      style: {
        opacity: 0,
        visibility: j === "exited" && !d ? "hidden" : void 0,
        ...aE[j],
        ...x,
        ...c.props.style
      },
      ref: E,
      ...z
    })
  });
});
function cE(e) {
  return Qe("MuiBackdrop", e);
}
Xe("MuiBackdrop", ["root", "invisible"]);
const uE = (e) => {
  const {
    classes: t,
    invisible: n
  } = e;
  return Ze({
    root: ["root", n && "invisible"]
  }, cE, t);
}, dE = he("div", {
  name: "MuiBackdrop",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.invisible && t.invisible];
  }
})({
  position: "fixed",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  right: 0,
  bottom: 0,
  top: 0,
  left: 0,
  backgroundColor: "rgba(0, 0, 0, 0.5)",
  WebkitTapHighlightColor: "transparent",
  variants: [{
    props: {
      invisible: !0
    },
    style: {
      backgroundColor: "transparent"
    }
  }]
}), hE = /* @__PURE__ */ K.forwardRef(function(t, n) {
  const r = nn({
    props: t,
    name: "MuiBackdrop"
  }), {
    children: i,
    className: s,
    component: l = "div",
    invisible: c = !1,
    open: u,
    components: d = {},
    componentsProps: h = {},
    slotProps: p = {},
    slots: v = {},
    TransitionComponent: m,
    transitionDuration: g,
    ...b
  } = r, x = {
    ...r,
    component: l,
    invisible: c
  }, w = uE(x), T = {
    transition: m,
    root: d.Root,
    ...v
  }, S = {
    ...h,
    ...p
  }, C = {
    slots: T,
    slotProps: S
  }, [E, O] = $n("root", {
    elementType: dE,
    externalForwardedProps: C,
    className: ge(w.root, s),
    ownerState: x
  }), [B, N] = $n("transition", {
    elementType: lE,
    externalForwardedProps: C,
    ownerState: x
  });
  return /* @__PURE__ */ W.jsx(B, {
    in: u,
    timeout: g,
    ...b,
    ...N,
    children: /* @__PURE__ */ W.jsx(E, {
      "aria-hidden": !0,
      ...O,
      classes: w,
      ref: n,
      children: i
    })
  });
}), fE = Xe("MuiBox", ["root"]), pE = SS(), Zt = OC({
  themeId: Ep,
  defaultTheme: pE,
  defaultClassName: fE.root,
  generateClassName: sS.generate
});
function mE(e) {
  return Qe("MuiButton", e);
}
const Xa = Xe("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorSuccess", "colorError", "colorInfo", "colorWarning", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "icon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge", "loading", "loadingWrapper", "loadingIconPlaceholder", "loadingIndicator", "loadingPositionCenter", "loadingPositionStart", "loadingPositionEnd"]), gE = /* @__PURE__ */ K.createContext({}), yE = /* @__PURE__ */ K.createContext(void 0), vE = (e) => {
  const {
    color: t,
    disableElevation: n,
    fullWidth: r,
    size: i,
    variant: s,
    loading: l,
    loadingPosition: c,
    classes: u
  } = e, d = {
    root: ["root", l && "loading", s, `${s}${pe(t)}`, `size${pe(i)}`, `${s}Size${pe(i)}`, `color${pe(t)}`, n && "disableElevation", r && "fullWidth", l && `loadingPosition${pe(c)}`],
    startIcon: ["icon", "startIcon", `iconSize${pe(i)}`],
    endIcon: ["icon", "endIcon", `iconSize${pe(i)}`],
    loadingIndicator: ["loadingIndicator"],
    loadingWrapper: ["loadingWrapper"]
  }, h = Ze(d, mE, u);
  return {
    ...u,
    // forward the focused, disabled, etc. classes to the ButtonBase
    ...h
  };
}, jS = [{
  props: {
    size: "small"
  },
  style: {
    "& > *:nth-of-type(1)": {
      fontSize: 18
    }
  }
}, {
  props: {
    size: "medium"
  },
  style: {
    "& > *:nth-of-type(1)": {
      fontSize: 20
    }
  }
}, {
  props: {
    size: "large"
  },
  style: {
    "& > *:nth-of-type(1)": {
      fontSize: 22
    }
  }
}], bE = he(Gp, {
  shouldForwardProp: (e) => $i(e) || e === "classes",
  name: "MuiButton",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, t[n.variant], t[`${n.variant}${pe(n.color)}`], t[`size${pe(n.size)}`], t[`${n.variant}Size${pe(n.size)}`], n.color === "inherit" && t.colorInherit, n.disableElevation && t.disableElevation, n.fullWidth && t.fullWidth, n.loading && t.loading];
  }
})(He(({
  theme: e
}) => {
  const t = e.palette.mode === "light" ? e.palette.grey[300] : e.palette.grey[800], n = e.palette.mode === "light" ? e.palette.grey.A100 : e.palette.grey[700];
  return {
    ...e.typography.button,
    minWidth: 64,
    padding: "6px 16px",
    border: 0,
    borderRadius: (e.vars || e).shape.borderRadius,
    transition: e.transitions.create(["background-color", "box-shadow", "border-color", "color"], {
      duration: e.transitions.duration.short
    }),
    "&:hover": {
      textDecoration: "none"
    },
    [`&.${Xa.disabled}`]: {
      color: (e.vars || e).palette.action.disabled
    },
    variants: [{
      props: {
        variant: "contained"
      },
      style: {
        color: "var(--variant-containedColor)",
        backgroundColor: "var(--variant-containedBg)",
        boxShadow: (e.vars || e).shadows[2],
        "&:hover": {
          boxShadow: (e.vars || e).shadows[4],
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            boxShadow: (e.vars || e).shadows[2]
          }
        },
        "&:active": {
          boxShadow: (e.vars || e).shadows[8]
        },
        [`&.${Xa.focusVisible}`]: {
          boxShadow: (e.vars || e).shadows[6]
        },
        [`&.${Xa.disabled}`]: {
          color: (e.vars || e).palette.action.disabled,
          boxShadow: (e.vars || e).shadows[0],
          backgroundColor: (e.vars || e).palette.action.disabledBackground
        }
      }
    }, {
      props: {
        variant: "outlined"
      },
      style: {
        padding: "5px 15px",
        border: "1px solid currentColor",
        borderColor: "var(--variant-outlinedBorder, currentColor)",
        backgroundColor: "var(--variant-outlinedBg)",
        color: "var(--variant-outlinedColor)",
        [`&.${Xa.disabled}`]: {
          border: `1px solid ${(e.vars || e).palette.action.disabledBackground}`
        }
      }
    }, {
      props: {
        variant: "text"
      },
      style: {
        padding: "6px 8px",
        color: "var(--variant-textColor)",
        backgroundColor: "var(--variant-textBg)"
      }
    }, ...Object.entries(e.palette).filter(Ei()).map(([r]) => ({
      props: {
        color: r
      },
      style: {
        "--variant-textColor": (e.vars || e).palette[r].main,
        "--variant-outlinedColor": (e.vars || e).palette[r].main,
        "--variant-outlinedBorder": e.vars ? `rgba(${e.vars.palette[r].mainChannel} / 0.5)` : xn(e.palette[r].main, 0.5),
        "--variant-containedColor": (e.vars || e).palette[r].contrastText,
        "--variant-containedBg": (e.vars || e).palette[r].main,
        "@media (hover: hover)": {
          "&:hover": {
            "--variant-containedBg": (e.vars || e).palette[r].dark,
            "--variant-textBg": e.vars ? `rgba(${e.vars.palette[r].mainChannel} / ${e.vars.palette.action.hoverOpacity})` : xn(e.palette[r].main, e.palette.action.hoverOpacity),
            "--variant-outlinedBorder": (e.vars || e).palette[r].main,
            "--variant-outlinedBg": e.vars ? `rgba(${e.vars.palette[r].mainChannel} / ${e.vars.palette.action.hoverOpacity})` : xn(e.palette[r].main, e.palette.action.hoverOpacity)
          }
        }
      }
    })), {
      props: {
        color: "inherit"
      },
      style: {
        color: "inherit",
        borderColor: "currentColor",
        "--variant-containedBg": e.vars ? e.vars.palette.Button.inheritContainedBg : t,
        "@media (hover: hover)": {
          "&:hover": {
            "--variant-containedBg": e.vars ? e.vars.palette.Button.inheritContainedHoverBg : n,
            "--variant-textBg": e.vars ? `rgba(${e.vars.palette.text.primaryChannel} / ${e.vars.palette.action.hoverOpacity})` : xn(e.palette.text.primary, e.palette.action.hoverOpacity),
            "--variant-outlinedBg": e.vars ? `rgba(${e.vars.palette.text.primaryChannel} / ${e.vars.palette.action.hoverOpacity})` : xn(e.palette.text.primary, e.palette.action.hoverOpacity)
          }
        }
      }
    }, {
      props: {
        size: "small",
        variant: "text"
      },
      style: {
        padding: "4px 5px",
        fontSize: e.typography.pxToRem(13)
      }
    }, {
      props: {
        size: "large",
        variant: "text"
      },
      style: {
        padding: "8px 11px",
        fontSize: e.typography.pxToRem(15)
      }
    }, {
      props: {
        size: "small",
        variant: "outlined"
      },
      style: {
        padding: "3px 9px",
        fontSize: e.typography.pxToRem(13)
      }
    }, {
      props: {
        size: "large",
        variant: "outlined"
      },
      style: {
        padding: "7px 21px",
        fontSize: e.typography.pxToRem(15)
      }
    }, {
      props: {
        size: "small",
        variant: "contained"
      },
      style: {
        padding: "4px 10px",
        fontSize: e.typography.pxToRem(13)
      }
    }, {
      props: {
        size: "large",
        variant: "contained"
      },
      style: {
        padding: "8px 22px",
        fontSize: e.typography.pxToRem(15)
      }
    }, {
      props: {
        disableElevation: !0
      },
      style: {
        boxShadow: "none",
        "&:hover": {
          boxShadow: "none"
        },
        [`&.${Xa.focusVisible}`]: {
          boxShadow: "none"
        },
        "&:active": {
          boxShadow: "none"
        },
        [`&.${Xa.disabled}`]: {
          boxShadow: "none"
        }
      }
    }, {
      props: {
        fullWidth: !0
      },
      style: {
        width: "100%"
      }
    }, {
      props: {
        loadingPosition: "center"
      },
      style: {
        transition: e.transitions.create(["background-color", "box-shadow", "border-color"], {
          duration: e.transitions.duration.short
        }),
        [`&.${Xa.loading}`]: {
          color: "transparent"
        }
      }
    }]
  };
})), _E = he("span", {
  name: "MuiButton",
  slot: "StartIcon",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.startIcon, n.loading && t.startIconLoadingStart, t[`iconSize${pe(n.size)}`]];
  }
})(({
  theme: e
}) => ({
  display: "inherit",
  marginRight: 8,
  marginLeft: -4,
  variants: [{
    props: {
      size: "small"
    },
    style: {
      marginLeft: -2
    }
  }, {
    props: {
      loadingPosition: "start",
      loading: !0
    },
    style: {
      transition: e.transitions.create(["opacity"], {
        duration: e.transitions.duration.short
      }),
      opacity: 0
    }
  }, {
    props: {
      loadingPosition: "start",
      loading: !0,
      fullWidth: !0
    },
    style: {
      marginRight: -8
    }
  }, ...jS]
})), SE = he("span", {
  name: "MuiButton",
  slot: "EndIcon",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.endIcon, n.loading && t.endIconLoadingEnd, t[`iconSize${pe(n.size)}`]];
  }
})(({
  theme: e
}) => ({
  display: "inherit",
  marginRight: -4,
  marginLeft: 8,
  variants: [{
    props: {
      size: "small"
    },
    style: {
      marginRight: -2
    }
  }, {
    props: {
      loadingPosition: "end",
      loading: !0
    },
    style: {
      transition: e.transitions.create(["opacity"], {
        duration: e.transitions.duration.short
      }),
      opacity: 0
    }
  }, {
    props: {
      loadingPosition: "end",
      loading: !0,
      fullWidth: !0
    },
    style: {
      marginLeft: -8
    }
  }, ...jS]
})), xE = he("span", {
  name: "MuiButton",
  slot: "LoadingIndicator",
  overridesResolver: (e, t) => t.loadingIndicator
})(({
  theme: e
}) => ({
  display: "none",
  position: "absolute",
  visibility: "visible",
  variants: [{
    props: {
      loading: !0
    },
    style: {
      display: "flex"
    }
  }, {
    props: {
      loadingPosition: "start"
    },
    style: {
      left: 14
    }
  }, {
    props: {
      loadingPosition: "start",
      size: "small"
    },
    style: {
      left: 10
    }
  }, {
    props: {
      variant: "text",
      loadingPosition: "start"
    },
    style: {
      left: 6
    }
  }, {
    props: {
      loadingPosition: "center"
    },
    style: {
      left: "50%",
      transform: "translate(-50%)",
      color: (e.vars || e).palette.action.disabled
    }
  }, {
    props: {
      loadingPosition: "end"
    },
    style: {
      right: 14
    }
  }, {
    props: {
      loadingPosition: "end",
      size: "small"
    },
    style: {
      right: 10
    }
  }, {
    props: {
      variant: "text",
      loadingPosition: "end"
    },
    style: {
      right: 6
    }
  }, {
    props: {
      loadingPosition: "start",
      fullWidth: !0
    },
    style: {
      position: "relative",
      left: -10
    }
  }, {
    props: {
      loadingPosition: "end",
      fullWidth: !0
    },
    style: {
      position: "relative",
      right: -10
    }
  }]
})), hb = he("span", {
  name: "MuiButton",
  slot: "LoadingIconPlaceholder",
  overridesResolver: (e, t) => t.loadingIconPlaceholder
})({
  display: "inline-block",
  width: "1em",
  height: "1em"
}), Nc = /* @__PURE__ */ K.forwardRef(function(t, n) {
  const r = K.useContext(gE), i = K.useContext(yE), s = rh(r, t), l = nn({
    props: s,
    name: "MuiButton"
  }), {
    children: c,
    color: u = "primary",
    component: d = "button",
    className: h,
    disabled: p = !1,
    disableElevation: v = !1,
    disableFocusRipple: m = !1,
    endIcon: g,
    focusVisibleClassName: b,
    fullWidth: x = !1,
    id: w,
    loading: T = null,
    loadingIndicator: S,
    loadingPosition: C = "center",
    size: E = "medium",
    startIcon: O,
    type: B,
    variant: N = "text",
    ...L
  } = l, k = bh(w), F = S ?? /* @__PURE__ */ W.jsx(ES, {
    "aria-labelledby": k,
    color: "inherit",
    size: 16
  }), G = {
    ...l,
    color: u,
    component: d,
    disabled: p,
    disableElevation: v,
    disableFocusRipple: m,
    fullWidth: x,
    loading: T,
    loadingIndicator: F,
    loadingPosition: C,
    size: E,
    type: B,
    variant: N
  }, M = vE(G), j = (O || T && C === "start") && /* @__PURE__ */ W.jsx(_E, {
    className: M.startIcon,
    ownerState: G,
    children: O || /* @__PURE__ */ W.jsx(hb, {
      className: M.loadingIconPlaceholder,
      ownerState: G
    })
  }), D = (g || T && C === "end") && /* @__PURE__ */ W.jsx(SE, {
    className: M.endIcon,
    ownerState: G,
    children: g || /* @__PURE__ */ W.jsx(hb, {
      className: M.loadingIconPlaceholder,
      ownerState: G
    })
  }), z = i || "", H = typeof T == "boolean" ? (
    // use plain HTML span to minimize the runtime overhead
    /* @__PURE__ */ W.jsx("span", {
      className: M.loadingWrapper,
      style: {
        display: "contents"
      },
      children: T && /* @__PURE__ */ W.jsx(xE, {
        className: M.loadingIndicator,
        ownerState: G,
        children: F
      })
    })
  ) : null;
  return /* @__PURE__ */ W.jsxs(bE, {
    ownerState: G,
    className: ge(r.className, M.root, h, z),
    component: d,
    disabled: p || T,
    focusRipple: !m,
    focusVisibleClassName: ge(M.focusVisible, b),
    ref: n,
    type: B,
    id: T ? k : w,
    ...L,
    classes: M,
    children: [j, C !== "end" && H, c, C === "end" && H, D]
  });
});
function TE(e) {
  const t = Er(e);
  return t.body === e ? vo(e).innerWidth > t.documentElement.clientWidth : e.scrollHeight > e.clientHeight;
}
function Qd(e, t) {
  t ? e.setAttribute("aria-hidden", "true") : e.removeAttribute("aria-hidden");
}
function fb(e) {
  return parseInt(vo(e).getComputedStyle(e).paddingRight, 10) || 0;
}
function CE(e) {
  const n = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"].includes(e.tagName), r = e.tagName === "INPUT" && e.getAttribute("type") === "hidden";
  return n || r;
}
function pb(e, t, n, r, i) {
  const s = [t, n, ...r];
  [].forEach.call(e.children, (l) => {
    const c = !s.includes(l), u = !CE(l);
    c && u && Qd(l, i);
  });
}
function bg(e, t) {
  let n = -1;
  return e.some((r, i) => t(r) ? (n = i, !0) : !1), n;
}
function wE(e, t) {
  const n = [], r = e.container;
  if (!t.disableScrollLock) {
    if (TE(r)) {
      const l = hS(vo(r));
      n.push({
        value: r.style.paddingRight,
        property: "padding-right",
        el: r
      }), r.style.paddingRight = `${fb(r) + l}px`;
      const c = Er(r).querySelectorAll(".mui-fixed");
      [].forEach.call(c, (u) => {
        n.push({
          value: u.style.paddingRight,
          property: "padding-right",
          el: u
        }), u.style.paddingRight = `${fb(u) + l}px`;
      });
    }
    let s;
    if (r.parentNode instanceof DocumentFragment)
      s = Er(r).body;
    else {
      const l = r.parentElement, c = vo(r);
      s = (l == null ? void 0 : l.nodeName) === "HTML" && c.getComputedStyle(l).overflowY === "scroll" ? l : r;
    }
    n.push({
      value: s.style.overflow,
      property: "overflow",
      el: s
    }, {
      value: s.style.overflowX,
      property: "overflow-x",
      el: s
    }, {
      value: s.style.overflowY,
      property: "overflow-y",
      el: s
    }), s.style.overflow = "hidden";
  }
  return () => {
    n.forEach(({
      value: s,
      el: l,
      property: c
    }) => {
      s ? l.style.setProperty(c, s) : l.style.removeProperty(c);
    });
  };
}
function EE(e) {
  const t = [];
  return [].forEach.call(e.children, (n) => {
    n.getAttribute("aria-hidden") === "true" && t.push(n);
  }), t;
}
class AE {
  constructor() {
    this.modals = [], this.containers = [];
  }
  add(t, n) {
    let r = this.modals.indexOf(t);
    if (r !== -1)
      return r;
    r = this.modals.length, this.modals.push(t), t.modalRef && Qd(t.modalRef, !1);
    const i = EE(n);
    pb(n, t.mount, t.modalRef, i, !0);
    const s = bg(this.containers, (l) => l.container === n);
    return s !== -1 ? (this.containers[s].modals.push(t), r) : (this.containers.push({
      modals: [t],
      container: n,
      restore: null,
      hiddenSiblings: i
    }), r);
  }
  mount(t, n) {
    const r = bg(this.containers, (s) => s.modals.includes(t)), i = this.containers[r];
    i.restore || (i.restore = wE(i, n));
  }
  remove(t, n = !0) {
    const r = this.modals.indexOf(t);
    if (r === -1)
      return r;
    const i = bg(this.containers, (l) => l.modals.includes(t)), s = this.containers[i];
    if (s.modals.splice(s.modals.indexOf(t), 1), this.modals.splice(r, 1), s.modals.length === 0)
      s.restore && s.restore(), t.modalRef && Qd(t.modalRef, n), pb(s.container, t.mount, t.modalRef, s.hiddenSiblings, !1), this.containers.splice(i, 1);
    else {
      const l = s.modals[s.modals.length - 1];
      l.modalRef && Qd(l.modalRef, !1);
    }
    return r;
  }
  isTopModal(t) {
    return this.modals.length > 0 && this.modals[this.modals.length - 1] === t;
  }
}
const kE = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
function RE(e) {
  const t = parseInt(e.getAttribute("tabindex") || "", 10);
  return Number.isNaN(t) ? e.contentEditable === "true" || (e.nodeName === "AUDIO" || e.nodeName === "VIDEO" || e.nodeName === "DETAILS") && e.getAttribute("tabindex") === null ? 0 : e.tabIndex : t;
}
function ME(e) {
  if (e.tagName !== "INPUT" || e.type !== "radio" || !e.name)
    return !1;
  const t = (r) => e.ownerDocument.querySelector(`input[type="radio"]${r}`);
  let n = t(`[name="${e.name}"]:checked`);
  return n || (n = t(`[name="${e.name}"]`)), n !== e;
}
function OE(e) {
  return !(e.disabled || e.tagName === "INPUT" && e.type === "hidden" || ME(e));
}
function NE(e) {
  const t = [], n = [];
  return Array.from(e.querySelectorAll(kE)).forEach((r, i) => {
    const s = RE(r);
    s === -1 || !OE(r) || (s === 0 ? t.push(r) : n.push({
      documentOrder: i,
      tabIndex: s,
      node: r
    }));
  }), n.sort((r, i) => r.tabIndex === i.tabIndex ? r.documentOrder - i.documentOrder : r.tabIndex - i.tabIndex).map((r) => r.node).concat(t);
}
function PE() {
  return !0;
}
function DE(e) {
  const {
    children: t,
    disableAutoFocus: n = !1,
    disableEnforceFocus: r = !1,
    disableRestoreFocus: i = !1,
    getTabbable: s = NE,
    isEnabled: l = PE,
    open: c
  } = e, u = K.useRef(!1), d = K.useRef(null), h = K.useRef(null), p = K.useRef(null), v = K.useRef(null), m = K.useRef(!1), g = K.useRef(null), b = ar(Qc(t), g), x = K.useRef(null);
  K.useEffect(() => {
    !c || !g.current || (m.current = !n);
  }, [n, c]), K.useEffect(() => {
    if (!c || !g.current)
      return;
    const S = Er(g.current);
    return g.current.contains(S.activeElement) || (g.current.hasAttribute("tabIndex") || g.current.setAttribute("tabIndex", "-1"), m.current && g.current.focus()), () => {
      i || (p.current && p.current.focus && (u.current = !0, p.current.focus()), p.current = null);
    };
  }, [c]), K.useEffect(() => {
    if (!c || !g.current)
      return;
    const S = Er(g.current), C = (B) => {
      x.current = B, !(r || !l() || B.key !== "Tab") && S.activeElement === g.current && B.shiftKey && (u.current = !0, h.current && h.current.focus());
    }, E = () => {
      var L, k;
      const B = g.current;
      if (B === null)
        return;
      if (!S.hasFocus() || !l() || u.current) {
        u.current = !1;
        return;
      }
      if (B.contains(S.activeElement) || r && S.activeElement !== d.current && S.activeElement !== h.current)
        return;
      if (S.activeElement !== v.current)
        v.current = null;
      else if (v.current !== null)
        return;
      if (!m.current)
        return;
      let N = [];
      if ((S.activeElement === d.current || S.activeElement === h.current) && (N = s(g.current)), N.length > 0) {
        const F = !!((L = x.current) != null && L.shiftKey && ((k = x.current) == null ? void 0 : k.key) === "Tab"), G = N[0], M = N[N.length - 1];
        typeof G != "string" && typeof M != "string" && (F ? M.focus() : G.focus());
      } else
        B.focus();
    };
    S.addEventListener("focusin", E), S.addEventListener("keydown", C, !0);
    const O = setInterval(() => {
      S.activeElement && S.activeElement.tagName === "BODY" && E();
    }, 50);
    return () => {
      clearInterval(O), S.removeEventListener("focusin", E), S.removeEventListener("keydown", C, !0);
    };
  }, [n, r, i, l, c, s]);
  const w = (S) => {
    p.current === null && (p.current = S.relatedTarget), m.current = !0, v.current = S.target;
    const C = t.props.onFocus;
    C && C(S);
  }, T = (S) => {
    p.current === null && (p.current = S.relatedTarget), m.current = !0;
  };
  return /* @__PURE__ */ W.jsxs(K.Fragment, {
    children: [/* @__PURE__ */ W.jsx("div", {
      tabIndex: c ? 0 : -1,
      onFocus: T,
      ref: d,
      "data-testid": "sentinelStart"
    }), /* @__PURE__ */ K.cloneElement(t, {
      ref: b,
      onFocus: w
    }), /* @__PURE__ */ W.jsx("div", {
      tabIndex: c ? 0 : -1,
      onFocus: T,
      ref: h,
      "data-testid": "sentinelEnd"
    })]
  });
}
function IE(e) {
  return typeof e == "function" ? e() : e;
}
function BE(e) {
  return e ? e.props.hasOwnProperty("in") : !1;
}
const mb = () => {
}, wf = new AE();
function FE(e) {
  const {
    container: t,
    disableEscapeKeyDown: n = !1,
    disableScrollLock: r = !1,
    closeAfterTransition: i = !1,
    onTransitionEnter: s,
    onTransitionExited: l,
    children: c,
    onClose: u,
    open: d,
    rootRef: h
  } = e, p = K.useRef({}), v = K.useRef(null), m = K.useRef(null), g = ar(m, h), [b, x] = K.useState(!d), w = BE(c);
  let T = !0;
  (e["aria-hidden"] === "false" || e["aria-hidden"] === !1) && (T = !1);
  const S = () => Er(v.current), C = () => (p.current.modalRef = m.current, p.current.mount = v.current, p.current), E = () => {
    wf.mount(C(), {
      disableScrollLock: r
    }), m.current && (m.current.scrollTop = 0);
  }, O = Vi(() => {
    const D = IE(t) || S().body;
    wf.add(C(), D), m.current && E();
  }), B = () => wf.isTopModal(C()), N = Vi((D) => {
    v.current = D, D && (d && B() ? E() : m.current && Qd(m.current, T));
  }), L = K.useCallback(() => {
    wf.remove(C(), T);
  }, [T]);
  K.useEffect(() => () => {
    L();
  }, [L]), K.useEffect(() => {
    d ? O() : (!w || !i) && L();
  }, [d, L, w, i, O]);
  const k = (D) => (z) => {
    var H;
    (H = D.onKeyDown) == null || H.call(D, z), !(z.key !== "Escape" || z.which === 229 || // Wait until IME is settled.
    !B()) && (n || (z.stopPropagation(), u && u(z, "escapeKeyDown")));
  }, F = (D) => (z) => {
    var H;
    (H = D.onClick) == null || H.call(D, z), z.target === z.currentTarget && u && u(z, "backdropClick");
  };
  return {
    getRootProps: (D = {}) => {
      const z = Kd(e);
      delete z.onTransitionEnter, delete z.onTransitionExited;
      const H = {
        ...z,
        ...D
      };
      return {
        /*
         * Marking an element with the role presentation indicates to assistive technology
         * that this element should be ignored; it exists to support the web application and
         * is not meant for humans to interact with directly.
         * https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/no-static-element-interactions.md
         */
        role: "presentation",
        ...H,
        onKeyDown: k(H),
        ref: g
      };
    },
    getBackdropProps: (D = {}) => {
      const z = D;
      return {
        "aria-hidden": !0,
        ...z,
        onClick: F(z),
        open: d
      };
    },
    getTransitionProps: () => {
      const D = () => {
        x(!1), s && s();
      }, z = () => {
        x(!0), l && l(), i && L();
      };
      return {
        onEnter: Dv(D, (c == null ? void 0 : c.props.onEnter) ?? mb),
        onExited: Dv(z, (c == null ? void 0 : c.props.onExited) ?? mb)
      };
    },
    rootRef: g,
    portalRef: N,
    isTopModal: B,
    exited: b,
    hasTransition: w
  };
}
function jE(e) {
  return Qe("MuiModal", e);
}
Xe("MuiModal", ["root", "hidden", "backdrop"]);
const LE = (e) => {
  const {
    open: t,
    exited: n,
    classes: r
  } = e;
  return Ze({
    root: ["root", !t && n && "hidden"],
    backdrop: ["backdrop"]
  }, jE, r);
}, zE = he("div", {
  name: "MuiModal",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, !n.open && n.exited && t.hidden];
  }
})(He(({
  theme: e
}) => ({
  position: "fixed",
  zIndex: (e.vars || e).zIndex.modal,
  right: 0,
  bottom: 0,
  top: 0,
  left: 0,
  variants: [{
    props: ({
      ownerState: t
    }) => !t.open && t.exited,
    style: {
      visibility: "hidden"
    }
  }]
}))), UE = he(hE, {
  name: "MuiModal",
  slot: "Backdrop",
  overridesResolver: (e, t) => t.backdrop
})({
  zIndex: -1
}), LS = /* @__PURE__ */ K.forwardRef(function(t, n) {
  const r = nn({
    name: "MuiModal",
    props: t
  }), {
    BackdropComponent: i = UE,
    BackdropProps: s,
    classes: l,
    className: c,
    closeAfterTransition: u = !1,
    children: d,
    container: h,
    component: p,
    components: v = {},
    componentsProps: m = {},
    disableAutoFocus: g = !1,
    disableEnforceFocus: b = !1,
    disableEscapeKeyDown: x = !1,
    disablePortal: w = !1,
    disableRestoreFocus: T = !1,
    disableScrollLock: S = !1,
    hideBackdrop: C = !1,
    keepMounted: E = !1,
    onBackdropClick: O,
    onClose: B,
    onTransitionEnter: N,
    onTransitionExited: L,
    open: k,
    slotProps: F = {},
    slots: G = {},
    // eslint-disable-next-line react/prop-types
    theme: M,
    ...j
  } = r, D = {
    ...r,
    closeAfterTransition: u,
    disableAutoFocus: g,
    disableEnforceFocus: b,
    disableEscapeKeyDown: x,
    disablePortal: w,
    disableRestoreFocus: T,
    disableScrollLock: S,
    hideBackdrop: C,
    keepMounted: E
  }, {
    getRootProps: z,
    getBackdropProps: H,
    getTransitionProps: X,
    portalRef: Y,
    isTopModal: V,
    exited: Z,
    hasTransition: ct
  } = FE({
    ...D,
    rootRef: n
  }), et = {
    ...D,
    exited: Z
  }, rt = LE(et), st = {};
  if (d.props.tabIndex === void 0 && (st.tabIndex = "-1"), ct) {
    const {
      onEnter: Ct,
      onExited: bt
    } = X();
    st.onEnter = Ct, st.onExited = bt;
  }
  const yt = {
    slots: {
      root: v.Root,
      backdrop: v.Backdrop,
      ...G
    },
    slotProps: {
      ...m,
      ...F
    }
  }, [J, tt] = $n("root", {
    ref: n,
    elementType: zE,
    externalForwardedProps: {
      ...yt,
      ...j,
      component: p
    },
    getSlotProps: z,
    ownerState: et,
    className: ge(c, rt == null ? void 0 : rt.root, !et.open && et.exited && (rt == null ? void 0 : rt.hidden))
  }), [ot, Tt] = $n("backdrop", {
    ref: s == null ? void 0 : s.ref,
    elementType: i,
    externalForwardedProps: yt,
    shouldForwardComponentProp: !0,
    additionalProps: s,
    getSlotProps: (Ct) => H({
      ...Ct,
      onClick: (bt) => {
        O && O(bt), Ct != null && Ct.onClick && Ct.onClick(bt);
      }
    }),
    className: ge(s == null ? void 0 : s.className, rt == null ? void 0 : rt.backdrop),
    ownerState: et
  });
  return !E && !k && (!ct || Z) ? null : /* @__PURE__ */ W.jsx(BS, {
    ref: Y,
    container: h,
    disablePortal: w,
    children: /* @__PURE__ */ W.jsxs(J, {
      ...tt,
      children: [!C && i ? /* @__PURE__ */ W.jsx(ot, {
        ...Tt
      }) : null, /* @__PURE__ */ W.jsx(DE, {
        disableEnforceFocus: b,
        disableAutoFocus: g,
        disableRestoreFocus: T,
        isEnabled: V,
        open: k,
        children: /* @__PURE__ */ K.cloneElement(d, st)
      })]
    })
  });
});
function VE(e) {
  return Qe("MuiDivider", e);
}
const gb = Xe("MuiDivider", ["root", "absolute", "fullWidth", "inset", "middle", "flexItem", "light", "vertical", "withChildren", "withChildrenVertical", "textAlignRight", "textAlignLeft", "wrapper", "wrapperVertical"]), GE = (e) => {
  const {
    absolute: t,
    children: n,
    classes: r,
    flexItem: i,
    light: s,
    orientation: l,
    textAlign: c,
    variant: u
  } = e;
  return Ze({
    root: ["root", t && "absolute", u, s && "light", l === "vertical" && "vertical", i && "flexItem", n && "withChildren", n && l === "vertical" && "withChildrenVertical", c === "right" && l !== "vertical" && "textAlignRight", c === "left" && l !== "vertical" && "textAlignLeft"],
    wrapper: ["wrapper", l === "vertical" && "wrapperVertical"]
  }, VE, r);
}, qE = he("div", {
  name: "MuiDivider",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.absolute && t.absolute, t[n.variant], n.light && t.light, n.orientation === "vertical" && t.vertical, n.flexItem && t.flexItem, n.children && t.withChildren, n.children && n.orientation === "vertical" && t.withChildrenVertical, n.textAlign === "right" && n.orientation !== "vertical" && t.textAlignRight, n.textAlign === "left" && n.orientation !== "vertical" && t.textAlignLeft];
  }
})(He(({
  theme: e
}) => ({
  margin: 0,
  // Reset browser default style.
  flexShrink: 0,
  borderWidth: 0,
  borderStyle: "solid",
  borderColor: (e.vars || e).palette.divider,
  borderBottomWidth: "thin",
  variants: [{
    props: {
      absolute: !0
    },
    style: {
      position: "absolute",
      bottom: 0,
      left: 0,
      width: "100%"
    }
  }, {
    props: {
      light: !0
    },
    style: {
      borderColor: e.vars ? `rgba(${e.vars.palette.dividerChannel} / 0.08)` : xn(e.palette.divider, 0.08)
    }
  }, {
    props: {
      variant: "inset"
    },
    style: {
      marginLeft: 72
    }
  }, {
    props: {
      variant: "middle",
      orientation: "horizontal"
    },
    style: {
      marginLeft: e.spacing(2),
      marginRight: e.spacing(2)
    }
  }, {
    props: {
      variant: "middle",
      orientation: "vertical"
    },
    style: {
      marginTop: e.spacing(1),
      marginBottom: e.spacing(1)
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      height: "100%",
      borderBottomWidth: 0,
      borderRightWidth: "thin"
    }
  }, {
    props: {
      flexItem: !0
    },
    style: {
      alignSelf: "stretch",
      height: "auto"
    }
  }, {
    props: ({
      ownerState: t
    }) => !!t.children,
    style: {
      display: "flex",
      textAlign: "center",
      border: 0,
      borderTopStyle: "solid",
      borderLeftStyle: "solid",
      "&::before, &::after": {
        content: '""',
        alignSelf: "center"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.children && t.orientation !== "vertical",
    style: {
      "&::before, &::after": {
        width: "100%",
        borderTop: `thin solid ${(e.vars || e).palette.divider}`,
        borderTopStyle: "inherit"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.orientation === "vertical" && t.children,
    style: {
      flexDirection: "column",
      "&::before, &::after": {
        height: "100%",
        borderLeft: `thin solid ${(e.vars || e).palette.divider}`,
        borderLeftStyle: "inherit"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.textAlign === "right" && t.orientation !== "vertical",
    style: {
      "&::before": {
        width: "90%"
      },
      "&::after": {
        width: "10%"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.textAlign === "left" && t.orientation !== "vertical",
    style: {
      "&::before": {
        width: "10%"
      },
      "&::after": {
        width: "90%"
      }
    }
  }]
}))), HE = he("span", {
  name: "MuiDivider",
  slot: "Wrapper",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.wrapper, n.orientation === "vertical" && t.wrapperVertical];
  }
})(He(({
  theme: e
}) => ({
  display: "inline-block",
  paddingLeft: `calc(${e.spacing(1)} * 1.2)`,
  paddingRight: `calc(${e.spacing(1)} * 1.2)`,
  whiteSpace: "nowrap",
  variants: [{
    props: {
      orientation: "vertical"
    },
    style: {
      paddingTop: `calc(${e.spacing(1)} * 1.2)`,
      paddingBottom: `calc(${e.spacing(1)} * 1.2)`
    }
  }]
}))), f0 = /* @__PURE__ */ K.forwardRef(function(t, n) {
  const r = nn({
    props: t,
    name: "MuiDivider"
  }), {
    absolute: i = !1,
    children: s,
    className: l,
    orientation: c = "horizontal",
    component: u = s || c === "vertical" ? "div" : "hr",
    flexItem: d = !1,
    light: h = !1,
    role: p = u !== "hr" ? "separator" : void 0,
    textAlign: v = "center",
    variant: m = "fullWidth",
    ...g
  } = r, b = {
    ...r,
    absolute: i,
    component: u,
    flexItem: d,
    light: h,
    orientation: c,
    role: p,
    textAlign: v,
    variant: m
  }, x = GE(b);
  return /* @__PURE__ */ W.jsx(qE, {
    as: u,
    className: ge(x.root, l),
    role: p,
    ref: n,
    ownerState: b,
    "aria-orientation": p === "separator" && (u !== "hr" || c === "vertical") ? c : void 0,
    ...g,
    children: s ? /* @__PURE__ */ W.jsx(HE, {
      className: x.wrapper,
      ownerState: b,
      children: s
    }) : null
  });
});
f0 && (f0.muiSkipListHighlight = !0);
const WE = (e) => {
  const {
    classes: t,
    disableUnderline: n,
    startAdornment: r,
    endAdornment: i,
    size: s,
    hiddenLabel: l,
    multiline: c
  } = e, u = {
    root: ["root", !n && "underline", r && "adornedStart", i && "adornedEnd", s === "small" && `size${pe(s)}`, l && "hiddenLabel", c && "multiline"],
    input: ["input"]
  }, d = Ze(u, sE, t);
  return {
    ...t,
    // forward classes to the InputBase
    ...d
  };
}, $E = he($p, {
  shouldForwardProp: (e) => $i(e) || e === "classes",
  name: "MuiFilledInput",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [...Hp(e, t), !n.disableUnderline && t.underline];
  }
})(He(({
  theme: e
}) => {
  const t = e.palette.mode === "light", n = t ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)", r = t ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)", i = t ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)", s = t ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
  return {
    position: "relative",
    backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : r,
    borderTopLeftRadius: (e.vars || e).shape.borderRadius,
    borderTopRightRadius: (e.vars || e).shape.borderRadius,
    transition: e.transitions.create("background-color", {
      duration: e.transitions.duration.shorter,
      easing: e.transitions.easing.easeOut
    }),
    "&:hover": {
      backgroundColor: e.vars ? e.vars.palette.FilledInput.hoverBg : i,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : r
      }
    },
    [`&.${Ya.focused}`]: {
      backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : r
    },
    [`&.${Ya.disabled}`]: {
      backgroundColor: e.vars ? e.vars.palette.FilledInput.disabledBg : s
    },
    variants: [{
      props: ({
        ownerState: l
      }) => !l.disableUnderline,
      style: {
        "&::after": {
          left: 0,
          bottom: 0,
          content: '""',
          position: "absolute",
          right: 0,
          transform: "scaleX(0)",
          transition: e.transitions.create("transform", {
            duration: e.transitions.duration.shorter,
            easing: e.transitions.easing.easeOut
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&.${Ya.focused}:after`]: {
          // translateX(0) is a workaround for Safari transform scale bug
          // See https://github.com/mui/material-ui/issues/31766
          transform: "scaleX(1) translateX(0)"
        },
        [`&.${Ya.error}`]: {
          "&::before, &::after": {
            borderBottomColor: (e.vars || e).palette.error.main
          }
        },
        "&::before": {
          borderBottom: `1px solid ${e.vars ? `rgba(${e.vars.palette.common.onBackgroundChannel} / ${e.vars.opacity.inputUnderline})` : n}`,
          left: 0,
          bottom: 0,
          content: '"\\00a0"',
          position: "absolute",
          right: 0,
          transition: e.transitions.create("border-bottom-color", {
            duration: e.transitions.duration.shorter
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&:hover:not(.${Ya.disabled}, .${Ya.error}):before`]: {
          borderBottom: `1px solid ${(e.vars || e).palette.text.primary}`
        },
        [`&.${Ya.disabled}:before`]: {
          borderBottomStyle: "dotted"
        }
      }
    }, ...Object.entries(e.palette).filter(Ei()).map(([l]) => {
      var c;
      return {
        props: {
          disableUnderline: !1,
          color: l
        },
        style: {
          "&::after": {
            borderBottom: `2px solid ${(c = (e.vars || e).palette[l]) == null ? void 0 : c.main}`
          }
        }
      };
    }), {
      props: ({
        ownerState: l
      }) => l.startAdornment,
      style: {
        paddingLeft: 12
      }
    }, {
      props: ({
        ownerState: l
      }) => l.endAdornment,
      style: {
        paddingRight: 12
      }
    }, {
      props: ({
        ownerState: l
      }) => l.multiline,
      style: {
        padding: "25px 12px 8px"
      }
    }, {
      props: ({
        ownerState: l,
        size: c
      }) => l.multiline && c === "small",
      style: {
        paddingTop: 21,
        paddingBottom: 4
      }
    }, {
      props: ({
        ownerState: l
      }) => l.multiline && l.hiddenLabel,
      style: {
        paddingTop: 16,
        paddingBottom: 17
      }
    }, {
      props: ({
        ownerState: l
      }) => l.multiline && l.hiddenLabel && l.size === "small",
      style: {
        paddingTop: 8,
        paddingBottom: 9
      }
    }]
  };
})), KE = he(Kp, {
  name: "MuiFilledInput",
  slot: "Input",
  overridesResolver: Wp
})(He(({
  theme: e
}) => ({
  paddingTop: 25,
  paddingRight: 12,
  paddingBottom: 8,
  paddingLeft: 12,
  ...!e.vars && {
    "&:-webkit-autofill": {
      WebkitBoxShadow: e.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
      WebkitTextFillColor: e.palette.mode === "light" ? null : "#fff",
      caretColor: e.palette.mode === "light" ? null : "#fff",
      borderTopLeftRadius: "inherit",
      borderTopRightRadius: "inherit"
    }
  },
  ...e.vars && {
    "&:-webkit-autofill": {
      borderTopLeftRadius: "inherit",
      borderTopRightRadius: "inherit"
    },
    [e.getColorSchemeSelector("dark")]: {
      "&:-webkit-autofill": {
        WebkitBoxShadow: "0 0 0 100px #266798 inset",
        WebkitTextFillColor: "#fff",
        caretColor: "#fff"
      }
    }
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      paddingTop: 21,
      paddingBottom: 4
    }
  }, {
    props: ({
      ownerState: t
    }) => t.hiddenLabel,
    style: {
      paddingTop: 16,
      paddingBottom: 17
    }
  }, {
    props: ({
      ownerState: t
    }) => t.startAdornment,
    style: {
      paddingLeft: 0
    }
  }, {
    props: ({
      ownerState: t
    }) => t.endAdornment,
    style: {
      paddingRight: 0
    }
  }, {
    props: ({
      ownerState: t
    }) => t.hiddenLabel && t.size === "small",
    style: {
      paddingTop: 8,
      paddingBottom: 9
    }
  }, {
    props: ({
      ownerState: t
    }) => t.multiline,
    style: {
      paddingTop: 0,
      paddingBottom: 0,
      paddingLeft: 0,
      paddingRight: 0
    }
  }]
}))), oy = /* @__PURE__ */ K.forwardRef(function(t, n) {
  const r = nn({
    props: t,
    name: "MuiFilledInput"
  }), {
    disableUnderline: i = !1,
    components: s = {},
    componentsProps: l,
    fullWidth: c = !1,
    hiddenLabel: u,
    // declare here to prevent spreading to DOM
    inputComponent: d = "input",
    multiline: h = !1,
    slotProps: p,
    slots: v = {},
    type: m = "text",
    ...g
  } = r, b = {
    ...r,
    disableUnderline: i,
    fullWidth: c,
    inputComponent: d,
    multiline: h,
    type: m
  }, x = WE(r), w = {
    root: {
      ownerState: b
    },
    input: {
      ownerState: b
    }
  }, T = p ?? l ? Fr(w, p ?? l) : w, S = v.root ?? s.Root ?? $E, C = v.input ?? s.Input ?? KE;
  return /* @__PURE__ */ W.jsx(sy, {
    slots: {
      root: S,
      input: C
    },
    slotProps: T,
    fullWidth: c,
    inputComponent: d,
    multiline: h,
    ref: n,
    type: m,
    ...g,
    classes: x
  });
});
oy.muiName = "Input";
function YE(e) {
  return Qe("MuiFormControl", e);
}
Xe("MuiFormControl", ["root", "marginNone", "marginNormal", "marginDense", "fullWidth", "disabled"]);
const XE = (e) => {
  const {
    classes: t,
    margin: n,
    fullWidth: r
  } = e, i = {
    root: ["root", n !== "none" && `margin${pe(n)}`, r && "fullWidth"]
  };
  return Ze(i, YE, t);
}, QE = he("div", {
  name: "MuiFormControl",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, t[`margin${pe(n.margin)}`], n.fullWidth && t.fullWidth];
  }
})({
  display: "inline-flex",
  flexDirection: "column",
  position: "relative",
  // Reset fieldset default style.
  minWidth: 0,
  padding: 0,
  margin: 0,
  border: 0,
  verticalAlign: "top",
  // Fix alignment issue on Safari.
  variants: [{
    props: {
      margin: "normal"
    },
    style: {
      marginTop: 16,
      marginBottom: 8
    }
  }, {
    props: {
      margin: "dense"
    },
    style: {
      marginTop: 8,
      marginBottom: 4
    }
  }, {
    props: {
      fullWidth: !0
    },
    style: {
      width: "100%"
    }
  }]
}), ZE = /* @__PURE__ */ K.forwardRef(function(t, n) {
  const r = nn({
    props: t,
    name: "MuiFormControl"
  }), {
    children: i,
    className: s,
    color: l = "primary",
    component: c = "div",
    disabled: u = !1,
    error: d = !1,
    focused: h,
    fullWidth: p = !1,
    hiddenLabel: v = !1,
    margin: m = "none",
    required: g = !1,
    size: b = "medium",
    variant: x = "outlined",
    ...w
  } = r, T = {
    ...r,
    color: l,
    component: c,
    disabled: u,
    error: d,
    fullWidth: p,
    hiddenLabel: v,
    margin: m,
    required: g,
    size: b,
    variant: x
  }, S = XE(T), [C, E] = K.useState(() => {
    let D = !1;
    return i && K.Children.forEach(i, (z) => {
      if (!mg(z, ["Input", "Select"]))
        return;
      const H = mg(z, ["Select"]) ? z.props.input : z;
      H && tE(H.props) && (D = !0);
    }), D;
  }), [O, B] = K.useState(() => {
    let D = !1;
    return i && K.Children.forEach(i, (z) => {
      mg(z, ["Input", "Select"]) && (sp(z.props, !0) || sp(z.props.inputProps, !0)) && (D = !0);
    }), D;
  }), [N, L] = K.useState(!1);
  u && N && L(!1);
  const k = h !== void 0 && !u ? h : N;
  let F;
  K.useRef(!1);
  const G = K.useCallback(() => {
    B(!0);
  }, []), M = K.useCallback(() => {
    B(!1);
  }, []), j = K.useMemo(() => ({
    adornedStart: C,
    setAdornedStart: E,
    color: l,
    disabled: u,
    error: d,
    filled: O,
    focused: k,
    fullWidth: p,
    hiddenLabel: v,
    size: b,
    onBlur: () => {
      L(!1);
    },
    onFocus: () => {
      L(!0);
    },
    onEmpty: M,
    onFilled: G,
    registerEffect: F,
    required: g,
    variant: x
  }), [C, l, u, d, O, k, p, v, F, M, G, g, b, x]);
  return /* @__PURE__ */ W.jsx(iy.Provider, {
    value: j,
    children: /* @__PURE__ */ W.jsx(QE, {
      as: c,
      ownerState: T,
      className: ge(S.root, s),
      ref: n,
      ...w,
      children: i
    })
  });
});
function JE(e) {
  return Qe("MuiFormHelperText", e);
}
const yb = Xe("MuiFormHelperText", ["root", "error", "disabled", "sizeSmall", "sizeMedium", "contained", "focused", "filled", "required"]);
var vb;
const t9 = (e) => {
  const {
    classes: t,
    contained: n,
    size: r,
    disabled: i,
    error: s,
    filled: l,
    focused: c,
    required: u
  } = e, d = {
    root: ["root", i && "disabled", s && "error", r && `size${pe(r)}`, n && "contained", c && "focused", l && "filled", u && "required"]
  };
  return Ze(d, JE, t);
}, e9 = he("p", {
  name: "MuiFormHelperText",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.size && t[`size${pe(n.size)}`], n.contained && t.contained, n.filled && t.filled];
  }
})(He(({
  theme: e
}) => ({
  color: (e.vars || e).palette.text.secondary,
  ...e.typography.caption,
  textAlign: "left",
  marginTop: 3,
  marginRight: 0,
  marginBottom: 0,
  marginLeft: 0,
  [`&.${yb.disabled}`]: {
    color: (e.vars || e).palette.text.disabled
  },
  [`&.${yb.error}`]: {
    color: (e.vars || e).palette.error.main
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      marginTop: 4
    }
  }, {
    props: ({
      ownerState: t
    }) => t.contained,
    style: {
      marginLeft: 14,
      marginRight: 14
    }
  }]
}))), n9 = /* @__PURE__ */ K.forwardRef(function(t, n) {
  const r = nn({
    props: t,
    name: "MuiFormHelperText"
  }), {
    children: i,
    className: s,
    component: l = "p",
    disabled: c,
    error: u,
    filled: d,
    focused: h,
    margin: p,
    required: v,
    variant: m,
    ...g
  } = r, b = Jc(), x = Zc({
    props: r,
    muiFormControl: b,
    states: ["variant", "size", "disabled", "error", "filled", "focused", "required"]
  }), w = {
    ...r,
    component: l,
    contained: x.variant === "filled" || x.variant === "outlined",
    variant: x.variant,
    size: x.size,
    disabled: x.disabled,
    error: x.error,
    filled: x.filled,
    focused: x.focused,
    required: x.required
  };
  delete w.ownerState;
  const T = t9(w);
  return /* @__PURE__ */ W.jsx(e9, {
    as: l,
    className: ge(T.root, s),
    ref: n,
    ...g,
    ownerState: w,
    children: i === " " ? (
      // notranslate needed while Google Translate will not fix zero-width space issue
      vb || (vb = /* @__PURE__ */ W.jsx("span", {
        className: "notranslate",
        "aria-hidden": !0,
        children: ""
      }))
    ) : i
  });
});
function r9(e) {
  return Qe("MuiFormLabel", e);
}
const Zd = Xe("MuiFormLabel", ["root", "colorSecondary", "focused", "disabled", "error", "filled", "required", "asterisk"]), i9 = (e) => {
  const {
    classes: t,
    color: n,
    focused: r,
    disabled: i,
    error: s,
    filled: l,
    required: c
  } = e, u = {
    root: ["root", `color${pe(n)}`, i && "disabled", s && "error", l && "filled", r && "focused", c && "required"],
    asterisk: ["asterisk", s && "error"]
  };
  return Ze(u, r9, t);
}, s9 = he("label", {
  name: "MuiFormLabel",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.color === "secondary" && t.colorSecondary, n.filled && t.filled];
  }
})(He(({
  theme: e
}) => ({
  color: (e.vars || e).palette.text.secondary,
  ...e.typography.body1,
  lineHeight: "1.4375em",
  padding: 0,
  position: "relative",
  variants: [...Object.entries(e.palette).filter(Ei()).map(([t]) => ({
    props: {
      color: t
    },
    style: {
      [`&.${Zd.focused}`]: {
        color: (e.vars || e).palette[t].main
      }
    }
  })), {
    props: {},
    style: {
      [`&.${Zd.disabled}`]: {
        color: (e.vars || e).palette.text.disabled
      },
      [`&.${Zd.error}`]: {
        color: (e.vars || e).palette.error.main
      }
    }
  }]
}))), o9 = he("span", {
  name: "MuiFormLabel",
  slot: "Asterisk",
  overridesResolver: (e, t) => t.asterisk
})(He(({
  theme: e
}) => ({
  [`&.${Zd.error}`]: {
    color: (e.vars || e).palette.error.main
  }
}))), a9 = /* @__PURE__ */ K.forwardRef(function(t, n) {
  const r = nn({
    props: t,
    name: "MuiFormLabel"
  }), {
    children: i,
    className: s,
    color: l,
    component: c = "label",
    disabled: u,
    error: d,
    filled: h,
    focused: p,
    required: v,
    ...m
  } = r, g = Jc(), b = Zc({
    props: r,
    muiFormControl: g,
    states: ["color", "required", "focused", "disabled", "error", "filled"]
  }), x = {
    ...r,
    color: b.color || "primary",
    component: c,
    disabled: b.disabled,
    error: b.error,
    filled: b.filled,
    focused: b.focused,
    required: b.required
  }, w = i9(x);
  return /* @__PURE__ */ W.jsxs(s9, {
    as: c,
    ownerState: x,
    className: ge(w.root, s),
    ref: n,
    ...m,
    children: [i, b.required && /* @__PURE__ */ W.jsxs(o9, {
      ownerState: x,
      "aria-hidden": !0,
      className: w.asterisk,
      children: ["", "*"]
    })]
  });
});
function p0(e) {
  return `scale(${e}, ${e ** 2})`;
}
const l9 = {
  entering: {
    opacity: 1,
    transform: p0(1)
  },
  entered: {
    opacity: 1,
    transform: "none"
  }
}, _g = typeof navigator < "u" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent), op = /* @__PURE__ */ K.forwardRef(function(t, n) {
  const {
    addEndListener: r,
    appear: i = !0,
    children: s,
    easing: l,
    in: c,
    onEnter: u,
    onEntered: d,
    onEntering: h,
    onExit: p,
    onExited: v,
    onExiting: m,
    style: g,
    timeout: b = "auto",
    // eslint-disable-next-line react/prop-types
    TransitionComponent: x = Fs,
    ...w
  } = t, T = Ec(), S = K.useRef(), C = Up(), E = K.useRef(null), O = ar(E, Qc(s), n), B = (D) => (z) => {
    if (D) {
      const H = E.current;
      z === void 0 ? D(H) : D(H, z);
    }
  }, N = B(h), L = B((D, z) => {
    wS(D);
    const {
      duration: H,
      delay: X,
      easing: Y
    } = np({
      style: g,
      timeout: b,
      easing: l
    }, {
      mode: "enter"
    });
    let V;
    b === "auto" ? (V = C.transitions.getAutoHeightDuration(D.clientHeight), S.current = V) : V = H, D.style.transition = [C.transitions.create("opacity", {
      duration: V,
      delay: X
    }), C.transitions.create("transform", {
      duration: _g ? V : V * 0.666,
      delay: X,
      easing: Y
    })].join(","), u && u(D, z);
  }), k = B(d), F = B(m), G = B((D) => {
    const {
      duration: z,
      delay: H,
      easing: X
    } = np({
      style: g,
      timeout: b,
      easing: l
    }, {
      mode: "exit"
    });
    let Y;
    b === "auto" ? (Y = C.transitions.getAutoHeightDuration(D.clientHeight), S.current = Y) : Y = z, D.style.transition = [C.transitions.create("opacity", {
      duration: Y,
      delay: H
    }), C.transitions.create("transform", {
      duration: _g ? Y : Y * 0.666,
      delay: _g ? H : H || Y * 0.333,
      easing: X
    })].join(","), D.style.opacity = 0, D.style.transform = p0(0.75), p && p(D);
  }), M = B(v), j = (D) => {
    b === "auto" && T.start(S.current || 0, D), r && r(E.current, D);
  };
  return /* @__PURE__ */ W.jsx(x, {
    appear: i,
    in: c,
    nodeRef: E,
    onEnter: L,
    onEntered: k,
    onEntering: N,
    onExit: G,
    onExited: M,
    onExiting: F,
    addEndListener: j,
    timeout: b === "auto" ? null : b,
    ...w,
    children: (D, {
      ownerState: z,
      ...H
    }) => /* @__PURE__ */ K.cloneElement(s, {
      style: {
        opacity: 0,
        transform: p0(0.75),
        visibility: D === "exited" && !c ? "hidden" : void 0,
        ...l9[D],
        ...g,
        ...s.props.style
      },
      ref: O,
      ...H
    })
  });
});
op && (op.muiSupportAuto = !0);
const c9 = (e) => {
  const {
    classes: t,
    disableUnderline: n
  } = e, i = Ze({
    root: ["root", !n && "underline"],
    input: ["input"]
  }, rE, t);
  return {
    ...t,
    // forward classes to the InputBase
    ...i
  };
}, u9 = he($p, {
  shouldForwardProp: (e) => $i(e) || e === "classes",
  name: "MuiInput",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [...Hp(e, t), !n.disableUnderline && t.underline];
  }
})(He(({
  theme: e
}) => {
  let n = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
  return e.vars && (n = `rgba(${e.vars.palette.common.onBackgroundChannel} / ${e.vars.opacity.inputUnderline})`), {
    position: "relative",
    variants: [{
      props: ({
        ownerState: r
      }) => r.formControl,
      style: {
        "label + &": {
          marginTop: 16
        }
      }
    }, {
      props: ({
        ownerState: r
      }) => !r.disableUnderline,
      style: {
        "&::after": {
          left: 0,
          bottom: 0,
          content: '""',
          position: "absolute",
          right: 0,
          transform: "scaleX(0)",
          transition: e.transitions.create("transform", {
            duration: e.transitions.duration.shorter,
            easing: e.transitions.easing.easeOut
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&.${Hu.focused}:after`]: {
          // translateX(0) is a workaround for Safari transform scale bug
          // See https://github.com/mui/material-ui/issues/31766
          transform: "scaleX(1) translateX(0)"
        },
        [`&.${Hu.error}`]: {
          "&::before, &::after": {
            borderBottomColor: (e.vars || e).palette.error.main
          }
        },
        "&::before": {
          borderBottom: `1px solid ${n}`,
          left: 0,
          bottom: 0,
          content: '"\\00a0"',
          position: "absolute",
          right: 0,
          transition: e.transitions.create("border-bottom-color", {
            duration: e.transitions.duration.shorter
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&:hover:not(.${Hu.disabled}, .${Hu.error}):before`]: {
          borderBottom: `2px solid ${(e.vars || e).palette.text.primary}`,
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            borderBottom: `1px solid ${n}`
          }
        },
        [`&.${Hu.disabled}:before`]: {
          borderBottomStyle: "dotted"
        }
      }
    }, ...Object.entries(e.palette).filter(Ei()).map(([r]) => ({
      props: {
        color: r,
        disableUnderline: !1
      },
      style: {
        "&::after": {
          borderBottom: `2px solid ${(e.vars || e).palette[r].main}`
        }
      }
    }))]
  };
})), d9 = he(Kp, {
  name: "MuiInput",
  slot: "Input",
  overridesResolver: Wp
})({}), ay = /* @__PURE__ */ K.forwardRef(function(t, n) {
  const r = nn({
    props: t,
    name: "MuiInput"
  }), {
    disableUnderline: i = !1,
    components: s = {},
    componentsProps: l,
    fullWidth: c = !1,
    inputComponent: u = "input",
    multiline: d = !1,
    slotProps: h,
    slots: p = {},
    type: v = "text",
    ...m
  } = r, g = c9(r), x = {
    root: {
      ownerState: {
        disableUnderline: i
      }
    }
  }, w = h ?? l ? Fr(h ?? l, x) : x, T = p.root ?? s.Root ?? u9, S = p.input ?? s.Input ?? d9;
  return /* @__PURE__ */ W.jsx(sy, {
    slots: {
      root: T,
      input: S
    },
    slotProps: w,
    fullWidth: c,
    inputComponent: u,
    multiline: d,
    ref: n,
    type: v,
    ...m,
    classes: g
  });
});
ay.muiName = "Input";
function h9(e) {
  return Qe("MuiInputLabel", e);
}
Xe("MuiInputLabel", ["root", "focused", "disabled", "error", "required", "asterisk", "formControl", "sizeSmall", "shrink", "animated", "standard", "filled", "outlined"]);
const f9 = (e) => {
  const {
    classes: t,
    formControl: n,
    size: r,
    shrink: i,
    disableAnimation: s,
    variant: l,
    required: c
  } = e, u = {
    root: ["root", n && "formControl", !s && "animated", i && "shrink", r && r !== "normal" && `size${pe(r)}`, l],
    asterisk: [c && "asterisk"]
  }, d = Ze(u, h9, t);
  return {
    ...t,
    // forward the focused, disabled, etc. classes to the FormLabel
    ...d
  };
}, p9 = he(a9, {
  shouldForwardProp: (e) => $i(e) || e === "classes",
  name: "MuiInputLabel",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [{
      [`& .${Zd.asterisk}`]: t.asterisk
    }, t.root, n.formControl && t.formControl, n.size === "small" && t.sizeSmall, n.shrink && t.shrink, !n.disableAnimation && t.animated, n.focused && t.focused, t[n.variant]];
  }
})(He(({
  theme: e
}) => ({
  display: "block",
  transformOrigin: "top left",
  whiteSpace: "nowrap",
  overflow: "hidden",
  textOverflow: "ellipsis",
  maxWidth: "100%",
  variants: [{
    props: ({
      ownerState: t
    }) => t.formControl,
    style: {
      position: "absolute",
      left: 0,
      top: 0,
      // slight alteration to spec spacing to match visual spec result
      transform: "translate(0, 20px) scale(1)"
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      // Compensation for the `Input.inputSizeSmall` style.
      transform: "translate(0, 17px) scale(1)"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.shrink,
    style: {
      transform: "translate(0, -1.5px) scale(0.75)",
      transformOrigin: "top left",
      maxWidth: "133%"
    }
  }, {
    props: ({
      ownerState: t
    }) => !t.disableAnimation,
    style: {
      transition: e.transitions.create(["color", "transform", "max-width"], {
        duration: e.transitions.duration.shorter,
        easing: e.transitions.easing.easeOut
      })
    }
  }, {
    props: {
      variant: "filled"
    },
    style: {
      // Chrome's autofill feature gives the input field a yellow background.
      // Since the input field is behind the label in the HTML tree,
      // the input field is drawn last and hides the label with an opaque background color.
      // zIndex: 1 will raise the label above opaque background-colors of input.
      zIndex: 1,
      pointerEvents: "none",
      transform: "translate(12px, 16px) scale(1)",
      maxWidth: "calc(100% - 24px)"
    }
  }, {
    props: {
      variant: "filled",
      size: "small"
    },
    style: {
      transform: "translate(12px, 13px) scale(1)"
    }
  }, {
    props: ({
      variant: t,
      ownerState: n
    }) => t === "filled" && n.shrink,
    style: {
      userSelect: "none",
      pointerEvents: "auto",
      transform: "translate(12px, 7px) scale(0.75)",
      maxWidth: "calc(133% - 24px)"
    }
  }, {
    props: ({
      variant: t,
      ownerState: n,
      size: r
    }) => t === "filled" && n.shrink && r === "small",
    style: {
      transform: "translate(12px, 4px) scale(0.75)"
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      // see comment above on filled.zIndex
      zIndex: 1,
      pointerEvents: "none",
      transform: "translate(14px, 16px) scale(1)",
      maxWidth: "calc(100% - 24px)"
    }
  }, {
    props: {
      variant: "outlined",
      size: "small"
    },
    style: {
      transform: "translate(14px, 9px) scale(1)"
    }
  }, {
    props: ({
      variant: t,
      ownerState: n
    }) => t === "outlined" && n.shrink,
    style: {
      userSelect: "none",
      pointerEvents: "auto",
      // Theoretically, we should have (8+5)*2/0.75 = 34px
      // but it feels a better when it bleeds a bit on the left, so 32px.
      maxWidth: "calc(133% - 32px)",
      transform: "translate(14px, -9px) scale(0.75)"
    }
  }]
}))), m9 = /* @__PURE__ */ K.forwardRef(function(t, n) {
  const r = nn({
    name: "MuiInputLabel",
    props: t
  }), {
    disableAnimation: i = !1,
    margin: s,
    shrink: l,
    variant: c,
    className: u,
    ...d
  } = r, h = Jc();
  let p = l;
  typeof p > "u" && h && (p = h.filled || h.focused || h.adornedStart);
  const v = Zc({
    props: r,
    muiFormControl: h,
    states: ["size", "variant", "required", "focused"]
  }), m = {
    ...r,
    disableAnimation: i,
    formControl: h,
    shrink: p,
    size: v.size,
    variant: v.variant,
    required: v.required,
    focused: v.focused
  }, g = f9(m);
  return /* @__PURE__ */ W.jsx(p9, {
    "data-shrink": p,
    ref: n,
    className: ge(g.root, u),
    ...d,
    ownerState: m,
    classes: g
  });
}), lh = /* @__PURE__ */ K.createContext({});
function g9(e) {
  return Qe("MuiList", e);
}
Xe("MuiList", ["root", "padding", "dense", "subheader"]);
const y9 = (e) => {
  const {
    classes: t,
    disablePadding: n,
    dense: r,
    subheader: i
  } = e;
  return Ze({
    root: ["root", !n && "padding", r && "dense", i && "subheader"]
  }, g9, t);
}, v9 = he("ul", {
  name: "MuiList",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, !n.disablePadding && t.padding, n.dense && t.dense, n.subheader && t.subheader];
  }
})({
  listStyle: "none",
  margin: 0,
  padding: 0,
  position: "relative",
  variants: [{
    props: ({
      ownerState: e
    }) => !e.disablePadding,
    style: {
      paddingTop: 8,
      paddingBottom: 8
    }
  }, {
    props: ({
      ownerState: e
    }) => e.subheader,
    style: {
      paddingTop: 0
    }
  }]
}), b9 = /* @__PURE__ */ K.forwardRef(function(t, n) {
  const r = nn({
    props: t,
    name: "MuiList"
  }), {
    children: i,
    className: s,
    component: l = "ul",
    dense: c = !1,
    disablePadding: u = !1,
    subheader: d,
    ...h
  } = r, p = K.useMemo(() => ({
    dense: c
  }), [c]), v = {
    ...r,
    component: l,
    dense: c,
    disablePadding: u
  }, m = y9(v);
  return /* @__PURE__ */ W.jsx(lh.Provider, {
    value: p,
    children: /* @__PURE__ */ W.jsxs(v9, {
      as: l,
      className: ge(m.root, s),
      ref: n,
      ownerState: v,
      ...h,
      children: [d, i]
    })
  });
});
function _9(e) {
  return Qe("MuiListItemIcon", e);
}
const bb = Xe("MuiListItemIcon", ["root", "alignItemsFlexStart"]), S9 = (e) => {
  const {
    alignItems: t,
    classes: n
  } = e;
  return Ze({
    root: ["root", t === "flex-start" && "alignItemsFlexStart"]
  }, _9, n);
}, x9 = he("div", {
  name: "MuiListItemIcon",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.alignItems === "flex-start" && t.alignItemsFlexStart];
  }
})(He(({
  theme: e
}) => ({
  minWidth: 56,
  color: (e.vars || e).palette.action.active,
  flexShrink: 0,
  display: "inline-flex",
  variants: [{
    props: {
      alignItems: "flex-start"
    },
    style: {
      marginTop: 8
    }
  }]
}))), Sg = /* @__PURE__ */ K.forwardRef(function(t, n) {
  const r = nn({
    props: t,
    name: "MuiListItemIcon"
  }), {
    className: i,
    ...s
  } = r, l = K.useContext(lh), c = {
    ...r,
    alignItems: l.alignItems
  }, u = S9(c);
  return /* @__PURE__ */ W.jsx(x9, {
    className: ge(u.root, i),
    ownerState: c,
    ref: n,
    ...s
  });
});
function T9(e) {
  return Qe("MuiListItemText", e);
}
const Ac = Xe("MuiListItemText", ["root", "multiline", "dense", "inset", "primary", "secondary"]), C9 = (e) => {
  const {
    classes: t,
    inset: n,
    primary: r,
    secondary: i,
    dense: s
  } = e;
  return Ze({
    root: ["root", n && "inset", s && "dense", r && i && "multiline"],
    primary: ["primary"],
    secondary: ["secondary"]
  }, T9, t);
}, w9 = he("div", {
  name: "MuiListItemText",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [{
      [`& .${Ac.primary}`]: t.primary
    }, {
      [`& .${Ac.secondary}`]: t.secondary
    }, t.root, n.inset && t.inset, n.primary && n.secondary && t.multiline, n.dense && t.dense];
  }
})({
  flex: "1 1 auto",
  minWidth: 0,
  marginTop: 4,
  marginBottom: 4,
  [`.${Qv.root}:where(& .${Ac.primary})`]: {
    display: "block"
  },
  [`.${Qv.root}:where(& .${Ac.secondary})`]: {
    display: "block"
  },
  variants: [{
    props: ({
      ownerState: e
    }) => e.primary && e.secondary,
    style: {
      marginTop: 6,
      marginBottom: 6
    }
  }, {
    props: ({
      ownerState: e
    }) => e.inset,
    style: {
      paddingLeft: 56
    }
  }]
}), xg = /* @__PURE__ */ K.forwardRef(function(t, n) {
  const r = nn({
    props: t,
    name: "MuiListItemText"
  }), {
    children: i,
    className: s,
    disableTypography: l = !1,
    inset: c = !1,
    primary: u,
    primaryTypographyProps: d,
    secondary: h,
    secondaryTypographyProps: p,
    slots: v = {},
    slotProps: m = {},
    ...g
  } = r, {
    dense: b
  } = K.useContext(lh);
  let x = u ?? i, w = h;
  const T = {
    ...r,
    disableTypography: l,
    inset: c,
    primary: !!x,
    secondary: !!w,
    dense: b
  }, S = C9(T), C = {
    slots: v,
    slotProps: {
      primary: d,
      secondary: p,
      ...m
    }
  }, [E, O] = $n("root", {
    className: ge(S.root, s),
    elementType: w9,
    externalForwardedProps: {
      ...C,
      ...g
    },
    ownerState: T,
    ref: n
  }), [B, N] = $n("primary", {
    className: S.primary,
    elementType: Hr,
    externalForwardedProps: C,
    ownerState: T
  }), [L, k] = $n("secondary", {
    className: S.secondary,
    elementType: Hr,
    externalForwardedProps: C,
    ownerState: T
  });
  return x != null && x.type !== Hr && !l && (x = /* @__PURE__ */ W.jsx(B, {
    variant: b ? "body2" : "body1",
    component: N != null && N.variant ? void 0 : "span",
    ...N,
    children: x
  })), w != null && w.type !== Hr && !l && (w = /* @__PURE__ */ W.jsx(L, {
    variant: "body2",
    color: "textSecondary",
    ...k,
    children: w
  })), /* @__PURE__ */ W.jsxs(E, {
    ...O,
    children: [x, w]
  });
});
function Tg(e, t, n) {
  return e === t ? e.firstChild : t && t.nextElementSibling ? t.nextElementSibling : n ? null : e.firstChild;
}
function _b(e, t, n) {
  return e === t ? n ? e.firstChild : e.lastChild : t && t.previousElementSibling ? t.previousElementSibling : n ? null : e.lastChild;
}
function zS(e, t) {
  if (t === void 0)
    return !0;
  let n = e.innerText;
  return n === void 0 && (n = e.textContent), n = n.trim().toLowerCase(), n.length === 0 ? !1 : t.repeating ? n[0] === t.keys[0] : n.startsWith(t.keys.join(""));
}
function Wu(e, t, n, r, i, s) {
  let l = !1, c = i(e, t, t ? n : !1);
  for (; c; ) {
    if (c === e.firstChild) {
      if (l)
        return !1;
      l = !0;
    }
    const u = r ? !1 : c.disabled || c.getAttribute("aria-disabled") === "true";
    if (!c.hasAttribute("tabindex") || !zS(c, s) || u)
      c = i(e, c, n);
    else
      return c.focus(), !0;
  }
  return !1;
}
const E9 = /* @__PURE__ */ K.forwardRef(function(t, n) {
  const {
    // private
    // eslint-disable-next-line react/prop-types
    actions: r,
    autoFocus: i = !1,
    autoFocusItem: s = !1,
    children: l,
    className: c,
    disabledItemsFocusable: u = !1,
    disableListWrap: d = !1,
    onKeyDown: h,
    variant: p = "selectedMenu",
    ...v
  } = t, m = K.useRef(null), g = K.useRef({
    keys: [],
    repeating: !0,
    previousKeyMatched: !0,
    lastTime: null
  });
  ls(() => {
    i && m.current.focus();
  }, [i]), K.useImperativeHandle(r, () => ({
    adjustStyleForScrollbar: (S, {
      direction: C
    }) => {
      const E = !m.current.style.width;
      if (S.clientHeight < m.current.clientHeight && E) {
        const O = `${hS(vo(S))}px`;
        m.current.style[C === "rtl" ? "paddingLeft" : "paddingRight"] = O, m.current.style.width = `calc(100% + ${O})`;
      }
      return m.current;
    }
  }), []);
  const b = (S) => {
    const C = m.current, E = S.key;
    if (S.ctrlKey || S.metaKey || S.altKey) {
      h && h(S);
      return;
    }
    const B = Er(C).activeElement;
    if (E === "ArrowDown")
      S.preventDefault(), Wu(C, B, d, u, Tg);
    else if (E === "ArrowUp")
      S.preventDefault(), Wu(C, B, d, u, _b);
    else if (E === "Home")
      S.preventDefault(), Wu(C, null, d, u, Tg);
    else if (E === "End")
      S.preventDefault(), Wu(C, null, d, u, _b);
    else if (E.length === 1) {
      const N = g.current, L = E.toLowerCase(), k = performance.now();
      N.keys.length > 0 && (k - N.lastTime > 500 ? (N.keys = [], N.repeating = !0, N.previousKeyMatched = !0) : N.repeating && L !== N.keys[0] && (N.repeating = !1)), N.lastTime = k, N.keys.push(L);
      const F = B && !N.repeating && zS(B, N);
      N.previousKeyMatched && (F || Wu(C, B, !1, u, Tg, N)) ? S.preventDefault() : N.previousKeyMatched = !1;
    }
    h && h(S);
  }, x = ar(m, n);
  let w = -1;
  K.Children.forEach(l, (S, C) => {
    if (!/* @__PURE__ */ K.isValidElement(S)) {
      w === C && (w += 1, w >= l.length && (w = -1));
      return;
    }
    S.props.disabled || (p === "selectedMenu" && S.props.selected || w === -1) && (w = C), w === C && (S.props.disabled || S.props.muiSkipListHighlight || S.type.muiSkipListHighlight) && (w += 1, w >= l.length && (w = -1));
  });
  const T = K.Children.map(l, (S, C) => {
    if (C === w) {
      const E = {};
      return s && (E.autoFocus = !0), S.props.tabIndex === void 0 && p === "selectedMenu" && (E.tabIndex = 0), /* @__PURE__ */ K.cloneElement(S, E);
    }
    return S;
  });
  return /* @__PURE__ */ W.jsx(b9, {
    role: "menu",
    ref: x,
    className: c,
    onKeyDown: b,
    tabIndex: i ? 0 : -1,
    ...v,
    children: T
  });
});
function A9(e) {
  return Qe("MuiPopover", e);
}
Xe("MuiPopover", ["root", "paper"]);
function Sb(e, t) {
  let n = 0;
  return typeof t == "number" ? n = t : t === "center" ? n = e.height / 2 : t === "bottom" && (n = e.height), n;
}
function xb(e, t) {
  let n = 0;
  return typeof t == "number" ? n = t : t === "center" ? n = e.width / 2 : t === "right" && (n = e.width), n;
}
function Tb(e) {
  return [e.horizontal, e.vertical].map((t) => typeof t == "number" ? `${t}px` : t).join(" ");
}
function Cg(e) {
  return typeof e == "function" ? e() : e;
}
const k9 = (e) => {
  const {
    classes: t
  } = e;
  return Ze({
    root: ["root"],
    paper: ["paper"]
  }, A9, t);
}, R9 = he(LS, {
  name: "MuiPopover",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({}), US = he(r6, {
  name: "MuiPopover",
  slot: "Paper",
  overridesResolver: (e, t) => t.paper
})({
  position: "absolute",
  overflowY: "auto",
  overflowX: "hidden",
  // So we see the popover when it's empty.
  // It's most likely on issue on userland.
  minWidth: 16,
  minHeight: 16,
  maxWidth: "calc(100% - 32px)",
  maxHeight: "calc(100% - 32px)",
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
}), VS = /* @__PURE__ */ K.forwardRef(function(t, n) {
  const r = nn({
    props: t,
    name: "MuiPopover"
  }), {
    action: i,
    anchorEl: s,
    anchorOrigin: l = {
      vertical: "top",
      horizontal: "left"
    },
    anchorPosition: c,
    anchorReference: u = "anchorEl",
    children: d,
    className: h,
    container: p,
    elevation: v = 8,
    marginThreshold: m = 16,
    open: g,
    PaperProps: b = {},
    // TODO: remove in v7
    slots: x = {},
    slotProps: w = {},
    transformOrigin: T = {
      vertical: "top",
      horizontal: "left"
    },
    TransitionComponent: S,
    // TODO: remove in v7
    transitionDuration: C = "auto",
    TransitionProps: E = {},
    // TODO: remove in v7
    disableScrollLock: O = !1,
    ...B
  } = r, N = K.useRef(), L = {
    ...r,
    anchorOrigin: l,
    anchorReference: u,
    elevation: v,
    marginThreshold: m,
    transformOrigin: T,
    TransitionComponent: S,
    transitionDuration: C,
    TransitionProps: E
  }, k = k9(L), F = K.useCallback(() => {
    if (u === "anchorPosition")
      return c;
    const Tt = Cg(s), bt = (Tt && Tt.nodeType === 1 ? Tt : Er(N.current).body).getBoundingClientRect();
    return {
      top: bt.top + Sb(bt, l.vertical),
      left: bt.left + xb(bt, l.horizontal)
    };
  }, [s, l.horizontal, l.vertical, c, u]), G = K.useCallback((Tt) => ({
    vertical: Sb(Tt, T.vertical),
    horizontal: xb(Tt, T.horizontal)
  }), [T.horizontal, T.vertical]), M = K.useCallback((Tt) => {
    const Ct = {
      width: Tt.offsetWidth,
      height: Tt.offsetHeight
    }, bt = G(Ct);
    if (u === "none")
      return {
        top: null,
        left: null,
        transformOrigin: Tb(bt)
      };
    const Ht = F();
    let $t = Ht.top - bt.vertical, wt = Ht.left - bt.horizontal;
    const Wt = $t + Ct.height, Ut = wt + Ct.width, ne = vo(Cg(s)), ce = ne.innerHeight - m, re = ne.innerWidth - m;
    if (m !== null && $t < m) {
      const le = $t - m;
      $t -= le, bt.vertical += le;
    } else if (m !== null && Wt > ce) {
      const le = Wt - ce;
      $t -= le, bt.vertical += le;
    }
    if (m !== null && wt < m) {
      const le = wt - m;
      wt -= le, bt.horizontal += le;
    } else if (Ut > re) {
      const le = Ut - re;
      wt -= le, bt.horizontal += le;
    }
    return {
      top: `${Math.round($t)}px`,
      left: `${Math.round(wt)}px`,
      transformOrigin: Tb(bt)
    };
  }, [s, u, F, G, m]), [j, D] = K.useState(g), z = K.useCallback(() => {
    const Tt = N.current;
    if (!Tt)
      return;
    const Ct = M(Tt);
    Ct.top !== null && Tt.style.setProperty("top", Ct.top), Ct.left !== null && (Tt.style.left = Ct.left), Tt.style.transformOrigin = Ct.transformOrigin, D(!0);
  }, [M]);
  K.useEffect(() => (O && window.addEventListener("scroll", z), () => window.removeEventListener("scroll", z)), [s, O, z]);
  const H = () => {
    z();
  }, X = () => {
    D(!1);
  };
  K.useEffect(() => {
    g && z();
  }), K.useImperativeHandle(i, () => g ? {
    updatePosition: () => {
      z();
    }
  } : null, [g, z]), K.useEffect(() => {
    if (!g)
      return;
    const Tt = uS(() => {
      z();
    }), Ct = vo(s);
    return Ct.addEventListener("resize", Tt), () => {
      Tt.clear(), Ct.removeEventListener("resize", Tt);
    };
  }, [s, g, z]);
  let Y = C;
  const V = {
    slots: {
      transition: S,
      ...x
    },
    slotProps: {
      transition: E,
      paper: b,
      ...w
    }
  }, [Z, ct] = $n("transition", {
    elementType: op,
    externalForwardedProps: V,
    ownerState: L,
    getSlotProps: (Tt) => ({
      ...Tt,
      onEntering: (Ct, bt) => {
        var Ht;
        (Ht = Tt.onEntering) == null || Ht.call(Tt, Ct, bt), H();
      },
      onExited: (Ct) => {
        var bt;
        (bt = Tt.onExited) == null || bt.call(Tt, Ct), X();
      }
    }),
    additionalProps: {
      appear: !0,
      in: g
    }
  });
  C === "auto" && !Z.muiSupportAuto && (Y = void 0);
  const et = p || (s ? Er(Cg(s)).body : void 0), [rt, {
    slots: st,
    slotProps: yt,
    ...J
  }] = $n("root", {
    ref: n,
    elementType: R9,
    externalForwardedProps: {
      ...V,
      ...B
    },
    shouldForwardComponentProp: !0,
    additionalProps: {
      slots: {
        backdrop: x.backdrop
      },
      slotProps: {
        backdrop: qw(typeof w.backdrop == "function" ? w.backdrop(L) : w.backdrop, {
          invisible: !0
        })
      },
      container: et,
      open: g
    },
    ownerState: L,
    className: ge(k.root, h)
  }), [tt, ot] = $n("paper", {
    ref: N,
    className: k.paper,
    elementType: US,
    externalForwardedProps: V,
    shouldForwardComponentProp: !0,
    additionalProps: {
      elevation: v,
      style: j ? void 0 : {
        opacity: 0
      }
    },
    ownerState: L
  });
  return /* @__PURE__ */ W.jsx(rt, {
    ...J,
    ...!ul(rt) && {
      slots: st,
      slotProps: yt,
      disableScrollLock: O
    },
    children: /* @__PURE__ */ W.jsx(Z, {
      ...ct,
      timeout: Y,
      children: /* @__PURE__ */ W.jsx(tt, {
        ...ot,
        children: d
      })
    })
  });
});
function M9(e) {
  return Qe("MuiMenu", e);
}
Xe("MuiMenu", ["root", "paper", "list"]);
const O9 = {
  vertical: "top",
  horizontal: "right"
}, N9 = {
  vertical: "top",
  horizontal: "left"
}, P9 = (e) => {
  const {
    classes: t
  } = e;
  return Ze({
    root: ["root"],
    paper: ["paper"],
    list: ["list"]
  }, M9, t);
}, D9 = he(VS, {
  shouldForwardProp: (e) => $i(e) || e === "classes",
  name: "MuiMenu",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({}), I9 = he(US, {
  name: "MuiMenu",
  slot: "Paper",
  overridesResolver: (e, t) => t.paper
})({
  // specZ: The maximum height of a simple menu should be one or more rows less than the view
  // height. This ensures a tappable area outside of the simple menu with which to dismiss
  // the menu.
  maxHeight: "calc(100% - 96px)",
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch"
}), B9 = he(E9, {
  name: "MuiMenu",
  slot: "List",
  overridesResolver: (e, t) => t.list
})({
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
}), ly = /* @__PURE__ */ K.forwardRef(function(t, n) {
  const r = nn({
    props: t,
    name: "MuiMenu"
  }), {
    autoFocus: i = !0,
    children: s,
    className: l,
    disableAutoFocusItem: c = !1,
    MenuListProps: u = {},
    onClose: d,
    open: h,
    PaperProps: p = {},
    PopoverClasses: v,
    transitionDuration: m = "auto",
    TransitionProps: {
      onEntering: g,
      ...b
    } = {},
    variant: x = "selectedMenu",
    slots: w = {},
    slotProps: T = {},
    ...S
  } = r, C = zp(), E = {
    ...r,
    autoFocus: i,
    disableAutoFocusItem: c,
    MenuListProps: u,
    onEntering: g,
    PaperProps: p,
    transitionDuration: m,
    TransitionProps: b,
    variant: x
  }, O = P9(E), B = i && !c && h, N = K.useRef(null), L = (Y, V) => {
    N.current && N.current.adjustStyleForScrollbar(Y, {
      direction: C ? "rtl" : "ltr"
    }), g && g(Y, V);
  }, k = (Y) => {
    Y.key === "Tab" && (Y.preventDefault(), d && d(Y, "tabKeyDown"));
  };
  let F = -1;
  K.Children.map(s, (Y, V) => {
    /* @__PURE__ */ K.isValidElement(Y) && (Y.props.disabled || (x === "selectedMenu" && Y.props.selected || F === -1) && (F = V));
  });
  const G = {
    slots: w,
    slotProps: {
      list: u,
      transition: b,
      paper: p,
      ...T
    }
  }, M = ws({
    elementType: w.root,
    externalSlotProps: T.root,
    ownerState: E,
    className: [O.root, l]
  }), [j, D] = $n("paper", {
    className: O.paper,
    elementType: I9,
    externalForwardedProps: G,
    shouldForwardComponentProp: !0,
    ownerState: E
  }), [z, H] = $n("list", {
    className: ge(O.list, u.className),
    elementType: B9,
    shouldForwardComponentProp: !0,
    externalForwardedProps: G,
    getSlotProps: (Y) => ({
      ...Y,
      onKeyDown: (V) => {
        var Z;
        k(V), (Z = Y.onKeyDown) == null || Z.call(Y, V);
      }
    }),
    ownerState: E
  }), X = typeof G.slotProps.transition == "function" ? G.slotProps.transition(E) : G.slotProps.transition;
  return /* @__PURE__ */ W.jsx(D9, {
    onClose: d,
    anchorOrigin: {
      vertical: "bottom",
      horizontal: C ? "right" : "left"
    },
    transformOrigin: C ? O9 : N9,
    slots: {
      root: w.root,
      paper: j,
      backdrop: w.backdrop,
      ...w.transition && {
        // TODO: pass `slots.transition` directly once `TransitionComponent` is removed from Popover
        transition: w.transition
      }
    },
    slotProps: {
      root: M,
      paper: D,
      backdrop: typeof T.backdrop == "function" ? T.backdrop(E) : T.backdrop,
      transition: {
        ...X,
        onEntering: (...Y) => {
          var V;
          L(...Y), (V = X == null ? void 0 : X.onEntering) == null || V.call(X, ...Y);
        }
      }
    },
    open: h,
    ref: n,
    transitionDuration: m,
    ownerState: E,
    ...S,
    classes: v,
    children: /* @__PURE__ */ W.jsx(z, {
      actions: N,
      autoFocus: i && (F === -1 || c),
      autoFocusItem: B,
      variant: x,
      ...H,
      children: s
    })
  });
});
function F9(e) {
  return Qe("MuiMenuItem", e);
}
const $u = Xe("MuiMenuItem", ["root", "focusVisible", "dense", "disabled", "divider", "gutters", "selected"]), j9 = (e, t) => {
  const {
    ownerState: n
  } = e;
  return [t.root, n.dense && t.dense, n.divider && t.divider, !n.disableGutters && t.gutters];
}, L9 = (e) => {
  const {
    disabled: t,
    dense: n,
    divider: r,
    disableGutters: i,
    selected: s,
    classes: l
  } = e, u = Ze({
    root: ["root", n && "dense", t && "disabled", !i && "gutters", r && "divider", s && "selected"]
  }, F9, l);
  return {
    ...l,
    ...u
  };
}, z9 = he(Gp, {
  shouldForwardProp: (e) => $i(e) || e === "classes",
  name: "MuiMenuItem",
  slot: "Root",
  overridesResolver: j9
})(He(({
  theme: e
}) => ({
  ...e.typography.body1,
  display: "flex",
  justifyContent: "flex-start",
  alignItems: "center",
  position: "relative",
  textDecoration: "none",
  minHeight: 48,
  paddingTop: 6,
  paddingBottom: 6,
  boxSizing: "border-box",
  whiteSpace: "nowrap",
  "&:hover": {
    textDecoration: "none",
    backgroundColor: (e.vars || e).palette.action.hover,
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  [`&.${$u.selected}`]: {
    backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : xn(e.palette.primary.main, e.palette.action.selectedOpacity),
    [`&.${$u.focusVisible}`]: {
      backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.focusOpacity}))` : xn(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.focusOpacity)
    }
  },
  [`&.${$u.selected}:hover`]: {
    backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.hoverOpacity}))` : xn(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : xn(e.palette.primary.main, e.palette.action.selectedOpacity)
    }
  },
  [`&.${$u.focusVisible}`]: {
    backgroundColor: (e.vars || e).palette.action.focus
  },
  [`&.${$u.disabled}`]: {
    opacity: (e.vars || e).palette.action.disabledOpacity
  },
  [`& + .${gb.root}`]: {
    marginTop: e.spacing(1),
    marginBottom: e.spacing(1)
  },
  [`& + .${gb.inset}`]: {
    marginLeft: 52
  },
  [`& .${Ac.root}`]: {
    marginTop: 0,
    marginBottom: 0
  },
  [`& .${Ac.inset}`]: {
    paddingLeft: 36
  },
  [`& .${bb.root}`]: {
    minWidth: 36
  },
  variants: [{
    props: ({
      ownerState: t
    }) => !t.disableGutters,
    style: {
      paddingLeft: 16,
      paddingRight: 16
    }
  }, {
    props: ({
      ownerState: t
    }) => t.divider,
    style: {
      borderBottom: `1px solid ${(e.vars || e).palette.divider}`,
      backgroundClip: "padding-box"
    }
  }, {
    props: ({
      ownerState: t
    }) => !t.dense,
    style: {
      [e.breakpoints.up("sm")]: {
        minHeight: "auto"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.dense,
    style: {
      minHeight: 32,
      // https://m2.material.io/components/menus#specs > Dense
      paddingTop: 4,
      paddingBottom: 4,
      ...e.typography.body2,
      [`& .${bb.root} svg`]: {
        fontSize: "1.25rem"
      }
    }
  }]
}))), ks = /* @__PURE__ */ K.forwardRef(function(t, n) {
  const r = nn({
    props: t,
    name: "MuiMenuItem"
  }), {
    autoFocus: i = !1,
    component: s = "li",
    dense: l = !1,
    divider: c = !1,
    disableGutters: u = !1,
    focusVisibleClassName: d,
    role: h = "menuitem",
    tabIndex: p,
    className: v,
    ...m
  } = r, g = K.useContext(lh), b = K.useMemo(() => ({
    dense: l || g.dense || !1,
    disableGutters: u
  }), [g.dense, l, u]), x = K.useRef(null);
  ls(() => {
    i && x.current && x.current.focus();
  }, [i]);
  const w = {
    ...r,
    dense: b.dense,
    divider: c,
    disableGutters: u
  }, T = L9(r), S = ar(x, n);
  let C;
  return r.disabled || (C = p !== void 0 ? p : -1), /* @__PURE__ */ W.jsx(lh.Provider, {
    value: b,
    children: /* @__PURE__ */ W.jsx(z9, {
      ref: S,
      role: h,
      tabIndex: C,
      component: s,
      focusVisibleClassName: ge(T.focusVisible, d),
      className: ge(T.root, v),
      ...m,
      ownerState: w,
      classes: T
    })
  });
});
function U9(e) {
  return Qe("MuiNativeSelect", e);
}
const cy = Xe("MuiNativeSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]), V9 = (e) => {
  const {
    classes: t,
    variant: n,
    disabled: r,
    multiple: i,
    open: s,
    error: l
  } = e, c = {
    select: ["select", n, r && "disabled", i && "multiple", l && "error"],
    icon: ["icon", `icon${pe(n)}`, s && "iconOpen", r && "disabled"]
  };
  return Ze(c, U9, t);
}, GS = he("select")(({
  theme: e
}) => ({
  // Reset
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // When interacting quickly, the text can end up selected.
  // Native select can't be selected either.
  userSelect: "none",
  // Reset
  borderRadius: 0,
  cursor: "pointer",
  "&:focus": {
    // Reset Chrome style
    borderRadius: 0
  },
  [`&.${cy.disabled}`]: {
    cursor: "default"
  },
  "&[multiple]": {
    height: "auto"
  },
  "&:not([multiple]) option, &:not([multiple]) optgroup": {
    backgroundColor: (e.vars || e).palette.background.paper
  },
  variants: [{
    props: ({
      ownerState: t
    }) => t.variant !== "filled" && t.variant !== "outlined",
    style: {
      // Bump specificity to allow extending custom inputs
      "&&&": {
        paddingRight: 24,
        minWidth: 16
        // So it doesn't collapse.
      }
    }
  }, {
    props: {
      variant: "filled"
    },
    style: {
      "&&&": {
        paddingRight: 32
      }
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      borderRadius: (e.vars || e).shape.borderRadius,
      "&:focus": {
        borderRadius: (e.vars || e).shape.borderRadius
        // Reset the reset for Chrome style
      },
      "&&&": {
        paddingRight: 32
      }
    }
  }]
})), G9 = he(GS, {
  name: "MuiNativeSelect",
  slot: "Select",
  shouldForwardProp: $i,
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.select, t[n.variant], n.error && t.error, {
      [`&.${cy.multiple}`]: t.multiple
    }];
  }
})({}), qS = he("svg")(({
  theme: e
}) => ({
  // We use a position absolute over a flexbox in order to forward the pointer events
  // to the input and to support wrapping tags..
  position: "absolute",
  right: 0,
  // Center vertically, height is 1em
  top: "calc(50% - .5em)",
  // Don't block pointer events on the select under the icon.
  pointerEvents: "none",
  color: (e.vars || e).palette.action.active,
  [`&.${cy.disabled}`]: {
    color: (e.vars || e).palette.action.disabled
  },
  variants: [{
    props: ({
      ownerState: t
    }) => t.open,
    style: {
      transform: "rotate(180deg)"
    }
  }, {
    props: {
      variant: "filled"
    },
    style: {
      right: 7
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      right: 7
    }
  }]
})), q9 = he(qS, {
  name: "MuiNativeSelect",
  slot: "Icon",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.icon, n.variant && t[`icon${pe(n.variant)}`], n.open && t.iconOpen];
  }
})({}), H9 = /* @__PURE__ */ K.forwardRef(function(t, n) {
  const {
    className: r,
    disabled: i,
    error: s,
    IconComponent: l,
    inputRef: c,
    variant: u = "standard",
    ...d
  } = t, h = {
    ...t,
    disabled: i,
    variant: u,
    error: s
  }, p = V9(h);
  return /* @__PURE__ */ W.jsxs(K.Fragment, {
    children: [/* @__PURE__ */ W.jsx(G9, {
      ownerState: h,
      className: ge(p.select, r),
      disabled: i,
      ref: c || n,
      ...d
    }), t.multiple ? null : /* @__PURE__ */ W.jsx(q9, {
      as: l,
      ownerState: h,
      className: p.icon
    })]
  });
});
var Cb;
const W9 = he("fieldset", {
  shouldForwardProp: $i
})({
  textAlign: "left",
  position: "absolute",
  bottom: 0,
  right: 0,
  top: -5,
  left: 0,
  margin: 0,
  padding: "0 8px",
  pointerEvents: "none",
  borderRadius: "inherit",
  borderStyle: "solid",
  borderWidth: 1,
  overflow: "hidden",
  minWidth: "0%"
}), $9 = he("legend", {
  shouldForwardProp: $i
})(He(({
  theme: e
}) => ({
  float: "unset",
  // Fix conflict with bootstrap
  width: "auto",
  // Fix conflict with bootstrap
  overflow: "hidden",
  // Fix Horizontal scroll when label too long
  variants: [{
    props: ({
      ownerState: t
    }) => !t.withLabel,
    style: {
      padding: 0,
      lineHeight: "11px",
      // sync with `height` in `legend` styles
      transition: e.transitions.create("width", {
        duration: 150,
        easing: e.transitions.easing.easeOut
      })
    }
  }, {
    props: ({
      ownerState: t
    }) => t.withLabel,
    style: {
      display: "block",
      // Fix conflict with normalize.css and sanitize.css
      padding: 0,
      height: 11,
      // sync with `lineHeight` in `legend` styles
      fontSize: "0.75em",
      visibility: "hidden",
      maxWidth: 0.01,
      transition: e.transitions.create("max-width", {
        duration: 50,
        easing: e.transitions.easing.easeOut
      }),
      whiteSpace: "nowrap",
      "& > span": {
        paddingLeft: 5,
        paddingRight: 5,
        display: "inline-block",
        opacity: 0,
        visibility: "visible"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.withLabel && t.notched,
    style: {
      maxWidth: "100%",
      transition: e.transitions.create("max-width", {
        duration: 100,
        easing: e.transitions.easing.easeOut,
        delay: 50
      })
    }
  }]
})));
function K9(e) {
  const {
    children: t,
    classes: n,
    className: r,
    label: i,
    notched: s,
    ...l
  } = e, c = i != null && i !== "", u = {
    ...e,
    notched: s,
    withLabel: c
  };
  return /* @__PURE__ */ W.jsx(W9, {
    "aria-hidden": !0,
    className: r,
    ownerState: u,
    ...l,
    children: /* @__PURE__ */ W.jsx($9, {
      ownerState: u,
      children: c ? /* @__PURE__ */ W.jsx("span", {
        children: i
      }) : (
        // notranslate needed while Google Translate will not fix zero-width space issue
        Cb || (Cb = /* @__PURE__ */ W.jsx("span", {
          className: "notranslate",
          "aria-hidden": !0,
          children: ""
        }))
      )
    })
  });
}
const Y9 = (e) => {
  const {
    classes: t
  } = e, r = Ze({
    root: ["root"],
    notchedOutline: ["notchedOutline"],
    input: ["input"]
  }, iE, t);
  return {
    ...t,
    // forward classes to the InputBase
    ...r
  };
}, X9 = he($p, {
  shouldForwardProp: (e) => $i(e) || e === "classes",
  name: "MuiOutlinedInput",
  slot: "Root",
  overridesResolver: Hp
})(He(({
  theme: e
}) => {
  const t = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return {
    position: "relative",
    borderRadius: (e.vars || e).shape.borderRadius,
    [`&:hover .${Cs.notchedOutline}`]: {
      borderColor: (e.vars || e).palette.text.primary
    },
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      [`&:hover .${Cs.notchedOutline}`]: {
        borderColor: e.vars ? `rgba(${e.vars.palette.common.onBackgroundChannel} / 0.23)` : t
      }
    },
    [`&.${Cs.focused} .${Cs.notchedOutline}`]: {
      borderWidth: 2
    },
    variants: [...Object.entries(e.palette).filter(Ei()).map(([n]) => ({
      props: {
        color: n
      },
      style: {
        [`&.${Cs.focused} .${Cs.notchedOutline}`]: {
          borderColor: (e.vars || e).palette[n].main
        }
      }
    })), {
      props: {},
      // to overide the above style
      style: {
        [`&.${Cs.error} .${Cs.notchedOutline}`]: {
          borderColor: (e.vars || e).palette.error.main
        },
        [`&.${Cs.disabled} .${Cs.notchedOutline}`]: {
          borderColor: (e.vars || e).palette.action.disabled
        }
      }
    }, {
      props: ({
        ownerState: n
      }) => n.startAdornment,
      style: {
        paddingLeft: 14
      }
    }, {
      props: ({
        ownerState: n
      }) => n.endAdornment,
      style: {
        paddingRight: 14
      }
    }, {
      props: ({
        ownerState: n
      }) => n.multiline,
      style: {
        padding: "16.5px 14px"
      }
    }, {
      props: ({
        ownerState: n,
        size: r
      }) => n.multiline && r === "small",
      style: {
        padding: "8.5px 14px"
      }
    }]
  };
})), Q9 = he(K9, {
  name: "MuiOutlinedInput",
  slot: "NotchedOutline",
  overridesResolver: (e, t) => t.notchedOutline
})(He(({
  theme: e
}) => {
  const t = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return {
    borderColor: e.vars ? `rgba(${e.vars.palette.common.onBackgroundChannel} / 0.23)` : t
  };
})), Z9 = he(Kp, {
  name: "MuiOutlinedInput",
  slot: "Input",
  overridesResolver: Wp
})(He(({
  theme: e
}) => ({
  padding: "16.5px 14px",
  ...!e.vars && {
    "&:-webkit-autofill": {
      WebkitBoxShadow: e.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
      WebkitTextFillColor: e.palette.mode === "light" ? null : "#fff",
      caretColor: e.palette.mode === "light" ? null : "#fff",
      borderRadius: "inherit"
    }
  },
  ...e.vars && {
    "&:-webkit-autofill": {
      borderRadius: "inherit"
    },
    [e.getColorSchemeSelector("dark")]: {
      "&:-webkit-autofill": {
        WebkitBoxShadow: "0 0 0 100px #266798 inset",
        WebkitTextFillColor: "#fff",
        caretColor: "#fff"
      }
    }
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      padding: "8.5px 14px"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.multiline,
    style: {
      padding: 0
    }
  }, {
    props: ({
      ownerState: t
    }) => t.startAdornment,
    style: {
      paddingLeft: 0
    }
  }, {
    props: ({
      ownerState: t
    }) => t.endAdornment,
    style: {
      paddingRight: 0
    }
  }]
}))), uy = /* @__PURE__ */ K.forwardRef(function(t, n) {
  var r;
  const i = nn({
    props: t,
    name: "MuiOutlinedInput"
  }), {
    components: s = {},
    fullWidth: l = !1,
    inputComponent: c = "input",
    label: u,
    multiline: d = !1,
    notched: h,
    slots: p = {},
    type: v = "text",
    ...m
  } = i, g = Y9(i), b = Jc(), x = Zc({
    props: i,
    muiFormControl: b,
    states: ["color", "disabled", "error", "focused", "hiddenLabel", "size", "required"]
  }), w = {
    ...i,
    color: x.color || "primary",
    disabled: x.disabled,
    error: x.error,
    focused: x.focused,
    formControl: b,
    fullWidth: l,
    hiddenLabel: x.hiddenLabel,
    multiline: d,
    size: x.size,
    type: v
  }, T = p.root ?? s.Root ?? X9, S = p.input ?? s.Input ?? Z9;
  return /* @__PURE__ */ W.jsx(sy, {
    slots: {
      root: T,
      input: S
    },
    renderSuffix: (C) => /* @__PURE__ */ W.jsx(Q9, {
      ownerState: w,
      className: g.notchedOutline,
      label: u != null && u !== "" && x.required ? r || (r = /* @__PURE__ */ W.jsxs(K.Fragment, {
        children: [u, "", "*"]
      })) : u,
      notched: typeof h < "u" ? h : !!(C.startAdornment || C.filled || C.focused)
    }),
    fullWidth: l,
    inputComponent: c,
    multiline: d,
    ref: n,
    type: v,
    ...m,
    classes: {
      ...g,
      notchedOutline: null
    }
  });
});
uy.muiName = "Input";
function HS(e) {
  return Qe("MuiSelect", e);
}
const Ku = Xe("MuiSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "focused", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]);
var wb;
const J9 = he(GS, {
  name: "MuiSelect",
  slot: "Select",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [
      // Win specificity over the input base
      {
        [`&.${Ku.select}`]: t.select
      },
      {
        [`&.${Ku.select}`]: t[n.variant]
      },
      {
        [`&.${Ku.error}`]: t.error
      },
      {
        [`&.${Ku.multiple}`]: t.multiple
      }
    ];
  }
})({
  // Win specificity over the input base
  [`&.${Ku.select}`]: {
    height: "auto",
    // Resets for multiple select with chips
    minHeight: "1.4375em",
    // Required for select\text-field height consistency
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    overflow: "hidden"
  }
}), t7 = he(qS, {
  name: "MuiSelect",
  slot: "Icon",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.icon, n.variant && t[`icon${pe(n.variant)}`], n.open && t.iconOpen];
  }
})({}), e7 = he("input", {
  shouldForwardProp: (e) => Vp(e) && e !== "classes",
  name: "MuiSelect",
  slot: "NativeInput",
  overridesResolver: (e, t) => t.nativeInput
})({
  bottom: 0,
  left: 0,
  position: "absolute",
  opacity: 0,
  pointerEvents: "none",
  width: "100%",
  boxSizing: "border-box"
});
function Eb(e, t) {
  return typeof t == "object" && t !== null ? e === t : String(e) === String(t);
}
function n7(e) {
  return e == null || typeof e == "string" && !e.trim();
}
const r7 = (e) => {
  const {
    classes: t,
    variant: n,
    disabled: r,
    multiple: i,
    open: s,
    error: l
  } = e, c = {
    select: ["select", n, r && "disabled", i && "multiple", l && "error"],
    icon: ["icon", `icon${pe(n)}`, s && "iconOpen", r && "disabled"],
    nativeInput: ["nativeInput"]
  };
  return Ze(c, HS, t);
}, i7 = /* @__PURE__ */ K.forwardRef(function(t, n) {
  var fe;
  const {
    "aria-describedby": r,
    "aria-label": i,
    autoFocus: s,
    autoWidth: l,
    children: c,
    className: u,
    defaultOpen: d,
    defaultValue: h,
    disabled: p,
    displayEmpty: v,
    error: m = !1,
    IconComponent: g,
    inputRef: b,
    labelId: x,
    MenuProps: w = {},
    multiple: T,
    name: S,
    onBlur: C,
    onChange: E,
    onClose: O,
    onFocus: B,
    onOpen: N,
    open: L,
    readOnly: k,
    renderValue: F,
    required: G,
    SelectDisplayProps: M = {},
    tabIndex: j,
    // catching `type` from Input which makes no sense for SelectInput
    type: D,
    value: z,
    variant: H = "standard",
    ...X
  } = t, [Y, V] = tp({
    controlled: z,
    default: h,
    name: "Select"
  }), [Z, ct] = tp({
    controlled: L,
    default: d,
    name: "Select"
  }), et = K.useRef(null), rt = K.useRef(null), [st, yt] = K.useState(null), {
    current: J
  } = K.useRef(L != null), [tt, ot] = K.useState(), Tt = ar(n, b), Ct = K.useCallback((ie) => {
    rt.current = ie, ie && yt(ie);
  }, []), bt = st == null ? void 0 : st.parentNode;
  K.useImperativeHandle(Tt, () => ({
    focus: () => {
      rt.current.focus();
    },
    node: et.current,
    value: Y
  }), [Y]), K.useEffect(() => {
    d && Z && st && !J && (ot(l ? null : bt.clientWidth), rt.current.focus());
  }, [st, l]), K.useEffect(() => {
    s && rt.current.focus();
  }, [s]), K.useEffect(() => {
    if (!x)
      return;
    const ie = Er(rt.current).getElementById(x);
    if (ie) {
      const zt = () => {
        getSelection().isCollapsed && rt.current.focus();
      };
      return ie.addEventListener("click", zt), () => {
        ie.removeEventListener("click", zt);
      };
    }
  }, [x]);
  const Ht = (ie, zt) => {
    ie ? N && N(zt) : O && O(zt), J || (ot(l ? null : bt.clientWidth), ct(ie));
  }, $t = (ie) => {
    ie.button === 0 && (ie.preventDefault(), rt.current.focus(), Ht(!0, ie));
  }, wt = (ie) => {
    Ht(!1, ie);
  }, Wt = K.Children.toArray(c), Ut = (ie) => {
    const zt = Wt.find((Pe) => Pe.props.value === ie.target.value);
    zt !== void 0 && (V(zt.props.value), E && E(ie, zt));
  }, ne = (ie) => (zt) => {
    let Pe;
    if (zt.currentTarget.hasAttribute("tabindex")) {
      if (T) {
        Pe = Array.isArray(Y) ? Y.slice() : [];
        const je = Y.indexOf(ie.props.value);
        je === -1 ? Pe.push(ie.props.value) : Pe.splice(je, 1);
      } else
        Pe = ie.props.value;
      if (ie.props.onClick && ie.props.onClick(zt), Y !== Pe && (V(Pe), E)) {
        const je = zt.nativeEvent || zt, cr = new je.constructor(je.type, je);
        Object.defineProperty(cr, "target", {
          writable: !0,
          value: {
            value: Pe,
            name: S
          }
        }), E(cr, ie);
      }
      T || Ht(!1, zt);
    }
  }, ce = (ie) => {
    k || [
      " ",
      "ArrowUp",
      "ArrowDown",
      // The native select doesn't respond to enter on macOS, but it's recommended by
      // https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-select-only/
      "Enter"
    ].includes(ie.key) && (ie.preventDefault(), Ht(!0, ie));
  }, re = st !== null && Z, le = (ie) => {
    !re && C && (Object.defineProperty(ie, "target", {
      writable: !0,
      value: {
        value: Y,
        name: S
      }
    }), C(ie));
  };
  delete X["aria-invalid"];
  let Lt, ye;
  const be = [];
  let Nt = !1;
  (sp({
    value: Y
  }) || v) && (F ? Lt = F(Y) : Nt = !0);
  const Bt = Wt.map((ie) => {
    if (!/* @__PURE__ */ K.isValidElement(ie))
      return null;
    let zt;
    if (T) {
      if (!Array.isArray(Y))
        throw new Error(go(2));
      zt = Y.some((Pe) => Eb(Pe, ie.props.value)), zt && Nt && be.push(ie.props.children);
    } else
      zt = Eb(Y, ie.props.value), zt && Nt && (ye = ie.props.children);
    return /* @__PURE__ */ K.cloneElement(ie, {
      "aria-selected": zt ? "true" : "false",
      onClick: ne(ie),
      onKeyUp: (Pe) => {
        Pe.key === " " && Pe.preventDefault(), ie.props.onKeyUp && ie.props.onKeyUp(Pe);
      },
      role: "option",
      selected: zt,
      value: void 0,
      // The value is most likely not a valid HTML attribute.
      "data-value": ie.props.value
      // Instead, we provide it as a data attribute.
    });
  });
  Nt && (T ? be.length === 0 ? Lt = null : Lt = be.reduce((ie, zt, Pe) => (ie.push(zt), Pe < be.length - 1 && ie.push(", "), ie), []) : Lt = ye);
  let Rt = tt;
  !l && J && st && (Rt = bt.clientWidth);
  let Dt;
  typeof j < "u" ? Dt = j : Dt = p ? null : 0;
  const jt = M.id || (S ? `mui-component-select-${S}` : void 0), Ft = {
    ...t,
    variant: H,
    value: Y,
    open: re,
    error: m
  }, Vt = r7(Ft), Yt = {
    ...w.PaperProps,
    ...(fe = w.slotProps) == null ? void 0 : fe.paper
  }, ee = bh();
  return /* @__PURE__ */ W.jsxs(K.Fragment, {
    children: [/* @__PURE__ */ W.jsx(J9, {
      as: "div",
      ref: Ct,
      tabIndex: Dt,
      role: "combobox",
      "aria-controls": re ? ee : void 0,
      "aria-disabled": p ? "true" : void 0,
      "aria-expanded": re ? "true" : "false",
      "aria-haspopup": "listbox",
      "aria-label": i,
      "aria-labelledby": [x, jt].filter(Boolean).join(" ") || void 0,
      "aria-describedby": r,
      "aria-required": G ? "true" : void 0,
      "aria-invalid": m ? "true" : void 0,
      onKeyDown: ce,
      onMouseDown: p || k ? null : $t,
      onBlur: le,
      onFocus: B,
      ...M,
      ownerState: Ft,
      className: ge(M.className, Vt.select, u),
      id: jt,
      children: n7(Lt) ? (
        // notranslate needed while Google Translate will not fix zero-width space issue
        wb || (wb = /* @__PURE__ */ W.jsx("span", {
          className: "notranslate",
          "aria-hidden": !0,
          children: ""
        }))
      ) : Lt
    }), /* @__PURE__ */ W.jsx(e7, {
      "aria-invalid": m,
      value: Array.isArray(Y) ? Y.join(",") : Y,
      name: S,
      ref: et,
      "aria-hidden": !0,
      onChange: Ut,
      tabIndex: -1,
      disabled: p,
      className: Vt.nativeInput,
      autoFocus: s,
      required: G,
      ...X,
      ownerState: Ft
    }), /* @__PURE__ */ W.jsx(t7, {
      as: g,
      className: Vt.icon,
      ownerState: Ft
    }), /* @__PURE__ */ W.jsx(ly, {
      id: `menu-${S || ""}`,
      anchorEl: bt,
      open: re,
      onClose: wt,
      anchorOrigin: {
        vertical: "bottom",
        horizontal: "center"
      },
      transformOrigin: {
        vertical: "top",
        horizontal: "center"
      },
      ...w,
      slotProps: {
        ...w.slotProps,
        list: {
          "aria-labelledby": x,
          role: "listbox",
          "aria-multiselectable": T ? "true" : void 0,
          disableListWrap: !0,
          id: ee,
          ...w.MenuListProps
        },
        paper: {
          ...Yt,
          style: {
            minWidth: Rt,
            ...Yt != null ? Yt.style : null
          }
        }
      },
      children: Bt
    })]
  });
}), s7 = (e) => {
  const {
    classes: t
  } = e, r = Ze({
    root: ["root"]
  }, HS, t);
  return {
    ...t,
    ...r
  };
}, dy = {
  name: "MuiSelect",
  overridesResolver: (e, t) => t.root,
  shouldForwardProp: (e) => $i(e) && e !== "variant",
  slot: "Root"
}, o7 = he(ay, dy)(""), a7 = he(uy, dy)(""), l7 = he(oy, dy)(""), ap = /* @__PURE__ */ K.forwardRef(function(t, n) {
  const r = nn({
    name: "MuiSelect",
    props: t
  }), {
    autoWidth: i = !1,
    children: s,
    classes: l = {},
    className: c,
    defaultOpen: u = !1,
    displayEmpty: d = !1,
    IconComponent: h = oE,
    id: p,
    input: v,
    inputProps: m,
    label: g,
    labelId: b,
    MenuProps: x,
    multiple: w = !1,
    native: T = !1,
    onClose: S,
    onOpen: C,
    open: E,
    renderValue: O,
    SelectDisplayProps: B,
    variant: N = "outlined",
    ...L
  } = r, k = T ? H9 : i7, F = Jc(), G = Zc({
    props: r,
    muiFormControl: F,
    states: ["variant", "error"]
  }), M = G.variant || N, j = {
    ...r,
    variant: M,
    classes: l
  }, D = s7(j), {
    root: z,
    ...H
  } = D, X = v || {
    standard: /* @__PURE__ */ W.jsx(o7, {
      ownerState: j
    }),
    outlined: /* @__PURE__ */ W.jsx(a7, {
      label: g,
      ownerState: j
    }),
    filled: /* @__PURE__ */ W.jsx(l7, {
      ownerState: j
    })
  }[M], Y = ar(n, Qc(X));
  return /* @__PURE__ */ W.jsx(K.Fragment, {
    children: /* @__PURE__ */ K.cloneElement(X, {
      // Most of the logic is implemented in `SelectInput`.
      // The `Select` component is a simple API wrapper to expose something better to play with.
      inputComponent: k,
      inputProps: {
        children: s,
        error: G.error,
        IconComponent: h,
        variant: M,
        type: void 0,
        // We render a select. We can ignore the type provided by the `Input`.
        multiple: w,
        ...T ? {
          id: p
        } : {
          autoWidth: i,
          defaultOpen: u,
          displayEmpty: d,
          labelId: b,
          MenuProps: x,
          onClose: S,
          onOpen: C,
          open: E,
          renderValue: O,
          SelectDisplayProps: {
            id: p,
            ...B
          }
        },
        ...m,
        classes: m ? Fr(H, m.classes) : H,
        ...v ? v.props.inputProps : {}
      },
      ...(w && T || d) && M === "outlined" ? {
        notched: !0
      } : {},
      ref: Y,
      className: ge(X.props.className, c, D.root),
      // If a custom input is provided via 'input' prop, do not allow 'variant' to be propagated to it's root element. See https://github.com/mui/material-ui/issues/33894.
      ...!v && {
        variant: M
      },
      ...L
    })
  });
});
ap.muiName = "Select";
function c7(e, t, n = (r, i) => r === i) {
  return e.length === t.length && e.every((r, i) => n(r, t[i]));
}
const u7 = 2;
function _c(e, t, n, r, i) {
  return n === 1 ? Math.min(e + t, i) : Math.max(e - t, r);
}
function WS(e, t) {
  return e - t;
}
function Ab(e, t) {
  const {
    index: n
  } = e.reduce((r, i, s) => {
    const l = Math.abs(t - i);
    return r === null || l < r.distance || l === r.distance ? {
      distance: l,
      index: s
    } : r;
  }, null) ?? {};
  return n;
}
function Ef(e, t) {
  if (t.current !== void 0 && e.changedTouches) {
    const n = e;
    for (let r = 0; r < n.changedTouches.length; r += 1) {
      const i = n.changedTouches[r];
      if (i.identifier === t.current)
        return {
          x: i.clientX,
          y: i.clientY
        };
    }
    return !1;
  }
  return {
    x: e.clientX,
    y: e.clientY
  };
}
function lp(e, t, n) {
  return (e - t) * 100 / (n - t);
}
function d7(e, t, n) {
  return (n - t) * e + t;
}
function h7(e) {
  if (Math.abs(e) < 1) {
    const n = e.toExponential().split("e-"), r = n[0].split(".")[1];
    return (r ? r.length : 0) + parseInt(n[1], 10);
  }
  const t = e.toString().split(".")[1];
  return t ? t.length : 0;
}
function f7(e, t, n) {
  const r = Math.round((e - n) / t) * t + n;
  return Number(r.toFixed(h7(t)));
}
function kb({
  values: e,
  newValue: t,
  index: n
}) {
  const r = e.slice();
  return r[n] = t, r.sort(WS);
}
function Af({
  sliderRef: e,
  activeIndex: t,
  setActive: n
}) {
  var i, s, l;
  const r = Er(e.current);
  (!((i = e.current) != null && i.contains(r.activeElement)) || Number((s = r == null ? void 0 : r.activeElement) == null ? void 0 : s.getAttribute("data-index")) !== t) && ((l = e.current) == null || l.querySelector(`[type="range"][data-index="${t}"]`).focus()), n && n(t);
}
function kf(e, t) {
  return typeof e == "number" && typeof t == "number" ? e === t : typeof e == "object" && typeof t == "object" ? c7(e, t) : !1;
}
const p7 = {
  horizontal: {
    offset: (e) => ({
      left: `${e}%`
    }),
    leap: (e) => ({
      width: `${e}%`
    })
  },
  "horizontal-reverse": {
    offset: (e) => ({
      right: `${e}%`
    }),
    leap: (e) => ({
      width: `${e}%`
    })
  },
  vertical: {
    offset: (e) => ({
      bottom: `${e}%`
    }),
    leap: (e) => ({
      height: `${e}%`
    })
  }
}, m7 = (e) => e;
let Rf;
function Rb() {
  return Rf === void 0 && (typeof CSS < "u" && typeof CSS.supports == "function" ? Rf = CSS.supports("touch-action", "none") : Rf = !0), Rf;
}
function g7(e) {
  const {
    "aria-labelledby": t,
    defaultValue: n,
    disabled: r = !1,
    disableSwap: i = !1,
    isRtl: s = !1,
    marks: l = !1,
    max: c = 100,
    min: u = 0,
    name: d,
    onChange: h,
    onChangeCommitted: p,
    orientation: v = "horizontal",
    rootRef: m,
    scale: g = m7,
    step: b = 1,
    shiftStep: x = 10,
    tabIndex: w,
    value: T
  } = e, S = K.useRef(void 0), [C, E] = K.useState(-1), [O, B] = K.useState(-1), [N, L] = K.useState(!1), k = K.useRef(0), F = K.useRef(null), [G, M] = tp({
    controlled: T,
    default: n ?? u,
    name: "Slider"
  }), j = h && ((Nt, Bt, Rt) => {
    const Dt = Nt.nativeEvent || Nt, jt = new Dt.constructor(Dt.type, Dt);
    Object.defineProperty(jt, "target", {
      writable: !0,
      value: {
        value: Bt,
        name: d
      }
    }), F.current = Bt, h(jt, Bt, Rt);
  }), D = Array.isArray(G);
  let z = D ? G.slice().sort(WS) : [G];
  z = z.map((Nt) => Nt == null ? u : xc(Nt, u, c));
  const H = l === !0 && b !== null ? [...Array(Math.floor((c - u) / b) + 1)].map((Nt, Bt) => ({
    value: u + b * Bt
  })) : l || [], X = H.map((Nt) => Nt.value), [Y, V] = K.useState(-1), Z = K.useRef(null), ct = ar(m, Z), et = (Nt) => (Bt) => {
    var Dt;
    const Rt = Number(Bt.currentTarget.getAttribute("data-index"));
    Ic(Bt.target) && V(Rt), B(Rt), (Dt = Nt == null ? void 0 : Nt.onFocus) == null || Dt.call(Nt, Bt);
  }, rt = (Nt) => (Bt) => {
    var Rt;
    Ic(Bt.target) || V(-1), B(-1), (Rt = Nt == null ? void 0 : Nt.onBlur) == null || Rt.call(Nt, Bt);
  }, st = (Nt, Bt) => {
    const Rt = Number(Nt.currentTarget.getAttribute("data-index")), Dt = z[Rt], jt = X.indexOf(Dt);
    let Ft = Bt;
    if (H && b == null) {
      const Vt = X[X.length - 1];
      Ft >= Vt ? Ft = Vt : Ft <= X[0] ? Ft = X[0] : Ft = Ft < Dt ? X[jt - 1] : X[jt + 1];
    }
    if (Ft = xc(Ft, u, c), D) {
      i && (Ft = xc(Ft, z[Rt - 1] || -1 / 0, z[Rt + 1] || 1 / 0));
      const Vt = Ft;
      Ft = kb({
        values: z,
        newValue: Ft,
        index: Rt
      });
      let Yt = Rt;
      i || (Yt = Ft.indexOf(Vt)), Af({
        sliderRef: Z,
        activeIndex: Yt
      });
    }
    M(Ft), V(Rt), j && !kf(Ft, G) && j(Nt, Ft, Rt), p && p(Nt, F.current ?? Ft);
  }, yt = (Nt) => (Bt) => {
    var Rt;
    if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "PageUp", "PageDown", "Home", "End"].includes(Bt.key)) {
      Bt.preventDefault();
      const Dt = Number(Bt.currentTarget.getAttribute("data-index")), jt = z[Dt];
      let Ft = null;
      if (b != null) {
        const Vt = Bt.shiftKey ? x : b;
        switch (Bt.key) {
          case "ArrowUp":
            Ft = _c(jt, Vt, 1, u, c);
            break;
          case "ArrowRight":
            Ft = _c(jt, Vt, s ? -1 : 1, u, c);
            break;
          case "ArrowDown":
            Ft = _c(jt, Vt, -1, u, c);
            break;
          case "ArrowLeft":
            Ft = _c(jt, Vt, s ? 1 : -1, u, c);
            break;
          case "PageUp":
            Ft = _c(jt, x, 1, u, c);
            break;
          case "PageDown":
            Ft = _c(jt, x, -1, u, c);
            break;
          case "Home":
            Ft = u;
            break;
          case "End":
            Ft = c;
            break;
        }
      } else if (H) {
        const Vt = X[X.length - 1], Yt = X.indexOf(jt), ee = [s ? "ArrowRight" : "ArrowLeft", "ArrowDown", "PageDown", "Home"], fe = [s ? "ArrowLeft" : "ArrowRight", "ArrowUp", "PageUp", "End"];
        ee.includes(Bt.key) ? Yt === 0 ? Ft = X[0] : Ft = X[Yt - 1] : fe.includes(Bt.key) && (Yt === X.length - 1 ? Ft = Vt : Ft = X[Yt + 1]);
      }
      Ft != null && st(Bt, Ft);
    }
    (Rt = Nt == null ? void 0 : Nt.onKeyDown) == null || Rt.call(Nt, Bt);
  };
  ls(() => {
    var Nt;
    r && Z.current.contains(document.activeElement) && ((Nt = document.activeElement) == null || Nt.blur());
  }, [r]), r && C !== -1 && E(-1), r && Y !== -1 && V(-1);
  const J = (Nt) => (Bt) => {
    var Rt;
    (Rt = Nt.onChange) == null || Rt.call(Nt, Bt), st(Bt, Bt.target.valueAsNumber);
  }, tt = K.useRef(void 0);
  let ot = v;
  s && v === "horizontal" && (ot += "-reverse");
  const Tt = ({
    finger: Nt,
    move: Bt = !1
  }) => {
    const {
      current: Rt
    } = Z, {
      width: Dt,
      height: jt,
      bottom: Ft,
      left: Vt
    } = Rt.getBoundingClientRect();
    let Yt;
    ot.startsWith("vertical") ? Yt = (Ft - Nt.y) / jt : Yt = (Nt.x - Vt) / Dt, ot.includes("-reverse") && (Yt = 1 - Yt);
    let ee;
    if (ee = d7(Yt, u, c), b)
      ee = f7(ee, b, u);
    else {
      const ie = Ab(X, ee);
      ee = X[ie];
    }
    ee = xc(ee, u, c);
    let fe = 0;
    if (D) {
      Bt ? fe = tt.current : fe = Ab(z, ee), i && (ee = xc(ee, z[fe - 1] || -1 / 0, z[fe + 1] || 1 / 0));
      const ie = ee;
      ee = kb({
        values: z,
        newValue: ee,
        index: fe
      }), i && Bt || (fe = ee.indexOf(ie), tt.current = fe);
    }
    return {
      newValue: ee,
      activeIndex: fe
    };
  }, Ct = Vi((Nt) => {
    const Bt = Ef(Nt, S);
    if (!Bt)
      return;
    if (k.current += 1, Nt.type === "mousemove" && Nt.buttons === 0) {
      bt(Nt);
      return;
    }
    const {
      newValue: Rt,
      activeIndex: Dt
    } = Tt({
      finger: Bt,
      move: !0
    });
    Af({
      sliderRef: Z,
      activeIndex: Dt,
      setActive: E
    }), M(Rt), !N && k.current > u7 && L(!0), j && !kf(Rt, G) && j(Nt, Rt, Dt);
  }), bt = Vi((Nt) => {
    const Bt = Ef(Nt, S);
    if (L(!1), !Bt)
      return;
    const {
      newValue: Rt
    } = Tt({
      finger: Bt,
      move: !0
    });
    E(-1), Nt.type === "touchend" && B(-1), p && p(Nt, F.current ?? Rt), S.current = void 0, $t();
  }), Ht = Vi((Nt) => {
    if (r)
      return;
    Rb() || Nt.preventDefault();
    const Bt = Nt.changedTouches[0];
    Bt != null && (S.current = Bt.identifier);
    const Rt = Ef(Nt, S);
    if (Rt !== !1) {
      const {
        newValue: jt,
        activeIndex: Ft
      } = Tt({
        finger: Rt
      });
      Af({
        sliderRef: Z,
        activeIndex: Ft,
        setActive: E
      }), M(jt), j && !kf(jt, G) && j(Nt, jt, Ft);
    }
    k.current = 0;
    const Dt = Er(Z.current);
    Dt.addEventListener("touchmove", Ct, {
      passive: !0
    }), Dt.addEventListener("touchend", bt, {
      passive: !0
    });
  }), $t = K.useCallback(() => {
    const Nt = Er(Z.current);
    Nt.removeEventListener("mousemove", Ct), Nt.removeEventListener("mouseup", bt), Nt.removeEventListener("touchmove", Ct), Nt.removeEventListener("touchend", bt);
  }, [bt, Ct]);
  K.useEffect(() => {
    const {
      current: Nt
    } = Z;
    return Nt.addEventListener("touchstart", Ht, {
      passive: Rb()
    }), () => {
      Nt.removeEventListener("touchstart", Ht), $t();
    };
  }, [$t, Ht]), K.useEffect(() => {
    r && $t();
  }, [r, $t]);
  const wt = (Nt) => (Bt) => {
    var jt;
    if ((jt = Nt.onMouseDown) == null || jt.call(Nt, Bt), r || Bt.defaultPrevented || Bt.button !== 0)
      return;
    Bt.preventDefault();
    const Rt = Ef(Bt, S);
    if (Rt !== !1) {
      const {
        newValue: Ft,
        activeIndex: Vt
      } = Tt({
        finger: Rt
      });
      Af({
        sliderRef: Z,
        activeIndex: Vt,
        setActive: E
      }), M(Ft), j && !kf(Ft, G) && j(Bt, Ft, Vt);
    }
    k.current = 0;
    const Dt = Er(Z.current);
    Dt.addEventListener("mousemove", Ct, {
      passive: !0
    }), Dt.addEventListener("mouseup", bt);
  }, Wt = lp(D ? z[0] : u, u, c), Ut = lp(z[z.length - 1], u, c) - Wt, ne = (Nt = {}) => {
    const Bt = Kd(Nt), Rt = {
      onMouseDown: wt(Bt || {})
    }, Dt = {
      ...Bt,
      ...Rt
    };
    return {
      ...Nt,
      ref: ct,
      ...Dt
    };
  }, ce = (Nt) => (Bt) => {
    var Dt;
    (Dt = Nt.onMouseOver) == null || Dt.call(Nt, Bt);
    const Rt = Number(Bt.currentTarget.getAttribute("data-index"));
    B(Rt);
  }, re = (Nt) => (Bt) => {
    var Rt;
    (Rt = Nt.onMouseLeave) == null || Rt.call(Nt, Bt), B(-1);
  }, le = (Nt = {}) => {
    const Bt = Kd(Nt), Rt = {
      onMouseOver: ce(Bt || {}),
      onMouseLeave: re(Bt || {})
    };
    return {
      ...Nt,
      ...Bt,
      ...Rt
    };
  }, Lt = (Nt) => ({
    // So the non active thumb doesn't show its label on hover.
    pointerEvents: C !== -1 && C !== Nt ? "none" : void 0
  });
  let ye;
  return v === "vertical" && (ye = s ? "vertical-rl" : "vertical-lr"), {
    active: C,
    axis: ot,
    axisProps: p7,
    dragging: N,
    focusedThumbIndex: Y,
    getHiddenInputProps: (Nt = {}) => {
      const Bt = Kd(Nt), Rt = {
        onChange: J(Bt || {}),
        onFocus: et(Bt || {}),
        onBlur: rt(Bt || {}),
        onKeyDown: yt(Bt || {})
      }, Dt = {
        ...Bt,
        ...Rt
      };
      return {
        tabIndex: w,
        "aria-labelledby": t,
        "aria-orientation": v,
        "aria-valuemax": g(c),
        "aria-valuemin": g(u),
        name: d,
        type: "range",
        min: e.min,
        max: e.max,
        step: e.step === null && e.marks ? "any" : e.step ?? void 0,
        disabled: r,
        ...Nt,
        ...Dt,
        style: {
          ...XC,
          direction: s ? "rtl" : "ltr",
          // So that VoiceOver's focus indicator matches the thumb's dimensions
          width: "100%",
          height: "100%",
          writingMode: ye
        }
      };
    },
    getRootProps: ne,
    getThumbProps: le,
    marks: H,
    open: O,
    range: D,
    rootRef: ct,
    trackLeap: Ut,
    trackOffset: Wt,
    values: z,
    getThumbStyle: Lt
  };
}
const y7 = (e) => !e || !ul(e);
function v7(e) {
  return Qe("MuiSlider", e);
}
const Ui = Xe("MuiSlider", ["root", "active", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "disabled", "dragging", "focusVisible", "mark", "markActive", "marked", "markLabel", "markLabelActive", "rail", "sizeSmall", "thumb", "thumbColorPrimary", "thumbColorSecondary", "thumbColorError", "thumbColorSuccess", "thumbColorInfo", "thumbColorWarning", "track", "trackInverted", "trackFalse", "thumbSizeSmall", "valueLabel", "valueLabelOpen", "valueLabelCircle", "valueLabelLabel", "vertical"]), b7 = (e) => {
  const {
    open: t
  } = e;
  return {
    offset: ge(t && Ui.valueLabelOpen),
    circle: Ui.valueLabelCircle,
    label: Ui.valueLabelLabel
  };
};
function _7(e) {
  const {
    children: t,
    className: n,
    value: r
  } = e, i = b7(e);
  return t ? /* @__PURE__ */ K.cloneElement(t, {
    className: ge(t.props.className)
  }, /* @__PURE__ */ W.jsxs(K.Fragment, {
    children: [t.props.children, /* @__PURE__ */ W.jsx("span", {
      className: ge(i.offset, n),
      "aria-hidden": !0,
      children: /* @__PURE__ */ W.jsx("span", {
        className: i.circle,
        children: /* @__PURE__ */ W.jsx("span", {
          className: i.label,
          children: r
        })
      })
    })]
  })) : null;
}
function Mb(e) {
  return e;
}
const S7 = he("span", {
  name: "MuiSlider",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, t[`color${pe(n.color)}`], n.size !== "medium" && t[`size${pe(n.size)}`], n.marked && t.marked, n.orientation === "vertical" && t.vertical, n.track === "inverted" && t.trackInverted, n.track === !1 && t.trackFalse];
  }
})(He(({
  theme: e
}) => ({
  borderRadius: 12,
  boxSizing: "content-box",
  display: "inline-block",
  position: "relative",
  cursor: "pointer",
  touchAction: "none",
  WebkitTapHighlightColor: "transparent",
  "@media print": {
    colorAdjust: "exact"
  },
  [`&.${Ui.disabled}`]: {
    pointerEvents: "none",
    cursor: "default",
    color: (e.vars || e).palette.grey[400]
  },
  [`&.${Ui.dragging}`]: {
    [`& .${Ui.thumb}, & .${Ui.track}`]: {
      transition: "none"
    }
  },
  variants: [...Object.entries(e.palette).filter(Ei()).map(([t]) => ({
    props: {
      color: t
    },
    style: {
      color: (e.vars || e).palette[t].main
    }
  })), {
    props: {
      orientation: "horizontal"
    },
    style: {
      height: 4,
      width: "100%",
      padding: "13px 0",
      // The primary input mechanism of the device includes a pointing device of limited accuracy.
      "@media (pointer: coarse)": {
        // Reach 42px touch target, about ~8mm on screen.
        padding: "20px 0"
      }
    }
  }, {
    props: {
      orientation: "horizontal",
      size: "small"
    },
    style: {
      height: 2
    }
  }, {
    props: {
      orientation: "horizontal",
      marked: !0
    },
    style: {
      marginBottom: 20
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      height: "100%",
      width: 4,
      padding: "0 13px",
      // The primary input mechanism of the device includes a pointing device of limited accuracy.
      "@media (pointer: coarse)": {
        // Reach 42px touch target, about ~8mm on screen.
        padding: "0 20px"
      }
    }
  }, {
    props: {
      orientation: "vertical",
      size: "small"
    },
    style: {
      width: 2
    }
  }, {
    props: {
      orientation: "vertical",
      marked: !0
    },
    style: {
      marginRight: 44
    }
  }]
}))), x7 = he("span", {
  name: "MuiSlider",
  slot: "Rail",
  overridesResolver: (e, t) => t.rail
})({
  display: "block",
  position: "absolute",
  borderRadius: "inherit",
  backgroundColor: "currentColor",
  opacity: 0.38,
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      width: "100%",
      height: "inherit",
      top: "50%",
      transform: "translateY(-50%)"
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      height: "100%",
      width: "inherit",
      left: "50%",
      transform: "translateX(-50%)"
    }
  }, {
    props: {
      track: "inverted"
    },
    style: {
      opacity: 1
    }
  }]
}), T7 = he("span", {
  name: "MuiSlider",
  slot: "Track",
  overridesResolver: (e, t) => t.track
})(He(({
  theme: e
}) => ({
  display: "block",
  position: "absolute",
  borderRadius: "inherit",
  border: "1px solid currentColor",
  backgroundColor: "currentColor",
  transition: e.transitions.create(["left", "width", "bottom", "height"], {
    duration: e.transitions.duration.shortest
  }),
  variants: [{
    props: {
      size: "small"
    },
    style: {
      border: "none"
    }
  }, {
    props: {
      orientation: "horizontal"
    },
    style: {
      height: "inherit",
      top: "50%",
      transform: "translateY(-50%)"
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      width: "inherit",
      left: "50%",
      transform: "translateX(-50%)"
    }
  }, {
    props: {
      track: !1
    },
    style: {
      display: "none"
    }
  }, ...Object.entries(e.palette).filter(Ei()).map(([t]) => ({
    props: {
      color: t,
      track: "inverted"
    },
    style: {
      ...e.vars ? {
        backgroundColor: e.vars.palette.Slider[`${t}Track`],
        borderColor: e.vars.palette.Slider[`${t}Track`]
      } : {
        backgroundColor: sh(e.palette[t].main, 0.62),
        borderColor: sh(e.palette[t].main, 0.62),
        ...e.applyStyles("dark", {
          backgroundColor: ih(e.palette[t].main, 0.5)
        }),
        ...e.applyStyles("dark", {
          borderColor: ih(e.palette[t].main, 0.5)
        })
      }
    }
  }))]
}))), C7 = he("span", {
  name: "MuiSlider",
  slot: "Thumb",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.thumb, t[`thumbColor${pe(n.color)}`], n.size !== "medium" && t[`thumbSize${pe(n.size)}`]];
  }
})(He(({
  theme: e
}) => ({
  position: "absolute",
  width: 20,
  height: 20,
  boxSizing: "border-box",
  borderRadius: "50%",
  outline: 0,
  backgroundColor: "currentColor",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  transition: e.transitions.create(["box-shadow", "left", "bottom"], {
    duration: e.transitions.duration.shortest
  }),
  "&::before": {
    position: "absolute",
    content: '""',
    borderRadius: "inherit",
    width: "100%",
    height: "100%",
    boxShadow: (e.vars || e).shadows[2]
  },
  "&::after": {
    position: "absolute",
    content: '""',
    borderRadius: "50%",
    // 42px is the hit target
    width: 42,
    height: 42,
    top: "50%",
    left: "50%",
    transform: "translate(-50%, -50%)"
  },
  [`&.${Ui.disabled}`]: {
    "&:hover": {
      boxShadow: "none"
    }
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      width: 12,
      height: 12,
      "&::before": {
        boxShadow: "none"
      }
    }
  }, {
    props: {
      orientation: "horizontal"
    },
    style: {
      top: "50%",
      transform: "translate(-50%, -50%)"
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      left: "50%",
      transform: "translate(-50%, 50%)"
    }
  }, ...Object.entries(e.palette).filter(Ei()).map(([t]) => ({
    props: {
      color: t
    },
    style: {
      [`&:hover, &.${Ui.focusVisible}`]: {
        ...e.vars ? {
          boxShadow: `0px 0px 0px 8px rgba(${e.vars.palette[t].mainChannel} / 0.16)`
        } : {
          boxShadow: `0px 0px 0px 8px ${xn(e.palette[t].main, 0.16)}`
        },
        "@media (hover: none)": {
          boxShadow: "none"
        }
      },
      [`&.${Ui.active}`]: {
        ...e.vars ? {
          boxShadow: `0px 0px 0px 14px rgba(${e.vars.palette[t].mainChannel} / 0.16)`
        } : {
          boxShadow: `0px 0px 0px 14px ${xn(e.palette[t].main, 0.16)}`
        }
      }
    }
  }))]
}))), w7 = he(_7, {
  name: "MuiSlider",
  slot: "ValueLabel",
  overridesResolver: (e, t) => t.valueLabel
})(He(({
  theme: e
}) => ({
  zIndex: 1,
  whiteSpace: "nowrap",
  ...e.typography.body2,
  fontWeight: 500,
  transition: e.transitions.create(["transform"], {
    duration: e.transitions.duration.shortest
  }),
  position: "absolute",
  backgroundColor: (e.vars || e).palette.grey[600],
  borderRadius: 2,
  color: (e.vars || e).palette.common.white,
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  padding: "0.25rem 0.75rem",
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      transform: "translateY(-100%) scale(0)",
      top: "-10px",
      transformOrigin: "bottom center",
      "&::before": {
        position: "absolute",
        content: '""',
        width: 8,
        height: 8,
        transform: "translate(-50%, 50%) rotate(45deg)",
        backgroundColor: "inherit",
        bottom: 0,
        left: "50%"
      },
      [`&.${Ui.valueLabelOpen}`]: {
        transform: "translateY(-100%) scale(1)"
      }
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      transform: "translateY(-50%) scale(0)",
      right: "30px",
      top: "50%",
      transformOrigin: "right center",
      "&::before": {
        position: "absolute",
        content: '""',
        width: 8,
        height: 8,
        transform: "translate(-50%, -50%) rotate(45deg)",
        backgroundColor: "inherit",
        right: -8,
        top: "50%"
      },
      [`&.${Ui.valueLabelOpen}`]: {
        transform: "translateY(-50%) scale(1)"
      }
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      fontSize: e.typography.pxToRem(12),
      padding: "0.25rem 0.5rem"
    }
  }, {
    props: {
      orientation: "vertical",
      size: "small"
    },
    style: {
      right: "20px"
    }
  }]
}))), E7 = he("span", {
  name: "MuiSlider",
  slot: "Mark",
  shouldForwardProp: (e) => Vp(e) && e !== "markActive",
  overridesResolver: (e, t) => {
    const {
      markActive: n
    } = e;
    return [t.mark, n && t.markActive];
  }
})(He(({
  theme: e
}) => ({
  position: "absolute",
  width: 2,
  height: 2,
  borderRadius: 1,
  backgroundColor: "currentColor",
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      top: "50%",
      transform: "translate(-1px, -50%)"
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      left: "50%",
      transform: "translate(-50%, 1px)"
    }
  }, {
    props: {
      markActive: !0
    },
    style: {
      backgroundColor: (e.vars || e).palette.background.paper,
      opacity: 0.8
    }
  }]
}))), A7 = he("span", {
  name: "MuiSlider",
  slot: "MarkLabel",
  shouldForwardProp: (e) => Vp(e) && e !== "markLabelActive",
  overridesResolver: (e, t) => t.markLabel
})(He(({
  theme: e
}) => ({
  ...e.typography.body2,
  color: (e.vars || e).palette.text.secondary,
  position: "absolute",
  whiteSpace: "nowrap",
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      top: 30,
      transform: "translateX(-50%)",
      "@media (pointer: coarse)": {
        top: 40
      }
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      left: 36,
      transform: "translateY(50%)",
      "@media (pointer: coarse)": {
        left: 44
      }
    }
  }, {
    props: {
      markLabelActive: !0
    },
    style: {
      color: (e.vars || e).palette.text.primary
    }
  }]
}))), k7 = (e) => {
  const {
    disabled: t,
    dragging: n,
    marked: r,
    orientation: i,
    track: s,
    classes: l,
    color: c,
    size: u
  } = e, d = {
    root: ["root", t && "disabled", n && "dragging", r && "marked", i === "vertical" && "vertical", s === "inverted" && "trackInverted", s === !1 && "trackFalse", c && `color${pe(c)}`, u && `size${pe(u)}`],
    rail: ["rail"],
    track: ["track"],
    mark: ["mark"],
    markActive: ["markActive"],
    markLabel: ["markLabel"],
    markLabelActive: ["markLabelActive"],
    valueLabel: ["valueLabel"],
    thumb: ["thumb", t && "disabled", u && `thumbSize${pe(u)}`, c && `thumbColor${pe(c)}`],
    active: ["active"],
    disabled: ["disabled"],
    focusVisible: ["focusVisible"]
  };
  return Ze(d, v7, l);
}, R7 = ({
  children: e
}) => e, Ob = /* @__PURE__ */ K.forwardRef(function(t, n) {
  const r = nn({
    props: t,
    name: "MuiSlider"
  }), i = zp(), {
    "aria-label": s,
    "aria-valuetext": l,
    "aria-labelledby": c,
    // eslint-disable-next-line react/prop-types
    component: u = "span",
    components: d = {},
    componentsProps: h = {},
    color: p = "primary",
    classes: v,
    className: m,
    disableSwap: g = !1,
    disabled: b = !1,
    getAriaLabel: x,
    getAriaValueText: w,
    marks: T = !1,
    max: S = 100,
    min: C = 0,
    name: E,
    onChange: O,
    onChangeCommitted: B,
    orientation: N = "horizontal",
    shiftStep: L = 10,
    size: k = "medium",
    step: F = 1,
    scale: G = Mb,
    slotProps: M,
    slots: j,
    tabIndex: D,
    track: z = "normal",
    value: H,
    valueLabelDisplay: X = "off",
    valueLabelFormat: Y = Mb,
    ...V
  } = r, Z = {
    ...r,
    isRtl: i,
    max: S,
    min: C,
    classes: v,
    disabled: b,
    disableSwap: g,
    orientation: N,
    marks: T,
    color: p,
    size: k,
    step: F,
    shiftStep: L,
    scale: G,
    track: z,
    valueLabelDisplay: X,
    valueLabelFormat: Y
  }, {
    axisProps: ct,
    getRootProps: et,
    getHiddenInputProps: rt,
    getThumbProps: st,
    open: yt,
    active: J,
    axis: tt,
    focusedThumbIndex: ot,
    range: Tt,
    dragging: Ct,
    marks: bt,
    values: Ht,
    trackOffset: $t,
    trackLeap: wt,
    getThumbStyle: Wt
  } = g7({
    ...Z,
    rootRef: n
  });
  Z.marked = bt.length > 0 && bt.some((on) => on.label), Z.dragging = Ct, Z.focusedThumbIndex = ot;
  const Ut = k7(Z), ne = (j == null ? void 0 : j.root) ?? d.Root ?? S7, ce = (j == null ? void 0 : j.rail) ?? d.Rail ?? x7, re = (j == null ? void 0 : j.track) ?? d.Track ?? T7, le = (j == null ? void 0 : j.thumb) ?? d.Thumb ?? C7, Lt = (j == null ? void 0 : j.valueLabel) ?? d.ValueLabel ?? w7, ye = (j == null ? void 0 : j.mark) ?? d.Mark ?? E7, be = (j == null ? void 0 : j.markLabel) ?? d.MarkLabel ?? A7, Nt = (j == null ? void 0 : j.input) ?? d.Input ?? "input", Bt = (M == null ? void 0 : M.root) ?? h.root, Rt = (M == null ? void 0 : M.rail) ?? h.rail, Dt = (M == null ? void 0 : M.track) ?? h.track, jt = (M == null ? void 0 : M.thumb) ?? h.thumb, Ft = (M == null ? void 0 : M.valueLabel) ?? h.valueLabel, Vt = (M == null ? void 0 : M.mark) ?? h.mark, Yt = (M == null ? void 0 : M.markLabel) ?? h.markLabel, ee = (M == null ? void 0 : M.input) ?? h.input, fe = ws({
    elementType: ne,
    getSlotProps: et,
    externalSlotProps: Bt,
    externalForwardedProps: V,
    additionalProps: {
      ...y7(ne) && {
        as: u
      }
    },
    ownerState: {
      ...Z,
      ...Bt == null ? void 0 : Bt.ownerState
    },
    className: [Ut.root, m]
  }), ie = ws({
    elementType: ce,
    externalSlotProps: Rt,
    ownerState: Z,
    className: Ut.rail
  }), zt = ws({
    elementType: re,
    externalSlotProps: Dt,
    additionalProps: {
      style: {
        ...ct[tt].offset($t),
        ...ct[tt].leap(wt)
      }
    },
    ownerState: {
      ...Z,
      ...Dt == null ? void 0 : Dt.ownerState
    },
    className: Ut.track
  }), Pe = ws({
    elementType: le,
    getSlotProps: st,
    externalSlotProps: jt,
    ownerState: {
      ...Z,
      ...jt == null ? void 0 : jt.ownerState
    },
    className: Ut.thumb
  }), je = ws({
    elementType: Lt,
    externalSlotProps: Ft,
    ownerState: {
      ...Z,
      ...Ft == null ? void 0 : Ft.ownerState
    },
    className: Ut.valueLabel
  }), cr = ws({
    elementType: ye,
    externalSlotProps: Vt,
    ownerState: Z,
    className: Ut.mark
  }), se = ws({
    elementType: be,
    externalSlotProps: Yt,
    ownerState: Z,
    className: Ut.markLabel
  }), Sr = ws({
    elementType: Nt,
    getSlotProps: rt,
    externalSlotProps: ee,
    ownerState: Z
  });
  return /* @__PURE__ */ W.jsxs(ne, {
    ...fe,
    children: [/* @__PURE__ */ W.jsx(ce, {
      ...ie
    }), /* @__PURE__ */ W.jsx(re, {
      ...zt
    }), bt.filter((on) => on.value >= C && on.value <= S).map((on, Le) => {
      const ai = lp(on.value, C, S), kr = ct[tt].offset(ai);
      let ur;
      return z === !1 ? ur = Ht.includes(on.value) : ur = z === "normal" && (Tt ? on.value >= Ht[0] && on.value <= Ht[Ht.length - 1] : on.value <= Ht[0]) || z === "inverted" && (Tt ? on.value <= Ht[0] || on.value >= Ht[Ht.length - 1] : on.value >= Ht[0]), /* @__PURE__ */ W.jsxs(K.Fragment, {
        children: [/* @__PURE__ */ W.jsx(ye, {
          "data-index": Le,
          ...cr,
          ...!ul(ye) && {
            markActive: ur
          },
          style: {
            ...kr,
            ...cr.style
          },
          className: ge(cr.className, ur && Ut.markActive)
        }), on.label != null ? /* @__PURE__ */ W.jsx(be, {
          "aria-hidden": !0,
          "data-index": Le,
          ...se,
          ...!ul(be) && {
            markLabelActive: ur
          },
          style: {
            ...kr,
            ...se.style
          },
          className: ge(Ut.markLabel, se.className, ur && Ut.markLabelActive),
          children: on.label
        }) : null]
      }, Le);
    }), Ht.map((on, Le) => {
      const ai = lp(on, C, S), kr = ct[tt].offset(ai), ur = X === "off" ? R7 : Lt;
      return (
        /* TODO v6: Change component structure. It will help in avoiding the complicated React.cloneElement API added in SliderValueLabel component. Should be: Thumb -> Input, ValueLabel. Follow Joy UI's Slider structure. */
        /* @__PURE__ */ W.jsx(ur, {
          ...!ul(ur) && {
            valueLabelFormat: Y,
            valueLabelDisplay: X,
            value: typeof Y == "function" ? Y(G(on), Le) : Y,
            index: Le,
            open: yt === Le || J === Le || X === "on",
            disabled: b
          },
          ...je,
          children: /* @__PURE__ */ W.jsx(le, {
            "data-index": Le,
            ...Pe,
            className: ge(Ut.thumb, Pe.className, J === Le && Ut.active, ot === Le && Ut.focusVisible),
            style: {
              ...kr,
              ...Wt(Le),
              ...Pe.style
            },
            children: /* @__PURE__ */ W.jsx(Nt, {
              "data-index": Le,
              "aria-label": x ? x(Le) : s,
              "aria-valuenow": G(on),
              "aria-labelledby": c,
              "aria-valuetext": w ? w(G(on), Le) : l,
              value: Ht[Le],
              ...Sr
            })
          })
        }, Le)
      );
    })]
  });
});
function M7(e) {
  return Qe("MuiTooltip", e);
}
const Vn = Xe("MuiTooltip", ["popper", "popperInteractive", "popperArrow", "popperClose", "tooltip", "tooltipArrow", "touch", "tooltipPlacementLeft", "tooltipPlacementRight", "tooltipPlacementTop", "tooltipPlacementBottom", "arrow"]);
function O7(e) {
  return Math.round(e * 1e5) / 1e5;
}
const N7 = (e) => {
  const {
    classes: t,
    disableInteractive: n,
    arrow: r,
    touch: i,
    placement: s
  } = e, l = {
    popper: ["popper", !n && "popperInteractive", r && "popperArrow"],
    tooltip: ["tooltip", r && "tooltipArrow", i && "touch", `tooltipPlacement${pe(s.split("-")[0])}`],
    arrow: ["arrow"]
  };
  return Ze(l, M7, t);
}, P7 = he(FS, {
  name: "MuiTooltip",
  slot: "Popper",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.popper, !n.disableInteractive && t.popperInteractive, n.arrow && t.popperArrow, !n.open && t.popperClose];
  }
})(He(({
  theme: e
}) => ({
  zIndex: (e.vars || e).zIndex.tooltip,
  pointerEvents: "none",
  variants: [{
    props: ({
      ownerState: t
    }) => !t.disableInteractive,
    style: {
      pointerEvents: "auto"
    }
  }, {
    props: ({
      open: t
    }) => !t,
    style: {
      pointerEvents: "none"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.arrow,
    style: {
      [`&[data-popper-placement*="bottom"] .${Vn.arrow}`]: {
        top: 0,
        marginTop: "-0.71em",
        "&::before": {
          transformOrigin: "0 100%"
        }
      },
      [`&[data-popper-placement*="top"] .${Vn.arrow}`]: {
        bottom: 0,
        marginBottom: "-0.71em",
        "&::before": {
          transformOrigin: "100% 0"
        }
      },
      [`&[data-popper-placement*="right"] .${Vn.arrow}`]: {
        height: "1em",
        width: "0.71em",
        "&::before": {
          transformOrigin: "100% 100%"
        }
      },
      [`&[data-popper-placement*="left"] .${Vn.arrow}`]: {
        height: "1em",
        width: "0.71em",
        "&::before": {
          transformOrigin: "0 0"
        }
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.arrow && !t.isRtl,
    style: {
      [`&[data-popper-placement*="right"] .${Vn.arrow}`]: {
        left: 0,
        marginLeft: "-0.71em"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.arrow && !!t.isRtl,
    style: {
      [`&[data-popper-placement*="right"] .${Vn.arrow}`]: {
        right: 0,
        marginRight: "-0.71em"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.arrow && !t.isRtl,
    style: {
      [`&[data-popper-placement*="left"] .${Vn.arrow}`]: {
        right: 0,
        marginRight: "-0.71em"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.arrow && !!t.isRtl,
    style: {
      [`&[data-popper-placement*="left"] .${Vn.arrow}`]: {
        left: 0,
        marginLeft: "-0.71em"
      }
    }
  }]
}))), D7 = he("div", {
  name: "MuiTooltip",
  slot: "Tooltip",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.tooltip, n.touch && t.touch, n.arrow && t.tooltipArrow, t[`tooltipPlacement${pe(n.placement.split("-")[0])}`]];
  }
})(He(({
  theme: e
}) => ({
  backgroundColor: e.vars ? e.vars.palette.Tooltip.bg : xn(e.palette.grey[700], 0.92),
  borderRadius: (e.vars || e).shape.borderRadius,
  color: (e.vars || e).palette.common.white,
  fontFamily: e.typography.fontFamily,
  padding: "4px 8px",
  fontSize: e.typography.pxToRem(11),
  maxWidth: 300,
  margin: 2,
  wordWrap: "break-word",
  fontWeight: e.typography.fontWeightMedium,
  [`.${Vn.popper}[data-popper-placement*="left"] &`]: {
    transformOrigin: "right center"
  },
  [`.${Vn.popper}[data-popper-placement*="right"] &`]: {
    transformOrigin: "left center"
  },
  [`.${Vn.popper}[data-popper-placement*="top"] &`]: {
    transformOrigin: "center bottom",
    marginBottom: "14px"
  },
  [`.${Vn.popper}[data-popper-placement*="bottom"] &`]: {
    transformOrigin: "center top",
    marginTop: "14px"
  },
  variants: [{
    props: ({
      ownerState: t
    }) => t.arrow,
    style: {
      position: "relative",
      margin: 0
    }
  }, {
    props: ({
      ownerState: t
    }) => t.touch,
    style: {
      padding: "8px 16px",
      fontSize: e.typography.pxToRem(14),
      lineHeight: `${O7(16 / 14)}em`,
      fontWeight: e.typography.fontWeightRegular
    }
  }, {
    props: ({
      ownerState: t
    }) => !t.isRtl,
    style: {
      [`.${Vn.popper}[data-popper-placement*="left"] &`]: {
        marginRight: "14px"
      },
      [`.${Vn.popper}[data-popper-placement*="right"] &`]: {
        marginLeft: "14px"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => !t.isRtl && t.touch,
    style: {
      [`.${Vn.popper}[data-popper-placement*="left"] &`]: {
        marginRight: "24px"
      },
      [`.${Vn.popper}[data-popper-placement*="right"] &`]: {
        marginLeft: "24px"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => !!t.isRtl,
    style: {
      [`.${Vn.popper}[data-popper-placement*="left"] &`]: {
        marginLeft: "14px"
      },
      [`.${Vn.popper}[data-popper-placement*="right"] &`]: {
        marginRight: "14px"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => !!t.isRtl && t.touch,
    style: {
      [`.${Vn.popper}[data-popper-placement*="left"] &`]: {
        marginLeft: "24px"
      },
      [`.${Vn.popper}[data-popper-placement*="right"] &`]: {
        marginRight: "24px"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.touch,
    style: {
      [`.${Vn.popper}[data-popper-placement*="top"] &`]: {
        marginBottom: "24px"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.touch,
    style: {
      [`.${Vn.popper}[data-popper-placement*="bottom"] &`]: {
        marginTop: "24px"
      }
    }
  }]
}))), I7 = he("span", {
  name: "MuiTooltip",
  slot: "Arrow",
  overridesResolver: (e, t) => t.arrow
})(He(({
  theme: e
}) => ({
  overflow: "hidden",
  position: "absolute",
  width: "1em",
  height: "0.71em",
  boxSizing: "border-box",
  color: e.vars ? e.vars.palette.Tooltip.bg : xn(e.palette.grey[700], 0.9),
  "&::before": {
    content: '""',
    margin: "auto",
    display: "block",
    width: "100%",
    height: "100%",
    backgroundColor: "currentColor",
    transform: "rotate(45deg)"
  }
})));
let Mf = !1;
const Nb = new Lp();
let Yu = {
  x: 0,
  y: 0
};
function Of(e, t) {
  return (n, ...r) => {
    t && t(n, ...r), e(n, ...r);
  };
}
const Nf = /* @__PURE__ */ K.forwardRef(function(t, n) {
  const r = nn({
    props: t,
    name: "MuiTooltip"
  }), {
    arrow: i = !1,
    children: s,
    classes: l,
    components: c = {},
    componentsProps: u = {},
    describeChild: d = !1,
    disableFocusListener: h = !1,
    disableHoverListener: p = !1,
    disableInteractive: v = !1,
    disableTouchListener: m = !1,
    enterDelay: g = 100,
    enterNextDelay: b = 0,
    enterTouchDelay: x = 700,
    followCursor: w = !1,
    id: T,
    leaveDelay: S = 0,
    leaveTouchDelay: C = 1500,
    onClose: E,
    onOpen: O,
    open: B,
    placement: N = "bottom",
    PopperComponent: L,
    PopperProps: k = {},
    slotProps: F = {},
    slots: G = {},
    title: M,
    TransitionComponent: j,
    TransitionProps: D,
    ...z
  } = r, H = /* @__PURE__ */ K.isValidElement(s) ? s : /* @__PURE__ */ W.jsx("span", {
    children: s
  }), X = Up(), Y = zp(), [V, Z] = K.useState(), [ct, et] = K.useState(null), rt = K.useRef(!1), st = v || w, yt = Ec(), J = Ec(), tt = Ec(), ot = Ec(), [Tt, Ct] = tp({
    controlled: B,
    default: !1,
    name: "Tooltip",
    state: "open"
  });
  let bt = Tt;
  const Ht = bh(T), $t = K.useRef(), wt = Vi(() => {
    $t.current !== void 0 && (document.body.style.WebkitUserSelect = $t.current, $t.current = void 0), ot.clear();
  });
  K.useEffect(() => wt, [wt]);
  const Wt = (_e) => {
    Nb.clear(), Mf = !0, Ct(!0), O && !bt && O(_e);
  }, Ut = Vi(
    /**
     * @param {React.SyntheticEvent | Event} event
     */
    (_e) => {
      Nb.start(800 + S, () => {
        Mf = !1;
      }), Ct(!1), E && bt && E(_e), yt.start(X.transitions.duration.shortest, () => {
        rt.current = !1;
      });
    }
  ), ne = (_e) => {
    rt.current && _e.type !== "touchstart" || (V && V.removeAttribute("title"), J.clear(), tt.clear(), g || Mf && b ? J.start(Mf ? b : g, () => {
      Wt(_e);
    }) : Wt(_e));
  }, ce = (_e) => {
    J.clear(), tt.start(S, () => {
      Ut(_e);
    });
  }, [, re] = K.useState(!1), le = (_e) => {
    Ic(_e.target) || (re(!1), ce(_e));
  }, Lt = (_e) => {
    V || Z(_e.currentTarget), Ic(_e.target) && (re(!0), ne(_e));
  }, ye = (_e) => {
    rt.current = !0;
    const Nn = H.props;
    Nn.onTouchStart && Nn.onTouchStart(_e);
  }, be = (_e) => {
    ye(_e), tt.clear(), yt.clear(), wt(), $t.current = document.body.style.WebkitUserSelect, document.body.style.WebkitUserSelect = "none", ot.start(x, () => {
      document.body.style.WebkitUserSelect = $t.current, ne(_e);
    });
  }, Nt = (_e) => {
    H.props.onTouchEnd && H.props.onTouchEnd(_e), wt(), tt.start(C, () => {
      Ut(_e);
    });
  };
  K.useEffect(() => {
    if (!bt)
      return;
    function _e(Nn) {
      Nn.key === "Escape" && Ut(Nn);
    }
    return document.addEventListener("keydown", _e), () => {
      document.removeEventListener("keydown", _e);
    };
  }, [Ut, bt]);
  const Bt = ar(Qc(H), Z, n);
  !M && M !== 0 && (bt = !1);
  const Rt = K.useRef(), Dt = (_e) => {
    const Nn = H.props;
    Nn.onMouseMove && Nn.onMouseMove(_e), Yu = {
      x: _e.clientX,
      y: _e.clientY
    }, Rt.current && Rt.current.update();
  }, jt = {}, Ft = typeof M == "string";
  d ? (jt.title = !bt && Ft && !p ? M : null, jt["aria-describedby"] = bt ? Ht : null) : (jt["aria-label"] = Ft ? M : null, jt["aria-labelledby"] = bt && !Ft ? Ht : null);
  const Vt = {
    ...jt,
    ...z,
    ...H.props,
    className: ge(z.className, H.props.className),
    onTouchStart: ye,
    ref: Bt,
    ...w ? {
      onMouseMove: Dt
    } : {}
  }, Yt = {};
  m || (Vt.onTouchStart = be, Vt.onTouchEnd = Nt), p || (Vt.onMouseOver = Of(ne, Vt.onMouseOver), Vt.onMouseLeave = Of(ce, Vt.onMouseLeave), st || (Yt.onMouseOver = ne, Yt.onMouseLeave = ce)), h || (Vt.onFocus = Of(Lt, Vt.onFocus), Vt.onBlur = Of(le, Vt.onBlur), st || (Yt.onFocus = Lt, Yt.onBlur = le));
  const ee = {
    ...r,
    isRtl: Y,
    arrow: i,
    disableInteractive: st,
    placement: N,
    PopperComponentProp: L,
    touch: rt.current
  }, fe = typeof F.popper == "function" ? F.popper(ee) : F.popper, ie = K.useMemo(() => {
    var Nn, Ri;
    let _e = [{
      name: "arrow",
      enabled: !!ct,
      options: {
        element: ct,
        padding: 4
      }
    }];
    return (Nn = k.popperOptions) != null && Nn.modifiers && (_e = _e.concat(k.popperOptions.modifiers)), (Ri = fe == null ? void 0 : fe.popperOptions) != null && Ri.modifiers && (_e = _e.concat(fe.popperOptions.modifiers)), {
      ...k.popperOptions,
      ...fe == null ? void 0 : fe.popperOptions,
      modifiers: _e
    };
  }, [ct, k.popperOptions, fe == null ? void 0 : fe.popperOptions]), zt = N7(ee), Pe = typeof F.transition == "function" ? F.transition(ee) : F.transition, je = {
    slots: {
      popper: c.Popper,
      transition: c.Transition ?? j,
      tooltip: c.Tooltip,
      arrow: c.Arrow,
      ...G
    },
    slotProps: {
      arrow: F.arrow ?? u.arrow,
      popper: {
        ...k,
        ...fe ?? u.popper
      },
      // resolvedPopperProps can be spread because it's already an object
      tooltip: F.tooltip ?? u.tooltip,
      transition: {
        ...D,
        ...Pe ?? u.transition
      }
    }
  }, [cr, se] = $n("popper", {
    elementType: P7,
    externalForwardedProps: je,
    ownerState: ee,
    className: ge(zt.popper, k == null ? void 0 : k.className)
  }), [Sr, on] = $n("transition", {
    elementType: op,
    externalForwardedProps: je,
    ownerState: ee
  }), [Le, ai] = $n("tooltip", {
    elementType: D7,
    className: zt.tooltip,
    externalForwardedProps: je,
    ownerState: ee
  }), [kr, ur] = $n("arrow", {
    elementType: I7,
    className: zt.arrow,
    externalForwardedProps: je,
    ownerState: ee,
    ref: et
  });
  return /* @__PURE__ */ W.jsxs(K.Fragment, {
    children: [/* @__PURE__ */ K.cloneElement(H, Vt), /* @__PURE__ */ W.jsx(cr, {
      as: L ?? FS,
      placement: N,
      anchorEl: w ? {
        getBoundingClientRect: () => ({
          top: Yu.y,
          left: Yu.x,
          right: Yu.x,
          bottom: Yu.y,
          width: 0,
          height: 0
        })
      } : V,
      popperRef: Rt,
      open: V ? bt : !1,
      id: Ht,
      transition: !0,
      ...Yt,
      ...se,
      popperOptions: ie,
      children: ({
        TransitionProps: _e
      }) => /* @__PURE__ */ W.jsx(Sr, {
        timeout: X.transitions.duration.shorter,
        ..._e,
        ...on,
        children: /* @__PURE__ */ W.jsxs(Le, {
          ...ai,
          children: [M, i ? /* @__PURE__ */ W.jsx(kr, {
            ...ur
          }) : null]
        })
      })
    })]
  });
});
function B7(e) {
  return Qe("MuiTextField", e);
}
Xe("MuiTextField", ["root"]);
const F7 = {
  standard: ay,
  filled: oy,
  outlined: uy
}, j7 = (e) => {
  const {
    classes: t
  } = e;
  return Ze({
    root: ["root"]
  }, B7, t);
}, L7 = he(ZE, {
  name: "MuiTextField",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({}), hy = /* @__PURE__ */ K.forwardRef(function(t, n) {
  const r = nn({
    props: t,
    name: "MuiTextField"
  }), {
    autoComplete: i,
    autoFocus: s = !1,
    children: l,
    className: c,
    color: u = "primary",
    defaultValue: d,
    disabled: h = !1,
    error: p = !1,
    FormHelperTextProps: v,
    fullWidth: m = !1,
    helperText: g,
    id: b,
    InputLabelProps: x,
    inputProps: w,
    InputProps: T,
    inputRef: S,
    label: C,
    maxRows: E,
    minRows: O,
    multiline: B = !1,
    name: N,
    onBlur: L,
    onChange: k,
    onFocus: F,
    placeholder: G,
    required: M = !1,
    rows: j,
    select: D = !1,
    SelectProps: z,
    slots: H = {},
    slotProps: X = {},
    type: Y,
    value: V,
    variant: Z = "outlined",
    ...ct
  } = r, et = {
    ...r,
    autoFocus: s,
    color: u,
    disabled: h,
    error: p,
    fullWidth: m,
    multiline: B,
    required: M,
    select: D,
    variant: Z
  }, rt = j7(et), st = bh(b), yt = g && st ? `${st}-helper-text` : void 0, J = C && st ? `${st}-label` : void 0, tt = F7[Z], ot = {
    slots: H,
    slotProps: {
      input: T,
      inputLabel: x,
      htmlInput: w,
      formHelperText: v,
      select: z,
      ...X
    }
  }, Tt = {}, Ct = ot.slotProps.inputLabel;
  Z === "outlined" && (Ct && typeof Ct.shrink < "u" && (Tt.notched = Ct.shrink), Tt.label = C), D && ((!z || !z.native) && (Tt.id = void 0), Tt["aria-describedby"] = void 0);
  const [bt, Ht] = $n("input", {
    elementType: tt,
    externalForwardedProps: ot,
    additionalProps: Tt,
    ownerState: et
  }), [$t, wt] = $n("inputLabel", {
    elementType: m9,
    externalForwardedProps: ot,
    ownerState: et
  }), [Wt, Ut] = $n("htmlInput", {
    elementType: "input",
    externalForwardedProps: ot,
    ownerState: et
  }), [ne, ce] = $n("formHelperText", {
    elementType: n9,
    externalForwardedProps: ot,
    ownerState: et
  }), [re, le] = $n("select", {
    elementType: ap,
    externalForwardedProps: ot,
    ownerState: et
  }), Lt = /* @__PURE__ */ W.jsx(bt, {
    "aria-describedby": yt,
    autoComplete: i,
    autoFocus: s,
    defaultValue: d,
    fullWidth: m,
    multiline: B,
    name: N,
    rows: j,
    maxRows: E,
    minRows: O,
    type: Y,
    value: V,
    id: st,
    inputRef: S,
    onBlur: L,
    onChange: k,
    onFocus: F,
    placeholder: G,
    inputProps: Ut,
    slots: {
      input: H.htmlInput ? Wt : void 0
    },
    ...Ht
  });
  return /* @__PURE__ */ W.jsxs(L7, {
    className: ge(rt.root, c),
    disabled: h,
    error: p,
    fullWidth: m,
    ref: n,
    required: M,
    color: u,
    variant: Z,
    ownerState: et,
    ...ct,
    children: [C != null && C !== "" && /* @__PURE__ */ W.jsx($t, {
      htmlFor: st,
      id: J,
      ...wt,
      children: C
    }), D ? /* @__PURE__ */ W.jsx(re, {
      "aria-describedby": yt,
      id: st,
      labelId: J,
      value: V,
      input: Lt,
      ...le,
      children: l
    }) : Lt, g && /* @__PURE__ */ W.jsx(ne, {
      id: yt,
      ...ce,
      children: g
    })]
  });
});
function z7(e) {
  return Qe("MuiToggleButton", e);
}
const ol = Xe("MuiToggleButton", ["root", "disabled", "selected", "standard", "primary", "secondary", "sizeSmall", "sizeMedium", "sizeLarge", "fullWidth"]), $S = /* @__PURE__ */ K.createContext({}), KS = /* @__PURE__ */ K.createContext(void 0);
function U7(e, t) {
  return t === void 0 || e === void 0 ? !1 : Array.isArray(t) ? t.includes(e) : e === t;
}
const V7 = (e) => {
  const {
    classes: t,
    fullWidth: n,
    selected: r,
    disabled: i,
    size: s,
    color: l
  } = e, c = {
    root: ["root", r && "selected", i && "disabled", n && "fullWidth", `size${pe(s)}`, l]
  };
  return Ze(c, z7, t);
}, G7 = he(Gp, {
  name: "MuiToggleButton",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, t[`size${pe(n.size)}`]];
  }
})(He(({
  theme: e
}) => ({
  ...e.typography.button,
  borderRadius: (e.vars || e).shape.borderRadius,
  padding: 11,
  border: `1px solid ${(e.vars || e).palette.divider}`,
  color: (e.vars || e).palette.action.active,
  [`&.${ol.disabled}`]: {
    color: (e.vars || e).palette.action.disabled,
    border: `1px solid ${(e.vars || e).palette.action.disabledBackground}`
  },
  "&:hover": {
    textDecoration: "none",
    // Reset on mouse devices
    backgroundColor: e.vars ? `rgba(${e.vars.palette.text.primaryChannel} / ${e.vars.palette.action.hoverOpacity})` : xn(e.palette.text.primary, e.palette.action.hoverOpacity),
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  variants: [{
    props: {
      color: "standard"
    },
    style: {
      [`&.${ol.selected}`]: {
        color: (e.vars || e).palette.text.primary,
        backgroundColor: e.vars ? `rgba(${e.vars.palette.text.primaryChannel} / ${e.vars.palette.action.selectedOpacity})` : xn(e.palette.text.primary, e.palette.action.selectedOpacity),
        "&:hover": {
          backgroundColor: e.vars ? `rgba(${e.vars.palette.text.primaryChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.hoverOpacity}))` : xn(e.palette.text.primary, e.palette.action.selectedOpacity + e.palette.action.hoverOpacity),
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            backgroundColor: e.vars ? `rgba(${e.vars.palette.text.primaryChannel} / ${e.vars.palette.action.selectedOpacity})` : xn(e.palette.text.primary, e.palette.action.selectedOpacity)
          }
        }
      }
    }
  }, ...Object.entries(e.palette).filter(Ei()).map(([t]) => ({
    props: {
      color: t
    },
    style: {
      [`&.${ol.selected}`]: {
        color: (e.vars || e).palette[t].main,
        backgroundColor: e.vars ? `rgba(${e.vars.palette[t].mainChannel} / ${e.vars.palette.action.selectedOpacity})` : xn(e.palette[t].main, e.palette.action.selectedOpacity),
        "&:hover": {
          backgroundColor: e.vars ? `rgba(${e.vars.palette[t].mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.hoverOpacity}))` : xn(e.palette[t].main, e.palette.action.selectedOpacity + e.palette.action.hoverOpacity),
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            backgroundColor: e.vars ? `rgba(${e.vars.palette[t].mainChannel} / ${e.vars.palette.action.selectedOpacity})` : xn(e.palette[t].main, e.palette.action.selectedOpacity)
          }
        }
      }
    }
  })), {
    props: {
      fullWidth: !0
    },
    style: {
      width: "100%"
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      padding: 7,
      fontSize: e.typography.pxToRem(13)
    }
  }, {
    props: {
      size: "large"
    },
    style: {
      padding: 15,
      fontSize: e.typography.pxToRem(15)
    }
  }]
}))), Pb = /* @__PURE__ */ K.forwardRef(function(t, n) {
  const {
    value: r,
    ...i
  } = K.useContext($S), s = K.useContext(KS), l = rh({
    ...i,
    selected: U7(t.value, r)
  }, t), c = nn({
    props: l,
    name: "MuiToggleButton"
  }), {
    children: u,
    className: d,
    color: h = "standard",
    disabled: p = !1,
    disableFocusRipple: v = !1,
    fullWidth: m = !1,
    onChange: g,
    onClick: b,
    selected: x,
    size: w = "medium",
    value: T,
    ...S
  } = c, C = {
    ...c,
    color: h,
    disabled: p,
    disableFocusRipple: v,
    fullWidth: m,
    size: w
  }, E = V7(C), O = (N) => {
    b && (b(N, T), N.defaultPrevented) || g && g(N, T);
  }, B = s || "";
  return /* @__PURE__ */ W.jsx(G7, {
    className: ge(i.className, E.root, d, B),
    disabled: p,
    focusRipple: !v,
    ref: n,
    onClick: O,
    onChange: g,
    value: T,
    ownerState: C,
    "aria-pressed": x,
    ...S,
    children: u
  });
});
function q7(e) {
  return Qe("MuiToggleButtonGroup", e);
}
const En = Xe("MuiToggleButtonGroup", ["root", "selected", "horizontal", "vertical", "disabled", "grouped", "groupedHorizontal", "groupedVertical", "fullWidth", "firstButton", "lastButton", "middleButton"]), H7 = (e) => {
  const {
    classes: t,
    orientation: n,
    fullWidth: r,
    disabled: i
  } = e, s = {
    root: ["root", n, r && "fullWidth"],
    grouped: ["grouped", `grouped${pe(n)}`, i && "disabled"],
    firstButton: ["firstButton"],
    lastButton: ["lastButton"],
    middleButton: ["middleButton"]
  };
  return Ze(s, q7, t);
}, W7 = he("div", {
  name: "MuiToggleButtonGroup",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [{
      [`& .${En.grouped}`]: t.grouped
    }, {
      [`& .${En.grouped}`]: t[`grouped${pe(n.orientation)}`]
    }, {
      [`& .${En.firstButton}`]: t.firstButton
    }, {
      [`& .${En.lastButton}`]: t.lastButton
    }, {
      [`& .${En.middleButton}`]: t.middleButton
    }, t.root, n.orientation === "vertical" && t.vertical, n.fullWidth && t.fullWidth];
  }
})(He(({
  theme: e
}) => ({
  display: "inline-flex",
  borderRadius: (e.vars || e).shape.borderRadius,
  variants: [{
    props: {
      orientation: "vertical"
    },
    style: {
      flexDirection: "column",
      [`& .${En.grouped}`]: {
        [`&.${En.selected} + .${En.grouped}.${En.selected}`]: {
          borderTop: 0,
          marginTop: 0
        }
      },
      [`& .${En.firstButton},& .${En.middleButton}`]: {
        borderBottomLeftRadius: 0,
        borderBottomRightRadius: 0
      },
      [`& .${En.lastButton},& .${En.middleButton}`]: {
        marginTop: -1,
        borderTop: "1px solid transparent",
        borderTopLeftRadius: 0,
        borderTopRightRadius: 0
      },
      [`& .${En.lastButton}.${ol.disabled},& .${En.middleButton}.${ol.disabled}`]: {
        borderTop: "1px solid transparent"
      }
    }
  }, {
    props: {
      fullWidth: !0
    },
    style: {
      width: "100%"
    }
  }, {
    props: {
      orientation: "horizontal"
    },
    style: {
      [`& .${En.grouped}`]: {
        [`&.${En.selected} + .${En.grouped}.${En.selected}`]: {
          borderLeft: 0,
          marginLeft: 0
        }
      },
      [`& .${En.firstButton},& .${En.middleButton}`]: {
        borderTopRightRadius: 0,
        borderBottomRightRadius: 0
      },
      [`& .${En.lastButton},& .${En.middleButton}`]: {
        marginLeft: -1,
        borderLeft: "1px solid transparent",
        borderTopLeftRadius: 0,
        borderBottomLeftRadius: 0
      },
      [`& .${En.lastButton}.${ol.disabled},& .${En.middleButton}.${ol.disabled}`]: {
        borderLeft: "1px solid transparent"
      }
    }
  }]
}))), $7 = /* @__PURE__ */ K.forwardRef(function(t, n) {
  const r = nn({
    props: t,
    name: "MuiToggleButtonGroup"
  }), {
    children: i,
    className: s,
    color: l = "standard",
    disabled: c = !1,
    exclusive: u = !1,
    fullWidth: d = !1,
    onChange: h,
    orientation: p = "horizontal",
    size: v = "medium",
    value: m,
    ...g
  } = r, b = {
    ...r,
    disabled: c,
    fullWidth: d,
    orientation: p,
    size: v
  }, x = H7(b), w = K.useCallback((B, N) => {
    if (!h)
      return;
    const L = m && m.indexOf(N);
    let k;
    m && L >= 0 ? (k = m.slice(), k.splice(L, 1)) : k = m ? m.concat(N) : [N], h(B, k);
  }, [h, m]), T = K.useCallback((B, N) => {
    h && h(B, m === N ? null : N);
  }, [h, m]), S = K.useMemo(() => ({
    className: x.grouped,
    onChange: u ? T : w,
    value: m,
    size: v,
    fullWidth: d,
    color: l,
    disabled: c
  }), [x.grouped, u, T, w, m, v, d, l, c]), C = YC(i), E = C.length, O = (B) => {
    const N = B === 0, L = B === E - 1;
    return N && L ? "" : N ? x.firstButton : L ? x.lastButton : x.middleButton;
  };
  return /* @__PURE__ */ W.jsx(W7, {
    role: "group",
    className: ge(x.root, s),
    ref: n,
    ownerState: b,
    ...g,
    children: /* @__PURE__ */ W.jsx($S.Provider, {
      value: S,
      children: C.map((B, N) => /* @__PURE__ */ W.jsx(KS.Provider, {
        value: O(N),
        children: B
      }, N))
    })
  });
}), K7 = zr(/* @__PURE__ */ W.jsx("path", {
  d: "M8 5v14l11-7z"
}), "PlayArrow"), Y7 = zr(/* @__PURE__ */ W.jsx("path", {
  d: "M6 19h4V5H6zm8-14v14h4V5z"
}), "Pause"), X7 = zr(/* @__PURE__ */ W.jsx("path", {
  d: "M6 6h2v12H6zm3.5 6 8.5 6V6z"
}), "SkipPrevious"), Q7 = zr([/* @__PURE__ */ W.jsx("path", {
  d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"
}, "0"), /* @__PURE__ */ W.jsx("path", {
  d: "M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"
}, "1")], "ZoomIn"), Z7 = zr(/* @__PURE__ */ W.jsx("path", {
  d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14M7 9h5v1H7z"
}), "ZoomOut"), J7 = zr(/* @__PURE__ */ W.jsx("path", {
  d: "M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8"
}), "Undo"), tA = zr(/* @__PURE__ */ W.jsx("path", {
  d: "M18.4 10.6C16.55 8.99 14.15 8 11.5 8c-4.65 0-8.58 3.03-9.96 7.22L3.9 16c1.05-3.19 4.05-5.5 7.6-5.5 1.95 0 3.73.72 5.12 1.88L13 16h9V7z"
}), "Redo"), eA = zr(/* @__PURE__ */ W.jsx("path", {
  d: "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6z"
}), "Add"), nA = ({ bpm: e, onBpmChange: t }) => {
  const n = K.useRef(null), r = (l) => {
    var c;
    l.key === "Enter" && (l.preventDefault(), (c = n.current) == null || c.blur());
  }, i = () => {
    var l;
    (l = n.current) == null || l.select();
  }, s = (l) => `${l.toString().length * 10}px`;
  return /* @__PURE__ */ W.jsxs(Zt, { sx: { display: "flex", alignItems: "center" }, children: [
    /* @__PURE__ */ W.jsx(Zt, { sx: { width: "28px", textAlign: "right" }, children: /* @__PURE__ */ W.jsx(
      hy,
      {
        value: e,
        onChange: t,
        onKeyDown: r,
        type: "number",
        onFocus: i,
        onClick: i,
        inputRef: n,
        inputProps: {
          min: 1,
          max: 999,
          style: {
            padding: "0px 0px",
            width: s(e),
            color: "white",
            backgroundColor: "transparent",
            border: "none",
            textAlign: "center",
            cursor: "pointer",
            caretColor: "transparent"
          }
        },
        sx: {
          "& input::selection": {
            backgroundColor: "transparent"
          },
          "@keyframes gentleFlash": {
            "0%": { backgroundColor: "#333" },
            "50%": { backgroundColor: "#444" },
            "100%": { backgroundColor: "#333" }
          },
          "& .MuiInput-root": {
            fontSize: "1rem",
            width: "auto"
          },
          "& .MuiInput-root:before, & .MuiInput-root:after": {
            display: "none"
          },
          "& input::-webkit-outer-spin-button, & input::-webkit-inner-spin-button": {
            display: "none"
          },
          "& input:focus": {
            backgroundColor: "#333",
            outline: "none",
            borderRadius: "2px",
            animation: "gentleFlash 2s ease-in-out infinite"
          }
        },
        variant: "standard"
      }
    ) }),
    /* @__PURE__ */ W.jsx(Zt, { sx: { opacity: 0.7, ml: 1 }, children: "bpm" })
  ] });
}, Db = ({
  anchorEl: e,
  open: t,
  onClose: n,
  selectedValue: r,
  options: i,
  onSelect: s
}) => /* @__PURE__ */ W.jsx(
  ly,
  {
    anchorEl: e,
    open: t,
    onClose: n,
    anchorOrigin: {
      vertical: "bottom",
      horizontal: "center"
    },
    transformOrigin: {
      vertical: -12,
      horizontal: "center"
    },
    slotProps: {
      paper: {
        elevation: 4,
        sx: {
          overflow: "visible",
          filter: "drop-shadow(0px 2px 8px rgba(0,0,0,0.32))",
          bgcolor: "#1A1A1A",
          color: "white",
          "&::before": {
            content: '""',
            display: "block",
            position: "absolute",
            top: 0,
            right: 14,
            width: 10,
            height: 10,
            bgcolor: "#1A1A1A",
            transform: "translateY(-50%) rotate(45deg)",
            zIndex: 0
          }
        }
      }
    },
    children: i.map((l) => /* @__PURE__ */ W.jsx(
      ks,
      {
        onClick: () => s(l),
        selected: l === r,
        sx: {
          borderRadius: 1,
          mx: 0.5,
          mb: 0.5,
          "&:hover": {
            bgcolor: "rgba(255, 255, 255, 0.1)"
          },
          "&.Mui-selected": {
            bgcolor: "rgba(255, 255, 255, 0.2)"
          }
        },
        children: l
      },
      l
    ))
  }
), Ib = ({
  value: e,
  onClick: t
}) => /* @__PURE__ */ W.jsx(
  Zt,
  {
    component: "span",
    onClick: t,
    sx: {
      cursor: "pointer",
      width: "16px",
      display: "inline-block",
      textAlign: "center",
      "&:hover": {
        color: "#888"
      },
      transition: "color 0.2s"
    },
    children: e
  }
), rA = ({
  topNumber: e,
  bottomNumber: t,
  onTopNumberChange: n,
  onBottomNumberChange: r
}) => {
  const [i, s] = K.useState(null), [l, c] = K.useState(null), u = (g) => {
    s(g.currentTarget);
  }, d = (g) => {
    c(g.currentTarget);
  }, h = () => {
    s(null);
  }, p = () => {
    c(null);
  }, v = (g) => {
    n && n(g), h();
  }, m = (g) => {
    r && r(g), p();
  };
  return /* @__PURE__ */ W.jsxs(
    Zt,
    {
      sx: {
        display: "flex",
        alignItems: "center",
        bgcolor: "#1E1E1E",
        borderRadius: 1,
        px: 2,
        py: 0.5,
        height: "24px"
      },
      children: [
        /* @__PURE__ */ W.jsx(Ib, { value: e, onClick: u }),
        /* @__PURE__ */ W.jsx(Zt, { component: "span", sx: { mx: 1 }, children: "/" }),
        /* @__PURE__ */ W.jsx(Ib, { value: t, onClick: d }),
        /* @__PURE__ */ W.jsx(
          Db,
          {
            anchorEl: i,
            open: !!i,
            onClose: h,
            selectedValue: e,
            options: [1, 2, 3, 4, 5, 6],
            onSelect: v
          }
        ),
        /* @__PURE__ */ W.jsx(
          Db,
          {
            anchorEl: l,
            open: !!l,
            onClose: p,
            selectedValue: t,
            options: [1, 2, 4, 8],
            onSelect: m
          }
        )
      ]
    }
  );
}, iA = ["C", "D", "E", "F", "G", "A", "B"], sA = ["C/D", "D/E", "F/G", "G/A", "A/B"], oA = ({ selectedKey: e = "C major", onKeyChange: t }) => {
  const [n, r] = K.useState(null), [i, s] = K.useState(
    e.toLowerCase().includes("minor") ? "minor" : "major"
  ), l = (p) => {
    r(p.currentTarget);
  }, c = () => {
    r(null);
  }, u = (p) => {
    t(`${p} ${i}`), c();
  }, d = (p, v) => {
    v !== null && (s(v), e.includes("minor") && v === "major" ? t(e.replace("minor", "major")) : e.includes("major") && v === "minor" && t(e.replace("major", "minor")));
  }, h = !!n;
  return /* @__PURE__ */ W.jsxs(Zt, { sx: { width: "124px" }, children: [
    /* @__PURE__ */ W.jsx(
      Nc,
      {
        onClick: l,
        sx: {
          bgcolor: "#1E1E1E",
          color: "white",
          width: "100%",
          px: 2,
          py: 0.5,
          borderRadius: 1,
          textTransform: "none",
          "&:hover": {
            bgcolor: "#2E2E2E"
          }
        },
        children: e
      }
    ),
    /* @__PURE__ */ W.jsxs(
      VS,
      {
        open: h,
        anchorEl: n,
        onClose: c,
        anchorOrigin: {
          vertical: "bottom",
          horizontal: "left"
        },
        transformOrigin: {
          vertical: "top",
          horizontal: "left"
        },
        PaperProps: {
          sx: {
            bgcolor: "#1A1A1A",
            color: "white",
            mt: 1,
            width: "auto",
            p: 1
          }
        },
        children: [
          /* @__PURE__ */ W.jsx(Zt, { sx: { mb: 1 }, children: /* @__PURE__ */ W.jsxs(
            $7,
            {
              value: i,
              exclusive: !0,
              onChange: d,
              sx: {
                bgcolor: "#111",
                ".MuiToggleButton-root": {
                  color: "#666",
                  textTransform: "none",
                  "&.Mui-selected": {
                    color: "white",
                    bgcolor: "#333",
                    "&:hover": {
                      bgcolor: "#444"
                    }
                  },
                  "&:hover": {
                    bgcolor: "#222"
                  }
                }
              },
              children: [
                /* @__PURE__ */ W.jsx(Pb, { value: "major", sx: { px: 2 }, children: "Major" }),
                /* @__PURE__ */ W.jsx(Pb, { value: "minor", sx: { px: 2 }, children: "Minor" })
              ]
            }
          ) }),
          /* @__PURE__ */ W.jsxs(
            Zt,
            {
              sx: {
                display: "grid",
                gridTemplateColumns: "repeat(auto-fit, minmax(60px, 1fr))",
                gap: 0.5
              },
              children: [
                iA.map((p) => /* @__PURE__ */ W.jsx(
                  Nc,
                  {
                    onClick: () => u(p),
                    variant: e === `${p} ${i}` ? "contained" : "text",
                    sx: {
                      minWidth: 0,
                      p: 1,
                      textTransform: "none",
                      bgcolor: e === `${p} ${i}` ? "#333" : "transparent",
                      color: e === `${p} ${i}` ? "white" : "#666",
                      "&:hover": {
                        bgcolor: e === `${p} ${i}` ? "#444" : "#222"
                      }
                    },
                    children: p
                  },
                  p
                )),
                sA.map((p) => /* @__PURE__ */ W.jsx(
                  Nc,
                  {
                    onClick: () => u(p),
                    variant: e === `${p} ${i}` ? "contained" : "text",
                    sx: {
                      minWidth: 0,
                      p: 1,
                      textTransform: "none",
                      bgcolor: e === `${p} ${i}` ? "#333" : "transparent",
                      color: e === `${p} ${i}` ? "white" : "#666",
                      "&:hover": {
                        bgcolor: e === `${p} ${i}` ? "#444" : "#222"
                      }
                    },
                    children: p
                  },
                  p
                ))
              ]
            }
          )
        ]
      }
    )
  ] });
}, aA = zr(/* @__PURE__ */ W.jsx("path", {
  d: "M3 9v6h4l5 5V4L7 9zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02M14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77"
}), "VolumeUp"), lA = zr(/* @__PURE__ */ W.jsx("path", {
  d: "M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63m2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71M4.27 3 3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9zM12 4 9.91 6.09 12 8.18z"
}), "VolumeOff"), cA = zr(/* @__PURE__ */ W.jsx("path", {
  d: "M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6zM19 4h-3.5l-1-1h-5l-1 1H5v2h14z"
}), "Delete"), uA = zr(/* @__PURE__ */ W.jsx("path", {
  d: "M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5"
}), "PanTool"), Ie = {
  headerHeight: 28,
  trackHeight: 80,
  drumPadHeight: 20,
  measureWidth: 200,
  borderWidth: 1,
  borderColor: "#333",
  sidebarWidth: 200,
  measureCount: 20,
  pixelsPerSecond: 100,
  controlsWidth: 0,
  gridSubdivisions: 4,
  minorGridOpacity: 0.3,
  majorGridOpacity: 1,
  beatsPerMeasure: 4,
  midiNoteHeight: 4,
  // Height of MIDI notes in the track preview
  scrollThreshold: 50,
  cursorColor: "#ff5555",
  // Color for the playback cursor
  cursorColorInactive: "#aaaaaa",
  // Color for inactive cursor
  borderRadiusMedium: "10px",
  borderRadiusLarge: "50px",
  // Track color palette - 10 distinct colors distributed evenly around the color wheel
  trackColors: [
    "#4CAF50",
    // Green (Material UI's default green)
    "#673AB7",
    // Deep Purple
    "#E91E63",
    // Pink
    "#2196F3",
    // Blue
    "#FF9800",
    // Orange
    "#00BCD4",
    // Cyan
    "#9C27B0",
    // Purple
    "#FF5252",
    // Red
    "#FFEB3B"
    // Yellow
  ]
}, cp = (e, t, n) => {
  const r = n ? n[0] : Ie.beatsPerMeasure;
  console.log("Calculating track width:", {
    durationInSeconds: e,
    bpm: t,
    timeSignature: n,
    beatsPerMeasure: r,
    measureWidth: Ie.measureWidth
  });
  const i = t / 60, s = e * i, l = s / r, c = l * Ie.measureWidth;
  return console.log("Track width calculation results:", {
    beatsPerSecond: i,
    totalBeats: s,
    measuresCount: l,
    finalWidth: c
  }), c;
}, dA = (e, t, n) => {
  const r = n ? n[0] : Ie.beatsPerMeasure, i = t / 60, s = e * i, l = Math.floor(s / r), c = s % r, u = Ie.measureWidth / r;
  return l * Ie.measureWidth + c * u;
}, fy = (e, t, n) => {
  const r = n ? n[0] : Ie.beatsPerMeasure, i = Ie.measureWidth / r, s = e / i, l = t / 60;
  return s / l;
}, py = (e) => {
  const t = e % Ie.trackColors.length;
  return Ie.trackColors[t];
}, hA = ({
  tracks: e,
  onVolumeChange: t,
  onPanChange: n,
  onMuteToggle: r,
  onSoloToggle: i,
  onTrackDelete: s
}) => e.length === 0 ? /* @__PURE__ */ W.jsxs(Zt, { sx: {
  p: 2,
  textAlign: "center",
  color: "rgba(255, 255, 255, 0.5)",
  display: "flex",
  flexDirection: "column",
  alignItems: "center",
  justifyContent: "center",
  height: "100%"
}, children: [
  /* @__PURE__ */ W.jsx(Hr, { variant: "body2", children: "No tracks yet" }),
  /* @__PURE__ */ W.jsx(Hr, { variant: "caption", sx: { mt: 1 }, children: "Add tracks using the button above" })
] }) : /* @__PURE__ */ W.jsx(Zt, { sx: {
  width: "100%",
  height: "100%",
  overflow: "auto"
}, children: e.map((l, c) => /* @__PURE__ */ W.jsx(
  fA,
  {
    track: l,
    index: c,
    onVolumeChange: t,
    onPanChange: n,
    onMuteToggle: r,
    onSoloToggle: i,
    onTrackDelete: s
  },
  l.id
)) }), fA = ({
  track: e,
  index: t,
  onVolumeChange: n,
  onPanChange: r,
  onMuteToggle: i,
  onSoloToggle: s,
  onTrackDelete: l,
  onTrackNameChange: c
}) => {
  const u = py(t), [d, h] = K.useState(!1), [p, v] = K.useState(e.name), m = K.useRef(null), [g, b] = K.useState(e.volume), [x, w] = K.useState(e.pan);
  K.useEffect(() => {
    b(e.volume);
  }, [e.volume]), K.useEffect(() => {
    w(e.pan);
  }, [e.pan]);
  const T = (F, G) => {
    b(G);
  }, S = (F, G) => {
    n(e.id, G);
  }, C = (F, G) => {
    w(G);
  }, E = (F, G) => {
    r(e.id, G);
  }, O = () => {
    i(e.id, !e.muted);
  }, B = () => {
    s(e.id, !e.soloed);
  }, N = () => {
    l(e.id);
  }, L = () => {
    p.trim() !== "" && c && c(e.id, p), h(!1);
  };
  K.useEffect(() => {
    d && m.current && m.current.focus();
  }, [d]);
  const k = () => {
    var F;
    switch (e.type) {
      case "midi":
        return /* @__PURE__ */ W.jsxs(Zt, { sx: { mb: 1 }, children: [
          /* @__PURE__ */ W.jsx(Hr, { variant: "caption", sx: { color: "rgba(255,255,255,0.6)" }, children: "Instrument" }),
          /* @__PURE__ */ W.jsxs(
            ap,
            {
              size: "small",
              value: "synth",
              fullWidth: !0,
              sx: {
                mt: 0.5,
                fontSize: "12px",
                ".MuiSelect-select": { py: 0.5 },
                bgcolor: "rgba(0,0,0,0.2)"
              },
              children: [
                /* @__PURE__ */ W.jsx(ks, { value: "synth", children: "Synth" }),
                /* @__PURE__ */ W.jsx(ks, { value: "piano", children: "Piano" }),
                /* @__PURE__ */ W.jsx(ks, { value: "bass", children: "Bass" })
              ]
            }
          )
        ] });
      case "drum":
        return /* @__PURE__ */ W.jsxs(Zt, { sx: { mb: 1 }, children: [
          /* @__PURE__ */ W.jsx(Hr, { variant: "caption", sx: { color: "rgba(255,255,255,0.6)" }, children: "Drum Kit" }),
          /* @__PURE__ */ W.jsxs(
            ap,
            {
              size: "small",
              value: "808",
              fullWidth: !0,
              sx: {
                mt: 0.5,
                fontSize: "12px",
                ".MuiSelect-select": { py: 0.5 },
                bgcolor: "rgba(0,0,0,0.2)"
              },
              children: [
                /* @__PURE__ */ W.jsx(ks, { value: "808", children: "808 Kit" }),
                /* @__PURE__ */ W.jsx(ks, { value: "acoustic", children: "Acoustic Kit" }),
                /* @__PURE__ */ W.jsx(ks, { value: "electronic", children: "Electronic Kit" })
              ]
            }
          )
        ] });
      case "audio":
        return /* @__PURE__ */ W.jsxs(Zt, { sx: { mb: 1 }, children: [
          /* @__PURE__ */ W.jsx(Hr, { variant: "caption", sx: { color: "rgba(255,255,255,0.6)" }, children: "Audio File" }),
          /* @__PURE__ */ W.jsx(Zt, { sx: {
            mt: 0.5,
            fontSize: "12px",
            color: "rgba(255,255,255,0.8)",
            bgcolor: "rgba(0,0,0,0.2)",
            p: 0.5,
            borderRadius: 1,
            overflow: "hidden",
            textOverflow: "ellipsis",
            whiteSpace: "nowrap"
          }, children: ((F = e.audioFile) == null ? void 0 : F.name) || "No file loaded" })
        ] });
      default:
        return null;
    }
  };
  return /* @__PURE__ */ W.jsxs(Zt, { sx: {
    p: 1,
    mb: 0.5,
    borderBottom: "1px solid rgba(255, 255, 255, 0.1)",
    borderLeft: `4px solid ${u}`,
    bgcolor: "rgba(30, 30, 30, 0.7)",
    "&:hover": {
      bgcolor: "rgba(40, 40, 40, 0.9)"
    }
  }, children: [
    /* @__PURE__ */ W.jsxs(Zt, { sx: {
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between",
      mb: 1
    }, children: [
      d ? /* @__PURE__ */ W.jsx(
        hy,
        {
          inputRef: m,
          size: "small",
          value: p,
          onChange: (F) => v(F.target.value),
          onBlur: L,
          onKeyDown: (F) => {
            F.key === "Enter" && L(), F.key === "Escape" && (v(e.name), h(!1));
          },
          sx: {
            minWidth: "120px",
            ".MuiInputBase-input": {
              color: "white",
              fontSize: "13px",
              py: 0.5,
              px: 1
            }
          }
        }
      ) : /* @__PURE__ */ W.jsx(
        Hr,
        {
          variant: "subtitle2",
          sx: {
            fontWeight: "bold",
            cursor: "pointer",
            "&:hover": { textDecoration: "underline" }
          },
          onClick: () => h(!0),
          children: e.name
        }
      ),
      /* @__PURE__ */ W.jsx(Zt, { sx: { display: "flex", gap: 0.5 }, children: /* @__PURE__ */ W.jsx(Nf, { title: "Delete track", children: /* @__PURE__ */ W.jsx(
        Qo,
        {
          size: "small",
          onClick: N,
          sx: {
            color: "rgba(255, 255, 255, 0.7)",
            "&:hover": {
              color: "#ff5252",
              bgcolor: "rgba(255, 82, 82, 0.1)"
            }
          },
          children: /* @__PURE__ */ W.jsx(cA, { fontSize: "small" })
        }
      ) }) })
    ] }),
    /* @__PURE__ */ W.jsxs(Zt, { sx: { display: "flex", alignItems: "center", mb: 1, gap: 0.5 }, children: [
      /* @__PURE__ */ W.jsx(
        Zt,
        {
          sx: {
            bgcolor: e.type === "audio" ? "#4caf50" : e.type === "midi" ? "#2196f3" : e.type === "drum" ? "#ff9800" : "#9c27b0",
            borderRadius: "3px",
            px: 0.7,
            py: 0.2,
            fontSize: "10px",
            fontWeight: "bold",
            color: "white"
          },
          children: e.type.toUpperCase()
        }
      ),
      /* @__PURE__ */ W.jsx(Hr, { variant: "caption", sx: { color: "rgba(255, 255, 255, 0.6)" }, children: e.type === "audio" ? "Audio Track" : e.type === "midi" ? "MIDI Instrument" : e.type === "drum" ? "Drum Machine" : "Video Track" })
    ] }),
    k(),
    /* @__PURE__ */ W.jsxs(Zt, { sx: { display: "flex", alignItems: "center", mb: 1 }, children: [
      /* @__PURE__ */ W.jsx(Nf, { title: e.muted ? "Unmute" : "Mute", children: /* @__PURE__ */ W.jsx(
        Qo,
        {
          size: "small",
          onClick: O,
          sx: {
            color: e.muted ? "rgba(255, 82, 82, 0.9)" : "rgba(255, 255, 255, 0.7)",
            "&:hover": { color: e.muted ? "#ff5252" : "white" }
          },
          children: e.muted ? /* @__PURE__ */ W.jsx(lA, { fontSize: "small" }) : /* @__PURE__ */ W.jsx(aA, { fontSize: "small" })
        }
      ) }),
      /* @__PURE__ */ W.jsx(
        Ob,
        {
          size: "small",
          value: g,
          onChange: T,
          onChangeCommitted: S,
          "aria-label": "Volume",
          min: 0,
          max: 100,
          sx: {
            mx: 1,
            color: e.muted ? "rgba(255, 255, 255, 0.3)" : u,
            opacity: e.muted ? 0.5 : 1,
            "& .MuiSlider-thumb": {
              width: 12,
              height: 12,
              "&:hover, &.Mui-focusVisible": {
                boxShadow: `0px 0px 0px 8px ${u}20`
              }
            }
          }
        }
      ),
      /* @__PURE__ */ W.jsxs(Hr, { variant: "caption", sx: {
        minWidth: "30px",
        textAlign: "right",
        color: e.muted ? "rgba(255, 255, 255, 0.3)" : "rgba(255, 255, 255, 0.8)"
      }, children: [
        g,
        "%"
      ] })
    ] }),
    /* @__PURE__ */ W.jsxs(Zt, { sx: { display: "flex", alignItems: "center", mb: 1 }, children: [
      /* @__PURE__ */ W.jsx(Nf, { title: "Pan", children: /* @__PURE__ */ W.jsx(
        uA,
        {
          fontSize: "small",
          sx: {
            color: "rgba(255, 255, 255, 0.7)",
            transform: "rotate(90deg)",
            fontSize: 18,
            mx: 0.5
          }
        }
      ) }),
      /* @__PURE__ */ W.jsx(
        Ob,
        {
          size: "small",
          value: x,
          onChange: C,
          onChangeCommitted: E,
          "aria-label": "Pan",
          min: -100,
          max: 100,
          sx: {
            mx: 1,
            color: u,
            "& .MuiSlider-thumb": {
              width: 12,
              height: 12,
              "&:hover, &.Mui-focusVisible": {
                boxShadow: `0px 0px 0px 8px ${u}20`
              }
            },
            "& .MuiSlider-track": {
              // Makes the track always grow from center for pan
              "&::before": {
                content: '""',
                position: "absolute",
                height: "100%",
                width: "2px",
                backgroundColor: "rgba(255, 255, 255, 0.3)",
                left: "50%",
                transform: "translateX(-50%)"
              }
            }
          },
          marks: [
            { value: -100, label: "L" },
            { value: 0, label: "C" },
            { value: 100, label: "R" }
          ]
        }
      ),
      /* @__PURE__ */ W.jsx(Hr, { variant: "caption", sx: {
        minWidth: "36px",
        textAlign: "right",
        color: "rgba(255, 255, 255, 0.8)"
      }, children: x === 0 ? "C" : x < 0 ? `L${Math.abs(x)}` : `R${x}` })
    ] }),
    /* @__PURE__ */ W.jsx(Zt, { sx: { display: "flex", justifyContent: "flex-end" }, children: /* @__PURE__ */ W.jsx(Nf, { title: e.soloed ? "Unsolo" : "Solo", children: /* @__PURE__ */ W.jsx(
      Zt,
      {
        onClick: B,
        sx: {
          bgcolor: e.soloed ? "#ffc107" : "rgba(255, 255, 255, 0.1)",
          color: e.soloed ? "#000" : "rgba(255, 255, 255, 0.7)",
          borderRadius: "3px",
          px: 1,
          py: 0.3,
          fontSize: "10px",
          fontWeight: "bold",
          cursor: "pointer",
          "&:hover": {
            bgcolor: e.soloed ? "#e6ac00" : "rgba(255, 255, 255, 0.15)"
          }
        },
        children: "S"
      }
    ) }) })
  ] });
}, pA = ({
  audioFile: e,
  trackColor: t,
  duration: n,
  width: r
}) => {
  const i = K.useRef(null);
  return K.useEffect(() => {
    var p, v, m;
    if (!e || !i.current) {
      console.error("Missing audio file or canvas reference");
      return;
    }
    const s = i.current, l = s.getContext("2d");
    if (!l) {
      console.error("Failed to get canvas context");
      return;
    }
    console.log("Canvas initial dimensions:", {
      clientWidth: s.clientWidth,
      clientHeight: s.clientHeight,
      offsetWidth: s.offsetWidth,
      offsetHeight: s.offsetHeight,
      parentWidth: (p = s.parentElement) == null ? void 0 : p.clientWidth,
      parentHeight: (v = s.parentElement) == null ? void 0 : v.clientHeight
    });
    const c = window.devicePixelRatio || 1, u = r, d = ((m = s.parentElement) == null ? void 0 : m.clientHeight) || 80;
    s.style.width = `${u}px`, s.style.height = `${d}px`, s.width = u * c, s.height = d * c, l.scale(c, c), l.clearRect(0, 0, u, d);
    const h = new FileReader();
    h.onload = (g) => {
      var x;
      if (!((x = g.target) != null && x.result)) {
        console.error("Failed to read file");
        return;
      }
      new (window.AudioContext || window.webkitAudioContext)().decodeAudioData(g.target.result).then((w) => {
        const T = w.getChannelData(0);
        mA(T, s, l);
      }).catch((w) => {
        throw console.error("Error decoding audio data:", w), new Error("Failed to decode audio data");
      });
    }, h.onerror = () => {
      throw console.error("Error reading file"), new Error("Failed to read audio file");
    }, h.readAsArrayBuffer(e);
  }, [e, t, r]), /* @__PURE__ */ W.jsx(Zt, { sx: {
    height: "100%",
    width: "100%",
    display: "flex",
    alignItems: "center",
    overflow: "hidden",
    position: "relative"
  }, children: /* @__PURE__ */ W.jsx(
    "canvas",
    {
      ref: i,
      style: {
        position: "absolute",
        left: 0,
        top: 0,
        width: "100%",
        height: "100%",
        display: "block"
      }
    }
  ) });
};
function mA(e, t, n, r) {
  const i = window.devicePixelRatio || 1, s = t.width / i, l = t.height / i, c = l / 2;
  console.log("Drawing waveform with dimensions:", { width: s, height: l, middle: c, dpr: i }), n.clearRect(0, 0, s, l), n.imageSmoothingEnabled = !0, n.imageSmoothingQuality = "high";
  const u = e.length, d = Math.max(1, Math.floor(u / s)), h = [], p = [];
  n.fillStyle = "rgba(255,255,255,0.2)", n.fillRect(0, c, s, 1), n.fillStyle = "rgba(255, 255, 255, 0.25)";
  for (let v = 0; v < s; v++) {
    const m = Math.floor(v * u / s);
    let g = 0, b = 0;
    for (let O = 0; O < d; O++) {
      const B = m + O;
      if (B < u) {
        const N = e[B];
        N < g && (g = N), N > b && (b = N);
      }
    }
    const x = Math.min(0, g), w = Math.max(0, b), T = 0.5, S = c + x * l * T, C = c + w * l * T;
    h.push({ x: v, y: S }), p.push({ x: v, y: C });
    const E = C - S;
    n.fillRect(v, S, 1, E);
  }
  if (n.strokeStyle = "rgba(255,255,255,1.0)", n.lineWidth = 1, n.beginPath(), h.length > 0) {
    n.moveTo(h[0].x, h[0].y);
    for (let v = 1; v < h.length; v++)
      n.lineTo(h[v].x, h[v].y);
    n.stroke();
  }
  if (n.beginPath(), p.length > 0) {
    n.moveTo(p[0].x, p[0].y);
    for (let v = 1; v < p.length; v++)
      n.lineTo(p[v].x, p[v].y);
    n.stroke();
  }
}
class gA {
  constructor() {
    xe(this, "undoStack", []);
    xe(this, "redoStack", []);
    xe(this, "listeners", /* @__PURE__ */ new Set());
    console.log(" History Manager initialized");
  }
  subscribe(t) {
    this.listeners.add(t);
  }
  unsubscribe(t) {
    this.listeners.delete(t);
  }
  notifyListeners() {
    this.listeners.forEach((t) => t());
  }
  async executeAction(t) {
    await t.execute(), this.undoStack.push(t), this.redoStack = [], this.logState(), this.notifyListeners();
  }
  async undo() {
    const t = this.undoStack.pop();
    t && (await t.undo(), this.redoStack.push(t), this.logState(), this.notifyListeners());
  }
  async redo() {
    const t = this.redoStack.pop();
    t && (await t.execute(), this.undoStack.push(t), this.logState(), this.notifyListeners());
  }
  canUndo() {
    return this.undoStack.length > 0;
  }
  canRedo() {
    return this.redoStack.length > 0;
  }
  logState() {
    console.log(" History State:", {
      undoStack: this.undoStack.map((t) => ({ type: t.type })),
      redoStack: this.redoStack.map((t) => ({ type: t.type })),
      canUndo: this.canUndo(),
      canRedo: this.canRedo()
    });
  }
}
const Ue = new gA();
class yA {
  constructor(t, n, r, i) {
    xe(this, "type", "NOTE_CREATE");
    this.store = t, this.setNotes = n, this.newNote = r, this.prevNotes = i;
  }
  async execute() {
    this.setNotes([...this.prevNotes, this.newNote]), this.newNote.trackId && this.store.getMidiManager && await this.store.getMidiManager().addNoteToTrack(this.newNote.trackId, this.newNote);
  }
  async undo() {
    this.setNotes(this.prevNotes), this.newNote.trackId && this.store.getMidiManager && await this.store.getMidiManager().removeNoteFromTrack(this.newNote.trackId, this.newNote.id);
  }
}
class vA {
  constructor(t, n, r, i, s, l) {
    xe(this, "type", "NOTE_MOVE");
    this.store = t, this.setNotes = n, this.noteId = r, this.oldPosition = i, this.newPosition = s, this.prevNotes = l;
  }
  async execute() {
    const t = this.prevNotes.map(
      (r) => r.id === this.noteId ? { ...r, row: this.newPosition.y, column: this.newPosition.x } : r
    );
    this.setNotes(t);
    const n = t.find((r) => r.id === this.noteId);
    n != null && n.trackId && this.store.getMidiManager && await this.store.getMidiManager().updateNote(n.trackId, n);
  }
  async undo() {
    const t = this.prevNotes.map(
      (r) => r.id === this.noteId ? { ...r, row: this.oldPosition.y, column: this.oldPosition.x } : r
    );
    this.setNotes(t);
    const n = t.find((r) => r.id === this.noteId);
    n != null && n.trackId && this.store.getMidiManager && await this.store.getMidiManager().updateNote(n.trackId, n);
  }
}
class bA {
  constructor(t, n, r, i, s, l, c, u) {
    xe(this, "type", "NOTE_RESIZE");
    this.store = t, this.setNotes = n, this.noteId = r, this.oldLength = i, this.newLength = s, this.prevNotes = l, this.oldColumn = c, this.newColumn = u;
  }
  async execute() {
    const t = this.prevNotes.map(
      (r) => r.id === this.noteId ? {
        ...r,
        length: this.newLength,
        ...this.newColumn !== void 0 && { column: this.newColumn }
      } : r
    );
    this.setNotes(t);
    const n = t.find((r) => r.id === this.noteId);
    n != null && n.trackId && this.store.getMidiManager && await this.store.getMidiManager().updateNote(n.trackId, n);
  }
  async undo() {
    const t = this.prevNotes.map(
      (r) => r.id === this.noteId ? {
        ...r,
        length: this.oldLength,
        ...this.oldColumn !== void 0 && { column: this.oldColumn }
      } : r
    );
    this.setNotes(t);
    const n = t.find((r) => r.id === this.noteId);
    n != null && n.trackId && this.store.getMidiManager && await this.store.getMidiManager().updateNote(n.trackId, n);
  }
}
const Bb = (e) => {
  let t;
  const n = /* @__PURE__ */ new Set(), r = (d, h) => {
    const p = typeof d == "function" ? d(t) : d;
    if (!Object.is(p, t)) {
      const v = t;
      t = h ?? (typeof p != "object" || p === null) ? p : Object.assign({}, t, p), n.forEach((m) => m(t, v));
    }
  }, i = () => t, c = { setState: r, getState: i, getInitialState: () => u, subscribe: (d) => (n.add(d), () => n.delete(d)) }, u = t = e(r, i, c);
  return c;
}, _A = (e) => e ? Bb(e) : Bb, SA = (e) => e;
function xA(e, t = SA) {
  const n = ke.useSyncExternalStore(
    e.subscribe,
    () => t(e.getState()),
    () => t(e.getInitialState())
  );
  return ke.useDebugValue(n), n;
}
const Fb = (e) => {
  const t = _A(e), n = (r) => xA(t, r);
  return Object.assign(n, t), n;
}, TA = (e) => e ? Fb(e) : Fb, YS = "15.0.4", jb = (e, t, n) => ({ endTime: t, insertTime: n, type: "exponentialRampToValue", value: e }), Lb = (e, t, n) => ({ endTime: t, insertTime: n, type: "linearRampToValue", value: e }), m0 = (e, t) => ({ startTime: t, type: "setValue", value: e }), XS = (e, t, n) => ({ duration: n, startTime: t, type: "setValueCurve", values: e }), QS = (e, t, { startTime: n, target: r, timeConstant: i }) => r + (t - r) * Math.exp((n - e) / i), kc = (e) => e.type === "exponentialRampToValue", up = (e) => e.type === "linearRampToValue", Zo = (e) => kc(e) || up(e), my = (e) => e.type === "setValue", fo = (e) => e.type === "setValueCurve", dp = (e, t, n, r) => {
  const i = e[t];
  return i === void 0 ? r : Zo(i) || my(i) ? i.value : fo(i) ? i.values[i.values.length - 1] : QS(n, dp(e, t - 1, i.startTime, r), i);
}, zb = (e, t, n, r, i) => n === void 0 ? [r.insertTime, i] : Zo(n) ? [n.endTime, n.value] : my(n) ? [n.startTime, n.value] : fo(n) ? [
  n.startTime + n.duration,
  n.values[n.values.length - 1]
] : [
  n.startTime,
  dp(e, t - 1, n.startTime, i)
], g0 = (e) => e.type === "cancelAndHold", y0 = (e) => e.type === "cancelScheduledValues", Ko = (e) => g0(e) || y0(e) ? e.cancelTime : kc(e) || up(e) ? e.endTime : e.startTime, Ub = (e, t, n, { endTime: r, value: i }) => n === i ? i : 0 < n && 0 < i || n < 0 && i < 0 ? n * (i / n) ** ((e - t) / (r - t)) : 0, Vb = (e, t, n, { endTime: r, value: i }) => n + (e - t) / (r - t) * (i - n), CA = (e, t) => {
  const n = Math.floor(t), r = Math.ceil(t);
  return n === r ? e[n] : (1 - (t - n)) * e[n] + (1 - (r - t)) * e[r];
}, wA = (e, { duration: t, startTime: n, values: r }) => {
  const i = (e - n) / t * (r.length - 1);
  return CA(r, i);
}, Pf = (e) => e.type === "setTarget";
class EA {
  constructor(t) {
    this._automationEvents = [], this._currenTime = 0, this._defaultValue = t;
  }
  [Symbol.iterator]() {
    return this._automationEvents[Symbol.iterator]();
  }
  add(t) {
    const n = Ko(t);
    if (g0(t) || y0(t)) {
      const r = this._automationEvents.findIndex((s) => y0(t) && fo(s) ? s.startTime + s.duration >= n : Ko(s) >= n), i = this._automationEvents[r];
      if (r !== -1 && (this._automationEvents = this._automationEvents.slice(0, r)), g0(t)) {
        const s = this._automationEvents[this._automationEvents.length - 1];
        if (i !== void 0 && Zo(i)) {
          if (s !== void 0 && Pf(s))
            throw new Error("The internal list is malformed.");
          const l = s === void 0 ? i.insertTime : fo(s) ? s.startTime + s.duration : Ko(s), c = s === void 0 ? this._defaultValue : fo(s) ? s.values[s.values.length - 1] : s.value, u = kc(i) ? Ub(n, l, c, i) : Vb(n, l, c, i), d = kc(i) ? jb(u, n, this._currenTime) : Lb(u, n, this._currenTime);
          this._automationEvents.push(d);
        }
        if (s !== void 0 && Pf(s) && this._automationEvents.push(m0(this.getValue(n), n)), s !== void 0 && fo(s) && s.startTime + s.duration > n) {
          const l = n - s.startTime, c = (s.values.length - 1) / s.duration, u = Math.max(2, 1 + Math.ceil(l * c)), d = l / (u - 1) * c, h = s.values.slice(0, u);
          if (d < 1)
            for (let p = 1; p < u; p += 1) {
              const v = d * p % 1;
              h[p] = s.values[p - 1] * (1 - v) + s.values[p] * v;
            }
          this._automationEvents[this._automationEvents.length - 1] = XS(h, s.startTime, l);
        }
      }
    } else {
      const r = this._automationEvents.findIndex((l) => Ko(l) > n), i = r === -1 ? this._automationEvents[this._automationEvents.length - 1] : this._automationEvents[r - 1];
      if (i !== void 0 && fo(i) && Ko(i) + i.duration > n)
        return !1;
      const s = kc(t) ? jb(t.value, t.endTime, this._currenTime) : up(t) ? Lb(t.value, n, this._currenTime) : t;
      if (r === -1)
        this._automationEvents.push(s);
      else {
        if (fo(t) && n + t.duration > Ko(this._automationEvents[r]))
          return !1;
        this._automationEvents.splice(r, 0, s);
      }
    }
    return !0;
  }
  flush(t) {
    const n = this._automationEvents.findIndex((r) => Ko(r) > t);
    if (n > 1) {
      const r = this._automationEvents.slice(n - 1), i = r[0];
      Pf(i) && r.unshift(m0(dp(this._automationEvents, n - 2, i.startTime, this._defaultValue), i.startTime)), this._automationEvents = r;
    }
  }
  getValue(t) {
    if (this._automationEvents.length === 0)
      return this._defaultValue;
    const n = this._automationEvents.findIndex((l) => Ko(l) > t), r = this._automationEvents[n], i = (n === -1 ? this._automationEvents.length : n) - 1, s = this._automationEvents[i];
    if (s !== void 0 && Pf(s) && (r === void 0 || !Zo(r) || r.insertTime > t))
      return QS(t, dp(this._automationEvents, i - 1, s.startTime, this._defaultValue), s);
    if (s !== void 0 && my(s) && (r === void 0 || !Zo(r)))
      return s.value;
    if (s !== void 0 && fo(s) && (r === void 0 || !Zo(r) || s.startTime + s.duration > t))
      return t < s.startTime + s.duration ? wA(t, s) : s.values[s.values.length - 1];
    if (s !== void 0 && Zo(s) && (r === void 0 || !Zo(r)))
      return s.value;
    if (r !== void 0 && kc(r)) {
      const [l, c] = zb(this._automationEvents, i, s, r, this._defaultValue);
      return Ub(t, l, c, r);
    }
    if (r !== void 0 && up(r)) {
      const [l, c] = zb(this._automationEvents, i, s, r, this._defaultValue);
      return Vb(t, l, c, r);
    }
    return this._defaultValue;
  }
}
const AA = (e) => ({ cancelTime: e, type: "cancelAndHold" }), kA = (e) => ({ cancelTime: e, type: "cancelScheduledValues" }), RA = (e, t) => ({ endTime: t, type: "exponentialRampToValue", value: e }), MA = (e, t) => ({ endTime: t, type: "linearRampToValue", value: e }), OA = (e, t, n) => ({ startTime: t, target: e, timeConstant: n, type: "setTarget" }), NA = () => new DOMException("", "AbortError"), PA = (e) => (t, n, [r, i, s], l) => {
  e(t[i], [n, r, s], (c) => c[0] === n && c[1] === r, l);
}, DA = (e) => (t, n, r) => {
  const i = [];
  for (let s = 0; s < r.numberOfInputs; s += 1)
    i.push(/* @__PURE__ */ new Set());
  e.set(t, {
    activeInputs: i,
    outputs: /* @__PURE__ */ new Set(),
    passiveInputs: /* @__PURE__ */ new WeakMap(),
    renderer: n
  });
}, IA = (e) => (t, n) => {
  e.set(t, { activeInputs: /* @__PURE__ */ new Set(), passiveInputs: /* @__PURE__ */ new WeakMap(), renderer: n });
}, Uc = /* @__PURE__ */ new WeakSet(), ZS = /* @__PURE__ */ new WeakMap(), gy = /* @__PURE__ */ new WeakMap(), JS = /* @__PURE__ */ new WeakMap(), yy = /* @__PURE__ */ new WeakMap(), Yp = /* @__PURE__ */ new WeakMap(), t5 = /* @__PURE__ */ new WeakMap(), v0 = /* @__PURE__ */ new WeakMap(), b0 = /* @__PURE__ */ new WeakMap(), _0 = /* @__PURE__ */ new WeakMap(), e5 = {
  construct() {
    return e5;
  }
}, BA = (e) => {
  try {
    const t = new Proxy(e, e5);
    new t();
  } catch {
    return !1;
  }
  return !0;
}, Gb = /^import(?:(?:[\s]+[\w]+|(?:[\s]+[\w]+[\s]*,)?[\s]*\{[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?(?:[\s]*,[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?)*[\s]*}|(?:[\s]+[\w]+[\s]*,)?[\s]*\*[\s]+as[\s]+[\w]+)[\s]+from)?(?:[\s]*)("([^"\\]|\\.)+"|'([^'\\]|\\.)+')(?:[\s]*);?/, qb = (e, t) => {
  const n = [];
  let r = e.replace(/^[\s]+/, ""), i = r.match(Gb);
  for (; i !== null; ) {
    const s = i[1].slice(1, -1), l = i[0].replace(/([\s]+)?;?$/, "").replace(s, new URL(s, t).toString());
    n.push(l), r = r.slice(i[0].length).replace(/^[\s]+/, ""), i = r.match(Gb);
  }
  return [n.join(";"), r];
}, Hb = (e) => {
  if (e !== void 0 && !Array.isArray(e))
    throw new TypeError("The parameterDescriptors property of given value for processorCtor is not an array.");
}, Wb = (e) => {
  if (!BA(e))
    throw new TypeError("The given value for processorCtor should be a constructor.");
  if (e.prototype === null || typeof e.prototype != "object")
    throw new TypeError("The given value for processorCtor should have a prototype.");
}, FA = (e, t, n, r, i, s, l, c, u, d, h, p, v) => {
  let m = 0;
  return (g, b, x = { credentials: "omit" }) => {
    const w = h.get(g);
    if (w !== void 0 && w.has(b))
      return Promise.resolve();
    const T = d.get(g);
    if (T !== void 0) {
      const E = T.get(b);
      if (E !== void 0)
        return E;
    }
    const S = s(g), C = S.audioWorklet === void 0 ? i(b).then(([E, O]) => {
      const [B, N] = qb(E, O), L = `${B};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${N}
})})(window,'_AWGS')`;
      return n(L);
    }).then(() => {
      const E = v._AWGS.pop();
      if (E === void 0)
        throw new SyntaxError();
      r(S.currentTime, S.sampleRate, () => E(class {
      }, void 0, (O, B) => {
        if (O.trim() === "")
          throw t();
        const N = b0.get(S);
        if (N !== void 0) {
          if (N.has(O))
            throw t();
          Wb(B), Hb(B.parameterDescriptors), N.set(O, B);
        } else
          Wb(B), Hb(B.parameterDescriptors), b0.set(S, /* @__PURE__ */ new Map([[O, B]]));
      }, S.sampleRate, void 0, void 0));
    }) : Promise.all([
      i(b),
      Promise.resolve(e(p, p))
    ]).then(([[E, O], B]) => {
      const N = m + 1;
      m = N;
      const [L, k] = qb(E, O), j = `${L};((AudioWorkletProcessor,registerProcessor)=>{${k}
})(${B ? "AudioWorkletProcessor" : "class extends AudioWorkletProcessor {__b=new WeakSet();constructor(){super();(p=>p.postMessage=(q=>(m,t)=>q.call(p,m,t?t.filter(u=>!this.__b.has(u)):t))(p.postMessage))(this.port)}}"},(n,p)=>registerProcessor(n,class extends p{${B ? "" : "__c = (a) => a.forEach(e=>this.__b.add(e.buffer));"}process(i,o,p){${B ? "" : "i.forEach(this.__c);o.forEach(this.__c);this.__c(Object.values(p));"}return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}));registerProcessor('__sac${N}',class extends AudioWorkletProcessor{process(){return !1}})`, D = new Blob([j], { type: "application/javascript; charset=utf-8" }), z = URL.createObjectURL(D);
      return S.audioWorklet.addModule(z, x).then(() => {
        if (c(S))
          return S;
        const H = l(S);
        return H.audioWorklet.addModule(z, x).then(() => H);
      }).then((H) => {
        if (u === null)
          throw new SyntaxError();
        try {
          new u(H, `__sac${N}`);
        } catch {
          throw new SyntaxError();
        }
      }).finally(() => URL.revokeObjectURL(z));
    });
    return T === void 0 ? d.set(g, /* @__PURE__ */ new Map([[b, C]])) : T.set(b, C), C.then(() => {
      const E = h.get(g);
      E === void 0 ? h.set(g, /* @__PURE__ */ new Set([b])) : E.add(b);
    }).finally(() => {
      const E = d.get(g);
      E !== void 0 && E.delete(b);
    }), C;
  };
}, cs = (e, t) => {
  const n = e.get(t);
  if (n === void 0)
    throw new Error("A value with the given key could not be found.");
  return n;
}, Xp = (e, t) => {
  const n = Array.from(e).filter(t);
  if (n.length > 1)
    throw Error("More than one element was found.");
  if (n.length === 0)
    throw Error("No element was found.");
  const [r] = n;
  return e.delete(r), r;
}, n5 = (e, t, n, r) => {
  const i = cs(e, t), s = Xp(i, (l) => l[0] === n && l[1] === r);
  return i.size === 0 && e.delete(t), s;
}, xh = (e) => cs(t5, e), Vc = (e) => {
  if (Uc.has(e))
    throw new Error("The AudioNode is already stored.");
  Uc.add(e), xh(e).forEach((t) => t(!0));
}, r5 = (e) => "port" in e, Th = (e) => {
  if (!Uc.has(e))
    throw new Error("The AudioNode is not stored.");
  Uc.delete(e), xh(e).forEach((t) => t(!1));
}, S0 = (e, t) => {
  !r5(e) && t.every((n) => n.size === 0) && Th(e);
}, jA = (e, t, n, r, i, s, l, c, u, d, h, p, v) => {
  const m = /* @__PURE__ */ new WeakMap();
  return (g, b, x, w, T) => {
    const { activeInputs: S, passiveInputs: C } = s(b), { outputs: E } = s(g), O = c(g), B = (N) => {
      const L = u(b), k = u(g);
      if (N) {
        const F = n5(C, g, x, w);
        e(S, g, F, !1), !T && !p(g) && n(k, L, x, w), v(b) && Vc(b);
      } else {
        const F = r(S, g, x, w);
        t(C, w, F, !1), !T && !p(g) && i(k, L, x, w);
        const G = l(b);
        if (G === 0)
          h(b) && S0(b, S);
        else {
          const M = m.get(b);
          M !== void 0 && clearTimeout(M), m.set(b, setTimeout(() => {
            h(b) && S0(b, S);
          }, G * 1e3));
        }
      }
    };
    return d(E, [b, x, w], (N) => N[0] === b && N[1] === x && N[2] === w, !0) ? (O.add(B), h(g) ? e(S, g, [x, w, B], !0) : t(C, w, [g, x, B], !0), !0) : !1;
  };
}, LA = (e) => (t, n, [r, i, s], l) => {
  const c = t.get(r);
  c === void 0 ? t.set(r, /* @__PURE__ */ new Set([[i, n, s]])) : e(c, [i, n, s], (u) => u[0] === i && u[1] === n, l);
}, zA = (e) => (t, n) => {
  const r = e(t, {
    channelCount: 1,
    channelCountMode: "explicit",
    channelInterpretation: "discrete",
    gain: 0
  });
  n.connect(r).connect(t.destination);
  const i = () => {
    n.removeEventListener("ended", i), n.disconnect(r), r.disconnect();
  };
  n.addEventListener("ended", i);
}, UA = (e) => (t, n) => {
  e(t).add(n);
}, VA = {
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers",
  fftSize: 2048,
  maxDecibels: -30,
  minDecibels: -100,
  smoothingTimeConstant: 0.8
}, GA = (e, t, n, r, i, s) => class extends e {
  constructor(c, u) {
    const d = i(c), h = { ...VA, ...u }, p = r(d, h), v = s(d) ? t() : null;
    super(c, !1, p, v), this._nativeAnalyserNode = p;
  }
  get fftSize() {
    return this._nativeAnalyserNode.fftSize;
  }
  set fftSize(c) {
    this._nativeAnalyserNode.fftSize = c;
  }
  get frequencyBinCount() {
    return this._nativeAnalyserNode.frequencyBinCount;
  }
  get maxDecibels() {
    return this._nativeAnalyserNode.maxDecibels;
  }
  set maxDecibels(c) {
    const u = this._nativeAnalyserNode.maxDecibels;
    if (this._nativeAnalyserNode.maxDecibels = c, !(c > this._nativeAnalyserNode.minDecibels))
      throw this._nativeAnalyserNode.maxDecibels = u, n();
  }
  get minDecibels() {
    return this._nativeAnalyserNode.minDecibels;
  }
  set minDecibels(c) {
    const u = this._nativeAnalyserNode.minDecibels;
    if (this._nativeAnalyserNode.minDecibels = c, !(this._nativeAnalyserNode.maxDecibels > c))
      throw this._nativeAnalyserNode.minDecibels = u, n();
  }
  get smoothingTimeConstant() {
    return this._nativeAnalyserNode.smoothingTimeConstant;
  }
  set smoothingTimeConstant(c) {
    this._nativeAnalyserNode.smoothingTimeConstant = c;
  }
  getByteFrequencyData(c) {
    this._nativeAnalyserNode.getByteFrequencyData(c);
  }
  getByteTimeDomainData(c) {
    this._nativeAnalyserNode.getByteTimeDomainData(c);
  }
  getFloatFrequencyData(c) {
    this._nativeAnalyserNode.getFloatFrequencyData(c);
  }
  getFloatTimeDomainData(c) {
    this._nativeAnalyserNode.getFloatTimeDomainData(c);
  }
}, Ur = (e, t) => e.context === t, qA = (e, t, n) => () => {
  const r = /* @__PURE__ */ new WeakMap(), i = async (s, l) => {
    let c = t(s);
    if (!Ur(c, l)) {
      const d = {
        channelCount: c.channelCount,
        channelCountMode: c.channelCountMode,
        channelInterpretation: c.channelInterpretation,
        fftSize: c.fftSize,
        maxDecibels: c.maxDecibels,
        minDecibels: c.minDecibels,
        smoothingTimeConstant: c.smoothingTimeConstant
      };
      c = e(l, d);
    }
    return r.set(l, c), await n(s, l, c), c;
  };
  return {
    render(s, l) {
      const c = r.get(l);
      return c !== void 0 ? Promise.resolve(c) : i(s, l);
    }
  };
}, hp = (e) => {
  try {
    e.copyToChannel(new Float32Array(1), 0, -1);
  } catch {
    return !1;
  }
  return !0;
}, js = () => new DOMException("", "IndexSizeError"), vy = (e) => {
  e.getChannelData = /* @__PURE__ */ ((t) => (n) => {
    try {
      return t.call(e, n);
    } catch (r) {
      throw r.code === 12 ? js() : r;
    }
  })(e.getChannelData);
}, HA = {
  numberOfChannels: 1
}, WA = (e, t, n, r, i, s, l, c) => {
  let u = null;
  return class i5 {
    constructor(h) {
      if (i === null)
        throw new Error("Missing the native OfflineAudioContext constructor.");
      const { length: p, numberOfChannels: v, sampleRate: m } = { ...HA, ...h };
      u === null && (u = new i(1, 1, 44100));
      const g = r !== null && t(s, s) ? new r({ length: p, numberOfChannels: v, sampleRate: m }) : u.createBuffer(v, p, m);
      if (g.numberOfChannels === 0)
        throw n();
      return typeof g.copyFromChannel != "function" ? (l(g), vy(g)) : t(hp, () => hp(g)) || c(g), e.add(g), g;
    }
    static [Symbol.hasInstance](h) {
      return h !== null && typeof h == "object" && Object.getPrototypeOf(h) === i5.prototype || e.has(h);
    }
  };
}, Si = -34028234663852886e22, Wr = 34028234663852886e22, mo = (e) => Uc.has(e), $A = {
  buffer: null,
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers",
  // Bug #149: Safari does not yet support the detune AudioParam.
  loop: !1,
  loopEnd: 0,
  loopStart: 0,
  playbackRate: 1
}, KA = (e, t, n, r, i, s, l, c) => class extends e {
  constructor(d, h) {
    const p = s(d), v = { ...$A, ...h }, m = i(p, v), g = l(p), b = g ? t() : null;
    super(d, !1, m, b), this._audioBufferSourceNodeRenderer = b, this._isBufferNullified = !1, this._isBufferSet = v.buffer !== null, this._nativeAudioBufferSourceNode = m, this._onended = null, this._playbackRate = n(this, g, m.playbackRate, Wr, Si);
  }
  get buffer() {
    return this._isBufferNullified ? null : this._nativeAudioBufferSourceNode.buffer;
  }
  set buffer(d) {
    if (this._nativeAudioBufferSourceNode.buffer = d, d !== null) {
      if (this._isBufferSet)
        throw r();
      this._isBufferSet = !0;
    }
  }
  get loop() {
    return this._nativeAudioBufferSourceNode.loop;
  }
  set loop(d) {
    this._nativeAudioBufferSourceNode.loop = d;
  }
  get loopEnd() {
    return this._nativeAudioBufferSourceNode.loopEnd;
  }
  set loopEnd(d) {
    this._nativeAudioBufferSourceNode.loopEnd = d;
  }
  get loopStart() {
    return this._nativeAudioBufferSourceNode.loopStart;
  }
  set loopStart(d) {
    this._nativeAudioBufferSourceNode.loopStart = d;
  }
  get onended() {
    return this._onended;
  }
  set onended(d) {
    const h = typeof d == "function" ? c(this, d) : null;
    this._nativeAudioBufferSourceNode.onended = h;
    const p = this._nativeAudioBufferSourceNode.onended;
    this._onended = p !== null && p === h ? d : p;
  }
  get playbackRate() {
    return this._playbackRate;
  }
  start(d = 0, h = 0, p) {
    if (this._nativeAudioBufferSourceNode.start(d, h, p), this._audioBufferSourceNodeRenderer !== null && (this._audioBufferSourceNodeRenderer.start = p === void 0 ? [d, h] : [d, h, p]), this.context.state !== "closed") {
      Vc(this);
      const v = () => {
        this._nativeAudioBufferSourceNode.removeEventListener("ended", v), mo(this) && Th(this);
      };
      this._nativeAudioBufferSourceNode.addEventListener("ended", v);
    }
  }
  stop(d = 0) {
    this._nativeAudioBufferSourceNode.stop(d), this._audioBufferSourceNodeRenderer !== null && (this._audioBufferSourceNodeRenderer.stop = d);
  }
}, YA = (e, t, n, r, i) => () => {
  const s = /* @__PURE__ */ new WeakMap();
  let l = null, c = null;
  const u = async (d, h) => {
    let p = n(d);
    const v = Ur(p, h);
    if (!v) {
      const m = {
        buffer: p.buffer,
        channelCount: p.channelCount,
        channelCountMode: p.channelCountMode,
        channelInterpretation: p.channelInterpretation,
        // Bug #149: Safari does not yet support the detune AudioParam.
        loop: p.loop,
        loopEnd: p.loopEnd,
        loopStart: p.loopStart,
        playbackRate: p.playbackRate.value
      };
      p = t(h, m), l !== null && p.start(...l), c !== null && p.stop(c);
    }
    return s.set(h, p), v ? await e(h, d.playbackRate, p.playbackRate) : await r(h, d.playbackRate, p.playbackRate), await i(d, h, p), p;
  };
  return {
    set start(d) {
      l = d;
    },
    set stop(d) {
      c = d;
    },
    render(d, h) {
      const p = s.get(h);
      return p !== void 0 ? Promise.resolve(p) : u(d, h);
    }
  };
}, XA = (e) => "playbackRate" in e, QA = (e) => "frequency" in e && "gain" in e, ZA = (e) => "offset" in e, JA = (e) => !("frequency" in e) && "gain" in e, tk = (e) => "detune" in e && "frequency" in e && !("gain" in e), ek = (e) => "pan" in e, $r = (e) => cs(ZS, e), Ch = (e) => cs(JS, e), x0 = (e, t) => {
  const { activeInputs: n } = $r(e);
  n.forEach((i) => i.forEach(([s]) => {
    t.includes(e) || x0(s, [...t, e]);
  }));
  const r = XA(e) ? [
    // Bug #149: Safari does not yet support the detune AudioParam.
    e.playbackRate
  ] : r5(e) ? Array.from(e.parameters.values()) : QA(e) ? [e.Q, e.detune, e.frequency, e.gain] : ZA(e) ? [e.offset] : JA(e) ? [e.gain] : tk(e) ? [e.detune, e.frequency] : ek(e) ? [e.pan] : [];
  for (const i of r) {
    const s = Ch(i);
    s !== void 0 && s.activeInputs.forEach(([l]) => x0(l, t));
  }
  mo(e) && Th(e);
}, s5 = (e) => {
  x0(e.destination, []);
}, nk = (e) => e === void 0 || typeof e == "number" || typeof e == "string" && (e === "balanced" || e === "interactive" || e === "playback"), rk = (e, t, n, r, i, s, l, c, u) => class extends e {
  constructor(h = {}) {
    if (u === null)
      throw new Error("Missing the native AudioContext constructor.");
    let p;
    try {
      p = new u(h);
    } catch (g) {
      throw g.code === 12 && g.message === "sampleRate is not in range" ? n() : g;
    }
    if (p === null)
      throw r();
    if (!nk(h.latencyHint))
      throw new TypeError(`The provided value '${h.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);
    if (h.sampleRate !== void 0 && p.sampleRate !== h.sampleRate)
      throw n();
    super(p, 2);
    const { latencyHint: v } = h, { sampleRate: m } = p;
    if (this._baseLatency = typeof p.baseLatency == "number" ? p.baseLatency : v === "balanced" ? 512 / m : v === "interactive" || v === void 0 ? 256 / m : v === "playback" ? 1024 / m : (
      /*
       * @todo The min (256) and max (16384) values are taken from the allowed bufferSize values of a
       * ScriptProcessorNode.
       */
      Math.max(2, Math.min(128, Math.round(v * m / 128))) * 128 / m
    ), this._nativeAudioContext = p, u.name === "webkitAudioContext" ? (this._nativeGainNode = p.createGain(), this._nativeOscillatorNode = p.createOscillator(), this._nativeGainNode.gain.value = 1e-37, this._nativeOscillatorNode.connect(this._nativeGainNode).connect(p.destination), this._nativeOscillatorNode.start()) : (this._nativeGainNode = null, this._nativeOscillatorNode = null), this._state = null, p.state === "running") {
      this._state = "suspended";
      const g = () => {
        this._state === "suspended" && (this._state = null), p.removeEventListener("statechange", g);
      };
      p.addEventListener("statechange", g);
    }
  }
  get baseLatency() {
    return this._baseLatency;
  }
  get state() {
    return this._state !== null ? this._state : this._nativeAudioContext.state;
  }
  close() {
    return this.state === "closed" ? this._nativeAudioContext.close().then(() => {
      throw t();
    }) : (this._state === "suspended" && (this._state = null), this._nativeAudioContext.close().then(() => {
      this._nativeGainNode !== null && this._nativeOscillatorNode !== null && (this._nativeOscillatorNode.stop(), this._nativeGainNode.disconnect(), this._nativeOscillatorNode.disconnect()), s5(this);
    }));
  }
  createMediaElementSource(h) {
    return new i(this, { mediaElement: h });
  }
  createMediaStreamDestination() {
    return new s(this);
  }
  createMediaStreamSource(h) {
    return new l(this, { mediaStream: h });
  }
  createMediaStreamTrackSource(h) {
    return new c(this, { mediaStreamTrack: h });
  }
  resume() {
    return this._state === "suspended" ? new Promise((h, p) => {
      const v = () => {
        this._nativeAudioContext.removeEventListener("statechange", v), this._nativeAudioContext.state === "running" ? h() : this.resume().then(h, p);
      };
      this._nativeAudioContext.addEventListener("statechange", v);
    }) : this._nativeAudioContext.resume().catch((h) => {
      throw h === void 0 || h.code === 15 ? t() : h;
    });
  }
  suspend() {
    return this._nativeAudioContext.suspend().catch((h) => {
      throw h === void 0 ? t() : h;
    });
  }
}, ik = (e, t, n, r, i, s, l, c) => class extends e {
  constructor(d, h) {
    const p = s(d), v = l(p), m = i(p, h, v), g = v ? t(c) : null;
    super(d, !1, m, g), this._isNodeOfNativeOfflineAudioContext = v, this._nativeAudioDestinationNode = m;
  }
  get channelCount() {
    return this._nativeAudioDestinationNode.channelCount;
  }
  set channelCount(d) {
    if (this._isNodeOfNativeOfflineAudioContext)
      throw r();
    if (d > this._nativeAudioDestinationNode.maxChannelCount)
      throw n();
    this._nativeAudioDestinationNode.channelCount = d;
  }
  get channelCountMode() {
    return this._nativeAudioDestinationNode.channelCountMode;
  }
  set channelCountMode(d) {
    if (this._isNodeOfNativeOfflineAudioContext)
      throw r();
    this._nativeAudioDestinationNode.channelCountMode = d;
  }
  get maxChannelCount() {
    return this._nativeAudioDestinationNode.maxChannelCount;
  }
}, sk = (e) => {
  const t = /* @__PURE__ */ new WeakMap(), n = async (r, i) => {
    const s = i.destination;
    return t.set(i, s), await e(r, i, s), s;
  };
  return {
    render(r, i) {
      const s = t.get(i);
      return s !== void 0 ? Promise.resolve(s) : n(r, i);
    }
  };
}, ok = (e, t, n, r, i, s, l, c) => (u, d) => {
  const h = d.listener, p = () => {
    const E = new Float32Array(1), O = t(d, {
      channelCount: 1,
      channelCountMode: "explicit",
      channelInterpretation: "speakers",
      numberOfInputs: 9
    }), B = l(d);
    let N = !1, L = [0, 0, -1, 0, 1, 0], k = [0, 0, 0];
    const F = () => {
      if (N)
        return;
      N = !0;
      const D = r(d, 256, 9, 0);
      D.onaudioprocess = ({ inputBuffer: z }) => {
        const H = [
          s(z, E, 0),
          s(z, E, 1),
          s(z, E, 2),
          s(z, E, 3),
          s(z, E, 4),
          s(z, E, 5)
        ];
        H.some((Y, V) => Y !== L[V]) && (h.setOrientation(...H), L = H);
        const X = [
          s(z, E, 6),
          s(z, E, 7),
          s(z, E, 8)
        ];
        X.some((Y, V) => Y !== k[V]) && (h.setPosition(...X), k = X);
      }, O.connect(D);
    }, G = (D) => (z) => {
      z !== L[D] && (L[D] = z, h.setOrientation(...L));
    }, M = (D) => (z) => {
      z !== k[D] && (k[D] = z, h.setPosition(...k));
    }, j = (D, z, H) => {
      const X = n(d, {
        channelCount: 1,
        channelCountMode: "explicit",
        channelInterpretation: "discrete",
        offset: z
      });
      X.connect(O, 0, D), X.start(), Object.defineProperty(X.offset, "defaultValue", {
        get() {
          return z;
        }
      });
      const Y = e({ context: u }, B, X.offset, Wr, Si);
      return c(Y, "value", (V) => () => V.call(Y), (V) => (Z) => {
        try {
          V.call(Y, Z);
        } catch (ct) {
          if (ct.code !== 9)
            throw ct;
        }
        F(), B && H(Z);
      }), Y.cancelAndHoldAtTime = /* @__PURE__ */ ((V) => B ? () => {
        throw i();
      } : (...Z) => {
        const ct = V.apply(Y, Z);
        return F(), ct;
      })(Y.cancelAndHoldAtTime), Y.cancelScheduledValues = /* @__PURE__ */ ((V) => B ? () => {
        throw i();
      } : (...Z) => {
        const ct = V.apply(Y, Z);
        return F(), ct;
      })(Y.cancelScheduledValues), Y.exponentialRampToValueAtTime = /* @__PURE__ */ ((V) => B ? () => {
        throw i();
      } : (...Z) => {
        const ct = V.apply(Y, Z);
        return F(), ct;
      })(Y.exponentialRampToValueAtTime), Y.linearRampToValueAtTime = /* @__PURE__ */ ((V) => B ? () => {
        throw i();
      } : (...Z) => {
        const ct = V.apply(Y, Z);
        return F(), ct;
      })(Y.linearRampToValueAtTime), Y.setTargetAtTime = /* @__PURE__ */ ((V) => B ? () => {
        throw i();
      } : (...Z) => {
        const ct = V.apply(Y, Z);
        return F(), ct;
      })(Y.setTargetAtTime), Y.setValueAtTime = /* @__PURE__ */ ((V) => B ? () => {
        throw i();
      } : (...Z) => {
        const ct = V.apply(Y, Z);
        return F(), ct;
      })(Y.setValueAtTime), Y.setValueCurveAtTime = /* @__PURE__ */ ((V) => B ? () => {
        throw i();
      } : (...Z) => {
        const ct = V.apply(Y, Z);
        return F(), ct;
      })(Y.setValueCurveAtTime), Y;
    };
    return {
      forwardX: j(0, 0, G(0)),
      forwardY: j(1, 0, G(1)),
      forwardZ: j(2, -1, G(2)),
      positionX: j(6, 0, M(0)),
      positionY: j(7, 0, M(1)),
      positionZ: j(8, 0, M(2)),
      upX: j(3, 0, G(3)),
      upY: j(4, 1, G(4)),
      upZ: j(5, 0, G(5))
    };
  }, { forwardX: v, forwardY: m, forwardZ: g, positionX: b, positionY: x, positionZ: w, upX: T, upY: S, upZ: C } = h.forwardX === void 0 ? p() : h;
  return {
    get forwardX() {
      return v;
    },
    get forwardY() {
      return m;
    },
    get forwardZ() {
      return g;
    },
    get positionX() {
      return b;
    },
    get positionY() {
      return x;
    },
    get positionZ() {
      return w;
    },
    get upX() {
      return T;
    },
    get upY() {
      return S;
    },
    get upZ() {
      return C;
    }
  };
}, fp = (e) => "context" in e, wh = (e) => fp(e[0]), vl = (e, t, n, r) => {
  for (const i of e)
    if (n(i)) {
      if (r)
        return !1;
      throw Error("The set contains at least one similar element.");
    }
  return e.add(t), !0;
}, $b = (e, t, [n, r], i) => {
  vl(e, [t, n, r], (s) => s[0] === t && s[1] === n, i);
}, Kb = (e, [t, n, r], i) => {
  const s = e.get(t);
  s === void 0 ? e.set(t, /* @__PURE__ */ new Set([[n, r]])) : vl(s, [n, r], (l) => l[0] === n, i);
}, tu = (e) => "inputs" in e, pp = (e, t, n, r) => {
  if (tu(t)) {
    const i = t.inputs[r];
    return e.connect(i, n, 0), [i, n, 0];
  }
  return e.connect(t, n, r), [t, n, r];
}, o5 = (e, t, n) => {
  for (const r of e)
    if (r[0] === t && r[1] === n)
      return e.delete(r), r;
  return null;
}, ak = (e, t, n) => Xp(e, (r) => r[0] === t && r[1] === n), a5 = (e, t) => {
  if (!xh(e).delete(t))
    throw new Error("Missing the expected event listener.");
}, l5 = (e, t, n) => {
  const r = cs(e, t), i = Xp(r, (s) => s[0] === n);
  return r.size === 0 && e.delete(t), i;
}, mp = (e, t, n, r) => {
  tu(t) ? e.disconnect(t.inputs[r], n, 0) : e.disconnect(t, n, r);
}, kn = (e) => cs(gy, e), ch = (e) => cs(yy, e), pl = (e) => v0.has(e), $f = (e) => !Uc.has(e), Yb = (e, t) => new Promise((n) => {
  if (t !== null)
    n(!0);
  else {
    const r = e.createScriptProcessor(256, 1, 1), i = e.createGain(), s = e.createBuffer(1, 2, 44100), l = s.getChannelData(0);
    l[0] = 1, l[1] = 1;
    const c = e.createBufferSource();
    c.buffer = s, c.loop = !0, c.connect(r).connect(e.destination), c.connect(i), c.disconnect(i), r.onaudioprocess = (u) => {
      const d = u.inputBuffer.getChannelData(0);
      Array.prototype.some.call(d, (h) => h === 1) ? n(!0) : n(!1), c.stop(), r.onaudioprocess = null, c.disconnect(r), r.disconnect(e.destination);
    }, c.start();
  }
}), wg = (e, t) => {
  const n = /* @__PURE__ */ new Map();
  for (const r of e)
    for (const i of r) {
      const s = n.get(i);
      n.set(i, s === void 0 ? 1 : s + 1);
    }
  n.forEach((r, i) => t(i, r));
}, gp = (e) => "context" in e, lk = (e) => {
  const t = /* @__PURE__ */ new Map();
  e.connect = /* @__PURE__ */ ((n) => (r, i = 0, s = 0) => {
    const l = gp(r) ? n(r, i, s) : n(r, i), c = t.get(r);
    return c === void 0 ? t.set(r, [{ input: s, output: i }]) : c.every((u) => u.input !== s || u.output !== i) && c.push({ input: s, output: i }), l;
  })(e.connect.bind(e)), e.disconnect = /* @__PURE__ */ ((n) => (r, i, s) => {
    if (n.apply(e), r === void 0)
      t.clear();
    else if (typeof r == "number")
      for (const [l, c] of t) {
        const u = c.filter((d) => d.output !== r);
        u.length === 0 ? t.delete(l) : t.set(l, u);
      }
    else if (t.has(r))
      if (i === void 0)
        t.delete(r);
      else {
        const l = t.get(r);
        if (l !== void 0) {
          const c = l.filter((u) => u.output !== i && (u.input !== s || s === void 0));
          c.length === 0 ? t.delete(r) : t.set(r, c);
        }
      }
    for (const [l, c] of t)
      c.forEach((u) => {
        gp(l) ? e.connect(l, u.output, u.input) : e.connect(l, u.output);
      });
  })(e.disconnect);
}, ck = (e, t, n, r) => {
  const { activeInputs: i, passiveInputs: s } = Ch(t), { outputs: l } = $r(e), c = xh(e), u = (d) => {
    const h = kn(e), p = ch(t);
    if (d) {
      const v = l5(s, e, n);
      $b(i, e, v, !1), !r && !pl(e) && h.connect(p, n);
    } else {
      const v = ak(i, e, n);
      Kb(s, v, !1), !r && !pl(e) && h.disconnect(p, n);
    }
  };
  return vl(l, [t, n], (d) => d[0] === t && d[1] === n, !0) ? (c.add(u), mo(e) ? $b(i, e, [n, u], !0) : Kb(s, [e, n, u], !0), !0) : !1;
}, uk = (e, t, n, r) => {
  const { activeInputs: i, passiveInputs: s } = $r(t), l = o5(i[r], e, n);
  return l === null ? [n5(s, e, n, r)[2], !1] : [l[2], !0];
}, dk = (e, t, n) => {
  const { activeInputs: r, passiveInputs: i } = Ch(t), s = o5(r, e, n);
  return s === null ? [l5(i, e, n)[1], !1] : [s[2], !0];
}, by = (e, t, n, r, i) => {
  const [s, l] = uk(e, n, r, i);
  if (s !== null && (a5(e, s), l && !t && !pl(e) && mp(kn(e), kn(n), r, i)), mo(n)) {
    const { activeInputs: c } = $r(n);
    S0(n, c);
  }
}, _y = (e, t, n, r) => {
  const [i, s] = dk(e, n, r);
  i !== null && (a5(e, i), s && !t && !pl(e) && kn(e).disconnect(ch(n), r));
}, hk = (e, t) => {
  const n = $r(e), r = [];
  for (const i of n.outputs)
    wh(i) ? by(e, t, ...i) : _y(e, t, ...i), r.push(i[0]);
  return n.outputs.clear(), r;
}, fk = (e, t, n) => {
  const r = $r(e), i = [];
  for (const s of r.outputs)
    s[1] === n && (wh(s) ? by(e, t, ...s) : _y(e, t, ...s), i.push(s[0]), r.outputs.delete(s));
  return i;
}, pk = (e, t, n, r, i) => {
  const s = $r(e);
  return Array.from(s.outputs).filter((l) => l[0] === n && (r === void 0 || l[1] === r) && (i === void 0 || l[2] === i)).map((l) => (wh(l) ? by(e, t, ...l) : _y(e, t, ...l), s.outputs.delete(l), l[0]));
}, mk = (e, t, n, r, i, s, l, c, u, d, h, p, v, m, g, b) => class extends d {
  constructor(w, T, S, C) {
    super(S), this._context = w, this._nativeAudioNode = S;
    const E = h(w);
    p(E) && n(Yb, () => Yb(E, b)) !== !0 && lk(S), gy.set(this, S), t5.set(this, /* @__PURE__ */ new Set()), w.state !== "closed" && T && Vc(this), e(this, C, S);
  }
  get channelCount() {
    return this._nativeAudioNode.channelCount;
  }
  set channelCount(w) {
    this._nativeAudioNode.channelCount = w;
  }
  get channelCountMode() {
    return this._nativeAudioNode.channelCountMode;
  }
  set channelCountMode(w) {
    this._nativeAudioNode.channelCountMode = w;
  }
  get channelInterpretation() {
    return this._nativeAudioNode.channelInterpretation;
  }
  set channelInterpretation(w) {
    this._nativeAudioNode.channelInterpretation = w;
  }
  get context() {
    return this._context;
  }
  get numberOfInputs() {
    return this._nativeAudioNode.numberOfInputs;
  }
  get numberOfOutputs() {
    return this._nativeAudioNode.numberOfOutputs;
  }
  // tslint:disable-next-line:invalid-void
  connect(w, T = 0, S = 0) {
    if (T < 0 || T >= this._nativeAudioNode.numberOfOutputs)
      throw i();
    const C = h(this._context), E = g(C);
    if (v(w) || m(w))
      throw s();
    if (fp(w)) {
      const N = kn(w);
      try {
        const k = pp(this._nativeAudioNode, N, T, S), F = $f(this);
        (E || F) && this._nativeAudioNode.disconnect(...k), this.context.state !== "closed" && !F && $f(w) && Vc(w);
      } catch (k) {
        throw k.code === 12 ? s() : k;
      }
      if (t(this, w, T, S, E)) {
        const k = u([this], w);
        wg(k, r(E));
      }
      return w;
    }
    const O = ch(w);
    if (O.name === "playbackRate" && O.maxValue === 1024)
      throw l();
    try {
      this._nativeAudioNode.connect(O, T), (E || $f(this)) && this._nativeAudioNode.disconnect(O, T);
    } catch (N) {
      throw N.code === 12 ? s() : N;
    }
    if (ck(this, w, T, E)) {
      const N = u([this], w);
      wg(N, r(E));
    }
  }
  disconnect(w, T, S) {
    let C;
    const E = h(this._context), O = g(E);
    if (w === void 0)
      C = hk(this, O);
    else if (typeof w == "number") {
      if (w < 0 || w >= this.numberOfOutputs)
        throw i();
      C = fk(this, O, w);
    } else {
      if (T !== void 0 && (T < 0 || T >= this.numberOfOutputs) || fp(w) && S !== void 0 && (S < 0 || S >= w.numberOfInputs))
        throw i();
      if (C = pk(this, O, w, T, S), C.length === 0)
        throw s();
    }
    for (const B of C) {
      const N = u([this], B);
      wg(N, c);
    }
  }
}, gk = (e, t, n, r, i, s, l, c, u, d, h, p, v) => (m, g, b, x = null, w = null) => {
  const T = b.value, S = new EA(T), C = g ? r(S) : null, E = {
    get defaultValue() {
      return T;
    },
    get maxValue() {
      return x === null ? b.maxValue : x;
    },
    get minValue() {
      return w === null ? b.minValue : w;
    },
    get value() {
      return b.value;
    },
    set value(O) {
      b.value = O, E.setValueAtTime(O, m.context.currentTime);
    },
    cancelAndHoldAtTime(O) {
      if (typeof b.cancelAndHoldAtTime == "function")
        C === null && S.flush(m.context.currentTime), S.add(i(O)), b.cancelAndHoldAtTime(O);
      else {
        const B = Array.from(S).pop();
        C === null && S.flush(m.context.currentTime), S.add(i(O));
        const N = Array.from(S).pop();
        b.cancelScheduledValues(O), B !== N && N !== void 0 && (N.type === "exponentialRampToValue" ? b.exponentialRampToValueAtTime(N.value, N.endTime) : N.type === "linearRampToValue" ? b.linearRampToValueAtTime(N.value, N.endTime) : N.type === "setValue" ? b.setValueAtTime(N.value, N.startTime) : N.type === "setValueCurve" && b.setValueCurveAtTime(N.values, N.startTime, N.duration));
      }
      return E;
    },
    cancelScheduledValues(O) {
      return C === null && S.flush(m.context.currentTime), S.add(s(O)), b.cancelScheduledValues(O), E;
    },
    exponentialRampToValueAtTime(O, B) {
      if (O === 0)
        throw new RangeError();
      if (!Number.isFinite(B) || B < 0)
        throw new RangeError();
      const N = m.context.currentTime;
      return C === null && S.flush(N), Array.from(S).length === 0 && (S.add(d(T, N)), b.setValueAtTime(T, N)), S.add(l(O, B)), b.exponentialRampToValueAtTime(O, B), E;
    },
    linearRampToValueAtTime(O, B) {
      const N = m.context.currentTime;
      return C === null && S.flush(N), Array.from(S).length === 0 && (S.add(d(T, N)), b.setValueAtTime(T, N)), S.add(c(O, B)), b.linearRampToValueAtTime(O, B), E;
    },
    setTargetAtTime(O, B, N) {
      return C === null && S.flush(m.context.currentTime), S.add(u(O, B, N)), b.setTargetAtTime(O, B, N), E;
    },
    setValueAtTime(O, B) {
      return C === null && S.flush(m.context.currentTime), S.add(d(O, B)), b.setValueAtTime(O, B), E;
    },
    setValueCurveAtTime(O, B, N) {
      const L = O instanceof Float32Array ? O : new Float32Array(O);
      if (p !== null && p.name === "webkitAudioContext") {
        const k = B + N, F = m.context.sampleRate, G = Math.ceil(B * F), M = Math.floor(k * F), j = M - G, D = new Float32Array(j);
        for (let H = 0; H < j; H += 1) {
          const X = (L.length - 1) / N * ((G + H) / F - B), Y = Math.floor(X), V = Math.ceil(X);
          D[H] = Y === V ? L[Y] : (1 - (X - Y)) * L[Y] + (1 - (V - X)) * L[V];
        }
        C === null && S.flush(m.context.currentTime), S.add(h(D, B, N)), b.setValueCurveAtTime(D, B, N);
        const z = M / F;
        z < k && v(E, D[D.length - 1], z), v(E, L[L.length - 1], k);
      } else
        C === null && S.flush(m.context.currentTime), S.add(h(L, B, N)), b.setValueCurveAtTime(L, B, N);
      return E;
    }
  };
  return n.set(E, b), t.set(E, m), e(E, C), E;
}, yk = (e) => ({
  replay(t) {
    for (const n of e)
      if (n.type === "exponentialRampToValue") {
        const { endTime: r, value: i } = n;
        t.exponentialRampToValueAtTime(i, r);
      } else if (n.type === "linearRampToValue") {
        const { endTime: r, value: i } = n;
        t.linearRampToValueAtTime(i, r);
      } else if (n.type === "setTarget") {
        const { startTime: r, target: i, timeConstant: s } = n;
        t.setTargetAtTime(i, r, s);
      } else if (n.type === "setValue") {
        const { startTime: r, value: i } = n;
        t.setValueAtTime(i, r);
      } else if (n.type === "setValueCurve") {
        const { duration: r, startTime: i, values: s } = n;
        t.setValueCurveAtTime(s, i, r);
      } else
        throw new Error("Can't apply an unknown automation.");
  }
});
class c5 {
  constructor(t) {
    this._map = new Map(t);
  }
  get size() {
    return this._map.size;
  }
  entries() {
    return this._map.entries();
  }
  forEach(t, n = null) {
    return this._map.forEach((r, i) => t.call(n, r, i, this));
  }
  get(t) {
    return this._map.get(t);
  }
  has(t) {
    return this._map.has(t);
  }
  keys() {
    return this._map.keys();
  }
  values() {
    return this._map.values();
  }
}
const vk = {
  channelCount: 2,
  // Bug #61: The channelCountMode should be 'max' according to the spec but is set to 'explicit' to achieve consistent behavior.
  channelCountMode: "explicit",
  channelInterpretation: "speakers",
  numberOfInputs: 1,
  numberOfOutputs: 1,
  parameterData: {},
  processorOptions: {}
}, bk = (e, t, n, r, i, s, l, c, u, d, h, p, v, m) => class extends t {
  constructor(b, x, w) {
    var T;
    const S = c(b), C = u(S), E = h({ ...vk, ...w });
    v(E);
    const O = b0.get(S), B = O == null ? void 0 : O.get(x), N = C || S.state !== "closed" ? S : (T = l(S)) !== null && T !== void 0 ? T : S, L = i(N, C ? null : b.baseLatency, d, x, B, E), k = C ? r(x, E, B) : null;
    super(b, !0, L, k);
    const F = [];
    L.parameters.forEach((M, j) => {
      const D = n(this, C, M);
      F.push([j, D]);
    }), this._nativeAudioWorkletNode = L, this._onprocessorerror = null, this._parameters = new c5(F), C && e(S, this);
    const { activeInputs: G } = s(this);
    p(L, G);
  }
  get onprocessorerror() {
    return this._onprocessorerror;
  }
  set onprocessorerror(b) {
    const x = typeof b == "function" ? m(this, b) : null;
    this._nativeAudioWorkletNode.onprocessorerror = x;
    const w = this._nativeAudioWorkletNode.onprocessorerror;
    this._onprocessorerror = w !== null && w === x ? b : w;
  }
  get parameters() {
    return this._parameters === null ? this._nativeAudioWorkletNode.parameters : this._parameters;
  }
  get port() {
    return this._nativeAudioWorkletNode.port;
  }
};
function yp(e, t, n, r, i) {
  if (typeof e.copyFromChannel == "function")
    t[n].byteLength === 0 && (t[n] = new Float32Array(128)), e.copyFromChannel(t[n], r, i);
  else {
    const s = e.getChannelData(r);
    if (t[n].byteLength === 0)
      t[n] = s.slice(i, i + 128);
    else {
      const l = new Float32Array(s.buffer, i * Float32Array.BYTES_PER_ELEMENT, 128);
      t[n].set(l);
    }
  }
}
const u5 = (e, t, n, r, i) => {
  typeof e.copyToChannel == "function" ? t[n].byteLength !== 0 && e.copyToChannel(t[n], r, i) : t[n].byteLength !== 0 && e.getChannelData(r).set(t[n], i);
}, vp = (e, t) => {
  const n = [];
  for (let r = 0; r < e; r += 1) {
    const i = [], s = typeof t == "number" ? t : t[r];
    for (let l = 0; l < s; l += 1)
      i.push(new Float32Array(128));
    n.push(i);
  }
  return n;
}, _k = (e, t) => {
  const n = cs(_0, e), r = kn(t);
  return cs(n, r);
}, Sk = async (e, t, n, r, i, s, l) => {
  const c = t === null ? Math.ceil(e.context.length / 128) * 128 : t.length, u = r.channelCount * r.numberOfInputs, d = i.reduce((x, w) => x + w, 0), h = d === 0 ? null : n.createBuffer(d, c, n.sampleRate);
  if (s === void 0)
    throw new Error("Missing the processor constructor.");
  const p = $r(e), v = await _k(n, e), m = vp(r.numberOfInputs, r.channelCount), g = vp(r.numberOfOutputs, i), b = Array.from(e.parameters.keys()).reduce((x, w) => ({ ...x, [w]: new Float32Array(128) }), {});
  for (let x = 0; x < c; x += 128) {
    if (r.numberOfInputs > 0 && t !== null)
      for (let w = 0; w < r.numberOfInputs; w += 1)
        for (let T = 0; T < r.channelCount; T += 1)
          yp(t, m[w], T, T, x);
    s.parameterDescriptors !== void 0 && t !== null && s.parameterDescriptors.forEach(({ name: w }, T) => {
      yp(t, b, w, u + T, x);
    });
    for (let w = 0; w < r.numberOfInputs; w += 1)
      for (let T = 0; T < i[w]; T += 1)
        g[w][T].byteLength === 0 && (g[w][T] = new Float32Array(128));
    try {
      const w = m.map((S, C) => p.activeInputs[C].size === 0 ? [] : S), T = l(x / n.sampleRate, n.sampleRate, () => v.process(w, g, b));
      if (h !== null)
        for (let S = 0, C = 0; S < r.numberOfOutputs; S += 1) {
          for (let E = 0; E < i[S]; E += 1)
            u5(h, g[S], E, C + E, x);
          C += i[S];
        }
      if (!T)
        break;
    } catch (w) {
      e.dispatchEvent(new ErrorEvent("processorerror", {
        colno: w.colno,
        filename: w.filename,
        lineno: w.lineno,
        message: w.message
      }));
      break;
    }
  }
  return h;
}, xk = (e, t, n, r, i, s, l, c, u, d, h, p, v, m, g, b) => (x, w, T) => {
  const S = /* @__PURE__ */ new WeakMap();
  let C = null;
  const E = async (O, B) => {
    let N = h(O), L = null;
    const k = Ur(N, B), F = Array.isArray(w.outputChannelCount) ? w.outputChannelCount : Array.from(w.outputChannelCount);
    if (p === null) {
      const G = F.reduce((z, H) => z + H, 0), M = i(B, {
        channelCount: Math.max(1, G),
        channelCountMode: "explicit",
        channelInterpretation: "discrete",
        numberOfOutputs: Math.max(1, G)
      }), j = [];
      for (let z = 0; z < O.numberOfOutputs; z += 1)
        j.push(r(B, {
          channelCount: 1,
          channelCountMode: "explicit",
          channelInterpretation: "speakers",
          numberOfInputs: F[z]
        }));
      const D = l(B, {
        channelCount: w.channelCount,
        channelCountMode: w.channelCountMode,
        channelInterpretation: w.channelInterpretation,
        gain: 1
      });
      D.connect = t.bind(null, j), D.disconnect = u.bind(null, j), L = [M, j, D];
    } else k || (N = new p(B, x));
    if (S.set(B, L === null ? N : L[2]), L !== null) {
      if (C === null) {
        if (T === void 0)
          throw new Error("Missing the processor constructor.");
        if (v === null)
          throw new Error("Missing the native OfflineAudioContext constructor.");
        const H = O.channelCount * O.numberOfInputs, X = T.parameterDescriptors === void 0 ? 0 : T.parameterDescriptors.length, Y = H + X;
        C = Sk(O, Y === 0 ? null : await (async () => {
          const Z = new v(
            Y,
            // Ceil the length to the next full render quantum.
            // Bug #17: Safari does not yet expose the length.
            Math.ceil(O.context.length / 128) * 128,
            B.sampleRate
          ), ct = [], et = [];
          for (let yt = 0; yt < w.numberOfInputs; yt += 1)
            ct.push(l(Z, {
              channelCount: w.channelCount,
              channelCountMode: w.channelCountMode,
              channelInterpretation: w.channelInterpretation,
              gain: 1
            })), et.push(i(Z, {
              channelCount: w.channelCount,
              channelCountMode: "explicit",
              channelInterpretation: "discrete",
              numberOfOutputs: w.channelCount
            }));
          const rt = await Promise.all(Array.from(O.parameters.values()).map(async (yt) => {
            const J = s(Z, {
              channelCount: 1,
              channelCountMode: "explicit",
              channelInterpretation: "discrete",
              offset: yt.value
            });
            return await m(Z, yt, J.offset), J;
          })), st = r(Z, {
            channelCount: 1,
            channelCountMode: "explicit",
            channelInterpretation: "speakers",
            numberOfInputs: Math.max(1, H + X)
          });
          for (let yt = 0; yt < w.numberOfInputs; yt += 1) {
            ct[yt].connect(et[yt]);
            for (let J = 0; J < w.channelCount; J += 1)
              et[yt].connect(st, J, yt * w.channelCount + J);
          }
          for (const [yt, J] of rt.entries())
            J.connect(st, 0, H + yt), J.start(0);
          return st.connect(Z.destination), await Promise.all(ct.map((yt) => g(O, Z, yt))), b(Z);
        })(), B, w, F, T, d);
      }
      const G = await C, M = n(B, {
        buffer: null,
        channelCount: 2,
        channelCountMode: "max",
        channelInterpretation: "speakers",
        loop: !1,
        loopEnd: 0,
        loopStart: 0,
        playbackRate: 1
      }), [j, D, z] = L;
      G !== null && (M.buffer = G, M.start(0)), M.connect(j);
      for (let H = 0, X = 0; H < O.numberOfOutputs; H += 1) {
        const Y = D[H];
        for (let V = 0; V < F[H]; V += 1)
          j.connect(Y, X + V, V);
        X += F[H];
      }
      return z;
    }
    if (k)
      for (const [G, M] of O.parameters.entries())
        await e(
          B,
          M,
          // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.
          N.parameters.get(G)
        );
    else
      for (const [G, M] of O.parameters.entries())
        await m(
          B,
          M,
          // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.
          N.parameters.get(G)
        );
    return await g(O, B, N), N;
  };
  return {
    render(O, B) {
      c(B, O);
      const N = S.get(B);
      return N !== void 0 ? Promise.resolve(N) : E(O, B);
    }
  };
}, Tk = (e, t, n, r, i, s, l, c, u, d, h, p, v, m, g, b, x, w, T, S) => class extends g {
  constructor(E, O) {
    super(E, O), this._nativeContext = E, this._audioWorklet = e === void 0 ? void 0 : {
      addModule: (B, N) => e(this, B, N)
    };
  }
  get audioWorklet() {
    return this._audioWorklet;
  }
  createAnalyser() {
    return new t(this);
  }
  createBiquadFilter() {
    return new i(this);
  }
  createBuffer(E, O, B) {
    return new n({ length: O, numberOfChannels: E, sampleRate: B });
  }
  createBufferSource() {
    return new r(this);
  }
  createChannelMerger(E = 6) {
    return new s(this, { numberOfInputs: E });
  }
  createChannelSplitter(E = 6) {
    return new l(this, { numberOfOutputs: E });
  }
  createConstantSource() {
    return new c(this);
  }
  createConvolver() {
    return new u(this);
  }
  createDelay(E = 1) {
    return new h(this, { maxDelayTime: E });
  }
  createDynamicsCompressor() {
    return new p(this);
  }
  createGain() {
    return new v(this);
  }
  createIIRFilter(E, O) {
    return new m(this, { feedback: O, feedforward: E });
  }
  createOscillator() {
    return new b(this);
  }
  createPanner() {
    return new x(this);
  }
  createPeriodicWave(E, O, B = { disableNormalization: !1 }) {
    return new w(this, { ...B, imag: O, real: E });
  }
  createStereoPanner() {
    return new T(this);
  }
  createWaveShaper() {
    return new S(this);
  }
  decodeAudioData(E, O, B) {
    return d(this._nativeContext, E).then((N) => (typeof O == "function" && O(N), N), (N) => {
      throw typeof B == "function" && B(N), N;
    });
  }
}, Ck = {
  Q: 1,
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers",
  detune: 0,
  frequency: 350,
  gain: 0,
  type: "lowpass"
}, wk = (e, t, n, r, i, s, l, c) => class extends e {
  constructor(d, h) {
    const p = s(d), v = { ...Ck, ...h }, m = i(p, v), g = l(p), b = g ? n() : null;
    super(d, !1, m, b), this._Q = t(this, g, m.Q, Wr, Si), this._detune = t(this, g, m.detune, 1200 * Math.log2(Wr), -1200 * Math.log2(Wr)), this._frequency = t(this, g, m.frequency, d.sampleRate / 2, 0), this._gain = t(this, g, m.gain, 40 * Math.log10(Wr), Si), this._nativeBiquadFilterNode = m, c(this, 1);
  }
  get detune() {
    return this._detune;
  }
  get frequency() {
    return this._frequency;
  }
  get gain() {
    return this._gain;
  }
  get Q() {
    return this._Q;
  }
  get type() {
    return this._nativeBiquadFilterNode.type;
  }
  set type(d) {
    this._nativeBiquadFilterNode.type = d;
  }
  getFrequencyResponse(d, h, p) {
    try {
      this._nativeBiquadFilterNode.getFrequencyResponse(d, h, p);
    } catch (v) {
      throw v.code === 11 ? r() : v;
    }
    if (d.length !== h.length || h.length !== p.length)
      throw r();
  }
}, Ek = (e, t, n, r, i) => () => {
  const s = /* @__PURE__ */ new WeakMap(), l = async (c, u) => {
    let d = n(c);
    const h = Ur(d, u);
    if (!h) {
      const p = {
        Q: d.Q.value,
        channelCount: d.channelCount,
        channelCountMode: d.channelCountMode,
        channelInterpretation: d.channelInterpretation,
        detune: d.detune.value,
        frequency: d.frequency.value,
        gain: d.gain.value,
        type: d.type
      };
      d = t(u, p);
    }
    return s.set(u, d), h ? (await e(u, c.Q, d.Q), await e(u, c.detune, d.detune), await e(u, c.frequency, d.frequency), await e(u, c.gain, d.gain)) : (await r(u, c.Q, d.Q), await r(u, c.detune, d.detune), await r(u, c.frequency, d.frequency), await r(u, c.gain, d.gain)), await i(c, u, d), d;
  };
  return {
    render(c, u) {
      const d = s.get(u);
      return d !== void 0 ? Promise.resolve(d) : l(c, u);
    }
  };
}, Ak = (e, t) => (n, r) => {
  const i = t.get(n);
  if (i !== void 0)
    return i;
  const s = e.get(n);
  if (s !== void 0)
    return s;
  try {
    const l = r();
    return l instanceof Promise ? (e.set(n, l), l.catch(() => !1).then((c) => (e.delete(n), t.set(n, c), c))) : (t.set(n, l), l);
  } catch {
    return t.set(n, !1), !1;
  }
}, kk = {
  channelCount: 1,
  channelCountMode: "explicit",
  channelInterpretation: "speakers",
  numberOfInputs: 6
}, Rk = (e, t, n, r, i) => class extends e {
  constructor(l, c) {
    const u = r(l), d = { ...kk, ...c }, h = n(u, d), p = i(u) ? t() : null;
    super(l, !1, h, p);
  }
}, Mk = (e, t, n) => () => {
  const r = /* @__PURE__ */ new WeakMap(), i = async (s, l) => {
    let c = t(s);
    if (!Ur(c, l)) {
      const d = {
        channelCount: c.channelCount,
        channelCountMode: c.channelCountMode,
        channelInterpretation: c.channelInterpretation,
        numberOfInputs: c.numberOfInputs
      };
      c = e(l, d);
    }
    return r.set(l, c), await n(s, l, c), c;
  };
  return {
    render(s, l) {
      const c = r.get(l);
      return c !== void 0 ? Promise.resolve(c) : i(s, l);
    }
  };
}, Ok = {
  channelCount: 6,
  channelCountMode: "explicit",
  channelInterpretation: "discrete",
  numberOfOutputs: 6
}, Nk = (e, t, n, r, i, s) => class extends e {
  constructor(c, u) {
    const d = r(c), h = s({ ...Ok, ...u }), p = n(d, h), v = i(d) ? t() : null;
    super(c, !1, p, v);
  }
}, Pk = (e, t, n) => () => {
  const r = /* @__PURE__ */ new WeakMap(), i = async (s, l) => {
    let c = t(s);
    if (!Ur(c, l)) {
      const d = {
        channelCount: c.channelCount,
        channelCountMode: c.channelCountMode,
        channelInterpretation: c.channelInterpretation,
        numberOfOutputs: c.numberOfOutputs
      };
      c = e(l, d);
    }
    return r.set(l, c), await n(s, l, c), c;
  };
  return {
    render(s, l) {
      const c = r.get(l);
      return c !== void 0 ? Promise.resolve(c) : i(s, l);
    }
  };
}, Dk = (e) => (t, n, r) => e(n, t, r), Ik = (e) => (t, n, r = 0, i = 0) => {
  const s = t[r];
  if (s === void 0)
    throw e();
  return gp(n) ? s.connect(n, 0, i) : s.connect(n, 0);
}, Bk = (e) => (t, n) => {
  const r = e(t, {
    buffer: null,
    channelCount: 2,
    channelCountMode: "max",
    channelInterpretation: "speakers",
    loop: !1,
    loopEnd: 0,
    loopStart: 0,
    playbackRate: 1
  }), i = t.createBuffer(1, 2, 44100);
  return r.buffer = i, r.loop = !0, r.connect(n), r.start(), () => {
    r.stop(), r.disconnect(n);
  };
}, Fk = {
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers",
  offset: 1
}, jk = (e, t, n, r, i, s, l) => class extends e {
  constructor(u, d) {
    const h = i(u), p = { ...Fk, ...d }, v = r(h, p), m = s(h), g = m ? n() : null;
    super(u, !1, v, g), this._constantSourceNodeRenderer = g, this._nativeConstantSourceNode = v, this._offset = t(this, m, v.offset, Wr, Si), this._onended = null;
  }
  get offset() {
    return this._offset;
  }
  get onended() {
    return this._onended;
  }
  set onended(u) {
    const d = typeof u == "function" ? l(this, u) : null;
    this._nativeConstantSourceNode.onended = d;
    const h = this._nativeConstantSourceNode.onended;
    this._onended = h !== null && h === d ? u : h;
  }
  start(u = 0) {
    if (this._nativeConstantSourceNode.start(u), this._constantSourceNodeRenderer !== null && (this._constantSourceNodeRenderer.start = u), this.context.state !== "closed") {
      Vc(this);
      const d = () => {
        this._nativeConstantSourceNode.removeEventListener("ended", d), mo(this) && Th(this);
      };
      this._nativeConstantSourceNode.addEventListener("ended", d);
    }
  }
  stop(u = 0) {
    this._nativeConstantSourceNode.stop(u), this._constantSourceNodeRenderer !== null && (this._constantSourceNodeRenderer.stop = u);
  }
}, Lk = (e, t, n, r, i) => () => {
  const s = /* @__PURE__ */ new WeakMap();
  let l = null, c = null;
  const u = async (d, h) => {
    let p = n(d);
    const v = Ur(p, h);
    if (!v) {
      const m = {
        channelCount: p.channelCount,
        channelCountMode: p.channelCountMode,
        channelInterpretation: p.channelInterpretation,
        offset: p.offset.value
      };
      p = t(h, m), l !== null && p.start(l), c !== null && p.stop(c);
    }
    return s.set(h, p), v ? await e(h, d.offset, p.offset) : await r(h, d.offset, p.offset), await i(d, h, p), p;
  };
  return {
    set start(d) {
      l = d;
    },
    set stop(d) {
      c = d;
    },
    render(d, h) {
      const p = s.get(h);
      return p !== void 0 ? Promise.resolve(p) : u(d, h);
    }
  };
}, zk = (e) => (t) => (e[0] = t, e[0]), Uk = {
  buffer: null,
  channelCount: 2,
  channelCountMode: "clamped-max",
  channelInterpretation: "speakers",
  disableNormalization: !1
}, Vk = (e, t, n, r, i, s) => class extends e {
  constructor(c, u) {
    const d = r(c), h = { ...Uk, ...u }, p = n(d, h), m = i(d) ? t() : null;
    super(c, !1, p, m), this._isBufferNullified = !1, this._nativeConvolverNode = p, h.buffer !== null && s(this, h.buffer.duration);
  }
  get buffer() {
    return this._isBufferNullified ? null : this._nativeConvolverNode.buffer;
  }
  set buffer(c) {
    if (this._nativeConvolverNode.buffer = c, c === null && this._nativeConvolverNode.buffer !== null) {
      const u = this._nativeConvolverNode.context;
      this._nativeConvolverNode.buffer = u.createBuffer(1, 1, u.sampleRate), this._isBufferNullified = !0, s(this, 0);
    } else
      this._isBufferNullified = !1, s(this, this._nativeConvolverNode.buffer === null ? 0 : this._nativeConvolverNode.buffer.duration);
  }
  get normalize() {
    return this._nativeConvolverNode.normalize;
  }
  set normalize(c) {
    this._nativeConvolverNode.normalize = c;
  }
}, Gk = (e, t, n) => () => {
  const r = /* @__PURE__ */ new WeakMap(), i = async (s, l) => {
    let c = t(s);
    if (!Ur(c, l)) {
      const d = {
        buffer: c.buffer,
        channelCount: c.channelCount,
        channelCountMode: c.channelCountMode,
        channelInterpretation: c.channelInterpretation,
        disableNormalization: !c.normalize
      };
      c = e(l, d);
    }
    return r.set(l, c), tu(c) ? await n(s, l, c.inputs[0]) : await n(s, l, c), c;
  };
  return {
    render(s, l) {
      const c = r.get(l);
      return c !== void 0 ? Promise.resolve(c) : i(s, l);
    }
  };
}, qk = (e, t) => (n, r, i) => {
  if (t === null)
    throw new Error("Missing the native OfflineAudioContext constructor.");
  try {
    return new t(n, r, i);
  } catch (s) {
    throw s.name === "SyntaxError" ? e() : s;
  }
}, Hk = () => new DOMException("", "DataCloneError"), Xb = (e) => {
  const { port1: t, port2: n } = new MessageChannel();
  return new Promise((r) => {
    const i = () => {
      n.onmessage = null, t.close(), n.close(), r();
    };
    n.onmessage = () => i();
    try {
      t.postMessage(e, [e]);
    } catch {
    } finally {
      i();
    }
  });
}, Wk = (e, t, n, r, i, s, l, c, u, d, h) => (p, v) => {
  const m = l(p) ? p : s(p);
  if (i.has(v)) {
    const g = n();
    return Promise.reject(g);
  }
  try {
    i.add(v);
  } catch {
  }
  return t(u, () => u(m)) ? m.decodeAudioData(v).then((g) => (Xb(v).catch(() => {
  }), t(c, () => c(g)) || h(g), e.add(g), g)) : new Promise((g, b) => {
    const x = async () => {
      try {
        await Xb(v);
      } catch {
      }
    }, w = (T) => {
      b(T), x();
    };
    try {
      m.decodeAudioData(v, (T) => {
        typeof T.copyFromChannel != "function" && (d(T), vy(T)), e.add(T), x().then(() => g(T));
      }, (T) => {
        w(T === null ? r() : T);
      });
    } catch (T) {
      w(T);
    }
  });
}, $k = (e, t, n, r, i, s, l, c) => (u, d) => {
  const h = t.get(u);
  if (h === void 0)
    throw new Error("Missing the expected cycle count.");
  const p = s(u.context), v = c(p);
  if (h === d) {
    if (t.delete(u), !v && l(u)) {
      const m = r(u), { outputs: g } = n(u);
      for (const b of g)
        if (wh(b)) {
          const x = r(b[0]);
          e(m, x, b[1], b[2]);
        } else {
          const x = i(b[0]);
          m.connect(x, b[1]);
        }
    }
  } else
    t.set(u, h - d);
}, Kk = {
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers",
  delayTime: 0,
  maxDelayTime: 1
}, Yk = (e, t, n, r, i, s, l) => class extends e {
  constructor(u, d) {
    const h = i(u), p = { ...Kk, ...d }, v = r(h, p), m = s(h), g = m ? n(p.maxDelayTime) : null;
    super(u, !1, v, g), this._delayTime = t(this, m, v.delayTime), l(this, p.maxDelayTime);
  }
  get delayTime() {
    return this._delayTime;
  }
}, Xk = (e, t, n, r, i) => (s) => {
  const l = /* @__PURE__ */ new WeakMap(), c = async (u, d) => {
    let h = n(u);
    const p = Ur(h, d);
    if (!p) {
      const v = {
        channelCount: h.channelCount,
        channelCountMode: h.channelCountMode,
        channelInterpretation: h.channelInterpretation,
        delayTime: h.delayTime.value,
        maxDelayTime: s
      };
      h = t(d, v);
    }
    return l.set(d, h), p ? await e(d, u.delayTime, h.delayTime) : await r(d, u.delayTime, h.delayTime), await i(u, d, h), h;
  };
  return {
    render(u, d) {
      const h = l.get(d);
      return h !== void 0 ? Promise.resolve(h) : c(u, d);
    }
  };
}, Qk = (e) => (t, n, r, i) => e(t[i], (s) => s[0] === n && s[1] === r), Zk = (e) => (t, n) => {
  e(t).delete(n);
}, Jk = (e) => "delayTime" in e, tR = (e, t, n) => function r(i, s) {
  const l = fp(s) ? s : n(e, s);
  if (Jk(l))
    return [];
  if (i[0] === l)
    return [i];
  if (i.includes(l))
    return [];
  const { outputs: c } = t(l);
  return Array.from(c).map((u) => r([...i, l], u[0])).reduce((u, d) => u.concat(d), []);
}, Df = (e, t, n) => {
  const r = t[n];
  if (r === void 0)
    throw e();
  return r;
}, eR = (e) => (t, n = void 0, r = void 0, i = 0) => n === void 0 ? t.forEach((s) => s.disconnect()) : typeof n == "number" ? Df(e, t, n).disconnect() : gp(n) ? r === void 0 ? t.forEach((s) => s.disconnect(n)) : i === void 0 ? Df(e, t, r).disconnect(n, 0) : Df(e, t, r).disconnect(n, 0, i) : r === void 0 ? t.forEach((s) => s.disconnect(n)) : Df(e, t, r).disconnect(n, 0), nR = {
  attack: 3e-3,
  channelCount: 2,
  channelCountMode: "clamped-max",
  channelInterpretation: "speakers",
  knee: 30,
  ratio: 12,
  release: 0.25,
  threshold: -24
}, rR = (e, t, n, r, i, s, l, c) => class extends e {
  constructor(d, h) {
    const p = s(d), v = { ...nR, ...h }, m = r(p, v), g = l(p), b = g ? n() : null;
    super(d, !1, m, b), this._attack = t(this, g, m.attack), this._knee = t(this, g, m.knee), this._nativeDynamicsCompressorNode = m, this._ratio = t(this, g, m.ratio), this._release = t(this, g, m.release), this._threshold = t(this, g, m.threshold), c(this, 6e-3);
  }
  get attack() {
    return this._attack;
  }
  // Bug #108: Safari allows a channelCount of three and above which is why the getter and setter needs to be overwritten here.
  get channelCount() {
    return this._nativeDynamicsCompressorNode.channelCount;
  }
  set channelCount(d) {
    const h = this._nativeDynamicsCompressorNode.channelCount;
    if (this._nativeDynamicsCompressorNode.channelCount = d, d > 2)
      throw this._nativeDynamicsCompressorNode.channelCount = h, i();
  }
  /*
   * Bug #109: Only Chrome and Firefox disallow a channelCountMode of 'max' yet which is why the getter and setter needs to be
   * overwritten here.
   */
  get channelCountMode() {
    return this._nativeDynamicsCompressorNode.channelCountMode;
  }
  set channelCountMode(d) {
    const h = this._nativeDynamicsCompressorNode.channelCountMode;
    if (this._nativeDynamicsCompressorNode.channelCountMode = d, d === "max")
      throw this._nativeDynamicsCompressorNode.channelCountMode = h, i();
  }
  get knee() {
    return this._knee;
  }
  get ratio() {
    return this._ratio;
  }
  get reduction() {
    return typeof this._nativeDynamicsCompressorNode.reduction.value == "number" ? this._nativeDynamicsCompressorNode.reduction.value : this._nativeDynamicsCompressorNode.reduction;
  }
  get release() {
    return this._release;
  }
  get threshold() {
    return this._threshold;
  }
}, iR = (e, t, n, r, i) => () => {
  const s = /* @__PURE__ */ new WeakMap(), l = async (c, u) => {
    let d = n(c);
    const h = Ur(d, u);
    if (!h) {
      const p = {
        attack: d.attack.value,
        channelCount: d.channelCount,
        channelCountMode: d.channelCountMode,
        channelInterpretation: d.channelInterpretation,
        knee: d.knee.value,
        ratio: d.ratio.value,
        release: d.release.value,
        threshold: d.threshold.value
      };
      d = t(u, p);
    }
    return s.set(u, d), h ? (await e(u, c.attack, d.attack), await e(u, c.knee, d.knee), await e(u, c.ratio, d.ratio), await e(u, c.release, d.release), await e(u, c.threshold, d.threshold)) : (await r(u, c.attack, d.attack), await r(u, c.knee, d.knee), await r(u, c.ratio, d.ratio), await r(u, c.release, d.release), await r(u, c.threshold, d.threshold)), await i(c, u, d), d;
  };
  return {
    render(c, u) {
      const d = s.get(u);
      return d !== void 0 ? Promise.resolve(d) : l(c, u);
    }
  };
}, sR = () => new DOMException("", "EncodingError"), oR = (e) => (t) => new Promise((n, r) => {
  if (e === null) {
    r(new SyntaxError());
    return;
  }
  const i = e.document.head;
  if (i === null)
    r(new SyntaxError());
  else {
    const s = e.document.createElement("script"), l = new Blob([t], { type: "application/javascript" }), c = URL.createObjectURL(l), u = e.onerror, d = () => {
      e.onerror = u, URL.revokeObjectURL(c);
    };
    e.onerror = (h, p, v, m, g) => {
      if (p === c || p === e.location.href && v === 1 && m === 1)
        return d(), r(g), !1;
      if (u !== null)
        return u(h, p, v, m, g);
    }, s.onerror = () => {
      d(), r(new SyntaxError());
    }, s.onload = () => {
      d(), n();
    }, s.src = c, s.type = "module", i.appendChild(s);
  }
}), aR = (e) => class {
  constructor(n) {
    this._nativeEventTarget = n, this._listeners = /* @__PURE__ */ new WeakMap();
  }
  addEventListener(n, r, i) {
    if (r !== null) {
      let s = this._listeners.get(r);
      s === void 0 && (s = e(this, r), typeof r == "function" && this._listeners.set(r, s)), this._nativeEventTarget.addEventListener(n, s, i);
    }
  }
  dispatchEvent(n) {
    return this._nativeEventTarget.dispatchEvent(n);
  }
  removeEventListener(n, r, i) {
    const s = r === null ? void 0 : this._listeners.get(r);
    this._nativeEventTarget.removeEventListener(n, s === void 0 ? null : s, i);
  }
}, lR = (e) => (t, n, r) => {
  Object.defineProperties(e, {
    currentFrame: {
      configurable: !0,
      get() {
        return Math.round(t * n);
      }
    },
    currentTime: {
      configurable: !0,
      get() {
        return t;
      }
    }
  });
  try {
    return r();
  } finally {
    e !== null && (delete e.currentFrame, delete e.currentTime);
  }
}, cR = (e) => async (t) => {
  try {
    const n = await fetch(t);
    if (n.ok)
      return [await n.text(), n.url];
  } catch {
  }
  throw e();
}, uR = {
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers",
  gain: 1
}, dR = (e, t, n, r, i, s) => class extends e {
  constructor(c, u) {
    const d = i(c), h = { ...uR, ...u }, p = r(d, h), v = s(d), m = v ? n() : null;
    super(c, !1, p, m), this._gain = t(this, v, p.gain, Wr, Si);
  }
  get gain() {
    return this._gain;
  }
}, hR = (e, t, n, r, i) => () => {
  const s = /* @__PURE__ */ new WeakMap(), l = async (c, u) => {
    let d = n(c);
    const h = Ur(d, u);
    if (!h) {
      const p = {
        channelCount: d.channelCount,
        channelCountMode: d.channelCountMode,
        channelInterpretation: d.channelInterpretation,
        gain: d.gain.value
      };
      d = t(u, p);
    }
    return s.set(u, d), h ? await e(u, c.gain, d.gain) : await r(u, c.gain, d.gain), await i(c, u, d), d;
  };
  return {
    render(c, u) {
      const d = s.get(u);
      return d !== void 0 ? Promise.resolve(d) : l(c, u);
    }
  };
}, fR = (e, t) => (n) => t(e, n), pR = (e) => (t) => {
  const n = e(t);
  if (n.renderer === null)
    throw new Error("Missing the renderer of the given AudioNode in the audio graph.");
  return n.renderer;
}, mR = (e) => (t) => {
  var n;
  return (n = e.get(t)) !== null && n !== void 0 ? n : 0;
}, gR = (e) => (t) => {
  const n = e(t);
  if (n.renderer === null)
    throw new Error("Missing the renderer of the given AudioParam in the audio graph.");
  return n.renderer;
}, yR = (e) => (t) => e.get(t), vr = () => new DOMException("", "InvalidStateError"), vR = (e) => (t) => {
  const n = e.get(t);
  if (n === void 0)
    throw vr();
  return n;
}, bR = (e, t) => (n) => {
  let r = e.get(n);
  if (r !== void 0)
    return r;
  if (t === null)
    throw new Error("Missing the native OfflineAudioContext constructor.");
  return r = new t(1, 1, 44100), e.set(n, r), r;
}, _R = (e) => (t) => {
  const n = e.get(t);
  if (n === void 0)
    throw new Error("The context has no set of AudioWorkletNodes.");
  return n;
}, Qp = () => new DOMException("", "InvalidAccessError"), SR = (e) => {
  e.getFrequencyResponse = /* @__PURE__ */ ((t) => (n, r, i) => {
    if (n.length !== r.length || r.length !== i.length)
      throw Qp();
    return t.call(e, n, r, i);
  })(e.getFrequencyResponse);
}, xR = {
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers"
}, TR = (e, t, n, r, i, s) => class extends e {
  constructor(c, u) {
    const d = r(c), h = i(d), p = { ...xR, ...u }, v = t(d, h ? null : c.baseLatency, p), m = h ? n(p.feedback, p.feedforward) : null;
    super(c, !1, v, m), SR(v), this._nativeIIRFilterNode = v, s(this, 1);
  }
  getFrequencyResponse(c, u, d) {
    return this._nativeIIRFilterNode.getFrequencyResponse(c, u, d);
  }
}, d5 = (e, t, n, r, i, s, l, c, u, d, h) => {
  const p = d.length;
  let v = c;
  for (let m = 0; m < p; m += 1) {
    let g = n[0] * d[m];
    for (let b = 1; b < i; b += 1) {
      const x = v - b & u - 1;
      g += n[b] * s[x], g -= e[b] * l[x];
    }
    for (let b = i; b < r; b += 1)
      g += n[b] * s[v - b & u - 1];
    for (let b = i; b < t; b += 1)
      g -= e[b] * l[v - b & u - 1];
    s[v] = d[m], l[v] = g, v = v + 1 & u - 1, h[m] = g;
  }
  return v;
}, CR = (e, t, n, r) => {
  const i = n instanceof Float64Array ? n : new Float64Array(n), s = r instanceof Float64Array ? r : new Float64Array(r), l = i.length, c = s.length, u = Math.min(l, c);
  if (i[0] !== 1) {
    for (let g = 0; g < l; g += 1)
      s[g] /= i[0];
    for (let g = 1; g < c; g += 1)
      i[g] /= i[0];
  }
  const d = 32, h = new Float32Array(d), p = new Float32Array(d), v = t.createBuffer(e.numberOfChannels, e.length, e.sampleRate), m = e.numberOfChannels;
  for (let g = 0; g < m; g += 1) {
    const b = e.getChannelData(g), x = v.getChannelData(g);
    h.fill(0), p.fill(0), d5(i, l, s, c, u, h, p, 0, d, b, x);
  }
  return v;
}, wR = (e, t, n, r, i) => (s, l) => {
  const c = /* @__PURE__ */ new WeakMap();
  let u = null;
  const d = async (h, p) => {
    let v = null, m = t(h);
    const g = Ur(m, p);
    if (p.createIIRFilter === void 0 ? v = e(p, {
      buffer: null,
      channelCount: 2,
      channelCountMode: "max",
      channelInterpretation: "speakers",
      loop: !1,
      loopEnd: 0,
      loopStart: 0,
      playbackRate: 1
    }) : g || (m = p.createIIRFilter(l, s)), c.set(p, v === null ? m : v), v !== null) {
      if (u === null) {
        if (n === null)
          throw new Error("Missing the native OfflineAudioContext constructor.");
        const x = new n(
          // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.
          h.context.destination.channelCount,
          // Bug #17: Safari does not yet expose the length.
          h.context.length,
          p.sampleRate
        );
        u = (async () => {
          await r(h, x, x.destination);
          const w = await i(x);
          return CR(w, p, s, l);
        })();
      }
      const b = await u;
      return v.buffer = b, v.start(0), v;
    }
    return await r(h, p, m), m;
  };
  return {
    render(h, p) {
      const v = c.get(p);
      return v !== void 0 ? Promise.resolve(v) : d(h, p);
    }
  };
}, ER = (e, t, n, r, i, s) => (l) => (c, u) => {
  const d = e.get(c);
  if (d === void 0) {
    if (!l && s(c)) {
      const h = r(c), { outputs: p } = n(c);
      for (const v of p)
        if (wh(v)) {
          const m = r(v[0]);
          t(h, m, v[1], v[2]);
        } else {
          const m = i(v[0]);
          h.disconnect(m, v[1]);
        }
    }
    e.set(c, u);
  } else
    e.set(c, d + u);
}, AR = (e, t) => (n) => {
  const r = e.get(n);
  return t(r) || t(n);
}, kR = (e, t) => (n) => e.has(n) || t(n), RR = (e, t) => (n) => e.has(n) || t(n), MR = (e, t) => (n) => {
  const r = e.get(n);
  return t(r) || t(n);
}, OR = (e) => (t) => e !== null && t instanceof e, NR = (e) => (t) => e !== null && typeof e.AudioNode == "function" && t instanceof e.AudioNode, PR = (e) => (t) => e !== null && typeof e.AudioParam == "function" && t instanceof e.AudioParam, DR = (e, t) => (n) => e(n) || t(n), IR = (e) => (t) => e !== null && t instanceof e, BR = (e) => e !== null && e.isSecureContext, FR = (e, t, n, r) => class extends e {
  constructor(s, l) {
    const c = n(s), u = t(c, l);
    if (r(c))
      throw TypeError();
    super(s, !0, u, null), this._nativeMediaElementAudioSourceNode = u;
  }
  get mediaElement() {
    return this._nativeMediaElementAudioSourceNode.mediaElement;
  }
}, jR = {
  channelCount: 2,
  channelCountMode: "explicit",
  channelInterpretation: "speakers"
}, LR = (e, t, n, r) => class extends e {
  constructor(s, l) {
    const c = n(s);
    if (r(c))
      throw new TypeError();
    const u = { ...jR, ...l }, d = t(c, u);
    super(s, !1, d, null), this._nativeMediaStreamAudioDestinationNode = d;
  }
  get stream() {
    return this._nativeMediaStreamAudioDestinationNode.stream;
  }
}, zR = (e, t, n, r) => class extends e {
  constructor(s, l) {
    const c = n(s), u = t(c, l);
    if (r(c))
      throw new TypeError();
    super(s, !0, u, null), this._nativeMediaStreamAudioSourceNode = u;
  }
  get mediaStream() {
    return this._nativeMediaStreamAudioSourceNode.mediaStream;
  }
}, UR = (e, t, n) => class extends e {
  constructor(i, s) {
    const l = n(i), c = t(l, s);
    super(i, !0, c, null);
  }
}, VR = (e, t, n, r, i, s) => class extends n {
  constructor(c, u) {
    super(c), this._nativeContext = c, Yp.set(this, c), r(c) && i.set(c, /* @__PURE__ */ new Set()), this._destination = new e(this, u), this._listener = t(this, c), this._onstatechange = null;
  }
  get currentTime() {
    return this._nativeContext.currentTime;
  }
  get destination() {
    return this._destination;
  }
  get listener() {
    return this._listener;
  }
  get onstatechange() {
    return this._onstatechange;
  }
  set onstatechange(c) {
    const u = typeof c == "function" ? s(this, c) : null;
    this._nativeContext.onstatechange = u;
    const d = this._nativeContext.onstatechange;
    this._onstatechange = d !== null && d === u ? c : d;
  }
  get sampleRate() {
    return this._nativeContext.sampleRate;
  }
  get state() {
    return this._nativeContext.state;
  }
}, uh = (e) => {
  const t = new Uint32Array([1179011410, 40, 1163280727, 544501094, 16, 131073, 44100, 176400, 1048580, 1635017060, 4, 0]);
  try {
    const n = e.decodeAudioData(t.buffer, () => {
    });
    return n === void 0 ? !1 : (n.catch(() => {
    }), !0);
  } catch {
  }
  return !1;
}, GR = (e, t) => (n, r, i) => {
  const s = /* @__PURE__ */ new Set();
  return n.connect = /* @__PURE__ */ ((l) => (c, u = 0, d = 0) => {
    const h = s.size === 0;
    if (t(c))
      return l.call(n, c, u, d), e(s, [c, u, d], (p) => p[0] === c && p[1] === u && p[2] === d, !0), h && r(), c;
    l.call(n, c, u), e(s, [c, u], (p) => p[0] === c && p[1] === u, !0), h && r();
  })(n.connect), n.disconnect = /* @__PURE__ */ ((l) => (c, u, d) => {
    const h = s.size > 0;
    if (c === void 0)
      l.apply(n), s.clear();
    else if (typeof c == "number") {
      l.call(n, c);
      for (const v of s)
        v[1] === c && s.delete(v);
    } else {
      t(c) ? l.call(n, c, u, d) : l.call(n, c, u);
      for (const v of s)
        v[0] === c && (u === void 0 || v[1] === u) && (d === void 0 || v[2] === d) && s.delete(v);
    }
    const p = s.size === 0;
    h && p && i();
  })(n.disconnect), n;
}, On = (e, t, n) => {
  const r = t[n];
  r !== void 0 && r !== e[n] && (e[n] = r);
}, lr = (e, t) => {
  On(e, t, "channelCount"), On(e, t, "channelCountMode"), On(e, t, "channelInterpretation");
}, Qb = (e) => typeof e.getFloatTimeDomainData == "function", qR = (e) => {
  e.getFloatTimeDomainData = (t) => {
    const n = new Uint8Array(t.length);
    e.getByteTimeDomainData(n);
    const r = Math.max(n.length, e.fftSize);
    for (let i = 0; i < r; i += 1)
      t[i] = (n[i] - 128) * 78125e-7;
    return t;
  };
}, HR = (e, t) => (n, r) => {
  const i = n.createAnalyser();
  if (lr(i, r), !(r.maxDecibels > r.minDecibels))
    throw t();
  return On(i, r, "fftSize"), On(i, r, "maxDecibels"), On(i, r, "minDecibels"), On(i, r, "smoothingTimeConstant"), e(Qb, () => Qb(i)) || qR(i), i;
}, WR = (e) => e === null ? null : e.hasOwnProperty("AudioBuffer") ? e.AudioBuffer : null, Gn = (e, t, n) => {
  const r = t[n];
  r !== void 0 && r !== e[n].value && (e[n].value = r);
}, $R = (e) => {
  e.start = /* @__PURE__ */ ((t) => {
    let n = !1;
    return (r = 0, i = 0, s) => {
      if (n)
        throw vr();
      t.call(e, r, i, s), n = !0;
    };
  })(e.start);
}, Sy = (e) => {
  e.start = /* @__PURE__ */ ((t) => (n = 0, r = 0, i) => {
    if (typeof i == "number" && i < 0 || r < 0 || n < 0)
      throw new RangeError("The parameters can't be negative.");
    t.call(e, n, r, i);
  })(e.start);
}, xy = (e) => {
  e.stop = /* @__PURE__ */ ((t) => (n = 0) => {
    if (n < 0)
      throw new RangeError("The parameter can't be negative.");
    t.call(e, n);
  })(e.stop);
}, KR = (e, t, n, r, i, s, l, c, u, d, h) => (p, v) => {
  const m = p.createBufferSource();
  return lr(m, v), Gn(m, v, "playbackRate"), On(m, v, "buffer"), On(m, v, "loop"), On(m, v, "loopEnd"), On(m, v, "loopStart"), t(n, () => n(p)) || $R(m), t(r, () => r(p)) || u(m), t(i, () => i(p)) || d(m, p), t(s, () => s(p)) || Sy(m), t(l, () => l(p)) || h(m, p), t(c, () => c(p)) || xy(m), e(p, m), m;
}, YR = (e) => e === null ? null : e.hasOwnProperty("AudioContext") ? e.AudioContext : e.hasOwnProperty("webkitAudioContext") ? e.webkitAudioContext : null, XR = (e, t) => (n, r, i) => {
  const s = n.destination;
  if (s.channelCount !== r)
    try {
      s.channelCount = r;
    } catch {
    }
  i && s.channelCountMode !== "explicit" && (s.channelCountMode = "explicit"), s.maxChannelCount === 0 && Object.defineProperty(s, "maxChannelCount", {
    value: r
  });
  const l = e(n, {
    channelCount: r,
    channelCountMode: s.channelCountMode,
    channelInterpretation: s.channelInterpretation,
    gain: 1
  });
  return t(l, "channelCount", (c) => () => c.call(l), (c) => (u) => {
    c.call(l, u);
    try {
      s.channelCount = u;
    } catch (d) {
      if (u > s.maxChannelCount)
        throw d;
    }
  }), t(l, "channelCountMode", (c) => () => c.call(l), (c) => (u) => {
    c.call(l, u), s.channelCountMode = u;
  }), t(l, "channelInterpretation", (c) => () => c.call(l), (c) => (u) => {
    c.call(l, u), s.channelInterpretation = u;
  }), Object.defineProperty(l, "maxChannelCount", {
    get: () => s.maxChannelCount
  }), l.connect(s), l;
}, QR = (e) => e === null ? null : e.hasOwnProperty("AudioWorkletNode") ? e.AudioWorkletNode : null, ZR = (e) => {
  const { port1: t } = new MessageChannel();
  try {
    t.postMessage(e);
  } finally {
    t.close();
  }
}, JR = (e, t, n, r, i) => (s, l, c, u, d, h) => {
  if (c !== null)
    try {
      const p = new c(s, u, h), v = /* @__PURE__ */ new Map();
      let m = null;
      if (Object.defineProperties(p, {
        /*
         * Bug #61: Overwriting the property accessors for channelCount and channelCountMode is necessary as long as some
         * browsers have no native implementation to achieve a consistent behavior.
         */
        channelCount: {
          get: () => h.channelCount,
          set: () => {
            throw e();
          }
        },
        channelCountMode: {
          get: () => "explicit",
          set: () => {
            throw e();
          }
        },
        // Bug #156: Chrome and Edge do not yet fire an ErrorEvent.
        onprocessorerror: {
          get: () => m,
          set: (g) => {
            typeof m == "function" && p.removeEventListener("processorerror", m), m = typeof g == "function" ? g : null, typeof m == "function" && p.addEventListener("processorerror", m);
          }
        }
      }), p.addEventListener = /* @__PURE__ */ ((g) => (...b) => {
        if (b[0] === "processorerror") {
          const x = typeof b[1] == "function" ? b[1] : typeof b[1] == "object" && b[1] !== null && typeof b[1].handleEvent == "function" ? b[1].handleEvent : null;
          if (x !== null) {
            const w = v.get(b[1]);
            w !== void 0 ? b[1] = w : (b[1] = (T) => {
              T.type === "error" ? (Object.defineProperties(T, {
                type: { value: "processorerror" }
              }), x(T)) : x(new ErrorEvent(b[0], { ...T }));
            }, v.set(x, b[1]));
          }
        }
        return g.call(p, "error", b[1], b[2]), g.call(p, ...b);
      })(p.addEventListener), p.removeEventListener = /* @__PURE__ */ ((g) => (...b) => {
        if (b[0] === "processorerror") {
          const x = v.get(b[1]);
          x !== void 0 && (v.delete(b[1]), b[1] = x);
        }
        return g.call(p, "error", b[1], b[2]), g.call(p, b[0], b[1], b[2]);
      })(p.removeEventListener), h.numberOfOutputs !== 0) {
        const g = n(s, {
          channelCount: 1,
          channelCountMode: "explicit",
          channelInterpretation: "discrete",
          gain: 0
        });
        return p.connect(g).connect(s.destination), i(p, () => g.disconnect(), () => g.connect(s.destination));
      }
      return p;
    } catch (p) {
      throw p.code === 11 ? r() : p;
    }
  if (d === void 0)
    throw r();
  return ZR(h), t(s, l, d, h);
}, h5 = (e, t) => e === null ? 512 : Math.max(512, Math.min(16384, Math.pow(2, Math.round(Math.log2(e * t))))), tM = (e) => new Promise((t, n) => {
  const { port1: r, port2: i } = new MessageChannel();
  r.onmessage = ({ data: s }) => {
    r.close(), i.close(), t(s);
  }, r.onmessageerror = ({ data: s }) => {
    r.close(), i.close(), n(s);
  }, i.postMessage(e);
}), eM = async (e, t) => {
  const n = await tM(t);
  return new e(n);
}, nM = (e, t, n, r) => {
  let i = _0.get(e);
  i === void 0 && (i = /* @__PURE__ */ new WeakMap(), _0.set(e, i));
  const s = eM(n, r);
  return i.set(t, s), s;
}, rM = (e, t, n, r, i, s, l, c, u, d, h, p, v) => (m, g, b, x) => {
  if (x.numberOfInputs === 0 && x.numberOfOutputs === 0)
    throw u();
  const w = Array.isArray(x.outputChannelCount) ? x.outputChannelCount : Array.from(x.outputChannelCount);
  if (w.some((wt) => wt < 1))
    throw u();
  if (w.length !== x.numberOfOutputs)
    throw t();
  if (x.channelCountMode !== "explicit")
    throw u();
  const T = x.channelCount * x.numberOfInputs, S = w.reduce((wt, Wt) => wt + Wt, 0), C = b.parameterDescriptors === void 0 ? 0 : b.parameterDescriptors.length;
  if (T + C > 6 || S > 6)
    throw u();
  const E = new MessageChannel(), O = [], B = [];
  for (let wt = 0; wt < x.numberOfInputs; wt += 1)
    O.push(l(m, {
      channelCount: x.channelCount,
      channelCountMode: x.channelCountMode,
      channelInterpretation: x.channelInterpretation,
      gain: 1
    })), B.push(i(m, {
      channelCount: x.channelCount,
      channelCountMode: "explicit",
      channelInterpretation: "discrete",
      numberOfOutputs: x.channelCount
    }));
  const N = [];
  if (b.parameterDescriptors !== void 0)
    for (const { defaultValue: wt, maxValue: Wt, minValue: Ut, name: ne } of b.parameterDescriptors) {
      const ce = s(m, {
        channelCount: 1,
        channelCountMode: "explicit",
        channelInterpretation: "discrete",
        offset: x.parameterData[ne] !== void 0 ? x.parameterData[ne] : wt === void 0 ? 0 : wt
      });
      Object.defineProperties(ce.offset, {
        defaultValue: {
          get: () => wt === void 0 ? 0 : wt
        },
        maxValue: {
          get: () => Wt === void 0 ? Wr : Wt
        },
        minValue: {
          get: () => Ut === void 0 ? Si : Ut
        }
      }), N.push(ce);
    }
  const L = r(m, {
    channelCount: 1,
    channelCountMode: "explicit",
    channelInterpretation: "speakers",
    numberOfInputs: Math.max(1, T + C)
  }), k = h5(g, m.sampleRate), F = c(
    m,
    k,
    T + C,
    // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.
    Math.max(1, S)
  ), G = i(m, {
    channelCount: Math.max(1, S),
    channelCountMode: "explicit",
    channelInterpretation: "discrete",
    numberOfOutputs: Math.max(1, S)
  }), M = [];
  for (let wt = 0; wt < x.numberOfOutputs; wt += 1)
    M.push(r(m, {
      channelCount: 1,
      channelCountMode: "explicit",
      channelInterpretation: "speakers",
      numberOfInputs: w[wt]
    }));
  for (let wt = 0; wt < x.numberOfInputs; wt += 1) {
    O[wt].connect(B[wt]);
    for (let Wt = 0; Wt < x.channelCount; Wt += 1)
      B[wt].connect(L, Wt, wt * x.channelCount + Wt);
  }
  const j = new c5(b.parameterDescriptors === void 0 ? [] : b.parameterDescriptors.map(({ name: wt }, Wt) => {
    const Ut = N[Wt];
    return Ut.connect(L, 0, T + Wt), Ut.start(0), [wt, Ut.offset];
  }));
  L.connect(F);
  let D = x.channelInterpretation, z = null;
  const H = x.numberOfOutputs === 0 ? [F] : M, X = {
    get bufferSize() {
      return k;
    },
    get channelCount() {
      return x.channelCount;
    },
    set channelCount(wt) {
      throw n();
    },
    get channelCountMode() {
      return x.channelCountMode;
    },
    set channelCountMode(wt) {
      throw n();
    },
    get channelInterpretation() {
      return D;
    },
    set channelInterpretation(wt) {
      for (const Wt of O)
        Wt.channelInterpretation = wt;
      D = wt;
    },
    get context() {
      return F.context;
    },
    get inputs() {
      return O;
    },
    get numberOfInputs() {
      return x.numberOfInputs;
    },
    get numberOfOutputs() {
      return x.numberOfOutputs;
    },
    get onprocessorerror() {
      return z;
    },
    set onprocessorerror(wt) {
      typeof z == "function" && X.removeEventListener("processorerror", z), z = typeof wt == "function" ? wt : null, typeof z == "function" && X.addEventListener("processorerror", z);
    },
    get parameters() {
      return j;
    },
    get port() {
      return E.port2;
    },
    addEventListener(...wt) {
      return F.addEventListener(wt[0], wt[1], wt[2]);
    },
    connect: e.bind(null, H),
    disconnect: d.bind(null, H),
    dispatchEvent(...wt) {
      return F.dispatchEvent(wt[0]);
    },
    removeEventListener(...wt) {
      return F.removeEventListener(wt[0], wt[1], wt[2]);
    }
  }, Y = /* @__PURE__ */ new Map();
  E.port1.addEventListener = /* @__PURE__ */ ((wt) => (...Wt) => {
    if (Wt[0] === "message") {
      const Ut = typeof Wt[1] == "function" ? Wt[1] : typeof Wt[1] == "object" && Wt[1] !== null && typeof Wt[1].handleEvent == "function" ? Wt[1].handleEvent : null;
      if (Ut !== null) {
        const ne = Y.get(Wt[1]);
        ne !== void 0 ? Wt[1] = ne : (Wt[1] = (ce) => {
          h(m.currentTime, m.sampleRate, () => Ut(ce));
        }, Y.set(Ut, Wt[1]));
      }
    }
    return wt.call(E.port1, Wt[0], Wt[1], Wt[2]);
  })(E.port1.addEventListener), E.port1.removeEventListener = /* @__PURE__ */ ((wt) => (...Wt) => {
    if (Wt[0] === "message") {
      const Ut = Y.get(Wt[1]);
      Ut !== void 0 && (Y.delete(Wt[1]), Wt[1] = Ut);
    }
    return wt.call(E.port1, Wt[0], Wt[1], Wt[2]);
  })(E.port1.removeEventListener);
  let V = null;
  Object.defineProperty(E.port1, "onmessage", {
    get: () => V,
    set: (wt) => {
      typeof V == "function" && E.port1.removeEventListener("message", V), V = typeof wt == "function" ? wt : null, typeof V == "function" && (E.port1.addEventListener("message", V), E.port1.start());
    }
  }), b.prototype.port = E.port1;
  let Z = null;
  nM(m, X, b, x).then((wt) => Z = wt);
  const et = vp(x.numberOfInputs, x.channelCount), rt = vp(x.numberOfOutputs, w), st = b.parameterDescriptors === void 0 ? [] : b.parameterDescriptors.reduce((wt, { name: Wt }) => ({ ...wt, [Wt]: new Float32Array(128) }), {});
  let yt = !0;
  const J = () => {
    x.numberOfOutputs > 0 && F.disconnect(G);
    for (let wt = 0, Wt = 0; wt < x.numberOfOutputs; wt += 1) {
      const Ut = M[wt];
      for (let ne = 0; ne < w[wt]; ne += 1)
        G.disconnect(Ut, Wt + ne, ne);
      Wt += w[wt];
    }
  }, tt = /* @__PURE__ */ new Map();
  F.onaudioprocess = ({ inputBuffer: wt, outputBuffer: Wt }) => {
    if (Z !== null) {
      const Ut = p(X);
      for (let ne = 0; ne < k; ne += 128) {
        for (let ce = 0; ce < x.numberOfInputs; ce += 1)
          for (let re = 0; re < x.channelCount; re += 1)
            yp(wt, et[ce], re, re, ne);
        b.parameterDescriptors !== void 0 && b.parameterDescriptors.forEach(({ name: ce }, re) => {
          yp(wt, st, ce, T + re, ne);
        });
        for (let ce = 0; ce < x.numberOfInputs; ce += 1)
          for (let re = 0; re < w[ce]; re += 1)
            rt[ce][re].byteLength === 0 && (rt[ce][re] = new Float32Array(128));
        try {
          const ce = et.map((le, Lt) => {
            if (Ut[Lt].size > 0)
              return tt.set(Lt, k / 128), le;
            const be = tt.get(Lt);
            return be === void 0 ? [] : (le.every((Nt) => Nt.every((Bt) => Bt === 0)) && (be === 1 ? tt.delete(Lt) : tt.set(Lt, be - 1)), le);
          });
          yt = h(m.currentTime + ne / m.sampleRate, m.sampleRate, () => Z.process(ce, rt, st));
          for (let le = 0, Lt = 0; le < x.numberOfOutputs; le += 1) {
            for (let ye = 0; ye < w[le]; ye += 1)
              u5(Wt, rt[le], ye, Lt + ye, ne);
            Lt += w[le];
          }
        } catch (ce) {
          yt = !1, X.dispatchEvent(new ErrorEvent("processorerror", {
            colno: ce.colno,
            filename: ce.filename,
            lineno: ce.lineno,
            message: ce.message
          }));
        }
        if (!yt) {
          for (let ce = 0; ce < x.numberOfInputs; ce += 1) {
            O[ce].disconnect(B[ce]);
            for (let re = 0; re < x.channelCount; re += 1)
              B[ne].disconnect(L, re, ce * x.channelCount + re);
          }
          if (b.parameterDescriptors !== void 0) {
            const ce = b.parameterDescriptors.length;
            for (let re = 0; re < ce; re += 1) {
              const le = N[re];
              le.disconnect(L, 0, T + re), le.stop();
            }
          }
          L.disconnect(F), F.onaudioprocess = null, ot ? J() : bt();
          break;
        }
      }
    }
  };
  let ot = !1;
  const Tt = l(m, {
    channelCount: 1,
    channelCountMode: "explicit",
    channelInterpretation: "discrete",
    gain: 0
  }), Ct = () => F.connect(Tt).connect(m.destination), bt = () => {
    F.disconnect(Tt), Tt.disconnect();
  }, Ht = () => {
    if (yt) {
      bt(), x.numberOfOutputs > 0 && F.connect(G);
      for (let wt = 0, Wt = 0; wt < x.numberOfOutputs; wt += 1) {
        const Ut = M[wt];
        for (let ne = 0; ne < w[wt]; ne += 1)
          G.connect(Ut, Wt + ne, ne);
        Wt += w[wt];
      }
    }
    ot = !0;
  }, $t = () => {
    yt && (Ct(), J()), ot = !1;
  };
  return Ct(), v(X, Ht, $t);
}, f5 = (e, t) => {
  const n = e.createBiquadFilter();
  return lr(n, t), Gn(n, t, "Q"), Gn(n, t, "detune"), Gn(n, t, "frequency"), Gn(n, t, "gain"), On(n, t, "type"), n;
}, iM = (e, t) => (n, r) => {
  const i = n.createChannelMerger(r.numberOfInputs);
  return e !== null && e.name === "webkitAudioContext" && t(n, i), lr(i, r), i;
}, sM = (e) => {
  const t = e.numberOfOutputs;
  Object.defineProperty(e, "channelCount", {
    get: () => t,
    set: (n) => {
      if (n !== t)
        throw vr();
    }
  }), Object.defineProperty(e, "channelCountMode", {
    get: () => "explicit",
    set: (n) => {
      if (n !== "explicit")
        throw vr();
    }
  }), Object.defineProperty(e, "channelInterpretation", {
    get: () => "discrete",
    set: (n) => {
      if (n !== "discrete")
        throw vr();
    }
  });
}, Eh = (e, t) => {
  const n = e.createChannelSplitter(t.numberOfOutputs);
  return lr(n, t), sM(n), n;
}, oM = (e, t, n, r, i) => (s, l) => {
  if (s.createConstantSource === void 0)
    return n(s, l);
  const c = s.createConstantSource();
  return lr(c, l), Gn(c, l, "offset"), t(r, () => r(s)) || Sy(c), t(i, () => i(s)) || xy(c), e(s, c), c;
}, eu = (e, t) => (e.connect = t.connect.bind(t), e.disconnect = t.disconnect.bind(t), e), aM = (e, t, n, r) => (i, { offset: s, ...l }) => {
  const c = i.createBuffer(1, 2, 44100), u = t(i, {
    buffer: null,
    channelCount: 2,
    channelCountMode: "max",
    channelInterpretation: "speakers",
    loop: !1,
    loopEnd: 0,
    loopStart: 0,
    playbackRate: 1
  }), d = n(i, { ...l, gain: s }), h = c.getChannelData(0);
  h[0] = 1, h[1] = 1, u.buffer = c, u.loop = !0;
  const p = {
    get bufferSize() {
    },
    get channelCount() {
      return d.channelCount;
    },
    set channelCount(g) {
      d.channelCount = g;
    },
    get channelCountMode() {
      return d.channelCountMode;
    },
    set channelCountMode(g) {
      d.channelCountMode = g;
    },
    get channelInterpretation() {
      return d.channelInterpretation;
    },
    set channelInterpretation(g) {
      d.channelInterpretation = g;
    },
    get context() {
      return d.context;
    },
    get inputs() {
      return [];
    },
    get numberOfInputs() {
      return u.numberOfInputs;
    },
    get numberOfOutputs() {
      return d.numberOfOutputs;
    },
    get offset() {
      return d.gain;
    },
    get onended() {
      return u.onended;
    },
    set onended(g) {
      u.onended = g;
    },
    addEventListener(...g) {
      return u.addEventListener(g[0], g[1], g[2]);
    },
    dispatchEvent(...g) {
      return u.dispatchEvent(g[0]);
    },
    removeEventListener(...g) {
      return u.removeEventListener(g[0], g[1], g[2]);
    },
    start(g = 0) {
      u.start.call(u, g);
    },
    stop(g = 0) {
      u.stop.call(u, g);
    }
  }, v = () => u.connect(d), m = () => u.disconnect(d);
  return e(i, u), r(eu(p, d), v, m);
}, lM = (e, t) => (n, r) => {
  const i = n.createConvolver();
  if (lr(i, r), r.disableNormalization === i.normalize && (i.normalize = !r.disableNormalization), On(i, r, "buffer"), r.channelCount > 2 || (t(i, "channelCount", (s) => () => s.call(i), (s) => (l) => {
    if (l > 2)
      throw e();
    return s.call(i, l);
  }), r.channelCountMode === "max"))
    throw e();
  return t(i, "channelCountMode", (s) => () => s.call(i), (s) => (l) => {
    if (l === "max")
      throw e();
    return s.call(i, l);
  }), i;
}, p5 = (e, t) => {
  const n = e.createDelay(t.maxDelayTime);
  return lr(n, t), Gn(n, t, "delayTime"), n;
}, cM = (e) => (t, n) => {
  const r = t.createDynamicsCompressor();
  if (lr(r, n), n.channelCount > 2 || n.channelCountMode === "max")
    throw e();
  return Gn(r, n, "attack"), Gn(r, n, "knee"), Gn(r, n, "ratio"), Gn(r, n, "release"), Gn(r, n, "threshold"), r;
}, oi = (e, t) => {
  const n = e.createGain();
  return lr(n, t), Gn(n, t, "gain"), n;
}, uM = (e) => (t, n, r) => {
  if (t.createIIRFilter === void 0)
    return e(t, n, r);
  const i = t.createIIRFilter(r.feedforward, r.feedback);
  return lr(i, r), i;
};
function dM(e, t) {
  const n = t[0] * t[0] + t[1] * t[1];
  return [(e[0] * t[0] + e[1] * t[1]) / n, (e[1] * t[0] - e[0] * t[1]) / n];
}
function hM(e, t) {
  return [e[0] * t[0] - e[1] * t[1], e[0] * t[1] + e[1] * t[0]];
}
function Zb(e, t) {
  let n = [0, 0];
  for (let r = e.length - 1; r >= 0; r -= 1)
    n = hM(n, t), n[0] += e[r];
  return n;
}
const fM = (e, t, n, r) => (i, s, { channelCount: l, channelCountMode: c, channelInterpretation: u, feedback: d, feedforward: h }) => {
  const p = h5(s, i.sampleRate), v = d instanceof Float64Array ? d : new Float64Array(d), m = h instanceof Float64Array ? h : new Float64Array(h), g = v.length, b = m.length, x = Math.min(g, b);
  if (g === 0 || g > 20)
    throw r();
  if (v[0] === 0)
    throw t();
  if (b === 0 || b > 20)
    throw r();
  if (m[0] === 0)
    throw t();
  if (v[0] !== 1) {
    for (let N = 0; N < b; N += 1)
      m[N] /= v[0];
    for (let N = 1; N < g; N += 1)
      v[N] /= v[0];
  }
  const w = n(i, p, l, l);
  w.channelCount = l, w.channelCountMode = c, w.channelInterpretation = u;
  const T = 32, S = [], C = [], E = [];
  for (let N = 0; N < l; N += 1) {
    S.push(0);
    const L = new Float32Array(T), k = new Float32Array(T);
    L.fill(0), k.fill(0), C.push(L), E.push(k);
  }
  w.onaudioprocess = (N) => {
    const L = N.inputBuffer, k = N.outputBuffer, F = L.numberOfChannels;
    for (let G = 0; G < F; G += 1) {
      const M = L.getChannelData(G), j = k.getChannelData(G);
      S[G] = d5(v, g, m, b, x, C[G], E[G], S[G], T, M, j);
    }
  };
  const O = i.sampleRate / 2;
  return eu({
    get bufferSize() {
      return p;
    },
    get channelCount() {
      return w.channelCount;
    },
    set channelCount(N) {
      w.channelCount = N;
    },
    get channelCountMode() {
      return w.channelCountMode;
    },
    set channelCountMode(N) {
      w.channelCountMode = N;
    },
    get channelInterpretation() {
      return w.channelInterpretation;
    },
    set channelInterpretation(N) {
      w.channelInterpretation = N;
    },
    get context() {
      return w.context;
    },
    get inputs() {
      return [w];
    },
    get numberOfInputs() {
      return w.numberOfInputs;
    },
    get numberOfOutputs() {
      return w.numberOfOutputs;
    },
    addEventListener(...N) {
      return w.addEventListener(N[0], N[1], N[2]);
    },
    dispatchEvent(...N) {
      return w.dispatchEvent(N[0]);
    },
    getFrequencyResponse(N, L, k) {
      if (N.length !== L.length || L.length !== k.length)
        throw e();
      const F = N.length;
      for (let G = 0; G < F; G += 1) {
        const M = -Math.PI * (N[G] / O), j = [Math.cos(M), Math.sin(M)], D = Zb(m, j), z = Zb(v, j), H = dM(D, z);
        L[G] = Math.sqrt(H[0] * H[0] + H[1] * H[1]), k[G] = Math.atan2(H[1], H[0]);
      }
    },
    removeEventListener(...N) {
      return w.removeEventListener(N[0], N[1], N[2]);
    }
  }, w);
}, pM = (e, t) => e.createMediaElementSource(t.mediaElement), mM = (e, t) => {
  const n = e.createMediaStreamDestination();
  return lr(n, t), n.numberOfOutputs === 1 && Object.defineProperty(n, "numberOfOutputs", { get: () => 0 }), n;
}, gM = (e, { mediaStream: t }) => {
  const n = t.getAudioTracks();
  n.sort((s, l) => s.id < l.id ? -1 : s.id > l.id ? 1 : 0);
  const r = n.slice(0, 1), i = e.createMediaStreamSource(new MediaStream(r));
  return Object.defineProperty(i, "mediaStream", { value: t }), i;
}, yM = (e, t) => (n, { mediaStreamTrack: r }) => {
  if (typeof n.createMediaStreamTrackSource == "function")
    return n.createMediaStreamTrackSource(r);
  const i = new MediaStream([r]), s = n.createMediaStreamSource(i);
  if (r.kind !== "audio")
    throw e();
  if (t(n))
    throw new TypeError();
  return s;
}, vM = (e) => e === null ? null : e.hasOwnProperty("OfflineAudioContext") ? e.OfflineAudioContext : e.hasOwnProperty("webkitOfflineAudioContext") ? e.webkitOfflineAudioContext : null, bM = (e, t, n, r, i, s) => (l, c) => {
  const u = l.createOscillator();
  return lr(u, c), Gn(u, c, "detune"), Gn(u, c, "frequency"), c.periodicWave !== void 0 ? u.setPeriodicWave(c.periodicWave) : On(u, c, "type"), t(n, () => n(l)) || Sy(u), t(r, () => r(l)) || s(u, l), t(i, () => i(l)) || xy(u), e(l, u), u;
}, _M = (e) => (t, n) => {
  const r = t.createPanner();
  return r.orientationX === void 0 ? e(t, n) : (lr(r, n), Gn(r, n, "orientationX"), Gn(r, n, "orientationY"), Gn(r, n, "orientationZ"), Gn(r, n, "positionX"), Gn(r, n, "positionY"), Gn(r, n, "positionZ"), On(r, n, "coneInnerAngle"), On(r, n, "coneOuterAngle"), On(r, n, "coneOuterGain"), On(r, n, "distanceModel"), On(r, n, "maxDistance"), On(r, n, "panningModel"), On(r, n, "refDistance"), On(r, n, "rolloffFactor"), r);
}, SM = (e, t, n, r, i, s, l, c, u, d) => (h, { coneInnerAngle: p, coneOuterAngle: v, coneOuterGain: m, distanceModel: g, maxDistance: b, orientationX: x, orientationY: w, orientationZ: T, panningModel: S, positionX: C, positionY: E, positionZ: O, refDistance: B, rolloffFactor: N, ...L }) => {
  const k = h.createPanner();
  if (L.channelCount > 2 || L.channelCountMode === "max")
    throw l();
  lr(k, L);
  const F = {
    channelCount: 1,
    channelCountMode: "explicit",
    channelInterpretation: "discrete"
  }, G = n(h, {
    ...F,
    channelInterpretation: "speakers",
    numberOfInputs: 6
  }), M = r(h, { ...L, gain: 1 }), j = r(h, { ...F, gain: 1 }), D = r(h, { ...F, gain: 0 }), z = r(h, { ...F, gain: 0 }), H = r(h, { ...F, gain: 0 }), X = r(h, { ...F, gain: 0 }), Y = r(h, { ...F, gain: 0 }), V = i(h, 256, 6, 1), Z = s(h, {
    ...F,
    curve: new Float32Array([1, 1]),
    oversample: "none"
  });
  let ct = [x, w, T], et = [C, E, O];
  const rt = new Float32Array(1);
  V.onaudioprocess = ({ inputBuffer: tt }) => {
    const ot = [
      u(tt, rt, 0),
      u(tt, rt, 1),
      u(tt, rt, 2)
    ];
    ot.some((Ct, bt) => Ct !== ct[bt]) && (k.setOrientation(...ot), ct = ot);
    const Tt = [
      u(tt, rt, 3),
      u(tt, rt, 4),
      u(tt, rt, 5)
    ];
    Tt.some((Ct, bt) => Ct !== et[bt]) && (k.setPosition(...Tt), et = Tt);
  }, Object.defineProperty(D.gain, "defaultValue", { get: () => 0 }), Object.defineProperty(z.gain, "defaultValue", { get: () => 0 }), Object.defineProperty(H.gain, "defaultValue", { get: () => 0 }), Object.defineProperty(X.gain, "defaultValue", { get: () => 0 }), Object.defineProperty(Y.gain, "defaultValue", { get: () => 0 });
  const st = {
    get bufferSize() {
    },
    get channelCount() {
      return k.channelCount;
    },
    set channelCount(tt) {
      if (tt > 2)
        throw l();
      M.channelCount = tt, k.channelCount = tt;
    },
    get channelCountMode() {
      return k.channelCountMode;
    },
    set channelCountMode(tt) {
      if (tt === "max")
        throw l();
      M.channelCountMode = tt, k.channelCountMode = tt;
    },
    get channelInterpretation() {
      return k.channelInterpretation;
    },
    set channelInterpretation(tt) {
      M.channelInterpretation = tt, k.channelInterpretation = tt;
    },
    get coneInnerAngle() {
      return k.coneInnerAngle;
    },
    set coneInnerAngle(tt) {
      k.coneInnerAngle = tt;
    },
    get coneOuterAngle() {
      return k.coneOuterAngle;
    },
    set coneOuterAngle(tt) {
      k.coneOuterAngle = tt;
    },
    get coneOuterGain() {
      return k.coneOuterGain;
    },
    set coneOuterGain(tt) {
      if (tt < 0 || tt > 1)
        throw t();
      k.coneOuterGain = tt;
    },
    get context() {
      return k.context;
    },
    get distanceModel() {
      return k.distanceModel;
    },
    set distanceModel(tt) {
      k.distanceModel = tt;
    },
    get inputs() {
      return [M];
    },
    get maxDistance() {
      return k.maxDistance;
    },
    set maxDistance(tt) {
      if (tt < 0)
        throw new RangeError();
      k.maxDistance = tt;
    },
    get numberOfInputs() {
      return k.numberOfInputs;
    },
    get numberOfOutputs() {
      return k.numberOfOutputs;
    },
    get orientationX() {
      return j.gain;
    },
    get orientationY() {
      return D.gain;
    },
    get orientationZ() {
      return z.gain;
    },
    get panningModel() {
      return k.panningModel;
    },
    set panningModel(tt) {
      k.panningModel = tt;
    },
    get positionX() {
      return H.gain;
    },
    get positionY() {
      return X.gain;
    },
    get positionZ() {
      return Y.gain;
    },
    get refDistance() {
      return k.refDistance;
    },
    set refDistance(tt) {
      if (tt < 0)
        throw new RangeError();
      k.refDistance = tt;
    },
    get rolloffFactor() {
      return k.rolloffFactor;
    },
    set rolloffFactor(tt) {
      if (tt < 0)
        throw new RangeError();
      k.rolloffFactor = tt;
    },
    addEventListener(...tt) {
      return M.addEventListener(tt[0], tt[1], tt[2]);
    },
    dispatchEvent(...tt) {
      return M.dispatchEvent(tt[0]);
    },
    removeEventListener(...tt) {
      return M.removeEventListener(tt[0], tt[1], tt[2]);
    }
  };
  p !== st.coneInnerAngle && (st.coneInnerAngle = p), v !== st.coneOuterAngle && (st.coneOuterAngle = v), m !== st.coneOuterGain && (st.coneOuterGain = m), g !== st.distanceModel && (st.distanceModel = g), b !== st.maxDistance && (st.maxDistance = b), x !== st.orientationX.value && (st.orientationX.value = x), w !== st.orientationY.value && (st.orientationY.value = w), T !== st.orientationZ.value && (st.orientationZ.value = T), S !== st.panningModel && (st.panningModel = S), C !== st.positionX.value && (st.positionX.value = C), E !== st.positionY.value && (st.positionY.value = E), O !== st.positionZ.value && (st.positionZ.value = O), B !== st.refDistance && (st.refDistance = B), N !== st.rolloffFactor && (st.rolloffFactor = N), (ct[0] !== 1 || ct[1] !== 0 || ct[2] !== 0) && k.setOrientation(...ct), (et[0] !== 0 || et[1] !== 0 || et[2] !== 0) && k.setPosition(...et);
  const yt = () => {
    M.connect(k), e(M, Z, 0, 0), Z.connect(j).connect(G, 0, 0), Z.connect(D).connect(G, 0, 1), Z.connect(z).connect(G, 0, 2), Z.connect(H).connect(G, 0, 3), Z.connect(X).connect(G, 0, 4), Z.connect(Y).connect(G, 0, 5), G.connect(V).connect(h.destination);
  }, J = () => {
    M.disconnect(k), c(M, Z, 0, 0), Z.disconnect(j), j.disconnect(G), Z.disconnect(D), D.disconnect(G), Z.disconnect(z), z.disconnect(G), Z.disconnect(H), H.disconnect(G), Z.disconnect(X), X.disconnect(G), Z.disconnect(Y), Y.disconnect(G), G.disconnect(V), V.disconnect(h.destination);
  };
  return d(eu(st, k), yt, J);
}, xM = (e) => (t, { disableNormalization: n, imag: r, real: i }) => {
  const s = r instanceof Float32Array ? r : new Float32Array(r), l = i instanceof Float32Array ? i : new Float32Array(i), c = t.createPeriodicWave(l, s, { disableNormalization: n });
  if (Array.from(r).length < 2)
    throw e();
  return c;
}, Ah = (e, t, n, r) => e.createScriptProcessor(t, n, r), TM = (e, t) => (n, r) => {
  const i = r.channelCountMode;
  if (i === "clamped-max")
    throw t();
  if (n.createStereoPanner === void 0)
    return e(n, r);
  const s = n.createStereoPanner();
  return lr(s, r), Gn(s, r, "pan"), Object.defineProperty(s, "channelCountMode", {
    get: () => i,
    set: (l) => {
      if (l !== i)
        throw t();
    }
  }), s;
}, CM = (e, t, n, r, i, s) => {
  const c = new Float32Array([1, 1]), u = Math.PI / 2, d = { channelCount: 1, channelCountMode: "explicit", channelInterpretation: "discrete" }, h = { ...d, oversample: "none" }, p = (g, b, x, w) => {
    const T = new Float32Array(16385), S = new Float32Array(16385);
    for (let L = 0; L < 16385; L += 1) {
      const k = L / 16384 * u;
      T[L] = Math.cos(k), S[L] = Math.sin(k);
    }
    const C = n(g, { ...d, gain: 0 }), E = r(g, { ...h, curve: T }), O = r(g, { ...h, curve: c }), B = n(g, { ...d, gain: 0 }), N = r(g, { ...h, curve: S });
    return {
      connectGraph() {
        b.connect(C), b.connect(O.inputs === void 0 ? O : O.inputs[0]), b.connect(B), O.connect(x), x.connect(E.inputs === void 0 ? E : E.inputs[0]), x.connect(N.inputs === void 0 ? N : N.inputs[0]), E.connect(C.gain), N.connect(B.gain), C.connect(w, 0, 0), B.connect(w, 0, 1);
      },
      disconnectGraph() {
        b.disconnect(C), b.disconnect(O.inputs === void 0 ? O : O.inputs[0]), b.disconnect(B), O.disconnect(x), x.disconnect(E.inputs === void 0 ? E : E.inputs[0]), x.disconnect(N.inputs === void 0 ? N : N.inputs[0]), E.disconnect(C.gain), N.disconnect(B.gain), C.disconnect(w, 0, 0), B.disconnect(w, 0, 1);
      }
    };
  }, v = (g, b, x, w) => {
    const T = new Float32Array(16385), S = new Float32Array(16385), C = new Float32Array(16385), E = new Float32Array(16385), O = Math.floor(16385 / 2);
    for (let H = 0; H < 16385; H += 1)
      if (H > O) {
        const X = (H - O) / (16384 - O) * u;
        T[H] = Math.cos(X), S[H] = Math.sin(X), C[H] = 0, E[H] = 1;
      } else {
        const X = H / (16384 - O) * u;
        T[H] = 1, S[H] = 0, C[H] = Math.cos(X), E[H] = Math.sin(X);
      }
    const B = t(g, {
      channelCount: 2,
      channelCountMode: "explicit",
      channelInterpretation: "discrete",
      numberOfOutputs: 2
    }), N = n(g, { ...d, gain: 0 }), L = r(g, {
      ...h,
      curve: T
    }), k = n(g, { ...d, gain: 0 }), F = r(g, {
      ...h,
      curve: S
    }), G = r(g, { ...h, curve: c }), M = n(g, { ...d, gain: 0 }), j = r(g, {
      ...h,
      curve: C
    }), D = n(g, { ...d, gain: 0 }), z = r(g, {
      ...h,
      curve: E
    });
    return {
      connectGraph() {
        b.connect(B), b.connect(G.inputs === void 0 ? G : G.inputs[0]), B.connect(N, 0), B.connect(k, 0), B.connect(M, 1), B.connect(D, 1), G.connect(x), x.connect(L.inputs === void 0 ? L : L.inputs[0]), x.connect(F.inputs === void 0 ? F : F.inputs[0]), x.connect(j.inputs === void 0 ? j : j.inputs[0]), x.connect(z.inputs === void 0 ? z : z.inputs[0]), L.connect(N.gain), F.connect(k.gain), j.connect(M.gain), z.connect(D.gain), N.connect(w, 0, 0), M.connect(w, 0, 0), k.connect(w, 0, 1), D.connect(w, 0, 1);
      },
      disconnectGraph() {
        b.disconnect(B), b.disconnect(G.inputs === void 0 ? G : G.inputs[0]), B.disconnect(N, 0), B.disconnect(k, 0), B.disconnect(M, 1), B.disconnect(D, 1), G.disconnect(x), x.disconnect(L.inputs === void 0 ? L : L.inputs[0]), x.disconnect(F.inputs === void 0 ? F : F.inputs[0]), x.disconnect(j.inputs === void 0 ? j : j.inputs[0]), x.disconnect(z.inputs === void 0 ? z : z.inputs[0]), L.disconnect(N.gain), F.disconnect(k.gain), j.disconnect(M.gain), z.disconnect(D.gain), N.disconnect(w, 0, 0), M.disconnect(w, 0, 0), k.disconnect(w, 0, 1), D.disconnect(w, 0, 1);
      }
    };
  }, m = (g, b, x, w, T) => {
    if (b === 1)
      return p(g, x, w, T);
    if (b === 2)
      return v(g, x, w, T);
    throw i();
  };
  return (g, { channelCount: b, channelCountMode: x, pan: w, ...T }) => {
    if (x === "max")
      throw i();
    const S = e(g, {
      ...T,
      channelCount: 1,
      channelCountMode: x,
      numberOfInputs: 2
    }), C = n(g, { ...T, channelCount: b, channelCountMode: x, gain: 1 }), E = n(g, {
      channelCount: 1,
      channelCountMode: "explicit",
      channelInterpretation: "discrete",
      gain: w
    });
    let { connectGraph: O, disconnectGraph: B } = m(g, b, C, E, S);
    Object.defineProperty(E.gain, "defaultValue", { get: () => 0 }), Object.defineProperty(E.gain, "maxValue", { get: () => 1 }), Object.defineProperty(E.gain, "minValue", { get: () => -1 });
    const N = {
      get bufferSize() {
      },
      get channelCount() {
        return C.channelCount;
      },
      set channelCount(G) {
        C.channelCount !== G && (L && B(), { connectGraph: O, disconnectGraph: B } = m(g, G, C, E, S), L && O()), C.channelCount = G;
      },
      get channelCountMode() {
        return C.channelCountMode;
      },
      set channelCountMode(G) {
        if (G === "clamped-max" || G === "max")
          throw i();
        C.channelCountMode = G;
      },
      get channelInterpretation() {
        return C.channelInterpretation;
      },
      set channelInterpretation(G) {
        C.channelInterpretation = G;
      },
      get context() {
        return C.context;
      },
      get inputs() {
        return [C];
      },
      get numberOfInputs() {
        return C.numberOfInputs;
      },
      get numberOfOutputs() {
        return C.numberOfOutputs;
      },
      get pan() {
        return E.gain;
      },
      addEventListener(...G) {
        return C.addEventListener(G[0], G[1], G[2]);
      },
      dispatchEvent(...G) {
        return C.dispatchEvent(G[0]);
      },
      removeEventListener(...G) {
        return C.removeEventListener(G[0], G[1], G[2]);
      }
    };
    let L = !1;
    const k = () => {
      O(), L = !0;
    }, F = () => {
      B(), L = !1;
    };
    return s(eu(N, S), k, F);
  };
}, wM = (e, t, n, r, i, s, l) => (c, u) => {
  const d = c.createWaveShaper();
  if (s !== null && s.name === "webkitAudioContext" && c.createGain().gain.automationRate === void 0)
    return n(c, u);
  lr(d, u);
  const h = u.curve === null || u.curve instanceof Float32Array ? u.curve : new Float32Array(u.curve);
  if (h !== null && h.length < 2)
    throw t();
  On(d, { curve: h }, "curve"), On(d, u, "oversample");
  let p = null, v = !1;
  return l(d, "curve", (b) => () => b.call(d), (b) => (x) => (b.call(d, x), v && (r(x) && p === null ? p = e(c, d) : !r(x) && p !== null && (p(), p = null)), x)), i(d, () => {
    v = !0, r(d.curve) && (p = e(c, d));
  }, () => {
    v = !1, p !== null && (p(), p = null);
  });
}, EM = (e, t, n, r, i) => (s, { curve: l, oversample: c, ...u }) => {
  const d = s.createWaveShaper(), h = s.createWaveShaper();
  lr(d, u), lr(h, u);
  const p = n(s, { ...u, gain: 1 }), v = n(s, { ...u, gain: -1 }), m = n(s, { ...u, gain: 1 }), g = n(s, { ...u, gain: -1 });
  let b = null, x = !1, w = null;
  const T = {
    get bufferSize() {
    },
    get channelCount() {
      return d.channelCount;
    },
    set channelCount(E) {
      p.channelCount = E, v.channelCount = E, d.channelCount = E, m.channelCount = E, h.channelCount = E, g.channelCount = E;
    },
    get channelCountMode() {
      return d.channelCountMode;
    },
    set channelCountMode(E) {
      p.channelCountMode = E, v.channelCountMode = E, d.channelCountMode = E, m.channelCountMode = E, h.channelCountMode = E, g.channelCountMode = E;
    },
    get channelInterpretation() {
      return d.channelInterpretation;
    },
    set channelInterpretation(E) {
      p.channelInterpretation = E, v.channelInterpretation = E, d.channelInterpretation = E, m.channelInterpretation = E, h.channelInterpretation = E, g.channelInterpretation = E;
    },
    get context() {
      return d.context;
    },
    get curve() {
      return w;
    },
    set curve(E) {
      if (E !== null && E.length < 2)
        throw t();
      if (E === null)
        d.curve = E, h.curve = E;
      else {
        const O = E.length, B = new Float32Array(O + 2 - O % 2), N = new Float32Array(O + 2 - O % 2);
        B[0] = E[0], N[0] = -E[O - 1];
        const L = Math.ceil((O + 1) / 2), k = (O + 1) / 2 - 1;
        for (let F = 1; F < L; F += 1) {
          const G = F / L * k, M = Math.floor(G), j = Math.ceil(G);
          B[F] = M === j ? E[M] : (1 - (G - M)) * E[M] + (1 - (j - G)) * E[j], N[F] = M === j ? -E[O - 1 - M] : -((1 - (G - M)) * E[O - 1 - M]) - (1 - (j - G)) * E[O - 1 - j];
        }
        B[L] = O % 2 === 1 ? E[L - 1] : (E[L - 2] + E[L - 1]) / 2, d.curve = B, h.curve = N;
      }
      w = E, x && (r(w) && b === null ? b = e(s, p) : b !== null && (b(), b = null));
    },
    get inputs() {
      return [p];
    },
    get numberOfInputs() {
      return d.numberOfInputs;
    },
    get numberOfOutputs() {
      return d.numberOfOutputs;
    },
    get oversample() {
      return d.oversample;
    },
    set oversample(E) {
      d.oversample = E, h.oversample = E;
    },
    addEventListener(...E) {
      return p.addEventListener(E[0], E[1], E[2]);
    },
    dispatchEvent(...E) {
      return p.dispatchEvent(E[0]);
    },
    removeEventListener(...E) {
      return p.removeEventListener(E[0], E[1], E[2]);
    }
  };
  l !== null && (T.curve = l instanceof Float32Array ? l : new Float32Array(l)), c !== T.oversample && (T.oversample = c);
  const S = () => {
    p.connect(d).connect(m), p.connect(v).connect(h).connect(g).connect(m), x = !0, r(w) && (b = e(s, p));
  }, C = () => {
    p.disconnect(d), d.disconnect(m), p.disconnect(v), v.disconnect(h), h.disconnect(g), g.disconnect(m), x = !1, b !== null && (b(), b = null);
  };
  return i(eu(T, m), S, C);
}, Yr = () => new DOMException("", "NotSupportedError"), AM = {
  numberOfChannels: 1
}, kM = (e, t, n, r, i) => class extends e {
  constructor(l, c, u) {
    let d;
    if (typeof l == "number" && c !== void 0 && u !== void 0)
      d = { length: c, numberOfChannels: l, sampleRate: u };
    else if (typeof l == "object")
      d = l;
    else
      throw new Error("The given parameters are not valid.");
    const { length: h, numberOfChannels: p, sampleRate: v } = { ...AM, ...d }, m = r(p, h, v);
    t(uh, () => uh(m)) || m.addEventListener("statechange", /* @__PURE__ */ (() => {
      let g = 0;
      const b = (x) => {
        this._state === "running" && (g > 0 ? (m.removeEventListener("statechange", b), x.stopImmediatePropagation(), this._waitForThePromiseToSettle(x)) : g += 1);
      };
      return b;
    })()), super(m, p), this._length = h, this._nativeOfflineAudioContext = m, this._state = null;
  }
  get length() {
    return this._nativeOfflineAudioContext.length === void 0 ? this._length : this._nativeOfflineAudioContext.length;
  }
  get state() {
    return this._state === null ? this._nativeOfflineAudioContext.state : this._state;
  }
  startRendering() {
    return this._state === "running" ? Promise.reject(n()) : (this._state = "running", i(this.destination, this._nativeOfflineAudioContext).finally(() => {
      this._state = null, s5(this);
    }));
  }
  _waitForThePromiseToSettle(l) {
    this._state === null ? this._nativeOfflineAudioContext.dispatchEvent(l) : setTimeout(() => this._waitForThePromiseToSettle(l));
  }
}, RM = {
  channelCount: 2,
  channelCountMode: "max",
  // This attribute has no effect for nodes with no inputs.
  channelInterpretation: "speakers",
  // This attribute has no effect for nodes with no inputs.
  detune: 0,
  frequency: 440,
  periodicWave: void 0,
  type: "sine"
}, MM = (e, t, n, r, i, s, l) => class extends e {
  constructor(u, d) {
    const h = i(u), p = { ...RM, ...d }, v = n(h, p), m = s(h), g = m ? r() : null, b = u.sampleRate / 2;
    super(u, !1, v, g), this._detune = t(this, m, v.detune, 153600, -153600), this._frequency = t(this, m, v.frequency, b, -b), this._nativeOscillatorNode = v, this._onended = null, this._oscillatorNodeRenderer = g, this._oscillatorNodeRenderer !== null && p.periodicWave !== void 0 && (this._oscillatorNodeRenderer.periodicWave = p.periodicWave);
  }
  get detune() {
    return this._detune;
  }
  get frequency() {
    return this._frequency;
  }
  get onended() {
    return this._onended;
  }
  set onended(u) {
    const d = typeof u == "function" ? l(this, u) : null;
    this._nativeOscillatorNode.onended = d;
    const h = this._nativeOscillatorNode.onended;
    this._onended = h !== null && h === d ? u : h;
  }
  get type() {
    return this._nativeOscillatorNode.type;
  }
  set type(u) {
    this._nativeOscillatorNode.type = u, this._oscillatorNodeRenderer !== null && (this._oscillatorNodeRenderer.periodicWave = null);
  }
  setPeriodicWave(u) {
    this._nativeOscillatorNode.setPeriodicWave(u), this._oscillatorNodeRenderer !== null && (this._oscillatorNodeRenderer.periodicWave = u);
  }
  start(u = 0) {
    if (this._nativeOscillatorNode.start(u), this._oscillatorNodeRenderer !== null && (this._oscillatorNodeRenderer.start = u), this.context.state !== "closed") {
      Vc(this);
      const d = () => {
        this._nativeOscillatorNode.removeEventListener("ended", d), mo(this) && Th(this);
      };
      this._nativeOscillatorNode.addEventListener("ended", d);
    }
  }
  stop(u = 0) {
    this._nativeOscillatorNode.stop(u), this._oscillatorNodeRenderer !== null && (this._oscillatorNodeRenderer.stop = u);
  }
}, OM = (e, t, n, r, i) => () => {
  const s = /* @__PURE__ */ new WeakMap();
  let l = null, c = null, u = null;
  const d = async (h, p) => {
    let v = n(h);
    const m = Ur(v, p);
    if (!m) {
      const g = {
        channelCount: v.channelCount,
        channelCountMode: v.channelCountMode,
        channelInterpretation: v.channelInterpretation,
        detune: v.detune.value,
        frequency: v.frequency.value,
        periodicWave: l === null ? void 0 : l,
        type: v.type
      };
      v = t(p, g), c !== null && v.start(c), u !== null && v.stop(u);
    }
    return s.set(p, v), m ? (await e(p, h.detune, v.detune), await e(p, h.frequency, v.frequency)) : (await r(p, h.detune, v.detune), await r(p, h.frequency, v.frequency)), await i(h, p, v), v;
  };
  return {
    set periodicWave(h) {
      l = h;
    },
    set start(h) {
      c = h;
    },
    set stop(h) {
      u = h;
    },
    render(h, p) {
      const v = s.get(p);
      return v !== void 0 ? Promise.resolve(v) : d(h, p);
    }
  };
}, NM = {
  channelCount: 2,
  channelCountMode: "clamped-max",
  channelInterpretation: "speakers",
  coneInnerAngle: 360,
  coneOuterAngle: 360,
  coneOuterGain: 0,
  distanceModel: "inverse",
  maxDistance: 1e4,
  orientationX: 1,
  orientationY: 0,
  orientationZ: 0,
  panningModel: "equalpower",
  positionX: 0,
  positionY: 0,
  positionZ: 0,
  refDistance: 1,
  rolloffFactor: 1
}, PM = (e, t, n, r, i, s, l) => class extends e {
  constructor(u, d) {
    const h = i(u), p = { ...NM, ...d }, v = n(h, p), m = s(h), g = m ? r() : null;
    super(u, !1, v, g), this._nativePannerNode = v, this._orientationX = t(this, m, v.orientationX, Wr, Si), this._orientationY = t(this, m, v.orientationY, Wr, Si), this._orientationZ = t(this, m, v.orientationZ, Wr, Si), this._positionX = t(this, m, v.positionX, Wr, Si), this._positionY = t(this, m, v.positionY, Wr, Si), this._positionZ = t(this, m, v.positionZ, Wr, Si), l(this, 1);
  }
  get coneInnerAngle() {
    return this._nativePannerNode.coneInnerAngle;
  }
  set coneInnerAngle(u) {
    this._nativePannerNode.coneInnerAngle = u;
  }
  get coneOuterAngle() {
    return this._nativePannerNode.coneOuterAngle;
  }
  set coneOuterAngle(u) {
    this._nativePannerNode.coneOuterAngle = u;
  }
  get coneOuterGain() {
    return this._nativePannerNode.coneOuterGain;
  }
  set coneOuterGain(u) {
    this._nativePannerNode.coneOuterGain = u;
  }
  get distanceModel() {
    return this._nativePannerNode.distanceModel;
  }
  set distanceModel(u) {
    this._nativePannerNode.distanceModel = u;
  }
  get maxDistance() {
    return this._nativePannerNode.maxDistance;
  }
  set maxDistance(u) {
    this._nativePannerNode.maxDistance = u;
  }
  get orientationX() {
    return this._orientationX;
  }
  get orientationY() {
    return this._orientationY;
  }
  get orientationZ() {
    return this._orientationZ;
  }
  get panningModel() {
    return this._nativePannerNode.panningModel;
  }
  set panningModel(u) {
    this._nativePannerNode.panningModel = u;
  }
  get positionX() {
    return this._positionX;
  }
  get positionY() {
    return this._positionY;
  }
  get positionZ() {
    return this._positionZ;
  }
  get refDistance() {
    return this._nativePannerNode.refDistance;
  }
  set refDistance(u) {
    this._nativePannerNode.refDistance = u;
  }
  get rolloffFactor() {
    return this._nativePannerNode.rolloffFactor;
  }
  set rolloffFactor(u) {
    this._nativePannerNode.rolloffFactor = u;
  }
}, DM = (e, t, n, r, i, s, l, c, u, d) => () => {
  const h = /* @__PURE__ */ new WeakMap();
  let p = null;
  const v = async (m, g) => {
    let b = null, x = s(m);
    const w = {
      channelCount: x.channelCount,
      channelCountMode: x.channelCountMode,
      channelInterpretation: x.channelInterpretation
    }, T = {
      ...w,
      coneInnerAngle: x.coneInnerAngle,
      coneOuterAngle: x.coneOuterAngle,
      coneOuterGain: x.coneOuterGain,
      distanceModel: x.distanceModel,
      maxDistance: x.maxDistance,
      panningModel: x.panningModel,
      refDistance: x.refDistance,
      rolloffFactor: x.rolloffFactor
    }, S = Ur(x, g);
    if ("bufferSize" in x)
      b = r(g, { ...w, gain: 1 });
    else if (!S) {
      const C = {
        ...T,
        orientationX: x.orientationX.value,
        orientationY: x.orientationY.value,
        orientationZ: x.orientationZ.value,
        positionX: x.positionX.value,
        positionY: x.positionY.value,
        positionZ: x.positionZ.value
      };
      x = i(g, C);
    }
    if (h.set(g, b === null ? x : b), b !== null) {
      if (p === null) {
        if (l === null)
          throw new Error("Missing the native OfflineAudioContext constructor.");
        const F = new l(
          6,
          // Bug #17: Safari does not yet expose the length.
          m.context.length,
          g.sampleRate
        ), G = t(F, {
          channelCount: 1,
          channelCountMode: "explicit",
          channelInterpretation: "speakers",
          numberOfInputs: 6
        });
        G.connect(F.destination), p = (async () => {
          const M = await Promise.all([
            m.orientationX,
            m.orientationY,
            m.orientationZ,
            m.positionX,
            m.positionY,
            m.positionZ
          ].map(async (j, D) => {
            const z = n(F, {
              channelCount: 1,
              channelCountMode: "explicit",
              channelInterpretation: "discrete",
              offset: D === 0 ? 1 : 0
            });
            return await c(F, j, z.offset), z;
          }));
          for (let j = 0; j < 6; j += 1)
            M[j].connect(G, 0, j), M[j].start(0);
          return d(F);
        })();
      }
      const C = await p, E = r(g, { ...w, gain: 1 });
      await u(m, g, E);
      const O = [];
      for (let F = 0; F < C.numberOfChannels; F += 1)
        O.push(C.getChannelData(F));
      let B = [O[0][0], O[1][0], O[2][0]], N = [O[3][0], O[4][0], O[5][0]], L = r(g, { ...w, gain: 1 }), k = i(g, {
        ...T,
        orientationX: B[0],
        orientationY: B[1],
        orientationZ: B[2],
        positionX: N[0],
        positionY: N[1],
        positionZ: N[2]
      });
      E.connect(L).connect(k.inputs[0]), k.connect(b);
      for (let F = 128; F < C.length; F += 128) {
        const G = [O[0][F], O[1][F], O[2][F]], M = [O[3][F], O[4][F], O[5][F]];
        if (G.some((j, D) => j !== B[D]) || M.some((j, D) => j !== N[D])) {
          B = G, N = M;
          const j = F / g.sampleRate;
          L.gain.setValueAtTime(0, j), L = r(g, { ...w, gain: 0 }), k = i(g, {
            ...T,
            orientationX: B[0],
            orientationY: B[1],
            orientationZ: B[2],
            positionX: N[0],
            positionY: N[1],
            positionZ: N[2]
          }), L.gain.setValueAtTime(1, j), E.connect(L).connect(k.inputs[0]), k.connect(b);
        }
      }
      return b;
    }
    return S ? (await e(g, m.orientationX, x.orientationX), await e(g, m.orientationY, x.orientationY), await e(g, m.orientationZ, x.orientationZ), await e(g, m.positionX, x.positionX), await e(g, m.positionY, x.positionY), await e(g, m.positionZ, x.positionZ)) : (await c(g, m.orientationX, x.orientationX), await c(g, m.orientationY, x.orientationY), await c(g, m.orientationZ, x.orientationZ), await c(g, m.positionX, x.positionX), await c(g, m.positionY, x.positionY), await c(g, m.positionZ, x.positionZ)), tu(x) ? await u(m, g, x.inputs[0]) : await u(m, g, x), x;
  };
  return {
    render(m, g) {
      const b = h.get(g);
      return b !== void 0 ? Promise.resolve(b) : v(m, g);
    }
  };
}, IM = {
  disableNormalization: !1
}, BM = (e, t, n, r) => class m5 {
  constructor(s, l) {
    const c = t(s), u = r({ ...IM, ...l }), d = e(c, u);
    return n.add(d), d;
  }
  static [Symbol.hasInstance](s) {
    return s !== null && typeof s == "object" && Object.getPrototypeOf(s) === m5.prototype || n.has(s);
  }
}, FM = (e, t) => (n, r, i) => (e(r).replay(i), t(r, n, i)), jM = (e, t, n) => async (r, i, s) => {
  const l = e(r);
  await Promise.all(l.activeInputs.map((c, u) => Array.from(c).map(async ([d, h]) => {
    const v = await t(d).render(d, i), m = r.context.destination;
    !n(d) && (r !== m || !n(r)) && v.connect(s, h, u);
  })).reduce((c, u) => [...c, ...u], []));
}, LM = (e, t, n) => async (r, i, s) => {
  const l = t(r);
  await Promise.all(Array.from(l.activeInputs).map(async ([c, u]) => {
    const h = await e(c).render(c, i);
    n(c) || h.connect(s, u);
  }));
}, zM = (e, t, n, r) => (i) => e(uh, () => uh(i)) ? Promise.resolve(e(r, r)).then((s) => {
  if (!s) {
    const l = n(i, 512, 0, 1);
    i.oncomplete = () => {
      l.onaudioprocess = null, l.disconnect();
    }, l.onaudioprocess = () => i.currentTime, l.connect(i.destination);
  }
  return i.startRendering();
}) : new Promise((s) => {
  const l = t(i, {
    channelCount: 1,
    channelCountMode: "explicit",
    channelInterpretation: "discrete",
    gain: 0
  });
  i.oncomplete = (c) => {
    l.disconnect(), s(c.renderedBuffer);
  }, l.connect(i.destination), i.startRendering();
}), UM = (e) => (t, n) => {
  e.set(t, n);
}, VM = (e) => (t, n) => e.set(t, n), GM = (e, t, n, r, i, s, l, c) => (u, d) => n(u).render(u, d).then(() => Promise.all(Array.from(r(d)).map((h) => n(h).render(h, d)))).then(() => i(d)).then((h) => (typeof h.copyFromChannel != "function" ? (l(h), vy(h)) : t(s, () => s(h)) || c(h), e.add(h), h)), qM = {
  channelCount: 2,
  /*
   * Bug #105: The channelCountMode should be 'clamped-max' according to the spec but is set to 'explicit' to achieve consistent
   * behavior.
   */
  channelCountMode: "explicit",
  channelInterpretation: "speakers",
  pan: 0
}, HM = (e, t, n, r, i, s) => class extends e {
  constructor(c, u) {
    const d = i(c), h = { ...qM, ...u }, p = n(d, h), v = s(d), m = v ? r() : null;
    super(c, !1, p, m), this._pan = t(this, v, p.pan);
  }
  get pan() {
    return this._pan;
  }
}, WM = (e, t, n, r, i) => () => {
  const s = /* @__PURE__ */ new WeakMap(), l = async (c, u) => {
    let d = n(c);
    const h = Ur(d, u);
    if (!h) {
      const p = {
        channelCount: d.channelCount,
        channelCountMode: d.channelCountMode,
        channelInterpretation: d.channelInterpretation,
        pan: d.pan.value
      };
      d = t(u, p);
    }
    return s.set(u, d), h ? await e(u, c.pan, d.pan) : await r(u, c.pan, d.pan), tu(d) ? await i(c, u, d.inputs[0]) : await i(c, u, d), d;
  };
  return {
    render(c, u) {
      const d = s.get(u);
      return d !== void 0 ? Promise.resolve(d) : l(c, u);
    }
  };
}, $M = (e) => () => {
  if (e === null)
    return !1;
  try {
    new e({ length: 1, sampleRate: 44100 });
  } catch {
    return !1;
  }
  return !0;
}, KM = (e, t) => async () => {
  if (e === null)
    return !0;
  if (t === null)
    return !1;
  const n = new Blob(['class A extends AudioWorkletProcessor{process(i){this.port.postMessage(i,[i[0][0].buffer])}}registerProcessor("a",A)'], {
    type: "application/javascript; charset=utf-8"
  }), r = new t(1, 128, 44100), i = URL.createObjectURL(n);
  let s = !1, l = !1;
  try {
    await r.audioWorklet.addModule(i);
    const c = new e(r, "a", { numberOfOutputs: 0 }), u = r.createOscillator();
    c.port.onmessage = () => s = !0, c.onprocessorerror = () => l = !0, u.connect(c), u.start(0), await r.startRendering(), await new Promise((d) => setTimeout(d));
  } catch {
  } finally {
    URL.revokeObjectURL(i);
  }
  return s && !l;
}, YM = (e, t) => () => {
  if (t === null)
    return Promise.resolve(!1);
  const n = new t(1, 1, 44100), r = e(n, {
    channelCount: 1,
    channelCountMode: "explicit",
    channelInterpretation: "discrete",
    gain: 0
  });
  return new Promise((i) => {
    n.oncomplete = () => {
      r.disconnect(), i(n.currentTime !== 0);
    }, n.startRendering();
  });
}, XM = () => new DOMException("", "UnknownError"), QM = {
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers",
  curve: null,
  oversample: "none"
}, ZM = (e, t, n, r, i, s, l) => class extends e {
  constructor(u, d) {
    const h = i(u), p = { ...QM, ...d }, v = n(h, p), g = s(h) ? r() : null;
    super(u, !0, v, g), this._isCurveNullified = !1, this._nativeWaveShaperNode = v, l(this, 1);
  }
  get curve() {
    return this._isCurveNullified ? null : this._nativeWaveShaperNode.curve;
  }
  set curve(u) {
    if (u === null)
      this._isCurveNullified = !0, this._nativeWaveShaperNode.curve = new Float32Array([0, 0]);
    else {
      if (u.length < 2)
        throw t();
      this._isCurveNullified = !1, this._nativeWaveShaperNode.curve = u;
    }
  }
  get oversample() {
    return this._nativeWaveShaperNode.oversample;
  }
  set oversample(u) {
    this._nativeWaveShaperNode.oversample = u;
  }
}, JM = (e, t, n) => () => {
  const r = /* @__PURE__ */ new WeakMap(), i = async (s, l) => {
    let c = t(s);
    if (!Ur(c, l)) {
      const d = {
        channelCount: c.channelCount,
        channelCountMode: c.channelCountMode,
        channelInterpretation: c.channelInterpretation,
        curve: c.curve,
        oversample: c.oversample
      };
      c = e(l, d);
    }
    return r.set(l, c), tu(c) ? await n(s, l, c.inputs[0]) : await n(s, l, c), c;
  };
  return {
    render(s, l) {
      const c = r.get(l);
      return c !== void 0 ? Promise.resolve(c) : i(s, l);
    }
  };
}, tO = () => typeof window > "u" ? null : window, eO = (e, t) => (n) => {
  n.copyFromChannel = (r, i, s = 0) => {
    const l = e(s), c = e(i);
    if (c >= n.numberOfChannels)
      throw t();
    const u = n.length, d = n.getChannelData(c), h = r.length;
    for (let p = l < 0 ? -l : 0; p + l < u && p < h; p += 1)
      r[p] = d[p + l];
  }, n.copyToChannel = (r, i, s = 0) => {
    const l = e(s), c = e(i);
    if (c >= n.numberOfChannels)
      throw t();
    const u = n.length, d = n.getChannelData(c), h = r.length;
    for (let p = l < 0 ? -l : 0; p + l < u && p < h; p += 1)
      d[p + l] = r[p];
  };
}, nO = (e) => (t) => {
  t.copyFromChannel = /* @__PURE__ */ ((n) => (r, i, s = 0) => {
    const l = e(s), c = e(i);
    if (l < t.length)
      return n.call(t, r, c, l);
  })(t.copyFromChannel), t.copyToChannel = /* @__PURE__ */ ((n) => (r, i, s = 0) => {
    const l = e(s), c = e(i);
    if (l < t.length)
      return n.call(t, r, c, l);
  })(t.copyToChannel);
}, rO = (e) => (t, n) => {
  const r = n.createBuffer(1, 1, 44100);
  t.buffer === null && (t.buffer = r), e(t, "buffer", (i) => () => {
    const s = i.call(t);
    return s === r ? null : s;
  }, (i) => (s) => i.call(t, s === null ? r : s));
}, iO = (e, t) => (n, r) => {
  r.channelCount = 1, r.channelCountMode = "explicit", Object.defineProperty(r, "channelCount", {
    get: () => 1,
    set: () => {
      throw e();
    }
  }), Object.defineProperty(r, "channelCountMode", {
    get: () => "explicit",
    set: () => {
      throw e();
    }
  });
  const i = n.createBufferSource();
  t(r, () => {
    const c = r.numberOfInputs;
    for (let u = 0; u < c; u += 1)
      i.connect(r, 0, u);
  }, () => i.disconnect(r));
}, g5 = (e, t, n) => e.copyFromChannel === void 0 ? e.getChannelData(n)[0] : (e.copyFromChannel(t, n), t[0]), y5 = (e) => {
  if (e === null)
    return !1;
  const t = e.length;
  return t % 2 !== 0 ? e[Math.floor(t / 2)] !== 0 : e[t / 2 - 1] + e[t / 2] !== 0;
}, kh = (e, t, n, r) => {
  let i = e;
  for (; !i.hasOwnProperty(t); )
    i = Object.getPrototypeOf(i);
  const { get: s, set: l } = Object.getOwnPropertyDescriptor(i, t);
  Object.defineProperty(e, t, { get: n(s), set: r(l) });
}, sO = (e) => ({
  ...e,
  outputChannelCount: e.outputChannelCount !== void 0 ? e.outputChannelCount : e.numberOfInputs === 1 && e.numberOfOutputs === 1 ? (
    /*
     * Bug #61: This should be the computedNumberOfChannels, but unfortunately that is almost impossible to fake. That's why
     * the channelCountMode is required to be 'explicit' as long as there is not a native implementation in every browser. That
     * makes sure the computedNumberOfChannels is equivilant to the channelCount which makes it much easier to compute.
     */
    [e.channelCount]
  ) : Array.from({ length: e.numberOfOutputs }, () => 1)
}), oO = (e) => ({ ...e, channelCount: e.numberOfOutputs }), aO = (e) => {
  const { imag: t, real: n } = e;
  return t === void 0 ? n === void 0 ? { ...e, imag: [0, 0], real: [0, 0] } : { ...e, imag: Array.from(n, () => 0), real: n } : n === void 0 ? { ...e, imag: t, real: Array.from(t, () => 0) } : { ...e, imag: t, real: n };
}, v5 = (e, t, n) => {
  try {
    e.setValueAtTime(t, n);
  } catch (r) {
    if (r.code !== 9)
      throw r;
    v5(e, t, n + 1e-7);
  }
}, lO = (e) => {
  const t = e.createBufferSource();
  t.start();
  try {
    t.start();
  } catch {
    return !0;
  }
  return !1;
}, cO = (e) => {
  const t = e.createBufferSource(), n = e.createBuffer(1, 1, 44100);
  t.buffer = n;
  try {
    t.start(0, 1);
  } catch {
    return !1;
  }
  return !0;
}, uO = (e) => {
  const t = e.createBufferSource();
  t.start();
  try {
    t.stop();
  } catch {
    return !1;
  }
  return !0;
}, Ty = (e) => {
  const t = e.createOscillator();
  try {
    t.start(-1);
  } catch (n) {
    return n instanceof RangeError;
  }
  return !1;
}, b5 = (e) => {
  const t = e.createBuffer(1, 1, 44100), n = e.createBufferSource();
  n.buffer = t, n.start(), n.stop();
  try {
    return n.stop(), !0;
  } catch {
    return !1;
  }
}, Cy = (e) => {
  const t = e.createOscillator();
  try {
    t.stop(-1);
  } catch (n) {
    return n instanceof RangeError;
  }
  return !1;
}, dO = (e) => {
  const { port1: t, port2: n } = new MessageChannel();
  try {
    t.postMessage(e);
  } finally {
    t.close(), n.close();
  }
}, hO = (e) => {
  e.start = /* @__PURE__ */ ((t) => (n = 0, r = 0, i) => {
    const s = e.buffer, l = s === null ? r : Math.min(s.duration, r);
    s !== null && l > s.duration - 0.5 / e.context.sampleRate ? t.call(e, n, 0, 0) : t.call(e, n, l, i);
  })(e.start);
}, _5 = (e, t) => {
  const n = t.createGain();
  e.connect(n);
  const r = /* @__PURE__ */ ((i) => () => {
    i.call(e, n), e.removeEventListener("ended", r);
  })(e.disconnect);
  e.addEventListener("ended", r), eu(e, n), e.stop = /* @__PURE__ */ ((i) => {
    let s = !1;
    return (l = 0) => {
      if (s)
        try {
          i.call(e, l);
        } catch {
          n.gain.setValueAtTime(0, l);
        }
      else
        i.call(e, l), s = !0;
    };
  })(e.stop);
}, nu = (e, t) => (n) => {
  const r = { value: e };
  return Object.defineProperties(n, {
    currentTarget: r,
    target: r
  }), typeof t == "function" ? t.call(e, n) : t.handleEvent.call(e, n);
}, fO = PA(vl), pO = LA(vl), mO = Qk(Xp), S5 = /* @__PURE__ */ new WeakMap(), gO = mR(S5), us = Ak(/* @__PURE__ */ new Map(), /* @__PURE__ */ new WeakMap()), Is = tO(), x5 = HR(us, js), wy = pR($r), Ar = jM($r, wy, pl), yO = qA(x5, kn, Ar), Tn = vR(Yp), So = vM(Is), mn = IR(So), T5 = /* @__PURE__ */ new WeakMap(), C5 = aR(nu), Rh = YR(Is), Ey = OR(Rh), Ay = NR(Is), w5 = PR(Is), dh = QR(Is), Yn = mk(DA(ZS), jA(fO, pO, pp, mO, mp, $r, gO, xh, kn, vl, mo, pl, $f), us, ER(v0, mp, $r, kn, ch, mo), js, Qp, Yr, $k(pp, v0, $r, kn, ch, Tn, mo, mn), tR(T5, $r, cs), C5, Tn, Ey, Ay, w5, mn, dh), vO = GA(Yn, yO, js, x5, Tn, mn), ky = /* @__PURE__ */ new WeakSet(), Jb = WR(Is), E5 = zk(new Uint32Array(1)), Ry = eO(E5, js), My = nO(E5), A5 = WA(ky, us, Yr, Jb, So, $M(Jb), Ry, My), Zp = zA(oi), k5 = LM(wy, Ch, pl), Ls = Dk(k5), ru = KR(Zp, us, lO, cO, uO, Ty, b5, Cy, hO, rO(kh), _5), zs = FM(gR(Ch), k5), bO = YA(Ls, ru, kn, zs, Ar), ds = gk(IA(JS), T5, yy, yk, AA, kA, RA, MA, OA, m0, XS, Rh, v5), _O = KA(Yn, bO, ds, vr, ru, Tn, mn, nu), SO = ik(Yn, sk, js, vr, XR(oi, kh), Tn, mn, Ar), xO = Ek(Ls, f5, kn, zs, Ar), bl = VM(S5), TO = wk(Yn, ds, xO, Qp, f5, Tn, mn, bl), oa = GR(vl, Ay), CO = iO(vr, oa), aa = iM(Rh, CO), wO = Mk(aa, kn, Ar), EO = Rk(Yn, wO, aa, Tn, mn), AO = Pk(Eh, kn, Ar), kO = Nk(Yn, AO, Eh, Tn, mn, oO), RO = aM(Zp, ru, oi, oa), iu = oM(Zp, us, RO, Ty, Cy), MO = Lk(Ls, iu, kn, zs, Ar), OO = jk(Yn, ds, MO, iu, Tn, mn, nu), R5 = lM(Yr, kh), NO = Gk(R5, kn, Ar), PO = Vk(Yn, NO, R5, Tn, mn, bl), DO = Xk(Ls, p5, kn, zs, Ar), IO = Yk(Yn, ds, DO, p5, Tn, mn, bl), M5 = cM(Yr), BO = iR(Ls, M5, kn, zs, Ar), FO = rR(Yn, ds, BO, M5, Yr, Tn, mn, bl), jO = hR(Ls, oi, kn, zs, Ar), LO = dR(Yn, ds, jO, oi, Tn, mn), zO = fM(Qp, vr, Ah, Yr), Jp = zM(us, oi, Ah, YM(oi, So)), UO = wR(ru, kn, So, Ar, Jp), VO = uM(zO), GO = TR(Yn, VO, UO, Tn, mn, bl), qO = ok(ds, aa, iu, Ah, Yr, g5, mn, kh), O5 = /* @__PURE__ */ new WeakMap(), HO = VR(SO, qO, C5, mn, O5, nu), N5 = bM(Zp, us, Ty, b5, Cy, _5), WO = OM(Ls, N5, kn, zs, Ar), $O = MM(Yn, ds, N5, WO, Tn, mn, nu), P5 = Bk(ru), KO = EM(P5, vr, oi, y5, oa), tm = wM(P5, vr, KO, y5, oa, Rh, kh), YO = SM(pp, vr, aa, oi, Ah, tm, Yr, mp, g5, oa), D5 = _M(YO), XO = DM(Ls, aa, iu, oi, D5, kn, So, zs, Ar, Jp), QO = PM(Yn, ds, D5, XO, Tn, mn, bl), ZO = xM(js), JO = BM(ZO, Tn, /* @__PURE__ */ new WeakSet(), aO), tN = CM(aa, Eh, oi, tm, Yr, oa), I5 = TM(tN, Yr), eN = WM(Ls, I5, kn, zs, Ar), nN = HM(Yn, ds, I5, eN, Tn, mn), rN = JM(tm, kn, Ar), iN = ZM(Yn, vr, tm, rN, Tn, mn, bl), B5 = BR(Is), Oy = lR(Is), F5 = /* @__PURE__ */ new WeakMap(), sN = bR(F5, So), oN = B5 ? FA(
  us,
  Yr,
  oR(Is),
  Oy,
  cR(NA),
  Tn,
  sN,
  mn,
  dh,
  /* @__PURE__ */ new WeakMap(),
  /* @__PURE__ */ new WeakMap(),
  KM(dh, So),
  // @todo window is guaranteed to be defined because isSecureContext checks that as well.
  Is
) : void 0, aN = DR(Ey, mn), lN = Wk(ky, us, Hk, sR, /* @__PURE__ */ new WeakSet(), Tn, aN, hp, uh, Ry, My), j5 = Tk(oN, vO, A5, _O, TO, EO, kO, OO, PO, lN, IO, FO, LO, GO, HO, $O, QO, JO, nN, iN), cN = FR(Yn, pM, Tn, mn), uN = LR(Yn, mM, Tn, mn), dN = zR(Yn, gM, Tn, mn), hN = yM(vr, mn), fN = UR(Yn, hN, Tn), pN = rk(j5, vr, Yr, XM, cN, uN, dN, fN, Rh), Ny = _R(O5), mN = UA(Ny), L5 = Ik(js), gN = Zk(Ny), z5 = eR(js), U5 = /* @__PURE__ */ new WeakMap(), yN = fR(U5, cs), vN = rM(L5, js, vr, aa, Eh, iu, oi, Ah, Yr, z5, Oy, yN, oa), bN = JR(vr, vN, oi, Yr, oa), _N = xk(Ls, L5, ru, aa, Eh, iu, oi, gN, z5, Oy, kn, dh, So, zs, Ar, Jp), SN = yR(F5), xN = UM(U5), t2 = B5 ? bk(mN, Yn, ds, _N, bN, $r, SN, Tn, mn, dh, sO, xN, dO, nu) : void 0, TN = qk(Yr, So), CN = GM(ky, us, wy, Ny, Jp, hp, Ry, My), wN = kM(j5, us, vr, TN, CN), EN = AR(Yp, Ey), AN = kR(gy, Ay), kN = RR(yy, w5), RN = MR(Yp, mn);
function wi(e) {
  return e === void 0;
}
function Be(e) {
  return e !== void 0;
}
function MN(e) {
  return typeof e == "function";
}
function Bs(e) {
  return typeof e == "number";
}
function ta(e) {
  return Object.prototype.toString.call(e) === "[object Object]" && e.constructor === Object;
}
function V5(e) {
  return typeof e == "boolean";
}
function ii(e) {
  return Array.isArray(e);
}
function _o(e) {
  return typeof e == "string";
}
function If(e) {
  return _o(e) && /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(e);
}
function we(e, t) {
  if (!e)
    throw new Error(t);
}
function ra(e, t, n = 1 / 0) {
  if (!(t <= e && e <= n))
    throw new RangeError(`Value must be within [${t}, ${n}], got: ${e}`);
}
function G5(e) {
  !e.isOffline && e.state !== "running" && em('The AudioContext is "suspended". Invoke Tone.start() from a user action to start the audio.');
}
let q5 = !1, e2 = !1;
function n2(e) {
  q5 = e;
}
function ON(e) {
  wi(e) && q5 && !e2 && (e2 = !0, em("Events scheduled inside of scheduled callbacks should use the passed in scheduling time. See https://github.com/Tonejs/Tone.js/wiki/Accurate-Timing"));
}
let H5 = console;
function NN(...e) {
  H5.log(...e);
}
function em(...e) {
  H5.warn(...e);
}
function PN(e) {
  return new pN(e);
}
function DN(e, t, n) {
  return new wN(e, t, n);
}
const xi = typeof self == "object" ? self : null, IN = xi && (xi.hasOwnProperty("AudioContext") || xi.hasOwnProperty("webkitAudioContext"));
function BN(e, t, n) {
  return we(Be(t2), "AudioWorkletNode only works in a secure context (https or localhost)"), new (e instanceof (xi == null ? void 0 : xi.BaseAudioContext) ? xi == null ? void 0 : xi.AudioWorkletNode : t2)(e, t, n);
}
function hs(e, t, n, r) {
  var i = arguments.length, s = i < 3 ? t : r === null ? r = Object.getOwnPropertyDescriptor(t, n) : r, l;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(e, t, n, r);
  else for (var c = e.length - 1; c >= 0; c--) (l = e[c]) && (s = (i < 3 ? l(s) : i > 3 ? l(t, n, s) : l(t, n)) || s);
  return i > 3 && s && Object.defineProperty(t, n, s), s;
}
function nr(e, t, n, r) {
  function i(s) {
    return s instanceof n ? s : new n(function(l) {
      l(s);
    });
  }
  return new (n || (n = Promise))(function(s, l) {
    function c(h) {
      try {
        d(r.next(h));
      } catch (p) {
        l(p);
      }
    }
    function u(h) {
      try {
        d(r.throw(h));
      } catch (p) {
        l(p);
      }
    }
    function d(h) {
      h.done ? s(h.value) : i(h.value).then(c, u);
    }
    d((r = r.apply(e, t || [])).next());
  });
}
class FN {
  constructor(t, n, r, i) {
    this._callback = t, this._type = n, this._minimumUpdateInterval = Math.max(128 / (i || 44100), 1e-3), this.updateInterval = r, this._createClock();
  }
  /**
   * Generate a web worker
   */
  _createWorker() {
    const t = new Blob([
      /* javascript */
      `
			// the initial timeout time
			let timeoutTime =  ${(this._updateInterval * 1e3).toFixed(1)};
			// onmessage callback
			self.onmessage = function(msg){
				timeoutTime = parseInt(msg.data);
			};
			// the tick function which posts a message
			// and schedules a new tick
			function tick(){
				setTimeout(tick, timeoutTime);
				self.postMessage('tick');
			}
			// call tick initially
			tick();
			`
    ], { type: "text/javascript" }), n = URL.createObjectURL(t), r = new Worker(n);
    r.onmessage = this._callback.bind(this), this._worker = r;
  }
  /**
   * Create a timeout loop
   */
  _createTimeout() {
    this._timeout = setTimeout(() => {
      this._createTimeout(), this._callback();
    }, this._updateInterval * 1e3);
  }
  /**
   * Create the clock source.
   */
  _createClock() {
    if (this._type === "worker")
      try {
        this._createWorker();
      } catch {
        this._type = "timeout", this._createClock();
      }
    else this._type === "timeout" && this._createTimeout();
  }
  /**
   * Clean up the current clock source
   */
  _disposeClock() {
    this._timeout && clearTimeout(this._timeout), this._worker && (this._worker.terminate(), this._worker.onmessage = null);
  }
  /**
   * The rate in seconds the ticker will update
   */
  get updateInterval() {
    return this._updateInterval;
  }
  set updateInterval(t) {
    var n;
    this._updateInterval = Math.max(t, this._minimumUpdateInterval), this._type === "worker" && ((n = this._worker) === null || n === void 0 || n.postMessage(this._updateInterval * 1e3));
  }
  /**
   * The type of the ticker, either a worker or a timeout
   */
  get type() {
    return this._type;
  }
  set type(t) {
    this._disposeClock(), this._type = t, this._createClock();
  }
  /**
   * Clean up
   */
  dispose() {
    this._disposeClock();
  }
}
function ml(e) {
  return kN(e);
}
function ea(e) {
  return AN(e);
}
function Kf(e) {
  return RN(e);
}
function Cc(e) {
  return EN(e);
}
function jN(e) {
  return e instanceof A5;
}
function LN(e, t) {
  return e === "value" || ml(t) || ea(t) || jN(t);
}
function dl(e, ...t) {
  if (!t.length)
    return e;
  const n = t.shift();
  if (ta(e) && ta(n))
    for (const r in n)
      LN(r, n[r]) ? e[r] = n[r] : ta(n[r]) ? (e[r] || Object.assign(e, { [r]: {} }), dl(e[r], n[r])) : Object.assign(e, { [r]: n[r] });
  return dl(e, ...t);
}
function zN(e, t) {
  return e.length === t.length && e.every((n, r) => t[r] === n);
}
function Re(e, t, n = [], r) {
  const i = {}, s = Array.from(t);
  if (ta(s[0]) && r && !Reflect.has(s[0], r) && (Object.keys(s[0]).some((c) => Reflect.has(e, c)) || (dl(i, { [r]: s[0] }), n.splice(n.indexOf(r), 1), s.shift())), s.length === 1 && ta(s[0]))
    dl(i, s[0]);
  else
    for (let l = 0; l < n.length; l++)
      Be(s[l]) && (i[n[l]] = s[l]);
  return dl(e, i);
}
function UN(e) {
  return e.constructor.getDefaults();
}
function Ns(e, t) {
  return wi(e) ? t : e;
}
function T0(e, t) {
  return t.forEach((n) => {
    Reflect.has(e, n) && delete e[n];
  }), e;
}
/**
 * Tone.js
 * @author Yotam Mann
 * @license http://opensource.org/licenses/MIT MIT License
 * @copyright 2014-2024 Yotam Mann
 */
class xo {
  constructor() {
    this.debug = !1, this._wasDisposed = !1;
  }
  /**
   * Returns all of the default options belonging to the class.
   */
  static getDefaults() {
    return {};
  }
  /**
   * Prints the outputs to the console log for debugging purposes.
   * Prints the contents only if either the object has a property
   * called `debug` set to true, or a variable called TONE_DEBUG_CLASS
   * is set to the name of the class.
   * @example
   * const osc = new Tone.Oscillator();
   * // prints all logs originating from this oscillator
   * osc.debug = true;
   * // calls to start/stop will print in the console
   * osc.start();
   */
  log(...t) {
    (this.debug || xi && this.toString() === xi.TONE_DEBUG_CLASS) && NN(this, ...t);
  }
  /**
   * disconnect and dispose.
   */
  dispose() {
    return this._wasDisposed = !0, this;
  }
  /**
   * Indicates if the instance was disposed. 'Disposing' an
   * instance means that all of the Web Audio nodes that were
   * created for the instance are disconnected and freed for garbage collection.
   */
  get disposed() {
    return this._wasDisposed;
  }
  /**
   * Convert the class to a string
   * @example
   * const osc = new Tone.Oscillator();
   * console.log(osc.toString());
   */
  toString() {
    return this.name;
  }
}
xo.version = YS;
const Py = 1e-6;
function Gc(e, t) {
  return e > t + Py;
}
function C0(e, t) {
  return Gc(e, t) || os(e, t);
}
function bp(e, t) {
  return e + Py < t;
}
function os(e, t) {
  return Math.abs(e - t) < Py;
}
function VN(e, t, n) {
  return Math.max(Math.min(e, n), t);
}
let Ps = class W5 extends xo {
  constructor() {
    super(), this.name = "Timeline", this._timeline = [];
    const t = Re(W5.getDefaults(), arguments, ["memory"]);
    this.memory = t.memory, this.increasing = t.increasing;
  }
  static getDefaults() {
    return {
      memory: 1 / 0,
      increasing: !1
    };
  }
  /**
   * The number of items in the timeline.
   */
  get length() {
    return this._timeline.length;
  }
  /**
   * Insert an event object onto the timeline. Events must have a "time" attribute.
   * @param event  The event object to insert into the timeline.
   */
  add(t) {
    if (we(Reflect.has(t, "time"), "Timeline: events must have a time attribute"), t.time = t.time.valueOf(), this.increasing && this.length) {
      const n = this._timeline[this.length - 1];
      we(C0(t.time, n.time), "The time must be greater than or equal to the last scheduled time"), this._timeline.push(t);
    } else {
      const n = this._search(t.time);
      this._timeline.splice(n + 1, 0, t);
    }
    if (this.length > this.memory) {
      const n = this.length - this.memory;
      this._timeline.splice(0, n);
    }
    return this;
  }
  /**
   * Remove an event from the timeline.
   * @param  {Object}  event  The event object to remove from the list.
   * @returns {Timeline} this
   */
  remove(t) {
    const n = this._timeline.indexOf(t);
    return n !== -1 && this._timeline.splice(n, 1), this;
  }
  /**
   * Get the nearest event whose time is less than or equal to the given time.
   * @param  time  The time to query.
   */
  get(t, n = "time") {
    const r = this._search(t, n);
    return r !== -1 ? this._timeline[r] : null;
  }
  /**
   * Return the first event in the timeline without removing it
   * @returns {Object} The first event object
   */
  peek() {
    return this._timeline[0];
  }
  /**
   * Return the first event in the timeline and remove it
   */
  shift() {
    return this._timeline.shift();
  }
  /**
   * Get the event which is scheduled after the given time.
   * @param  time  The time to query.
   */
  getAfter(t, n = "time") {
    const r = this._search(t, n);
    return r + 1 < this._timeline.length ? this._timeline[r + 1] : null;
  }
  /**
   * Get the event before the event at the given time.
   * @param  time  The time to query.
   */
  getBefore(t) {
    const n = this._timeline.length;
    if (n > 0 && this._timeline[n - 1].time < t)
      return this._timeline[n - 1];
    const r = this._search(t);
    return r - 1 >= 0 ? this._timeline[r - 1] : null;
  }
  /**
   * Cancel events at and after the given time
   * @param  after  The time to query.
   */
  cancel(t) {
    if (this._timeline.length > 1) {
      let n = this._search(t);
      if (n >= 0)
        if (os(this._timeline[n].time, t)) {
          for (let r = n; r >= 0 && os(this._timeline[r].time, t); r--)
            n = r;
          this._timeline = this._timeline.slice(0, n);
        } else
          this._timeline = this._timeline.slice(0, n + 1);
      else
        this._timeline = [];
    } else this._timeline.length === 1 && C0(this._timeline[0].time, t) && (this._timeline = []);
    return this;
  }
  /**
   * Cancel events before or equal to the given time.
   * @param  time  The time to cancel before.
   */
  cancelBefore(t) {
    const n = this._search(t);
    return n >= 0 && (this._timeline = this._timeline.slice(n + 1)), this;
  }
  /**
   * Returns the previous event if there is one. null otherwise
   * @param  event The event to find the previous one of
   * @return The event right before the given event
   */
  previousEvent(t) {
    const n = this._timeline.indexOf(t);
    return n > 0 ? this._timeline[n - 1] : null;
  }
  /**
   * Does a binary search on the timeline array and returns the
   * nearest event index whose time is after or equal to the given time.
   * If a time is searched before the first index in the timeline, -1 is returned.
   * If the time is after the end, the index of the last item is returned.
   */
  _search(t, n = "time") {
    if (this._timeline.length === 0)
      return -1;
    let r = 0;
    const i = this._timeline.length;
    let s = i;
    if (i > 0 && this._timeline[i - 1][n] <= t)
      return i - 1;
    for (; r < s; ) {
      let l = Math.floor(r + (s - r) / 2);
      const c = this._timeline[l], u = this._timeline[l + 1];
      if (os(c[n], t)) {
        for (let d = l; d < this._timeline.length; d++) {
          const h = this._timeline[d];
          if (os(h[n], t))
            l = d;
          else
            break;
        }
        return l;
      } else {
        if (bp(c[n], t) && Gc(u[n], t))
          return l;
        Gc(c[n], t) ? s = l : r = l + 1;
      }
    }
    return -1;
  }
  /**
   * Internal iterator. Applies extra safety checks for
   * removing items from the array.
   */
  _iterate(t, n = 0, r = this._timeline.length - 1) {
    this._timeline.slice(n, r + 1).forEach(t);
  }
  /**
   * Iterate over everything in the array
   * @param  callback The callback to invoke with every item
   */
  forEach(t) {
    return this._iterate(t), this;
  }
  /**
   * Iterate over everything in the array at or before the given time.
   * @param  time The time to check if items are before
   * @param  callback The callback to invoke with every item
   */
  forEachBefore(t, n) {
    const r = this._search(t);
    return r !== -1 && this._iterate(n, 0, r), this;
  }
  /**
   * Iterate over everything in the array after the given time.
   * @param  time The time to check if items are before
   * @param  callback The callback to invoke with every item
   */
  forEachAfter(t, n) {
    const r = this._search(t);
    return this._iterate(n, r + 1), this;
  }
  /**
   * Iterate over everything in the array between the startTime and endTime.
   * The timerange is inclusive of the startTime, but exclusive of the endTime.
   * range = [startTime, endTime).
   * @param  startTime The time to check if items are before
   * @param  endTime The end of the test interval.
   * @param  callback The callback to invoke with every item
   */
  forEachBetween(t, n, r) {
    let i = this._search(t), s = this._search(n);
    return i !== -1 && s !== -1 ? (this._timeline[i].time !== t && (i += 1), this._timeline[s].time === n && (s -= 1), this._iterate(r, i, s)) : i === -1 && this._iterate(r, 0, s), this;
  }
  /**
   * Iterate over everything in the array at or after the given time. Similar to
   * forEachAfter, but includes the item(s) at the given time.
   * @param  time The time to check if items are before
   * @param  callback The callback to invoke with every item
   */
  forEachFrom(t, n) {
    let r = this._search(t);
    for (; r >= 0 && this._timeline[r].time >= t; )
      r--;
    return this._iterate(n, r + 1), this;
  }
  /**
   * Iterate over everything in the array at the given time
   * @param  time The time to check if items are before
   * @param  callback The callback to invoke with every item
   */
  forEachAtTime(t, n) {
    const r = this._search(t);
    if (r !== -1 && os(this._timeline[r].time, t)) {
      let i = r;
      for (let s = r; s >= 0 && os(this._timeline[s].time, t); s--)
        i = s;
      this._iterate((s) => {
        n(s);
      }, i, r);
    }
    return this;
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this._timeline = [], this;
  }
};
const $5 = [];
function nm(e) {
  $5.push(e);
}
function GN(e) {
  $5.forEach((t) => t(e));
}
const K5 = [];
function rm(e) {
  K5.push(e);
}
function qN(e) {
  K5.forEach((t) => t(e));
}
class Mh extends xo {
  constructor() {
    super(...arguments), this.name = "Emitter";
  }
  /**
   * Bind a callback to a specific event.
   * @param  event     The name of the event to listen for.
   * @param  callback  The callback to invoke when the event is emitted
   */
  on(t, n) {
    return t.split(/\W+/).forEach((i) => {
      wi(this._events) && (this._events = {}), this._events.hasOwnProperty(i) || (this._events[i] = []), this._events[i].push(n);
    }), this;
  }
  /**
   * Bind a callback which is only invoked once
   * @param  event     The name of the event to listen for.
   * @param  callback  The callback to invoke when the event is emitted
   */
  once(t, n) {
    const r = (...i) => {
      n(...i), this.off(t, r);
    };
    return this.on(t, r), this;
  }
  /**
   * Remove the event listener.
   * @param  event     The event to stop listening to.
   * @param  callback  The callback which was bound to the event with Emitter.on.
   *                   If no callback is given, all callbacks events are removed.
   */
  off(t, n) {
    return t.split(/\W+/).forEach((i) => {
      if (wi(this._events) && (this._events = {}), this._events.hasOwnProperty(i))
        if (wi(n))
          this._events[i] = [];
        else {
          const s = this._events[i];
          for (let l = s.length - 1; l >= 0; l--)
            s[l] === n && s.splice(l, 1);
        }
    }), this;
  }
  /**
   * Invoke all of the callbacks bound to the event
   * with any arguments passed in.
   * @param  event  The name of the event.
   * @param args The arguments to pass to the functions listening.
   */
  emit(t, ...n) {
    if (this._events && this._events.hasOwnProperty(t)) {
      const r = this._events[t].slice(0);
      for (let i = 0, s = r.length; i < s; i++)
        r[i].apply(this, n);
    }
    return this;
  }
  /**
   * Add Emitter functions (on/off/emit) to the object
   */
  static mixin(t) {
    ["on", "once", "off", "emit"].forEach((n) => {
      const r = Object.getOwnPropertyDescriptor(Mh.prototype, n);
      Object.defineProperty(t.prototype, n, r);
    });
  }
  /**
   * Clean up
   */
  dispose() {
    return super.dispose(), this._events = void 0, this;
  }
}
class Y5 extends Mh {
  constructor() {
    super(...arguments), this.isOffline = !1;
  }
  /*
   * This is a placeholder so that JSON.stringify does not throw an error
   * This matches what JSON.stringify(audioContext) returns on a native
   * audioContext instance.
   */
  toJSON() {
    return {};
  }
}
let Dy = class X5 extends Y5 {
  constructor() {
    var t, n;
    super(), this.name = "Context", this._constants = /* @__PURE__ */ new Map(), this._timeouts = new Ps(), this._timeoutIds = 0, this._initialized = !1, this._closeStarted = !1, this.isOffline = !1, this._workletPromise = null;
    const r = Re(X5.getDefaults(), arguments, [
      "context"
    ]);
    r.context ? (this._context = r.context, this._latencyHint = ((t = arguments[0]) === null || t === void 0 ? void 0 : t.latencyHint) || "") : (this._context = PN({
      latencyHint: r.latencyHint
    }), this._latencyHint = r.latencyHint), this._ticker = new FN(this.emit.bind(this, "tick"), r.clockSource, r.updateInterval, this._context.sampleRate), this.on("tick", this._timeoutLoop.bind(this)), this._context.onstatechange = () => {
      this.emit("statechange", this.state);
    }, this[!((n = arguments[0]) === null || n === void 0) && n.hasOwnProperty("updateInterval") ? "_lookAhead" : "lookAhead"] = r.lookAhead;
  }
  static getDefaults() {
    return {
      clockSource: "worker",
      latencyHint: "interactive",
      lookAhead: 0.1,
      updateInterval: 0.05
    };
  }
  /**
   * Finish setting up the context. **You usually do not need to do this manually.**
   */
  initialize() {
    return this._initialized || (GN(this), this._initialized = !0), this;
  }
  //---------------------------
  // BASE AUDIO CONTEXT METHODS
  //---------------------------
  createAnalyser() {
    return this._context.createAnalyser();
  }
  createOscillator() {
    return this._context.createOscillator();
  }
  createBufferSource() {
    return this._context.createBufferSource();
  }
  createBiquadFilter() {
    return this._context.createBiquadFilter();
  }
  createBuffer(t, n, r) {
    return this._context.createBuffer(t, n, r);
  }
  createChannelMerger(t) {
    return this._context.createChannelMerger(t);
  }
  createChannelSplitter(t) {
    return this._context.createChannelSplitter(t);
  }
  createConstantSource() {
    return this._context.createConstantSource();
  }
  createConvolver() {
    return this._context.createConvolver();
  }
  createDelay(t) {
    return this._context.createDelay(t);
  }
  createDynamicsCompressor() {
    return this._context.createDynamicsCompressor();
  }
  createGain() {
    return this._context.createGain();
  }
  createIIRFilter(t, n) {
    return this._context.createIIRFilter(t, n);
  }
  createPanner() {
    return this._context.createPanner();
  }
  createPeriodicWave(t, n, r) {
    return this._context.createPeriodicWave(t, n, r);
  }
  createStereoPanner() {
    return this._context.createStereoPanner();
  }
  createWaveShaper() {
    return this._context.createWaveShaper();
  }
  createMediaStreamSource(t) {
    return we(Cc(this._context), "Not available if OfflineAudioContext"), this._context.createMediaStreamSource(t);
  }
  createMediaElementSource(t) {
    return we(Cc(this._context), "Not available if OfflineAudioContext"), this._context.createMediaElementSource(t);
  }
  createMediaStreamDestination() {
    return we(Cc(this._context), "Not available if OfflineAudioContext"), this._context.createMediaStreamDestination();
  }
  decodeAudioData(t) {
    return this._context.decodeAudioData(t);
  }
  /**
   * The current time in seconds of the AudioContext.
   */
  get currentTime() {
    return this._context.currentTime;
  }
  /**
   * The current time in seconds of the AudioContext.
   */
  get state() {
    return this._context.state;
  }
  /**
   * The current time in seconds of the AudioContext.
   */
  get sampleRate() {
    return this._context.sampleRate;
  }
  /**
   * The listener
   */
  get listener() {
    return this.initialize(), this._listener;
  }
  set listener(t) {
    we(!this._initialized, "The listener cannot be set after initialization."), this._listener = t;
  }
  /**
   * There is only one Transport per Context. It is created on initialization.
   */
  get transport() {
    return this.initialize(), this._transport;
  }
  set transport(t) {
    we(!this._initialized, "The transport cannot be set after initialization."), this._transport = t;
  }
  /**
   * This is the Draw object for the context which is useful for synchronizing the draw frame with the Tone.js clock.
   */
  get draw() {
    return this.initialize(), this._draw;
  }
  set draw(t) {
    we(!this._initialized, "Draw cannot be set after initialization."), this._draw = t;
  }
  /**
   * A reference to the Context's destination node.
   */
  get destination() {
    return this.initialize(), this._destination;
  }
  set destination(t) {
    we(!this._initialized, "The destination cannot be set after initialization."), this._destination = t;
  }
  /**
   * Create an audio worklet node from a name and options. The module
   * must first be loaded using {@link addAudioWorkletModule}.
   */
  createAudioWorkletNode(t, n) {
    return BN(this.rawContext, t, n);
  }
  /**
   * Add an AudioWorkletProcessor module
   * @param url The url of the module
   */
  addAudioWorkletModule(t) {
    return nr(this, void 0, void 0, function* () {
      we(Be(this.rawContext.audioWorklet), "AudioWorkletNode is only available in a secure context (https or localhost)"), this._workletPromise || (this._workletPromise = this.rawContext.audioWorklet.addModule(t)), yield this._workletPromise;
    });
  }
  /**
   * Returns a promise which resolves when all of the worklets have been loaded on this context
   */
  workletsAreReady() {
    return nr(this, void 0, void 0, function* () {
      (yield this._workletPromise) ? this._workletPromise : Promise.resolve();
    });
  }
  //---------------------------
  // TICKER
  //---------------------------
  /**
   * How often the interval callback is invoked.
   * This number corresponds to how responsive the scheduling
   * can be. Setting to 0 will result in the lowest practial interval
   * based on context properties. context.updateInterval + context.lookAhead
   * gives you the total latency between scheduling an event and hearing it.
   */
  get updateInterval() {
    return this._ticker.updateInterval;
  }
  set updateInterval(t) {
    this._ticker.updateInterval = t;
  }
  /**
   * What the source of the clock is, either "worker" (default),
   * "timeout", or "offline" (none).
   */
  get clockSource() {
    return this._ticker.type;
  }
  set clockSource(t) {
    this._ticker.type = t;
  }
  /**
   * The amount of time into the future events are scheduled. Giving Web Audio
   * a short amount of time into the future to schedule events can reduce clicks and
   * improve performance. This value can be set to 0 to get the lowest latency.
   * Adjusting this value also affects the {@link updateInterval}.
   */
  get lookAhead() {
    return this._lookAhead;
  }
  set lookAhead(t) {
    this._lookAhead = t, this.updateInterval = t ? t / 2 : 0.01;
  }
  /**
   * The type of playback, which affects tradeoffs between audio
   * output latency and responsiveness.
   * In addition to setting the value in seconds, the latencyHint also
   * accepts the strings "interactive" (prioritizes low latency),
   * "playback" (prioritizes sustained playback), "balanced" (balances
   * latency and performance).
   * @example
   * // prioritize sustained playback
   * const context = new Tone.Context({ latencyHint: "playback" });
   * // set this context as the global Context
   * Tone.setContext(context);
   * // the global context is gettable with Tone.getContext()
   * console.log(Tone.getContext().latencyHint);
   */
  get latencyHint() {
    return this._latencyHint;
  }
  /**
   * The unwrapped AudioContext or OfflineAudioContext
   */
  get rawContext() {
    return this._context;
  }
  /**
   * The current audio context time plus a short {@link lookAhead}.
   * @example
   * setInterval(() => {
   * 	console.log("now", Tone.now());
   * }, 100);
   */
  now() {
    return this._context.currentTime + this._lookAhead;
  }
  /**
   * The current audio context time without the {@link lookAhead}.
   * In most cases it is better to use {@link now} instead of {@link immediate} since
   * with {@link now} the {@link lookAhead} is applied equally to _all_ components including internal components,
   * to making sure that everything is scheduled in sync. Mixing {@link now} and {@link immediate}
   * can cause some timing issues. If no lookAhead is desired, you can set the {@link lookAhead} to `0`.
   */
  immediate() {
    return this._context.currentTime;
  }
  /**
   * Starts the audio context from a suspended state. This is required
   * to initially start the AudioContext.
   * @see {@link start}
   */
  resume() {
    return Cc(this._context) ? this._context.resume() : Promise.resolve();
  }
  /**
   * Close the context. Once closed, the context can no longer be used and
   * any AudioNodes created from the context will be silent.
   */
  close() {
    return nr(this, void 0, void 0, function* () {
      Cc(this._context) && this.state !== "closed" && !this._closeStarted && (this._closeStarted = !0, yield this._context.close()), this._initialized && qN(this);
    });
  }
  /**
   * **Internal** Generate a looped buffer at some constant value.
   */
  getConstant(t) {
    if (this._constants.has(t))
      return this._constants.get(t);
    {
      const n = this._context.createBuffer(1, 128, this._context.sampleRate), r = n.getChannelData(0);
      for (let s = 0; s < r.length; s++)
        r[s] = t;
      const i = this._context.createBufferSource();
      return i.channelCount = 1, i.channelCountMode = "explicit", i.buffer = n, i.loop = !0, i.start(0), this._constants.set(t, i), i;
    }
  }
  /**
   * Clean up. Also closes the audio context.
   */
  dispose() {
    return super.dispose(), this._ticker.dispose(), this._timeouts.dispose(), Object.keys(this._constants).map((t) => this._constants[t].disconnect()), this.close(), this;
  }
  //---------------------------
  // TIMEOUTS
  //---------------------------
  /**
   * The private loop which keeps track of the context scheduled timeouts
   * Is invoked from the clock source
   */
  _timeoutLoop() {
    const t = this.now();
    let n = this._timeouts.peek();
    for (; this._timeouts.length && n && n.time <= t; )
      n.callback(), this._timeouts.shift(), n = this._timeouts.peek();
  }
  /**
   * A setTimeout which is guaranteed by the clock source.
   * Also runs in the offline context.
   * @param  fn       The callback to invoke
   * @param  timeout  The timeout in seconds
   * @returns ID to use when invoking Context.clearTimeout
   */
  setTimeout(t, n) {
    this._timeoutIds++;
    const r = this.now();
    return this._timeouts.add({
      callback: t,
      id: this._timeoutIds,
      time: r + n
    }), this._timeoutIds;
  }
  /**
   * Clears a previously scheduled timeout with Tone.context.setTimeout
   * @param  id  The ID returned from setTimeout
   */
  clearTimeout(t) {
    return this._timeouts.forEach((n) => {
      n.id === t && this._timeouts.remove(n);
    }), this;
  }
  /**
   * Clear the function scheduled by {@link setInterval}
   */
  clearInterval(t) {
    return this.clearTimeout(t);
  }
  /**
   * Adds a repeating event to the context's callback clock
   */
  setInterval(t, n) {
    const r = ++this._timeoutIds, i = () => {
      const s = this.now();
      this._timeouts.add({
        callback: () => {
          t(), i();
        },
        id: r,
        time: s + n
      });
    };
    return i(), r;
  }
};
class HN extends Y5 {
  constructor() {
    super(...arguments), this.lookAhead = 0, this.latencyHint = 0, this.isOffline = !1;
  }
  //---------------------------
  // BASE AUDIO CONTEXT METHODS
  //---------------------------
  createAnalyser() {
    return {};
  }
  createOscillator() {
    return {};
  }
  createBufferSource() {
    return {};
  }
  createBiquadFilter() {
    return {};
  }
  createBuffer(t, n, r) {
    return {};
  }
  createChannelMerger(t) {
    return {};
  }
  createChannelSplitter(t) {
    return {};
  }
  createConstantSource() {
    return {};
  }
  createConvolver() {
    return {};
  }
  createDelay(t) {
    return {};
  }
  createDynamicsCompressor() {
    return {};
  }
  createGain() {
    return {};
  }
  createIIRFilter(t, n) {
    return {};
  }
  createPanner() {
    return {};
  }
  createPeriodicWave(t, n, r) {
    return {};
  }
  createStereoPanner() {
    return {};
  }
  createWaveShaper() {
    return {};
  }
  createMediaStreamSource(t) {
    return {};
  }
  createMediaElementSource(t) {
    return {};
  }
  createMediaStreamDestination() {
    return {};
  }
  decodeAudioData(t) {
    return Promise.resolve({});
  }
  //---------------------------
  // TONE AUDIO CONTEXT METHODS
  //---------------------------
  createAudioWorkletNode(t, n) {
    return {};
  }
  get rawContext() {
    return {};
  }
  addAudioWorkletModule(t) {
    return nr(this, void 0, void 0, function* () {
      return Promise.resolve();
    });
  }
  resume() {
    return Promise.resolve();
  }
  setTimeout(t, n) {
    return 0;
  }
  clearTimeout(t) {
    return this;
  }
  setInterval(t, n) {
    return 0;
  }
  clearInterval(t) {
    return this;
  }
  getConstant(t) {
    return {};
  }
  get currentTime() {
    return 0;
  }
  get state() {
    return {};
  }
  get sampleRate() {
    return 0;
  }
  get listener() {
    return {};
  }
  get transport() {
    return {};
  }
  get draw() {
    return {};
  }
  set draw(t) {
  }
  get destination() {
    return {};
  }
  set destination(t) {
  }
  now() {
    return 0;
  }
  immediate() {
    return 0;
  }
}
function qn(e, t) {
  ii(t) ? t.forEach((n) => qn(e, n)) : Object.defineProperty(e, t, {
    enumerable: !0,
    writable: !1
  });
}
function Q5(e, t) {
  ii(t) ? t.forEach((n) => Q5(e, n)) : Object.defineProperty(e, t, {
    writable: !0
  });
}
const un = () => {
};
class Sn extends xo {
  constructor() {
    super(), this.name = "ToneAudioBuffer", this.onload = un;
    const t = Re(Sn.getDefaults(), arguments, ["url", "onload", "onerror"]);
    this.reverse = t.reverse, this.onload = t.onload, _o(t.url) ? this.load(t.url).catch(t.onerror) : t.url && this.set(t.url);
  }
  static getDefaults() {
    return {
      onerror: un,
      onload: un,
      reverse: !1
    };
  }
  /**
   * The sample rate of the AudioBuffer
   */
  get sampleRate() {
    return this._buffer ? this._buffer.sampleRate : Kr().sampleRate;
  }
  /**
   * Pass in an AudioBuffer or ToneAudioBuffer to set the value of this buffer.
   */
  set(t) {
    return t instanceof Sn ? t.loaded ? this._buffer = t.get() : t.onload = () => {
      this.set(t), this.onload(this);
    } : this._buffer = t, this._reversed && this._reverse(), this;
  }
  /**
   * The audio buffer stored in the object.
   */
  get() {
    return this._buffer;
  }
  /**
   * Makes an fetch request for the selected url then decodes the file as an audio buffer.
   * Invokes the callback once the audio buffer loads.
   * @param url The url of the buffer to load. filetype support depends on the browser.
   * @returns A Promise which resolves with this ToneAudioBuffer
   */
  load(t) {
    return nr(this, void 0, void 0, function* () {
      const n = Sn.load(t).then((r) => {
        this.set(r), this.onload(this);
      });
      Sn.downloads.push(n);
      try {
        yield n;
      } finally {
        const r = Sn.downloads.indexOf(n);
        Sn.downloads.splice(r, 1);
      }
      return this;
    });
  }
  /**
   * clean up
   */
  dispose() {
    return super.dispose(), this._buffer = void 0, this;
  }
  /**
   * Set the audio buffer from the array.
   * To create a multichannel AudioBuffer, pass in a multidimensional array.
   * @param array The array to fill the audio buffer
   */
  fromArray(t) {
    const n = ii(t) && t[0].length > 0, r = n ? t.length : 1, i = n ? t[0].length : t.length, s = Kr(), l = s.createBuffer(r, i, s.sampleRate), c = !n && r === 1 ? [t] : t;
    for (let u = 0; u < r; u++)
      l.copyToChannel(c[u], u);
    return this._buffer = l, this;
  }
  /**
   * Sums multiple channels into 1 channel
   * @param chanNum Optionally only copy a single channel from the array.
   */
  toMono(t) {
    if (Bs(t))
      this.fromArray(this.toArray(t));
    else {
      let n = new Float32Array(this.length);
      const r = this.numberOfChannels;
      for (let i = 0; i < r; i++) {
        const s = this.toArray(i);
        for (let l = 0; l < s.length; l++)
          n[l] += s[l];
      }
      n = n.map((i) => i / r), this.fromArray(n);
    }
    return this;
  }
  /**
   * Get the buffer as an array. Single channel buffers will return a 1-dimensional
   * Float32Array, and multichannel buffers will return multidimensional arrays.
   * @param channel Optionally only copy a single channel from the array.
   */
  toArray(t) {
    if (Bs(t))
      return this.getChannelData(t);
    if (this.numberOfChannels === 1)
      return this.toArray(0);
    {
      const n = [];
      for (let r = 0; r < this.numberOfChannels; r++)
        n[r] = this.getChannelData(r);
      return n;
    }
  }
  /**
   * Returns the Float32Array representing the PCM audio data for the specific channel.
   * @param  channel  The channel number to return
   * @return The audio as a TypedArray
   */
  getChannelData(t) {
    return this._buffer ? this._buffer.getChannelData(t) : new Float32Array(0);
  }
  /**
   * Cut a subsection of the array and return a buffer of the
   * subsection. Does not modify the original buffer
   * @param start The time to start the slice
   * @param end The end time to slice. If none is given will default to the end of the buffer
   */
  slice(t, n = this.duration) {
    we(this.loaded, "Buffer is not loaded");
    const r = Math.floor(t * this.sampleRate), i = Math.floor(n * this.sampleRate);
    we(r < i, "The start time must be less than the end time");
    const s = i - r, l = Kr().createBuffer(this.numberOfChannels, s, this.sampleRate);
    for (let c = 0; c < this.numberOfChannels; c++)
      l.copyToChannel(this.getChannelData(c).subarray(r, i), c);
    return new Sn(l);
  }
  /**
   * Reverse the buffer.
   */
  _reverse() {
    if (this.loaded)
      for (let t = 0; t < this.numberOfChannels; t++)
        this.getChannelData(t).reverse();
    return this;
  }
  /**
   * If the buffer is loaded or not
   */
  get loaded() {
    return this.length > 0;
  }
  /**
   * The duration of the buffer in seconds.
   */
  get duration() {
    return this._buffer ? this._buffer.duration : 0;
  }
  /**
   * The length of the buffer in samples
   */
  get length() {
    return this._buffer ? this._buffer.length : 0;
  }
  /**
   * The number of discrete audio channels. Returns 0 if no buffer is loaded.
   */
  get numberOfChannels() {
    return this._buffer ? this._buffer.numberOfChannels : 0;
  }
  /**
   * Reverse the buffer.
   */
  get reverse() {
    return this._reversed;
  }
  set reverse(t) {
    this._reversed !== t && (this._reversed = t, this._reverse());
  }
  /**
   * Create a ToneAudioBuffer from the array. To create a multichannel AudioBuffer,
   * pass in a multidimensional array.
   * @param array The array to fill the audio buffer
   * @return A ToneAudioBuffer created from the array
   */
  static fromArray(t) {
    return new Sn().fromArray(t);
  }
  /**
   * Creates a ToneAudioBuffer from a URL, returns a promise which resolves to a ToneAudioBuffer
   * @param  url The url to load.
   * @return A promise which resolves to a ToneAudioBuffer
   */
  static fromUrl(t) {
    return nr(this, void 0, void 0, function* () {
      return yield new Sn().load(t);
    });
  }
  /**
   * Loads a url using fetch and returns the AudioBuffer.
   */
  static load(t) {
    return nr(this, void 0, void 0, function* () {
      const n = t.match(/\[([^\]\[]+\|.+)\]$/);
      if (n) {
        const u = n[1].split("|");
        let d = u[0];
        for (const h of u)
          if (Sn.supportsType(h)) {
            d = h;
            break;
          }
        t = t.replace(n[0], d);
      }
      const r = Sn.baseUrl === "" || Sn.baseUrl.endsWith("/") ? Sn.baseUrl : Sn.baseUrl + "/", i = document.createElement("a");
      i.href = r + t, i.pathname = (i.pathname + i.hash).split("/").map(encodeURIComponent).join("/");
      const s = yield fetch(i.href);
      if (!s.ok)
        throw new Error(`could not load url: ${t}`);
      const l = yield s.arrayBuffer();
      return yield Kr().decodeAudioData(l);
    });
  }
  /**
   * Checks a url's extension to see if the current browser can play that file type.
   * @param url The url/extension to test
   * @return If the file extension can be played
   * @static
   * @example
   * Tone.ToneAudioBuffer.supportsType("wav"); // returns true
   * Tone.ToneAudioBuffer.supportsType("path/to/file.wav"); // returns true
   */
  static supportsType(t) {
    const n = t.split("."), r = n[n.length - 1];
    return document.createElement("audio").canPlayType("audio/" + r) !== "";
  }
  /**
   * Returns a Promise which resolves when all of the buffers have loaded
   */
  static loaded() {
    return nr(this, void 0, void 0, function* () {
      for (yield Promise.resolve(); Sn.downloads.length; )
        yield Sn.downloads[0];
    });
  }
}
Sn.baseUrl = "";
Sn.downloads = [];
class Iy extends Dy {
  constructor() {
    super({
      clockSource: "offline",
      context: Kf(arguments[0]) ? arguments[0] : DN(arguments[0], arguments[1] * arguments[2], arguments[2]),
      lookAhead: 0,
      updateInterval: Kf(arguments[0]) ? 128 / arguments[0].sampleRate : 128 / arguments[2]
    }), this.name = "OfflineContext", this._currentTime = 0, this.isOffline = !0, this._duration = Kf(arguments[0]) ? arguments[0].length / arguments[0].sampleRate : arguments[1];
  }
  /**
   * Override the now method to point to the internal clock time
   */
  now() {
    return this._currentTime;
  }
  /**
   * Same as this.now()
   */
  get currentTime() {
    return this._currentTime;
  }
  /**
   * Render just the clock portion of the audio context.
   */
  _renderClock(t) {
    return nr(this, void 0, void 0, function* () {
      let n = 0;
      for (; this._duration - this._currentTime >= 0; ) {
        this.emit("tick"), this._currentTime += 128 / this.sampleRate, n++;
        const r = Math.floor(this.sampleRate / 128);
        t && n % r === 0 && (yield new Promise((i) => setTimeout(i, 1)));
      }
    });
  }
  /**
   * Render the output of the OfflineContext
   * @param asynchronous If the clock should be rendered asynchronously, which will not block the main thread, but be slightly slower.
   */
  render() {
    return nr(this, arguments, void 0, function* (t = !0) {
      yield this.workletsAreReady(), yield this._renderClock(t);
      const n = yield this._context.startRendering();
      return new Sn(n);
    });
  }
  /**
   * Close the context
   */
  close() {
    return Promise.resolve();
  }
}
const Z5 = new HN();
let al = Z5;
function Kr() {
  return al === Z5 && IN && WN(new Dy()), al;
}
function WN(e, t = !1) {
  t && al.dispose(), Cc(e) ? al = new Dy(e) : Kf(e) ? al = new Iy(e) : al = e;
}
function J5() {
  return al.resume();
}
if (xi && !xi.TONE_SILENCE_LOGGING) {
  const t = ` * Tone.js v${YS} * `;
  console.log(`%c${t}`, "background: #000; color: #fff");
}
function $N(e) {
  return Math.pow(10, e / 20);
}
function KN(e) {
  return 20 * (Math.log(e) / Math.LN10);
}
function tx(e) {
  return Math.pow(2, e / 12);
}
let im = 440;
function YN() {
  return im;
}
function XN(e) {
  im = e;
}
function ll(e) {
  return Math.round(ex(e));
}
function ex(e) {
  return 69 + 12 * Math.log2(e / im);
}
function nx(e) {
  return im * Math.pow(2, (e - 69) / 12);
}
class By extends xo {
  /**
   * @param context The context associated with the time value. Used to compute
   * Transport and context-relative timing.
   * @param  value  The time value as a number, string or object
   * @param  units  Unit values
   */
  constructor(t, n, r) {
    super(), this.defaultUnits = "s", this._val = n, this._units = r, this.context = t, this._expressions = this._getExpressions();
  }
  /**
   * All of the time encoding expressions
   */
  _getExpressions() {
    return {
      hz: {
        method: (t) => this._frequencyToUnits(parseFloat(t)),
        regexp: /^(\d+(?:\.\d+)?)hz$/i
      },
      i: {
        method: (t) => this._ticksToUnits(parseInt(t, 10)),
        regexp: /^(\d+)i$/i
      },
      m: {
        method: (t) => this._beatsToUnits(parseInt(t, 10) * this._getTimeSignature()),
        regexp: /^(\d+)m$/i
      },
      n: {
        method: (t, n) => {
          const r = parseInt(t, 10), i = n === "." ? 1.5 : 1;
          return r === 1 ? this._beatsToUnits(this._getTimeSignature()) * i : this._beatsToUnits(4 / r) * i;
        },
        regexp: /^(\d+)n(\.?)$/i
      },
      number: {
        method: (t) => this._expressions[this.defaultUnits].method.call(this, t),
        regexp: /^(\d+(?:\.\d+)?)$/
      },
      s: {
        method: (t) => this._secondsToUnits(parseFloat(t)),
        regexp: /^(\d+(?:\.\d+)?)s$/
      },
      samples: {
        method: (t) => parseInt(t, 10) / this.context.sampleRate,
        regexp: /^(\d+)samples$/
      },
      t: {
        method: (t) => {
          const n = parseInt(t, 10);
          return this._beatsToUnits(8 / (Math.floor(n) * 3));
        },
        regexp: /^(\d+)t$/i
      },
      tr: {
        method: (t, n, r) => {
          let i = 0;
          return t && t !== "0" && (i += this._beatsToUnits(this._getTimeSignature() * parseFloat(t))), n && n !== "0" && (i += this._beatsToUnits(parseFloat(n))), r && r !== "0" && (i += this._beatsToUnits(parseFloat(r) / 4)), i;
        },
        regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?$/
      }
    };
  }
  //-------------------------------------
  // 	VALUE OF
  //-------------------------------------
  /**
   * Evaluate the time value. Returns the time in seconds.
   */
  valueOf() {
    if (this._val instanceof By && this.fromType(this._val), wi(this._val))
      return this._noArg();
    if (_o(this._val) && wi(this._units)) {
      for (const t in this._expressions)
        if (this._expressions[t].regexp.test(this._val.trim())) {
          this._units = t;
          break;
        }
    } else if (ta(this._val)) {
      let t = 0;
      for (const n in this._val)
        if (Be(this._val[n])) {
          const r = this._val[n], i = (
            // @ts-ignore
            new this.constructor(this.context, n).valueOf() * r
          );
          t += i;
        }
      return t;
    }
    if (Be(this._units)) {
      const t = this._expressions[this._units], n = this._val.toString().trim().match(t.regexp);
      return n ? t.method.apply(this, n.slice(1)) : t.method.call(this, this._val);
    } else return _o(this._val) ? parseFloat(this._val) : this._val;
  }
  //-------------------------------------
  // 	UNIT CONVERSIONS
  //-------------------------------------
  /**
   * Returns the value of a frequency in the current units
   */
  _frequencyToUnits(t) {
    return 1 / t;
  }
  /**
   * Return the value of the beats in the current units
   */
  _beatsToUnits(t) {
    return 60 / this._getBpm() * t;
  }
  /**
   * Returns the value of a second in the current units
   */
  _secondsToUnits(t) {
    return t;
  }
  /**
   * Returns the value of a tick in the current time units
   */
  _ticksToUnits(t) {
    return t * this._beatsToUnits(1) / this._getPPQ();
  }
  /**
   * With no arguments, return 'now'
   */
  _noArg() {
    return this._now();
  }
  //-------------------------------------
  // 	TEMPO CONVERSIONS
  //-------------------------------------
  /**
   * Return the bpm
   */
  _getBpm() {
    return this.context.transport.bpm.value;
  }
  /**
   * Return the timeSignature
   */
  _getTimeSignature() {
    return this.context.transport.timeSignature;
  }
  /**
   * Return the PPQ or 192 if Transport is not available
   */
  _getPPQ() {
    return this.context.transport.PPQ;
  }
  //-------------------------------------
  // 	CONVERSION INTERFACE
  //-------------------------------------
  /**
   * Coerce a time type into this units type.
   * @param type Any time type units
   */
  fromType(t) {
    switch (this._units = void 0, this.defaultUnits) {
      case "s":
        this._val = t.toSeconds();
        break;
      case "i":
        this._val = t.toTicks();
        break;
      case "hz":
        this._val = t.toFrequency();
        break;
      case "midi":
        this._val = t.toMidi();
        break;
    }
    return this;
  }
  /**
   * Return the value in hertz
   */
  toFrequency() {
    return 1 / this.toSeconds();
  }
  /**
   * Return the time in samples
   */
  toSamples() {
    return this.toSeconds() * this.context.sampleRate;
  }
  /**
   * Return the time in milliseconds.
   */
  toMilliseconds() {
    return this.toSeconds() * 1e3;
  }
}
class as extends By {
  constructor() {
    super(...arguments), this.name = "TimeClass";
  }
  _getExpressions() {
    return Object.assign(super._getExpressions(), {
      now: {
        method: (t) => this._now() + new this.constructor(this.context, t).valueOf(),
        regexp: /^\+(.+)/
      },
      quantize: {
        method: (t) => {
          const n = new as(this.context, t).valueOf();
          return this._secondsToUnits(this.context.transport.nextSubdivision(n));
        },
        regexp: /^@(.+)/
      }
    });
  }
  /**
   * Quantize the time by the given subdivision. Optionally add a
   * percentage which will move the time value towards the ideal
   * quantized value by that percentage.
   * @param  subdiv    The subdivision to quantize to
   * @param  percent  Move the time value towards the quantized value by a percentage.
   * @example
   * Tone.Time(21).quantize(2); // returns 22
   * Tone.Time(0.6).quantize("4n", 0.5); // returns 0.55
   */
  quantize(t, n = 1) {
    const r = new this.constructor(this.context, t).valueOf(), i = this.valueOf(), c = Math.round(i / r) * r - i;
    return i + c * n;
  }
  //-------------------------------------
  // CONVERSIONS
  //-------------------------------------
  /**
   * Convert a Time to Notation. The notation values are will be the
   * closest representation between 1m to 128th note.
   * @return {Notation}
   * @example
   * // if the Transport is at 120bpm:
   * Tone.Time(2).toNotation(); // returns "1m"
   */
  toNotation() {
    const t = this.toSeconds(), n = ["1m"];
    for (let s = 1; s < 9; s++) {
      const l = Math.pow(2, s);
      n.push(l + "n."), n.push(l + "n"), n.push(l + "t");
    }
    n.push("0");
    let r = n[0], i = new as(this.context, n[0]).toSeconds();
    return n.forEach((s) => {
      const l = new as(this.context, s).toSeconds();
      Math.abs(l - t) < Math.abs(i - t) && (r = s, i = l);
    }), r;
  }
  /**
   * Return the time encoded as Bars:Beats:Sixteenths.
   */
  toBarsBeatsSixteenths() {
    const t = this._beatsToUnits(1);
    let n = this.valueOf() / t;
    n = parseFloat(n.toFixed(4));
    const r = Math.floor(n / this._getTimeSignature());
    let i = n % 1 * 4;
    n = Math.floor(n) % this._getTimeSignature();
    const s = i.toString();
    return s.length > 3 && (i = parseFloat(parseFloat(s).toFixed(3))), [r, n, i].join(":");
  }
  /**
   * Return the time in ticks.
   */
  toTicks() {
    const t = this._beatsToUnits(1);
    return this.valueOf() / t * this._getPPQ();
  }
  /**
   * Return the time in seconds.
   */
  toSeconds() {
    return this.valueOf();
  }
  /**
   * Return the value as a midi note.
   */
  toMidi() {
    return ll(this.toFrequency());
  }
  _now() {
    return this.context.now();
  }
}
class ei extends as {
  constructor() {
    super(...arguments), this.name = "Frequency", this.defaultUnits = "hz";
  }
  /**
   * The [concert tuning pitch](https://en.wikipedia.org/wiki/Concert_pitch) which is used
   * to generate all the other pitch values from notes. A4's values in Hertz.
   */
  static get A4() {
    return YN();
  }
  static set A4(t) {
    XN(t);
  }
  //-------------------------------------
  // 	AUGMENT BASE EXPRESSIONS
  //-------------------------------------
  _getExpressions() {
    return Object.assign({}, super._getExpressions(), {
      midi: {
        regexp: /^(\d+(?:\.\d+)?midi)/,
        method(t) {
          return this.defaultUnits === "midi" ? t : ei.mtof(t);
        }
      },
      note: {
        regexp: /^([a-g]{1}(?:b|#|##|x|bb|###|#x|x#|bbb)?)(-?[0-9]+)/i,
        method(t, n) {
          const i = QN[t.toLowerCase()] + (parseInt(n, 10) + 1) * 12;
          return this.defaultUnits === "midi" ? i : ei.mtof(i);
        }
      },
      tr: {
        regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?/,
        method(t, n, r) {
          let i = 1;
          return t && t !== "0" && (i *= this._beatsToUnits(this._getTimeSignature() * parseFloat(t))), n && n !== "0" && (i *= this._beatsToUnits(parseFloat(n))), r && r !== "0" && (i *= this._beatsToUnits(parseFloat(r) / 4)), i;
        }
      }
    });
  }
  //-------------------------------------
  // 	EXPRESSIONS
  //-------------------------------------
  /**
   * Transposes the frequency by the given number of semitones.
   * @return  A new transposed frequency
   * @example
   * Tone.Frequency("A4").transpose(3); // "C5"
   */
  transpose(t) {
    return new ei(this.context, this.valueOf() * tx(t));
  }
  /**
   * Takes an array of semitone intervals and returns
   * an array of frequencies transposed by those intervals.
   * @return  Returns an array of Frequencies
   * @example
   * Tone.Frequency("A4").harmonize([0, 3, 7]); // ["A4", "C5", "E5"]
   */
  harmonize(t) {
    return t.map((n) => this.transpose(n));
  }
  //-------------------------------------
  // 	UNIT CONVERSIONS
  //-------------------------------------
  /**
   * Return the value of the frequency as a MIDI note
   * @example
   * Tone.Frequency("C4").toMidi(); // 60
   */
  toMidi() {
    return ll(this.valueOf());
  }
  /**
   * Return the value of the frequency in Scientific Pitch Notation
   * @example
   * Tone.Frequency(69, "midi").toNote(); // "A4"
   */
  toNote() {
    const t = this.toFrequency(), n = Math.log2(t / ei.A4);
    let r = Math.round(12 * n) + 57;
    const i = Math.floor(r / 12);
    return i < 0 && (r += -12 * i), ZN[r % 12] + i.toString();
  }
  /**
   * Return the duration of one cycle in seconds.
   */
  toSeconds() {
    return 1 / super.toSeconds();
  }
  /**
   * Return the duration of one cycle in ticks
   */
  toTicks() {
    const t = this._beatsToUnits(1), n = this.valueOf() / t;
    return Math.floor(n * this._getPPQ());
  }
  //-------------------------------------
  // 	UNIT CONVERSIONS HELPERS
  //-------------------------------------
  /**
   * With no arguments, return 0
   */
  _noArg() {
    return 0;
  }
  /**
   * Returns the value of a frequency in the current units
   */
  _frequencyToUnits(t) {
    return t;
  }
  /**
   * Returns the value of a tick in the current time units
   */
  _ticksToUnits(t) {
    return 1 / (t * 60 / (this._getBpm() * this._getPPQ()));
  }
  /**
   * Return the value of the beats in the current units
   */
  _beatsToUnits(t) {
    return 1 / super._beatsToUnits(t);
  }
  /**
   * Returns the value of a second in the current units
   */
  _secondsToUnits(t) {
    return 1 / t;
  }
  /**
   * Convert a MIDI note to frequency value.
   * @param  midi The midi number to convert.
   * @return The corresponding frequency value
   */
  static mtof(t) {
    return nx(t);
  }
  /**
   * Convert a frequency value to a MIDI note.
   * @param frequency The value to frequency value to convert.
   */
  static ftom(t) {
    return ll(t);
  }
}
const QN = {
  cbbb: -3,
  cbb: -2,
  cb: -1,
  c: 0,
  "c#": 1,
  cx: 2,
  "c##": 2,
  "c###": 3,
  "cx#": 3,
  "c#x": 3,
  dbbb: -1,
  dbb: 0,
  db: 1,
  d: 2,
  "d#": 3,
  dx: 4,
  "d##": 4,
  "d###": 5,
  "dx#": 5,
  "d#x": 5,
  ebbb: 1,
  ebb: 2,
  eb: 3,
  e: 4,
  "e#": 5,
  ex: 6,
  "e##": 6,
  "e###": 7,
  "ex#": 7,
  "e#x": 7,
  fbbb: 2,
  fbb: 3,
  fb: 4,
  f: 5,
  "f#": 6,
  fx: 7,
  "f##": 7,
  "f###": 8,
  "fx#": 8,
  "f#x": 8,
  gbbb: 4,
  gbb: 5,
  gb: 6,
  g: 7,
  "g#": 8,
  gx: 9,
  "g##": 9,
  "g###": 10,
  "gx#": 10,
  "g#x": 10,
  abbb: 6,
  abb: 7,
  ab: 8,
  a: 9,
  "a#": 10,
  ax: 11,
  "a##": 11,
  "a###": 12,
  "ax#": 12,
  "a#x": 12,
  bbbb: 8,
  bbb: 9,
  bb: 10,
  b: 11,
  "b#": 12,
  bx: 13,
  "b##": 13,
  "b###": 14,
  "bx#": 14,
  "b#x": 14
}, ZN = [
  "C",
  "C#",
  "D",
  "D#",
  "E",
  "F",
  "F#",
  "G",
  "G#",
  "A",
  "A#",
  "B"
];
function r2(e, t) {
  return new ei(Kr(), e, t);
}
class Pc extends as {
  constructor() {
    super(...arguments), this.name = "TransportTime";
  }
  /**
   * Return the current time in whichever context is relevant
   */
  _now() {
    return this.context.transport.seconds;
  }
}
class jr extends xo {
  constructor() {
    super();
    const t = Re(jr.getDefaults(), arguments, ["context"]);
    this.defaultContext ? this.context = this.defaultContext : this.context = t.context;
  }
  static getDefaults() {
    return {
      context: Kr()
    };
  }
  /**
   * Return the current time of the Context clock plus the lookAhead.
   * @example
   * setInterval(() => {
   * 	console.log(Tone.now());
   * }, 100);
   */
  now() {
    return this.context.currentTime + this.context.lookAhead;
  }
  /**
   * Return the current time of the Context clock without any lookAhead.
   * @example
   * setInterval(() => {
   * 	console.log(Tone.immediate());
   * }, 100);
   */
  immediate() {
    return this.context.currentTime;
  }
  /**
   * The duration in seconds of one sample.
   */
  get sampleTime() {
    return 1 / this.context.sampleRate;
  }
  /**
   * The number of seconds of 1 processing block (128 samples)
   * @example
   * console.log(Tone.Destination.blockTime);
   */
  get blockTime() {
    return 128 / this.context.sampleRate;
  }
  /**
   * Convert the incoming time to seconds.
   * This is calculated against the current {@link TransportClass} bpm
   * @example
   * const gain = new Tone.Gain();
   * setInterval(() => console.log(gain.toSeconds("4n")), 100);
   * // ramp the tempo to 60 bpm over 30 seconds
   * Tone.getTransport().bpm.rampTo(60, 30);
   */
  toSeconds(t) {
    return ON(t), new as(this.context, t).toSeconds();
  }
  /**
   * Convert the input to a frequency number
   * @example
   * const gain = new Tone.Gain();
   * console.log(gain.toFrequency("4n"));
   */
  toFrequency(t) {
    return new ei(this.context, t).toFrequency();
  }
  /**
   * Convert the input time into ticks
   * @example
   * const gain = new Tone.Gain();
   * console.log(gain.toTicks("4n"));
   */
  toTicks(t) {
    return new Pc(this.context, t).toTicks();
  }
  //-------------------------------------
  // 	GET/SET
  //-------------------------------------
  /**
   * Get a subset of the properties which are in the partial props
   */
  _getPartialProperties(t) {
    const n = this.get();
    return Object.keys(n).forEach((r) => {
      wi(t[r]) && delete n[r];
    }), n;
  }
  /**
   * Get the object's attributes.
   * @example
   * const osc = new Tone.Oscillator();
   * console.log(osc.get());
   */
  get() {
    const t = UN(this);
    return Object.keys(t).forEach((n) => {
      if (Reflect.has(this, n)) {
        const r = this[n];
        Be(r) && Be(r.value) && Be(r.setValueAtTime) ? t[n] = r.value : r instanceof jr ? t[n] = r._getPartialProperties(t[n]) : ii(r) || Bs(r) || _o(r) || V5(r) ? t[n] = r : delete t[n];
      }
    }), t;
  }
  /**
   * Set multiple properties at once with an object.
   * @example
   * const filter = new Tone.Filter().toDestination();
   * // set values using an object
   * filter.set({
   * 	frequency: "C6",
   * 	type: "highpass"
   * });
   * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/Analogsynth_octaves_highmid.mp3").connect(filter);
   * player.autostart = true;
   */
  set(t) {
    return Object.keys(t).forEach((n) => {
      Reflect.has(this, n) && Be(this[n]) && (this[n] && Be(this[n].value) && Be(this[n].setValueAtTime) ? this[n].value !== t[n] && (this[n].value = t[n]) : this[n] instanceof jr ? this[n].set(t[n]) : this[n] = t[n]);
    }), this;
  }
}
class Oh extends Ps {
  constructor(t = "stopped") {
    super(), this.name = "StateTimeline", this._initial = t, this.setStateAtTime(this._initial, 0);
  }
  /**
   * Returns the scheduled state scheduled before or at
   * the given time.
   * @param  time  The time to query.
   * @return  The name of the state input in setStateAtTime.
   */
  getValueAtTime(t) {
    const n = this.get(t);
    return n !== null ? n.state : this._initial;
  }
  /**
   * Add a state to the timeline.
   * @param  state The name of the state to set.
   * @param  time  The time to query.
   * @param options Any additional options that are needed in the timeline.
   */
  setStateAtTime(t, n, r) {
    return ra(n, 0), this.add(Object.assign({}, r, {
      state: t,
      time: n
    })), this;
  }
  /**
   * Return the event before the time with the given state
   * @param  state The state to look for
   * @param  time  When to check before
   * @return  The event with the given state before the time
   */
  getLastState(t, n) {
    const r = this._search(n);
    for (let i = r; i >= 0; i--) {
      const s = this._timeline[i];
      if (s.state === t)
        return s;
    }
  }
  /**
   * Return the event after the time with the given state
   * @param  state The state to look for
   * @param  time  When to check from
   * @return  The event with the given state after the time
   */
  getNextState(t, n) {
    const r = this._search(n);
    if (r !== -1)
      for (let i = r; i < this._timeline.length; i++) {
        const s = this._timeline[i];
        if (s.state === t)
          return s;
      }
  }
}
class Pn extends jr {
  constructor() {
    const t = Re(Pn.getDefaults(), arguments, [
      "param",
      "units",
      "convert"
    ]);
    for (super(t), this.name = "Param", this.overridden = !1, this._minOutput = 1e-7, we(Be(t.param) && (ml(t.param) || t.param instanceof Pn), "param must be an AudioParam"); !ml(t.param); )
      t.param = t.param._param;
    this._swappable = Be(t.swappable) ? t.swappable : !1, this._swappable ? (this.input = this.context.createGain(), this._param = t.param, this.input.connect(this._param)) : this._param = this.input = t.param, this._events = new Ps(1e3), this._initialValue = this._param.defaultValue, this.units = t.units, this.convert = t.convert, this._minValue = t.minValue, this._maxValue = t.maxValue, Be(t.value) && t.value !== this._toType(this._initialValue) && this.setValueAtTime(t.value, 0);
  }
  static getDefaults() {
    return Object.assign(jr.getDefaults(), {
      convert: !0,
      units: "number"
    });
  }
  get value() {
    const t = this.now();
    return this.getValueAtTime(t);
  }
  set value(t) {
    this.cancelScheduledValues(this.now()), this.setValueAtTime(t, this.now());
  }
  get minValue() {
    return Be(this._minValue) ? this._minValue : this.units === "time" || this.units === "frequency" || this.units === "normalRange" || this.units === "positive" || this.units === "transportTime" || this.units === "ticks" || this.units === "bpm" || this.units === "hertz" || this.units === "samples" ? 0 : this.units === "audioRange" ? -1 : this.units === "decibels" ? -1 / 0 : this._param.minValue;
  }
  get maxValue() {
    return Be(this._maxValue) ? this._maxValue : this.units === "normalRange" || this.units === "audioRange" ? 1 : this._param.maxValue;
  }
  /**
   * Type guard based on the unit name
   */
  _is(t, n) {
    return this.units === n;
  }
  /**
   * Make sure the value is always in the defined range
   */
  _assertRange(t) {
    return Be(this.maxValue) && Be(this.minValue) && ra(t, this._fromType(this.minValue), this._fromType(this.maxValue)), t;
  }
  /**
   * Convert the given value from the type specified by Param.units
   * into the destination value (such as Gain or Frequency).
   */
  _fromType(t) {
    return this.convert && !this.overridden ? this._is(t, "time") ? this.toSeconds(t) : this._is(t, "decibels") ? $N(t) : this._is(t, "frequency") ? this.toFrequency(t) : t : this.overridden ? 0 : t;
  }
  /**
   * Convert the parameters value into the units specified by Param.units.
   */
  _toType(t) {
    return this.convert && this.units === "decibels" ? KN(t) : t;
  }
  //-------------------------------------
  // ABSTRACT PARAM INTERFACE
  // all docs are generated from ParamInterface.ts
  //-------------------------------------
  setValueAtTime(t, n) {
    const r = this.toSeconds(n), i = this._fromType(t);
    return we(isFinite(i) && isFinite(r), `Invalid argument(s) to setValueAtTime: ${JSON.stringify(t)}, ${JSON.stringify(n)}`), this._assertRange(i), this.log(this.units, "setValueAtTime", t, r), this._events.add({
      time: r,
      type: "setValueAtTime",
      value: i
    }), this._param.setValueAtTime(i, r), this;
  }
  getValueAtTime(t) {
    const n = Math.max(this.toSeconds(t), 0), r = this._events.getAfter(n), i = this._events.get(n);
    let s = this._initialValue;
    if (i === null)
      s = this._initialValue;
    else if (i.type === "setTargetAtTime" && (r === null || r.type === "setValueAtTime")) {
      const l = this._events.getBefore(i.time);
      let c;
      l === null ? c = this._initialValue : c = l.value, i.type === "setTargetAtTime" && (s = this._exponentialApproach(i.time, c, i.value, i.constant, n));
    } else if (r === null)
      s = i.value;
    else if (r.type === "linearRampToValueAtTime" || r.type === "exponentialRampToValueAtTime") {
      let l = i.value;
      if (i.type === "setTargetAtTime") {
        const c = this._events.getBefore(i.time);
        c === null ? l = this._initialValue : l = c.value;
      }
      r.type === "linearRampToValueAtTime" ? s = this._linearInterpolate(i.time, l, r.time, r.value, n) : s = this._exponentialInterpolate(i.time, l, r.time, r.value, n);
    } else
      s = i.value;
    return this._toType(s);
  }
  setRampPoint(t) {
    t = this.toSeconds(t);
    let n = this.getValueAtTime(t);
    return this.cancelAndHoldAtTime(t), this._fromType(n) === 0 && (n = this._toType(this._minOutput)), this.setValueAtTime(n, t), this;
  }
  linearRampToValueAtTime(t, n) {
    const r = this._fromType(t), i = this.toSeconds(n);
    return we(isFinite(r) && isFinite(i), `Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(t)}, ${JSON.stringify(n)}`), this._assertRange(r), this._events.add({
      time: i,
      type: "linearRampToValueAtTime",
      value: r
    }), this.log(this.units, "linearRampToValueAtTime", t, i), this._param.linearRampToValueAtTime(r, i), this;
  }
  exponentialRampToValueAtTime(t, n) {
    let r = this._fromType(t);
    r = os(r, 0) ? this._minOutput : r, this._assertRange(r);
    const i = this.toSeconds(n);
    return we(isFinite(r) && isFinite(i), `Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(t)}, ${JSON.stringify(n)}`), this._events.add({
      time: i,
      type: "exponentialRampToValueAtTime",
      value: r
    }), this.log(this.units, "exponentialRampToValueAtTime", t, i), this._param.exponentialRampToValueAtTime(r, i), this;
  }
  exponentialRampTo(t, n, r) {
    return r = this.toSeconds(r), this.setRampPoint(r), this.exponentialRampToValueAtTime(t, r + this.toSeconds(n)), this;
  }
  linearRampTo(t, n, r) {
    return r = this.toSeconds(r), this.setRampPoint(r), this.linearRampToValueAtTime(t, r + this.toSeconds(n)), this;
  }
  targetRampTo(t, n, r) {
    return r = this.toSeconds(r), this.setRampPoint(r), this.exponentialApproachValueAtTime(t, r, n), this;
  }
  exponentialApproachValueAtTime(t, n, r) {
    n = this.toSeconds(n), r = this.toSeconds(r);
    const i = Math.log(r + 1) / Math.log(200);
    return this.setTargetAtTime(t, n, i), this.cancelAndHoldAtTime(n + r * 0.9), this.linearRampToValueAtTime(t, n + r), this;
  }
  setTargetAtTime(t, n, r) {
    const i = this._fromType(t);
    we(isFinite(r) && r > 0, "timeConstant must be a number greater than 0");
    const s = this.toSeconds(n);
    return this._assertRange(i), we(isFinite(i) && isFinite(s), `Invalid argument(s) to setTargetAtTime: ${JSON.stringify(t)}, ${JSON.stringify(n)}`), this._events.add({
      constant: r,
      time: s,
      type: "setTargetAtTime",
      value: i
    }), this.log(this.units, "setTargetAtTime", t, s, r), this._param.setTargetAtTime(i, s, r), this;
  }
  setValueCurveAtTime(t, n, r, i = 1) {
    r = this.toSeconds(r), n = this.toSeconds(n);
    const s = this._fromType(t[0]) * i;
    this.setValueAtTime(this._toType(s), n);
    const l = r / (t.length - 1);
    for (let c = 1; c < t.length; c++) {
      const u = this._fromType(t[c]) * i;
      this.linearRampToValueAtTime(this._toType(u), n + c * l);
    }
    return this;
  }
  cancelScheduledValues(t) {
    const n = this.toSeconds(t);
    return we(isFinite(n), `Invalid argument to cancelScheduledValues: ${JSON.stringify(t)}`), this._events.cancel(n), this._param.cancelScheduledValues(n), this.log(this.units, "cancelScheduledValues", n), this;
  }
  cancelAndHoldAtTime(t) {
    const n = this.toSeconds(t), r = this._fromType(this.getValueAtTime(n));
    we(isFinite(n), `Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(t)}`), this.log(this.units, "cancelAndHoldAtTime", n, "value=" + r);
    const i = this._events.get(n), s = this._events.getAfter(n);
    return i && os(i.time, n) ? s ? (this._param.cancelScheduledValues(s.time), this._events.cancel(s.time)) : (this._param.cancelAndHoldAtTime(n), this._events.cancel(n + this.sampleTime)) : s && (this._param.cancelScheduledValues(s.time), this._events.cancel(s.time), s.type === "linearRampToValueAtTime" ? this.linearRampToValueAtTime(this._toType(r), n) : s.type === "exponentialRampToValueAtTime" && this.exponentialRampToValueAtTime(this._toType(r), n)), this._events.add({
      time: n,
      type: "setValueAtTime",
      value: r
    }), this._param.setValueAtTime(r, n), this;
  }
  rampTo(t, n = 0.1, r) {
    return this.units === "frequency" || this.units === "bpm" || this.units === "decibels" ? this.exponentialRampTo(t, n, r) : this.linearRampTo(t, n, r), this;
  }
  /**
   * Apply all of the previously scheduled events to the passed in Param or AudioParam.
   * The applied values will start at the context's current time and schedule
   * all of the events which are scheduled on this Param onto the passed in param.
   */
  apply(t) {
    const n = this.context.currentTime;
    t.setValueAtTime(this.getValueAtTime(n), n);
    const r = this._events.get(n);
    if (r && r.type === "setTargetAtTime") {
      const i = this._events.getAfter(r.time), s = i ? i.time : n + 2, l = (s - n) / 10;
      for (let c = n; c < s; c += l)
        t.linearRampToValueAtTime(this.getValueAtTime(c), c);
    }
    return this._events.forEachAfter(this.context.currentTime, (i) => {
      i.type === "cancelScheduledValues" ? t.cancelScheduledValues(i.time) : i.type === "setTargetAtTime" ? t.setTargetAtTime(i.value, i.time, i.constant) : t[i.type](i.value, i.time);
    }), this;
  }
  /**
   * Replace the Param's internal AudioParam. Will apply scheduled curves
   * onto the parameter and replace the connections.
   */
  setParam(t) {
    we(this._swappable, "The Param must be assigned as 'swappable' in the constructor");
    const n = this.input;
    return n.disconnect(this._param), this.apply(t), this._param = t, n.connect(this._param), this;
  }
  dispose() {
    return super.dispose(), this._events.dispose(), this;
  }
  get defaultValue() {
    return this._toType(this._param.defaultValue);
  }
  //-------------------------------------
  // 	AUTOMATION CURVE CALCULATIONS
  // 	MIT License, copyright (c) 2014 Jordan Santell
  //-------------------------------------
  // Calculates the the value along the curve produced by setTargetAtTime
  _exponentialApproach(t, n, r, i, s) {
    return r + (n - r) * Math.exp(-(s - t) / i);
  }
  // Calculates the the value along the curve produced by linearRampToValueAtTime
  _linearInterpolate(t, n, r, i, s) {
    return n + (i - n) * ((s - t) / (r - t));
  }
  // Calculates the the value along the curve produced by exponentialRampToValueAtTime
  _exponentialInterpolate(t, n, r, i, s) {
    return n * Math.pow(i / n, (s - t) / (r - t));
  }
}
class qe extends jr {
  constructor() {
    super(...arguments), this._internalChannels = [];
  }
  /**
   * The number of inputs feeding into the AudioNode.
   * For source nodes, this will be 0.
   * @example
   * const node = new Tone.Gain();
   * console.log(node.numberOfInputs);
   */
  get numberOfInputs() {
    return Be(this.input) ? ml(this.input) || this.input instanceof Pn ? 1 : this.input.numberOfInputs : 0;
  }
  /**
   * The number of outputs of the AudioNode.
   * @example
   * const node = new Tone.Gain();
   * console.log(node.numberOfOutputs);
   */
  get numberOfOutputs() {
    return Be(this.output) ? this.output.numberOfOutputs : 0;
  }
  //-------------------------------------
  // AUDIO PROPERTIES
  //-------------------------------------
  /**
   * Used to decide which nodes to get/set properties on
   */
  _isAudioNode(t) {
    return Be(t) && (t instanceof qe || ea(t));
  }
  /**
   * Get all of the audio nodes (either internal or input/output) which together
   * make up how the class node responds to channel input/output
   */
  _getInternalNodes() {
    const t = this._internalChannels.slice(0);
    return this._isAudioNode(this.input) && t.push(this.input), this._isAudioNode(this.output) && this.input !== this.output && t.push(this.output), t;
  }
  /**
   * Set the audio options for this node such as channelInterpretation
   * channelCount, etc.
   * @param options
   */
  _setChannelProperties(t) {
    this._getInternalNodes().forEach((r) => {
      r.channelCount = t.channelCount, r.channelCountMode = t.channelCountMode, r.channelInterpretation = t.channelInterpretation;
    });
  }
  /**
   * Get the current audio options for this node such as channelInterpretation
   * channelCount, etc.
   */
  _getChannelProperties() {
    const t = this._getInternalNodes();
    we(t.length > 0, "ToneAudioNode does not have any internal nodes");
    const n = t[0];
    return {
      channelCount: n.channelCount,
      channelCountMode: n.channelCountMode,
      channelInterpretation: n.channelInterpretation
    };
  }
  /**
   * channelCount is the number of channels used when up-mixing and down-mixing
   * connections to any inputs to the node. The default value is 2 except for
   * specific nodes where its value is specially determined.
   */
  get channelCount() {
    return this._getChannelProperties().channelCount;
  }
  set channelCount(t) {
    const n = this._getChannelProperties();
    this._setChannelProperties(Object.assign(n, { channelCount: t }));
  }
  /**
   * channelCountMode determines how channels will be counted when up-mixing and
   * down-mixing connections to any inputs to the node.
   * The default value is "max". This attribute has no effect for nodes with no inputs.
   * * "max" - computedNumberOfChannels is the maximum of the number of channels of all connections to an input. In this mode channelCount is ignored.
   * * "clamped-max" - computedNumberOfChannels is determined as for "max" and then clamped to a maximum value of the given channelCount.
   * * "explicit" - computedNumberOfChannels is the exact value as specified by the channelCount.
   */
  get channelCountMode() {
    return this._getChannelProperties().channelCountMode;
  }
  set channelCountMode(t) {
    const n = this._getChannelProperties();
    this._setChannelProperties(Object.assign(n, { channelCountMode: t }));
  }
  /**
   * channelInterpretation determines how individual channels will be treated
   * when up-mixing and down-mixing connections to any inputs to the node.
   * The default value is "speakers".
   */
  get channelInterpretation() {
    return this._getChannelProperties().channelInterpretation;
  }
  set channelInterpretation(t) {
    const n = this._getChannelProperties();
    this._setChannelProperties(Object.assign(n, { channelInterpretation: t }));
  }
  //-------------------------------------
  // CONNECTIONS
  //-------------------------------------
  /**
   * connect the output of a ToneAudioNode to an AudioParam, AudioNode, or ToneAudioNode
   * @param destination The output to connect to
   * @param outputNum The output to connect from
   * @param inputNum The input to connect to
   */
  connect(t, n = 0, r = 0) {
    return su(this, t, n, r), this;
  }
  /**
   * Connect the output to the context's destination node.
   * @example
   * const osc = new Tone.Oscillator("C2").start();
   * osc.toDestination();
   */
  toDestination() {
    return this.connect(this.context.destination), this;
  }
  /**
   * Connect the output to the context's destination node.
   * @see {@link toDestination}
   * @deprecated
   */
  toMaster() {
    return em("toMaster() has been renamed toDestination()"), this.toDestination();
  }
  /**
   * disconnect the output
   */
  disconnect(t, n = 0, r = 0) {
    return JN(this, t, n, r), this;
  }
  /**
   * Connect the output of this node to the rest of the nodes in series.
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/drum-samples/handdrum-loop.mp3");
   * player.autostart = true;
   * const filter = new Tone.AutoFilter(4).start();
   * const distortion = new Tone.Distortion(0.5);
   * // connect the player to the filter, distortion and then to the master output
   * player.chain(filter, distortion, Tone.Destination);
   */
  chain(...t) {
    return w0(this, ...t), this;
  }
  /**
   * connect the output of this node to the rest of the nodes in parallel.
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/drum-samples/conga-rhythm.mp3");
   * player.autostart = true;
   * const pitchShift = new Tone.PitchShift(4).toDestination();
   * const filter = new Tone.Filter("G5").toDestination();
   * // connect a node to the pitch shift and filter in parallel
   * player.fan(pitchShift, filter);
   */
  fan(...t) {
    return t.forEach((n) => this.connect(n)), this;
  }
  /**
   * Dispose and disconnect
   */
  dispose() {
    return super.dispose(), Be(this.input) && (this.input instanceof qe ? this.input.dispose() : ea(this.input) && this.input.disconnect()), Be(this.output) && (this.output instanceof qe ? this.output.dispose() : ea(this.output) && this.output.disconnect()), this._internalChannels = [], this;
  }
}
function w0(...e) {
  const t = e.shift();
  e.reduce((n, r) => (n instanceof qe ? n.connect(r) : ea(n) && su(n, r), r), t);
}
function su(e, t, n = 0, r = 0) {
  for (we(Be(e), "Cannot connect from undefined node"), we(Be(t), "Cannot connect to undefined node"), (t instanceof qe || ea(t)) && we(t.numberOfInputs > 0, "Cannot connect to node with no inputs"), we(e.numberOfOutputs > 0, "Cannot connect from node with no outputs"); t instanceof qe || t instanceof Pn; )
    Be(t.input) && (t = t.input);
  for (; e instanceof qe; )
    Be(e.output) && (e = e.output);
  ml(t) ? e.connect(t, n) : e.connect(t, n, r);
}
function JN(e, t, n = 0, r = 0) {
  if (Be(t))
    for (; t instanceof qe; )
      t = t.input;
  for (; !ea(e); )
    Be(e.output) && (e = e.output);
  ml(t) ? e.disconnect(t, n) : ea(t) ? e.disconnect(t, n, r) : e.disconnect();
}
class Lr extends qe {
  constructor() {
    const t = Re(Lr.getDefaults(), arguments, [
      "gain",
      "units"
    ]);
    super(t), this.name = "Gain", this._gainNode = this.context.createGain(), this.input = this._gainNode, this.output = this._gainNode, this.gain = new Pn({
      context: this.context,
      convert: t.convert,
      param: this._gainNode.gain,
      units: t.units,
      value: t.gain,
      minValue: t.minValue,
      maxValue: t.maxValue
    }), qn(this, "gain");
  }
  static getDefaults() {
    return Object.assign(qe.getDefaults(), {
      convert: !0,
      gain: 1,
      units: "gain"
    });
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this._gainNode.disconnect(), this.gain.dispose(), this;
  }
}
class qc extends qe {
  constructor(t) {
    super(t), this.onended = un, this._startTime = -1, this._stopTime = -1, this._timeout = -1, this.output = new Lr({
      context: this.context,
      gain: 0
    }), this._gainNode = this.output, this.getStateAtTime = function(n) {
      const r = this.toSeconds(n);
      return this._startTime !== -1 && r >= this._startTime && (this._stopTime === -1 || r <= this._stopTime) ? "started" : "stopped";
    }, this._fadeIn = t.fadeIn, this._fadeOut = t.fadeOut, this._curve = t.curve, this.onended = t.onended;
  }
  static getDefaults() {
    return Object.assign(qe.getDefaults(), {
      curve: "linear",
      fadeIn: 0,
      fadeOut: 0,
      onended: un
    });
  }
  /**
   * Start the source at the given time
   * @param  time When to start the source
   */
  _startGain(t, n = 1) {
    we(this._startTime === -1, "Source cannot be started more than once");
    const r = this.toSeconds(this._fadeIn);
    return this._startTime = t + r, this._startTime = Math.max(this._startTime, this.context.currentTime), r > 0 ? (this._gainNode.gain.setValueAtTime(0, t), this._curve === "linear" ? this._gainNode.gain.linearRampToValueAtTime(n, t + r) : this._gainNode.gain.exponentialApproachValueAtTime(n, t, r)) : this._gainNode.gain.setValueAtTime(n, t), this;
  }
  /**
   * Stop the source node at the given time.
   * @param time When to stop the source
   */
  stop(t) {
    return this.log("stop", t), this._stopGain(this.toSeconds(t)), this;
  }
  /**
   * Stop the source at the given time
   * @param  time When to stop the source
   */
  _stopGain(t) {
    we(this._startTime !== -1, "'start' must be called before 'stop'"), this.cancelStop();
    const n = this.toSeconds(this._fadeOut);
    return this._stopTime = this.toSeconds(t) + n, this._stopTime = Math.max(this._stopTime, this.now()), n > 0 ? this._curve === "linear" ? this._gainNode.gain.linearRampTo(0, n, t) : this._gainNode.gain.targetRampTo(0, n, t) : (this._gainNode.gain.cancelAndHoldAtTime(t), this._gainNode.gain.setValueAtTime(0, t)), this.context.clearTimeout(this._timeout), this._timeout = this.context.setTimeout(() => {
      const r = this._curve === "exponential" ? n * 2 : 0;
      this._stopSource(this.now() + r), this._onended();
    }, this._stopTime - this.context.currentTime), this;
  }
  /**
   * Invoke the onended callback
   */
  _onended() {
    if (this.onended !== un && (this.onended(this), this.onended = un, !this.context.isOffline)) {
      const t = () => this.dispose();
      typeof window.requestIdleCallback < "u" ? window.requestIdleCallback(t) : setTimeout(t, 1e3);
    }
  }
  /**
   * Get the playback state at the current time
   */
  get state() {
    return this.getStateAtTime(this.now());
  }
  /**
   * Cancel a scheduled stop event
   */
  cancelStop() {
    return this.log("cancelStop"), we(this._startTime !== -1, "Source is not started"), this._gainNode.gain.cancelScheduledValues(this._startTime + this.sampleTime), this.context.clearTimeout(this._timeout), this._stopTime = -1, this;
  }
  dispose() {
    return super.dispose(), this._gainNode.dispose(), this.onended = un, this;
  }
}
class Fy extends qc {
  constructor() {
    const t = Re(Fy.getDefaults(), arguments, ["offset"]);
    super(t), this.name = "ToneConstantSource", this._source = this.context.createConstantSource(), su(this._source, this._gainNode), this.offset = new Pn({
      context: this.context,
      convert: t.convert,
      param: this._source.offset,
      units: t.units,
      value: t.offset,
      minValue: t.minValue,
      maxValue: t.maxValue
    });
  }
  static getDefaults() {
    return Object.assign(qc.getDefaults(), {
      convert: !0,
      offset: 1,
      units: "number"
    });
  }
  /**
   * Start the source node at the given time
   * @param  time When to start the source
   */
  start(t) {
    const n = this.toSeconds(t);
    return this.log("start", n), this._startGain(n), this._source.start(n), this;
  }
  _stopSource(t) {
    this._source.stop(t);
  }
  dispose() {
    return super.dispose(), this.state === "started" && this.stop(), this._source.disconnect(), this.offset.dispose(), this;
  }
}
class br extends qe {
  constructor() {
    const t = Re(br.getDefaults(), arguments, [
      "value",
      "units"
    ]);
    super(t), this.name = "Signal", this.override = !0, this.output = this._constantSource = new Fy({
      context: this.context,
      convert: t.convert,
      offset: t.value,
      units: t.units,
      minValue: t.minValue,
      maxValue: t.maxValue
    }), this._constantSource.start(0), this.input = this._param = this._constantSource.offset;
  }
  static getDefaults() {
    return Object.assign(qe.getDefaults(), {
      convert: !0,
      units: "number",
      value: 0
    });
  }
  connect(t, n = 0, r = 0) {
    return jy(this, t, n, r), this;
  }
  dispose() {
    return super.dispose(), this._param.dispose(), this._constantSource.dispose(), this;
  }
  //-------------------------------------
  // ABSTRACT PARAM INTERFACE
  // just a proxy for the ConstantSourceNode's offset AudioParam
  // all docs are generated from AbstractParam.ts
  //-------------------------------------
  setValueAtTime(t, n) {
    return this._param.setValueAtTime(t, n), this;
  }
  getValueAtTime(t) {
    return this._param.getValueAtTime(t);
  }
  setRampPoint(t) {
    return this._param.setRampPoint(t), this;
  }
  linearRampToValueAtTime(t, n) {
    return this._param.linearRampToValueAtTime(t, n), this;
  }
  exponentialRampToValueAtTime(t, n) {
    return this._param.exponentialRampToValueAtTime(t, n), this;
  }
  exponentialRampTo(t, n, r) {
    return this._param.exponentialRampTo(t, n, r), this;
  }
  linearRampTo(t, n, r) {
    return this._param.linearRampTo(t, n, r), this;
  }
  targetRampTo(t, n, r) {
    return this._param.targetRampTo(t, n, r), this;
  }
  exponentialApproachValueAtTime(t, n, r) {
    return this._param.exponentialApproachValueAtTime(t, n, r), this;
  }
  setTargetAtTime(t, n, r) {
    return this._param.setTargetAtTime(t, n, r), this;
  }
  setValueCurveAtTime(t, n, r, i) {
    return this._param.setValueCurveAtTime(t, n, r, i), this;
  }
  cancelScheduledValues(t) {
    return this._param.cancelScheduledValues(t), this;
  }
  cancelAndHoldAtTime(t) {
    return this._param.cancelAndHoldAtTime(t), this;
  }
  rampTo(t, n, r) {
    return this._param.rampTo(t, n, r), this;
  }
  get value() {
    return this._param.value;
  }
  set value(t) {
    this._param.value = t;
  }
  get convert() {
    return this._param.convert;
  }
  set convert(t) {
    this._param.convert = t;
  }
  get units() {
    return this._param.units;
  }
  get overridden() {
    return this._param.overridden;
  }
  set overridden(t) {
    this._param.overridden = t;
  }
  get maxValue() {
    return this._param.maxValue;
  }
  get minValue() {
    return this._param.minValue;
  }
  /**
   * @see {@link Param.apply}.
   */
  apply(t) {
    return this._param.apply(t), this;
  }
}
function jy(e, t, n, r) {
  (t instanceof Pn || ml(t) || t instanceof br && t.override) && (t.cancelScheduledValues(0), t.setValueAtTime(0, 0), t instanceof br && (t.overridden = !0)), su(e, t, n, r);
}
class Ly extends Pn {
  constructor() {
    const t = Re(Ly.getDefaults(), arguments, ["value"]);
    super(t), this.name = "TickParam", this._events = new Ps(1 / 0), this._multiplier = 1, this._multiplier = t.multiplier, this._events.cancel(0), this._events.add({
      ticks: 0,
      time: 0,
      type: "setValueAtTime",
      value: this._fromType(t.value)
    }), this.setValueAtTime(t.value, 0);
  }
  static getDefaults() {
    return Object.assign(Pn.getDefaults(), {
      multiplier: 1,
      units: "hertz",
      value: 1
    });
  }
  setTargetAtTime(t, n, r) {
    n = this.toSeconds(n), this.setRampPoint(n);
    const i = this._fromType(t), s = this._events.get(n), l = Math.round(Math.max(1 / r, 1));
    for (let c = 0; c <= l; c++) {
      const u = r * c + n, d = this._exponentialApproach(s.time, s.value, i, r, u);
      this.linearRampToValueAtTime(this._toType(d), u);
    }
    return this;
  }
  setValueAtTime(t, n) {
    const r = this.toSeconds(n);
    super.setValueAtTime(t, n);
    const i = this._events.get(r), s = this._events.previousEvent(i), l = this._getTicksUntilEvent(s, r);
    return i.ticks = Math.max(l, 0), this;
  }
  linearRampToValueAtTime(t, n) {
    const r = this.toSeconds(n);
    super.linearRampToValueAtTime(t, n);
    const i = this._events.get(r), s = this._events.previousEvent(i), l = this._getTicksUntilEvent(s, r);
    return i.ticks = Math.max(l, 0), this;
  }
  exponentialRampToValueAtTime(t, n) {
    n = this.toSeconds(n);
    const r = this._fromType(t), i = this._events.get(n), s = Math.round(Math.max((n - i.time) * 10, 1)), l = (n - i.time) / s;
    for (let c = 0; c <= s; c++) {
      const u = l * c + i.time, d = this._exponentialInterpolate(i.time, i.value, n, r, u);
      this.linearRampToValueAtTime(this._toType(d), u);
    }
    return this;
  }
  /**
   * Returns the tick value at the time. Takes into account
   * any automation curves scheduled on the signal.
   * @param  event The time to get the tick count at
   * @return The number of ticks which have elapsed at the time given any automations.
   */
  _getTicksUntilEvent(t, n) {
    if (t === null)
      t = {
        ticks: 0,
        time: 0,
        type: "setValueAtTime",
        value: 0
      };
    else if (wi(t.ticks)) {
      const l = this._events.previousEvent(t);
      t.ticks = this._getTicksUntilEvent(l, t.time);
    }
    const r = this._fromType(this.getValueAtTime(t.time));
    let i = this._fromType(this.getValueAtTime(n));
    const s = this._events.get(n);
    return s && s.time === n && s.type === "setValueAtTime" && (i = this._fromType(this.getValueAtTime(n - this.sampleTime))), 0.5 * (n - t.time) * (r + i) + t.ticks;
  }
  /**
   * Returns the tick value at the time. Takes into account
   * any automation curves scheduled on the signal.
   * @param  time The time to get the tick count at
   * @return The number of ticks which have elapsed at the time given any automations.
   */
  getTicksAtTime(t) {
    const n = this.toSeconds(t), r = this._events.get(n);
    return Math.max(this._getTicksUntilEvent(r, n), 0);
  }
  /**
   * Return the elapsed time of the number of ticks from the given time
   * @param ticks The number of ticks to calculate
   * @param  time The time to get the next tick from
   * @return The duration of the number of ticks from the given time in seconds
   */
  getDurationOfTicks(t, n) {
    const r = this.toSeconds(n), i = this.getTicksAtTime(n);
    return this.getTimeOfTick(i + t) - r;
  }
  /**
   * Given a tick, returns the time that tick occurs at.
   * @return The time that the tick occurs.
   */
  getTimeOfTick(t) {
    const n = this._events.get(t, "ticks"), r = this._events.getAfter(t, "ticks");
    if (n && n.ticks === t)
      return n.time;
    if (n && r && r.type === "linearRampToValueAtTime" && n.value !== r.value) {
      const i = this._fromType(this.getValueAtTime(n.time)), l = (this._fromType(this.getValueAtTime(r.time)) - i) / (r.time - n.time), c = Math.sqrt(Math.pow(i, 2) - 2 * l * (n.ticks - t)), u = (-i + c) / l, d = (-i - c) / l;
      return (u > 0 ? u : d) + n.time;
    } else return n ? n.value === 0 ? 1 / 0 : n.time + (t - n.ticks) / n.value : t / this._initialValue;
  }
  /**
   * Convert some number of ticks their the duration in seconds accounting
   * for any automation curves starting at the given time.
   * @param  ticks The number of ticks to convert to seconds.
   * @param  when  When along the automation timeline to convert the ticks.
   * @return The duration in seconds of the ticks.
   */
  ticksToTime(t, n) {
    return this.getDurationOfTicks(t, n);
  }
  /**
   * The inverse of {@link ticksToTime}. Convert a duration in
   * seconds to the corresponding number of ticks accounting for any
   * automation curves starting at the given time.
   * @param  duration The time interval to convert to ticks.
   * @param  when When along the automation timeline to convert the ticks.
   * @return The duration in ticks.
   */
  timeToTicks(t, n) {
    const r = this.toSeconds(n), i = this.toSeconds(t), s = this.getTicksAtTime(r);
    return this.getTicksAtTime(r + i) - s;
  }
  /**
   * Convert from the type when the unit value is BPM
   */
  _fromType(t) {
    return this.units === "bpm" && this.multiplier ? 1 / (60 / t / this.multiplier) : super._fromType(t);
  }
  /**
   * Special case of type conversion where the units === "bpm"
   */
  _toType(t) {
    return this.units === "bpm" && this.multiplier ? t / this.multiplier * 60 : super._toType(t);
  }
  /**
   * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.
   */
  get multiplier() {
    return this._multiplier;
  }
  set multiplier(t) {
    const n = this.value;
    this._multiplier = t, this.cancelScheduledValues(0), this.setValueAtTime(n, 0);
  }
}
class zy extends br {
  constructor() {
    const t = Re(zy.getDefaults(), arguments, ["value"]);
    super(t), this.name = "TickSignal", this.input = this._param = new Ly({
      context: this.context,
      convert: t.convert,
      multiplier: t.multiplier,
      param: this._constantSource.offset,
      units: t.units,
      value: t.value
    });
  }
  static getDefaults() {
    return Object.assign(br.getDefaults(), {
      multiplier: 1,
      units: "hertz",
      value: 1
    });
  }
  ticksToTime(t, n) {
    return this._param.ticksToTime(t, n);
  }
  timeToTicks(t, n) {
    return this._param.timeToTicks(t, n);
  }
  getTimeOfTick(t) {
    return this._param.getTimeOfTick(t);
  }
  getDurationOfTicks(t, n) {
    return this._param.getDurationOfTicks(t, n);
  }
  getTicksAtTime(t) {
    return this._param.getTicksAtTime(t);
  }
  /**
   * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.
   */
  get multiplier() {
    return this._param.multiplier;
  }
  set multiplier(t) {
    this._param.multiplier = t;
  }
  dispose() {
    return super.dispose(), this._param.dispose(), this;
  }
}
class Uy extends jr {
  constructor() {
    const t = Re(Uy.getDefaults(), arguments, ["frequency"]);
    super(t), this.name = "TickSource", this._state = new Oh(), this._tickOffset = new Ps(), this._ticksAtTime = new Ps(), this._secondsAtTime = new Ps(), this.frequency = new zy({
      context: this.context,
      units: t.units,
      value: t.frequency
    }), qn(this, "frequency"), this._state.setStateAtTime("stopped", 0), this.setTicksAtTime(0, 0);
  }
  static getDefaults() {
    return Object.assign({
      frequency: 1,
      units: "hertz"
    }, jr.getDefaults());
  }
  /**
   * Returns the playback state of the source, either "started", "stopped" or "paused".
   */
  get state() {
    return this.getStateAtTime(this.now());
  }
  /**
   * Start the clock at the given time. Optionally pass in an offset
   * of where to start the tick counter from.
   * @param  time    The time the clock should start
   * @param offset The number of ticks to start the source at
   */
  start(t, n) {
    const r = this.toSeconds(t);
    return this._state.getValueAtTime(r) !== "started" && (this._state.setStateAtTime("started", r), Be(n) && this.setTicksAtTime(n, r), this._ticksAtTime.cancel(r), this._secondsAtTime.cancel(r)), this;
  }
  /**
   * Stop the clock. Stopping the clock resets the tick counter to 0.
   * @param time The time when the clock should stop.
   */
  stop(t) {
    const n = this.toSeconds(t);
    if (this._state.getValueAtTime(n) === "stopped") {
      const r = this._state.get(n);
      r && r.time > 0 && (this._tickOffset.cancel(r.time), this._state.cancel(r.time));
    }
    return this._state.cancel(n), this._state.setStateAtTime("stopped", n), this.setTicksAtTime(0, n), this._ticksAtTime.cancel(n), this._secondsAtTime.cancel(n), this;
  }
  /**
   * Pause the clock. Pausing does not reset the tick counter.
   * @param time The time when the clock should stop.
   */
  pause(t) {
    const n = this.toSeconds(t);
    return this._state.getValueAtTime(n) === "started" && (this._state.setStateAtTime("paused", n), this._ticksAtTime.cancel(n), this._secondsAtTime.cancel(n)), this;
  }
  /**
   * Cancel start/stop/pause and setTickAtTime events scheduled after the given time.
   * @param time When to clear the events after
   */
  cancel(t) {
    return t = this.toSeconds(t), this._state.cancel(t), this._tickOffset.cancel(t), this._ticksAtTime.cancel(t), this._secondsAtTime.cancel(t), this;
  }
  /**
   * Get the elapsed ticks at the given time
   * @param  time  When to get the tick value
   * @return The number of ticks
   */
  getTicksAtTime(t) {
    const n = this.toSeconds(t), r = this._state.getLastState("stopped", n), i = this._ticksAtTime.get(n), s = {
      state: "paused",
      time: n
    };
    this._state.add(s);
    let l = i || r, c = i ? i.ticks : 0, u = null;
    return this._state.forEachBetween(l.time, n + this.sampleTime, (d) => {
      let h = l.time;
      const p = this._tickOffset.get(d.time);
      p && p.time >= l.time && (c = p.ticks, h = p.time), l.state === "started" && d.state !== "started" && (c += this.frequency.getTicksAtTime(d.time) - this.frequency.getTicksAtTime(h), d.time !== s.time && (u = {
        state: d.state,
        time: d.time,
        ticks: c
      })), l = d;
    }), this._state.remove(s), u && this._ticksAtTime.add(u), c;
  }
  /**
   * The number of times the callback was invoked. Starts counting at 0
   * and increments after the callback was invoked. Returns -1 when stopped.
   */
  get ticks() {
    return this.getTicksAtTime(this.now());
  }
  set ticks(t) {
    this.setTicksAtTime(t, this.now());
  }
  /**
   * The time since ticks=0 that the TickSource has been running. Accounts
   * for tempo curves
   */
  get seconds() {
    return this.getSecondsAtTime(this.now());
  }
  set seconds(t) {
    const n = this.now(), r = this.frequency.timeToTicks(t, n);
    this.setTicksAtTime(r, n);
  }
  /**
   * Return the elapsed seconds at the given time.
   * @param  time  When to get the elapsed seconds
   * @return  The number of elapsed seconds
   */
  getSecondsAtTime(t) {
    t = this.toSeconds(t);
    const n = this._state.getLastState("stopped", t), r = { state: "paused", time: t };
    this._state.add(r);
    const i = this._secondsAtTime.get(t);
    let s = i || n, l = i ? i.seconds : 0, c = null;
    return this._state.forEachBetween(s.time, t + this.sampleTime, (u) => {
      let d = s.time;
      const h = this._tickOffset.get(u.time);
      h && h.time >= s.time && (l = h.seconds, d = h.time), s.state === "started" && u.state !== "started" && (l += u.time - d, u.time !== r.time && (c = {
        state: u.state,
        time: u.time,
        seconds: l
      })), s = u;
    }), this._state.remove(r), c && this._secondsAtTime.add(c), l;
  }
  /**
   * Set the clock's ticks at the given time.
   * @param  ticks The tick value to set
   * @param  time  When to set the tick value
   */
  setTicksAtTime(t, n) {
    return n = this.toSeconds(n), this._tickOffset.cancel(n), this._tickOffset.add({
      seconds: this.frequency.getDurationOfTicks(t, n),
      ticks: t,
      time: n
    }), this._ticksAtTime.cancel(n), this._secondsAtTime.cancel(n), this;
  }
  /**
   * Returns the scheduled state at the given time.
   * @param  time  The time to query.
   */
  getStateAtTime(t) {
    return t = this.toSeconds(t), this._state.getValueAtTime(t);
  }
  /**
   * Get the time of the given tick. The second argument
   * is when to test before. Since ticks can be set (with setTicksAtTime)
   * there may be multiple times for a given tick value.
   * @param  tick The tick number.
   * @param  before When to measure the tick value from.
   * @return The time of the tick
   */
  getTimeOfTick(t, n = this.now()) {
    const r = this._tickOffset.get(n), i = this._state.get(n), s = Math.max(r.time, i.time), l = this.frequency.getTicksAtTime(s) + t - r.ticks;
    return this.frequency.getTimeOfTick(l);
  }
  /**
   * Invoke the callback event at all scheduled ticks between the
   * start time and the end time
   * @param  startTime  The beginning of the search range
   * @param  endTime    The end of the search range
   * @param  callback   The callback to invoke with each tick
   */
  forEachTickBetween(t, n, r) {
    let i = this._state.get(t);
    this._state.forEachBetween(t, n, (l) => {
      i && i.state === "started" && l.state !== "started" && this.forEachTickBetween(Math.max(i.time, t), l.time - this.sampleTime, r), i = l;
    });
    let s = null;
    if (i && i.state === "started") {
      const l = Math.max(i.time, t), c = this.frequency.getTicksAtTime(l), u = this.frequency.getTicksAtTime(i.time), d = c - u;
      let h = Math.ceil(d) - d;
      h = os(h, 1) ? 0 : h;
      let p = this.frequency.getTimeOfTick(c + h);
      for (; p < n; ) {
        try {
          r(p, Math.round(this.getTicksAtTime(p)));
        } catch (v) {
          s = v;
          break;
        }
        p += this.frequency.getDurationOfTicks(1, p);
      }
    }
    if (s)
      throw s;
    return this;
  }
  /**
   * Clean up
   */
  dispose() {
    return super.dispose(), this._state.dispose(), this._tickOffset.dispose(), this._ticksAtTime.dispose(), this._secondsAtTime.dispose(), this.frequency.dispose(), this;
  }
}
class sm extends jr {
  constructor() {
    const t = Re(sm.getDefaults(), arguments, [
      "callback",
      "frequency"
    ]);
    super(t), this.name = "Clock", this.callback = un, this._lastUpdate = 0, this._state = new Oh("stopped"), this._boundLoop = this._loop.bind(this), this.callback = t.callback, this._tickSource = new Uy({
      context: this.context,
      frequency: t.frequency,
      units: t.units
    }), this._lastUpdate = 0, this.frequency = this._tickSource.frequency, qn(this, "frequency"), this._state.setStateAtTime("stopped", 0), this.context.on("tick", this._boundLoop);
  }
  static getDefaults() {
    return Object.assign(jr.getDefaults(), {
      callback: un,
      frequency: 1,
      units: "hertz"
    });
  }
  /**
   * Returns the playback state of the source, either "started", "stopped" or "paused".
   */
  get state() {
    return this._state.getValueAtTime(this.now());
  }
  /**
   * Start the clock at the given time. Optionally pass in an offset
   * of where to start the tick counter from.
   * @param  time    The time the clock should start
   * @param offset  Where the tick counter starts counting from.
   */
  start(t, n) {
    G5(this.context);
    const r = this.toSeconds(t);
    return this.log("start", r), this._state.getValueAtTime(r) !== "started" && (this._state.setStateAtTime("started", r), this._tickSource.start(r, n), r < this._lastUpdate && this.emit("start", r, n)), this;
  }
  /**
   * Stop the clock. Stopping the clock resets the tick counter to 0.
   * @param time The time when the clock should stop.
   * @example
   * const clock = new Tone.Clock(time => {
   * 	console.log(time);
   * }, 1);
   * clock.start();
   * // stop the clock after 10 seconds
   * clock.stop("+10");
   */
  stop(t) {
    const n = this.toSeconds(t);
    return this.log("stop", n), this._state.cancel(n), this._state.setStateAtTime("stopped", n), this._tickSource.stop(n), n < this._lastUpdate && this.emit("stop", n), this;
  }
  /**
   * Pause the clock. Pausing does not reset the tick counter.
   * @param time The time when the clock should stop.
   */
  pause(t) {
    const n = this.toSeconds(t);
    return this._state.getValueAtTime(n) === "started" && (this._state.setStateAtTime("paused", n), this._tickSource.pause(n), n < this._lastUpdate && this.emit("pause", n)), this;
  }
  /**
   * The number of times the callback was invoked. Starts counting at 0
   * and increments after the callback was invoked.
   */
  get ticks() {
    return Math.ceil(this.getTicksAtTime(this.now()));
  }
  set ticks(t) {
    this._tickSource.ticks = t;
  }
  /**
   * The time since ticks=0 that the Clock has been running. Accounts for tempo curves
   */
  get seconds() {
    return this._tickSource.seconds;
  }
  set seconds(t) {
    this._tickSource.seconds = t;
  }
  /**
   * Return the elapsed seconds at the given time.
   * @param  time  When to get the elapsed seconds
   * @return  The number of elapsed seconds
   */
  getSecondsAtTime(t) {
    return this._tickSource.getSecondsAtTime(t);
  }
  /**
   * Set the clock's ticks at the given time.
   * @param  ticks The tick value to set
   * @param  time  When to set the tick value
   */
  setTicksAtTime(t, n) {
    return this._tickSource.setTicksAtTime(t, n), this;
  }
  /**
   * Get the time of the given tick. The second argument
   * is when to test before. Since ticks can be set (with setTicksAtTime)
   * there may be multiple times for a given tick value.
   * @param  tick The tick number.
   * @param  before When to measure the tick value from.
   * @return The time of the tick
   */
  getTimeOfTick(t, n = this.now()) {
    return this._tickSource.getTimeOfTick(t, n);
  }
  /**
   * Get the clock's ticks at the given time.
   * @param  time  When to get the tick value
   * @return The tick value at the given time.
   */
  getTicksAtTime(t) {
    return this._tickSource.getTicksAtTime(t);
  }
  /**
   * Get the time of the next tick
   * @param  offset The tick number.
   */
  nextTickTime(t, n) {
    const r = this.toSeconds(n), i = this.getTicksAtTime(r);
    return this._tickSource.getTimeOfTick(i + t, r);
  }
  /**
   * The scheduling loop.
   */
  _loop() {
    const t = this._lastUpdate, n = this.now();
    this._lastUpdate = n, this.log("loop", t, n), t !== n && (this._state.forEachBetween(t, n, (r) => {
      switch (r.state) {
        case "started":
          const i = this._tickSource.getTicksAtTime(r.time);
          this.emit("start", r.time, i);
          break;
        case "stopped":
          r.time !== 0 && this.emit("stop", r.time);
          break;
        case "paused":
          this.emit("pause", r.time);
          break;
      }
    }), this._tickSource.forEachTickBetween(t, n, (r, i) => {
      this.callback(r, i);
    }));
  }
  /**
   * Returns the scheduled state at the given time.
   * @param  time  The time to query.
   * @return  The name of the state input in setStateAtTime.
   * @example
   * const clock = new Tone.Clock();
   * clock.start("+0.1");
   * clock.getStateAtTime("+0.1"); // returns "started"
   */
  getStateAtTime(t) {
    const n = this.toSeconds(t);
    return this._state.getValueAtTime(n);
  }
  /**
   * Clean up
   */
  dispose() {
    return super.dispose(), this.context.off("tick", this._boundLoop), this._tickSource.dispose(), this._state.dispose(), this;
  }
}
Mh.mixin(sm);
class ou extends qe {
  constructor() {
    const t = Re(ou.getDefaults(), arguments, [
      "volume"
    ]);
    super(t), this.name = "Volume", this.input = this.output = new Lr({
      context: this.context,
      gain: t.volume,
      units: "decibels"
    }), this.volume = this.output.gain, qn(this, "volume"), this._unmutedVolume = t.volume, this.mute = t.mute;
  }
  static getDefaults() {
    return Object.assign(qe.getDefaults(), {
      mute: !1,
      volume: 0
    });
  }
  /**
   * Mute the output.
   * @example
   * const vol = new Tone.Volume(-12).toDestination();
   * const osc = new Tone.Oscillator().connect(vol).start();
   * // mute the output
   * vol.mute = true;
   */
  get mute() {
    return this.volume.value === -1 / 0;
  }
  set mute(t) {
    !this.mute && t ? (this._unmutedVolume = this.volume.value, this.volume.value = -1 / 0) : this.mute && !t && (this.volume.value = this._unmutedVolume);
  }
  /**
   * clean up
   */
  dispose() {
    return super.dispose(), this.input.dispose(), this.volume.dispose(), this;
  }
}
class Vy extends qe {
  constructor() {
    const t = Re(Vy.getDefaults(), arguments);
    super(t), this.name = "Destination", this.input = new ou({ context: this.context }), this.output = new Lr({ context: this.context }), this.volume = this.input.volume, w0(this.input, this.output, this.context.rawContext.destination), this.mute = t.mute, this._internalChannels = [
      this.input,
      this.context.rawContext.destination,
      this.output
    ];
  }
  static getDefaults() {
    return Object.assign(qe.getDefaults(), {
      mute: !1,
      volume: 0
    });
  }
  /**
   * Mute the output.
   * @example
   * const oscillator = new Tone.Oscillator().start().toDestination();
   * setTimeout(() => {
   * 	// mute the output
   * 	Tone.Destination.mute = true;
   * }, 1000);
   */
  get mute() {
    return this.input.mute;
  }
  set mute(t) {
    this.input.mute = t;
  }
  /**
   * Add a master effects chain. NOTE: this will disconnect any nodes which were previously
   * chained in the master effects chain.
   * @param args All arguments will be connected in a row and the Master will be routed through it.
   * @example
   * // route all audio through a filter and compressor
   * const lowpass = new Tone.Filter(800, "lowpass");
   * const compressor = new Tone.Compressor(-18);
   * Tone.Destination.chain(lowpass, compressor);
   */
  chain(...t) {
    return this.input.disconnect(), t.unshift(this.input), t.push(this.output), w0(...t), this;
  }
  /**
   * The maximum number of channels the system can output
   * @example
   * console.log(Tone.Destination.maxChannelCount);
   */
  get maxChannelCount() {
    return this.context.rawContext.destination.maxChannelCount;
  }
  /**
   * Clean up
   */
  dispose() {
    return super.dispose(), this.volume.dispose(), this;
  }
}
nm((e) => {
  e.destination = new Vy({ context: e });
});
rm((e) => {
  e.destination.dispose();
});
class tP extends qe {
  constructor() {
    super(...arguments), this.name = "Listener", this.positionX = new Pn({
      context: this.context,
      param: this.context.rawContext.listener.positionX
    }), this.positionY = new Pn({
      context: this.context,
      param: this.context.rawContext.listener.positionY
    }), this.positionZ = new Pn({
      context: this.context,
      param: this.context.rawContext.listener.positionZ
    }), this.forwardX = new Pn({
      context: this.context,
      param: this.context.rawContext.listener.forwardX
    }), this.forwardY = new Pn({
      context: this.context,
      param: this.context.rawContext.listener.forwardY
    }), this.forwardZ = new Pn({
      context: this.context,
      param: this.context.rawContext.listener.forwardZ
    }), this.upX = new Pn({
      context: this.context,
      param: this.context.rawContext.listener.upX
    }), this.upY = new Pn({
      context: this.context,
      param: this.context.rawContext.listener.upY
    }), this.upZ = new Pn({
      context: this.context,
      param: this.context.rawContext.listener.upZ
    });
  }
  static getDefaults() {
    return Object.assign(qe.getDefaults(), {
      positionX: 0,
      positionY: 0,
      positionZ: 0,
      forwardX: 0,
      forwardY: 0,
      forwardZ: -1,
      upX: 0,
      upY: 1,
      upZ: 0
    });
  }
  dispose() {
    return super.dispose(), this.positionX.dispose(), this.positionY.dispose(), this.positionZ.dispose(), this.forwardX.dispose(), this.forwardY.dispose(), this.forwardZ.dispose(), this.upX.dispose(), this.upY.dispose(), this.upZ.dispose(), this;
  }
}
nm((e) => {
  e.listener = new tP({ context: e });
});
rm((e) => {
  e.listener.dispose();
});
class Gy extends xo {
  constructor() {
    super(), this.name = "ToneAudioBuffers", this._buffers = /* @__PURE__ */ new Map(), this._loadingCount = 0;
    const t = Re(Gy.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls");
    this.baseUrl = t.baseUrl, Object.keys(t.urls).forEach((n) => {
      this._loadingCount++;
      const r = t.urls[n];
      this.add(n, r, this._bufferLoaded.bind(this, t.onload), t.onerror);
    });
  }
  static getDefaults() {
    return {
      baseUrl: "",
      onerror: un,
      onload: un,
      urls: {}
    };
  }
  /**
   * True if the buffers object has a buffer by that name.
   * @param  name  The key or index of the buffer.
   */
  has(t) {
    return this._buffers.has(t.toString());
  }
  /**
   * Get a buffer by name. If an array was loaded,
   * then use the array index.
   * @param  name  The key or index of the buffer.
   */
  get(t) {
    return we(this.has(t), `ToneAudioBuffers has no buffer named: ${t}`), this._buffers.get(t.toString());
  }
  /**
   * A buffer was loaded. decrement the counter.
   */
  _bufferLoaded(t) {
    this._loadingCount--, this._loadingCount === 0 && t && t();
  }
  /**
   * If the buffers are loaded or not
   */
  get loaded() {
    return Array.from(this._buffers).every(([t, n]) => n.loaded);
  }
  /**
   * Add a buffer by name and url to the Buffers
   * @param  name      A unique name to give the buffer
   * @param  url  Either the url of the bufer, or a buffer which will be added with the given name.
   * @param  callback  The callback to invoke when the url is loaded.
   * @param  onerror  Invoked if the buffer can't be loaded
   */
  add(t, n, r = un, i = un) {
    return _o(n) ? (this.baseUrl && n.trim().substring(0, 11).toLowerCase() === "data:audio/" && (this.baseUrl = ""), this._buffers.set(t.toString(), new Sn(this.baseUrl + n, r, i))) : this._buffers.set(t.toString(), new Sn(n, r, i)), this;
  }
  dispose() {
    return super.dispose(), this._buffers.forEach((t) => t.dispose()), this._buffers.clear(), this;
  }
}
class _p extends ei {
  constructor() {
    super(...arguments), this.name = "MidiClass", this.defaultUnits = "midi";
  }
  /**
   * Returns the value of a frequency in the current units
   */
  _frequencyToUnits(t) {
    return ll(super._frequencyToUnits(t));
  }
  /**
   * Returns the value of a tick in the current time units
   */
  _ticksToUnits(t) {
    return ll(super._ticksToUnits(t));
  }
  /**
   * Return the value of the beats in the current units
   */
  _beatsToUnits(t) {
    return ll(super._beatsToUnits(t));
  }
  /**
   * Returns the value of a second in the current units
   */
  _secondsToUnits(t) {
    return ll(super._secondsToUnits(t));
  }
  /**
   * Return the value of the frequency as a MIDI note
   * @example
   * Tone.Midi(60).toMidi(); // 60
   */
  toMidi() {
    return this.valueOf();
  }
  /**
   * Return the value of the frequency as a MIDI note
   * @example
   * Tone.Midi(60).toFrequency(); // 261.6255653005986
   */
  toFrequency() {
    return nx(this.toMidi());
  }
  /**
   * Transposes the frequency by the given number of semitones.
   * @return A new transposed MidiClass
   * @example
   * Tone.Midi("A4").transpose(3); // "C5"
   */
  transpose(t) {
    return new _p(this.context, this.toMidi() + t);
  }
}
class or extends Pc {
  constructor() {
    super(...arguments), this.name = "Ticks", this.defaultUnits = "i";
  }
  /**
   * Get the current time in the given units
   */
  _now() {
    return this.context.transport.ticks;
  }
  /**
   * Return the value of the beats in the current units
   */
  _beatsToUnits(t) {
    return this._getPPQ() * t;
  }
  /**
   * Returns the value of a second in the current units
   */
  _secondsToUnits(t) {
    return Math.floor(t / (60 / this._getBpm()) * this._getPPQ());
  }
  /**
   * Returns the value of a tick in the current time units
   */
  _ticksToUnits(t) {
    return t;
  }
  /**
   * Return the time in ticks
   */
  toTicks() {
    return this.valueOf();
  }
  /**
   * Return the time in seconds
   */
  toSeconds() {
    return this.valueOf() / this._getPPQ() * (60 / this._getBpm());
  }
}
class eP extends jr {
  constructor() {
    super(...arguments), this.name = "Draw", this.expiration = 0.25, this.anticipation = 8e-3, this._events = new Ps(), this._boundDrawLoop = this._drawLoop.bind(this), this._animationFrame = -1;
  }
  /**
   * Schedule a function at the given time to be invoked
   * on the nearest animation frame.
   * @param  callback  Callback is invoked at the given time.
   * @param  time      The time relative to the AudioContext time to invoke the callback.
   * @example
   * Tone.Transport.scheduleRepeat(time => {
   * 	Tone.Draw.schedule(() => console.log(time), time);
   * }, 1);
   * Tone.Transport.start();
   */
  schedule(t, n) {
    return this._events.add({
      callback: t,
      time: this.toSeconds(n)
    }), this._events.length === 1 && (this._animationFrame = requestAnimationFrame(this._boundDrawLoop)), this;
  }
  /**
   * Cancel events scheduled after the given time
   * @param  after  Time after which scheduled events will be removed from the scheduling timeline.
   */
  cancel(t) {
    return this._events.cancel(this.toSeconds(t)), this;
  }
  /**
   * The draw loop
   */
  _drawLoop() {
    const t = this.context.currentTime;
    for (; this._events.length && this._events.peek().time - this.anticipation <= t; ) {
      const n = this._events.shift();
      n && t - n.time <= this.expiration && n.callback();
    }
    this._events.length > 0 && (this._animationFrame = requestAnimationFrame(this._boundDrawLoop));
  }
  dispose() {
    return super.dispose(), this._events.dispose(), cancelAnimationFrame(this._animationFrame), this;
  }
}
nm((e) => {
  e.draw = new eP({ context: e });
});
rm((e) => {
  e.draw.dispose();
});
class nP extends xo {
  constructor() {
    super(...arguments), this.name = "IntervalTimeline", this._root = null, this._length = 0;
  }
  /**
   * The event to add to the timeline. All events must
   * have a time and duration value
   * @param  event  The event to add to the timeline
   */
  add(t) {
    we(Be(t.time), "Events must have a time property"), we(Be(t.duration), "Events must have a duration parameter"), t.time = t.time.valueOf();
    let n = new rP(t.time, t.time + t.duration, t);
    for (this._root === null ? this._root = n : this._root.insert(n), this._length++; n !== null; )
      n.updateHeight(), n.updateMax(), this._rebalance(n), n = n.parent;
    return this;
  }
  /**
   * Remove an event from the timeline.
   * @param  event  The event to remove from the timeline
   */
  remove(t) {
    if (this._root !== null) {
      const n = [];
      this._root.search(t.time, n);
      for (const r of n)
        if (r.event === t) {
          this._removeNode(r), this._length--;
          break;
        }
    }
    return this;
  }
  /**
   * The number of items in the timeline.
   * @readOnly
   */
  get length() {
    return this._length;
  }
  /**
   * Remove events whose time time is after the given time
   * @param  after  The time to query.
   */
  cancel(t) {
    return this.forEachFrom(t, (n) => this.remove(n)), this;
  }
  /**
   * Set the root node as the given node
   */
  _setRoot(t) {
    this._root = t, this._root !== null && (this._root.parent = null);
  }
  /**
   * Replace the references to the node in the node's parent
   * with the replacement node.
   */
  _replaceNodeInParent(t, n) {
    t.parent !== null ? (t.isLeftChild() ? t.parent.left = n : t.parent.right = n, this._rebalance(t.parent)) : this._setRoot(n);
  }
  /**
   * Remove the node from the tree and replace it with
   * a successor which follows the schema.
   */
  _removeNode(t) {
    if (t.left === null && t.right === null)
      this._replaceNodeInParent(t, null);
    else if (t.right === null)
      this._replaceNodeInParent(t, t.left);
    else if (t.left === null)
      this._replaceNodeInParent(t, t.right);
    else {
      const n = t.getBalance();
      let r, i = null;
      if (n > 0)
        if (t.left.right === null)
          r = t.left, r.right = t.right, i = r;
        else {
          for (r = t.left.right; r.right !== null; )
            r = r.right;
          r.parent && (r.parent.right = r.left, i = r.parent, r.left = t.left, r.right = t.right);
        }
      else if (t.right.left === null)
        r = t.right, r.left = t.left, i = r;
      else {
        for (r = t.right.left; r.left !== null; )
          r = r.left;
        r.parent && (r.parent.left = r.right, i = r.parent, r.left = t.left, r.right = t.right);
      }
      t.parent !== null ? t.isLeftChild() ? t.parent.left = r : t.parent.right = r : this._setRoot(r), i && this._rebalance(i);
    }
    t.dispose();
  }
  /**
   * Rotate the tree to the left
   */
  _rotateLeft(t) {
    const n = t.parent, r = t.isLeftChild(), i = t.right;
    i && (t.right = i.left, i.left = t), n !== null ? r ? n.left = i : n.right = i : this._setRoot(i);
  }
  /**
   * Rotate the tree to the right
   */
  _rotateRight(t) {
    const n = t.parent, r = t.isLeftChild(), i = t.left;
    i && (t.left = i.right, i.right = t), n !== null ? r ? n.left = i : n.right = i : this._setRoot(i);
  }
  /**
   * Balance the BST
   */
  _rebalance(t) {
    const n = t.getBalance();
    n > 1 && t.left ? t.left.getBalance() < 0 ? this._rotateLeft(t.left) : this._rotateRight(t) : n < -1 && t.right && (t.right.getBalance() > 0 ? this._rotateRight(t.right) : this._rotateLeft(t));
  }
  /**
   * Get an event whose time and duration span the give time. Will
   * return the match whose "time" value is closest to the given time.
   * @return  The event which spans the desired time
   */
  get(t) {
    if (this._root !== null) {
      const n = [];
      if (this._root.search(t, n), n.length > 0) {
        let r = n[0];
        for (let i = 1; i < n.length; i++)
          n[i].low > r.low && (r = n[i]);
        return r.event;
      }
    }
    return null;
  }
  /**
   * Iterate over everything in the timeline.
   * @param  callback The callback to invoke with every item
   */
  forEach(t) {
    if (this._root !== null) {
      const n = [];
      this._root.traverse((r) => n.push(r)), n.forEach((r) => {
        r.event && t(r.event);
      });
    }
    return this;
  }
  /**
   * Iterate over everything in the array in which the given time
   * overlaps with the time and duration time of the event.
   * @param  time The time to check if items are overlapping
   * @param  callback The callback to invoke with every item
   */
  forEachAtTime(t, n) {
    if (this._root !== null) {
      const r = [];
      this._root.search(t, r), r.forEach((i) => {
        i.event && n(i.event);
      });
    }
    return this;
  }
  /**
   * Iterate over everything in the array in which the time is greater
   * than or equal to the given time.
   * @param  time The time to check if items are before
   * @param  callback The callback to invoke with every item
   */
  forEachFrom(t, n) {
    if (this._root !== null) {
      const r = [];
      this._root.searchAfter(t, r), r.forEach((i) => {
        i.event && n(i.event);
      });
    }
    return this;
  }
  /**
   * Clean up
   */
  dispose() {
    return super.dispose(), this._root !== null && this._root.traverse((t) => t.dispose()), this._root = null, this;
  }
}
class rP {
  constructor(t, n, r) {
    this._left = null, this._right = null, this.parent = null, this.height = 0, this.event = r, this.low = t, this.high = n, this.max = this.high;
  }
  /**
   * Insert a node into the correct spot in the tree
   */
  insert(t) {
    t.low <= this.low ? this.left === null ? this.left = t : this.left.insert(t) : this.right === null ? this.right = t : this.right.insert(t);
  }
  /**
   * Search the tree for nodes which overlap
   * with the given point
   * @param  point  The point to query
   * @param  results  The array to put the results
   */
  search(t, n) {
    t > this.max || (this.left !== null && this.left.search(t, n), this.low <= t && this.high > t && n.push(this), !(this.low > t) && this.right !== null && this.right.search(t, n));
  }
  /**
   * Search the tree for nodes which are less
   * than the given point
   * @param  point  The point to query
   * @param  results  The array to put the results
   */
  searchAfter(t, n) {
    this.low >= t && (n.push(this), this.left !== null && this.left.searchAfter(t, n)), this.right !== null && this.right.searchAfter(t, n);
  }
  /**
   * Invoke the callback on this element and both it's branches
   * @param  {Function}  callback
   */
  traverse(t) {
    t(this), this.left !== null && this.left.traverse(t), this.right !== null && this.right.traverse(t);
  }
  /**
   * Update the height of the node
   */
  updateHeight() {
    this.left !== null && this.right !== null ? this.height = Math.max(this.left.height, this.right.height) + 1 : this.right !== null ? this.height = this.right.height + 1 : this.left !== null ? this.height = this.left.height + 1 : this.height = 0;
  }
  /**
   * Update the height of the node
   */
  updateMax() {
    this.max = this.high, this.left !== null && (this.max = Math.max(this.max, this.left.max)), this.right !== null && (this.max = Math.max(this.max, this.right.max));
  }
  /**
   * The balance is how the leafs are distributed on the node
   * @return  Negative numbers are balanced to the right
   */
  getBalance() {
    let t = 0;
    return this.left !== null && this.right !== null ? t = this.left.height - this.right.height : this.left !== null ? t = this.left.height + 1 : this.right !== null && (t = -(this.right.height + 1)), t;
  }
  /**
   * @returns true if this node is the left child of its parent
   */
  isLeftChild() {
    return this.parent !== null && this.parent.left === this;
  }
  /**
   * get/set the left node
   */
  get left() {
    return this._left;
  }
  set left(t) {
    this._left = t, t !== null && (t.parent = this), this.updateHeight(), this.updateMax();
  }
  /**
   * get/set the right node
   */
  get right() {
    return this._right;
  }
  set right(t) {
    this._right = t, t !== null && (t.parent = this), this.updateHeight(), this.updateMax();
  }
  /**
   * null out references.
   */
  dispose() {
    this.parent = null, this._left = null, this._right = null, this.event = null;
  }
}
class iP extends xo {
  /**
   * @param initialValue The value to return if there is no scheduled values
   */
  constructor(t) {
    super(), this.name = "TimelineValue", this._timeline = new Ps({
      memory: 10
    }), this._initialValue = t;
  }
  /**
   * Set the value at the given time
   */
  set(t, n) {
    return this._timeline.add({
      value: t,
      time: n
    }), this;
  }
  /**
   * Get the value at the given time
   */
  get(t) {
    const n = this._timeline.get(t);
    return n ? n.value : this._initialValue;
  }
}
class Hc extends qe {
  constructor() {
    super(Re(Hc.getDefaults(), arguments, [
      "context"
    ]));
  }
  connect(t, n = 0, r = 0) {
    return jy(this, t, n, r), this;
  }
}
class Nh extends Hc {
  constructor() {
    const t = Re(Nh.getDefaults(), arguments, ["mapping", "length"]);
    super(t), this.name = "WaveShaper", this._shaper = this.context.createWaveShaper(), this.input = this._shaper, this.output = this._shaper, ii(t.mapping) || t.mapping instanceof Float32Array ? this.curve = Float32Array.from(t.mapping) : MN(t.mapping) && this.setMap(t.mapping, t.length);
  }
  static getDefaults() {
    return Object.assign(br.getDefaults(), {
      length: 1024
    });
  }
  /**
   * Uses a mapping function to set the value of the curve.
   * @param mapping The function used to define the values.
   *                The mapping function take two arguments:
   *                the first is the value at the current position
   *                which goes from -1 to 1 over the number of elements
   *                in the curve array. The second argument is the array position.
   * @example
   * const shaper = new Tone.WaveShaper();
   * // map the input signal from [-1, 1] to [0, 10]
   * shaper.setMap((val, index) => (val + 1) * 5);
   */
  setMap(t, n = 1024) {
    const r = new Float32Array(n);
    for (let i = 0, s = n; i < s; i++) {
      const l = i / (s - 1) * 2 - 1;
      r[i] = t(l, i);
    }
    return this.curve = r, this;
  }
  /**
   * The array to set as the waveshaper curve. For linear curves
   * array length does not make much difference, but for complex curves
   * longer arrays will provide smoother interpolation.
   */
  get curve() {
    return this._shaper.curve;
  }
  set curve(t) {
    this._shaper.curve = t;
  }
  /**
   * Specifies what type of oversampling (if any) should be used when
   * applying the shaping curve. Can either be "none", "2x" or "4x".
   */
  get oversample() {
    return this._shaper.oversample;
  }
  set oversample(t) {
    const n = ["none", "2x", "4x"].some((r) => r.includes(t));
    we(n, "oversampling must be either 'none', '2x', or '4x'"), this._shaper.oversample = t;
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this._shaper.disconnect(), this;
  }
}
class qy extends Hc {
  constructor() {
    const t = Re(qy.getDefaults(), arguments, [
      "value"
    ]);
    super(t), this.name = "Pow", this._exponentScaler = this.input = this.output = new Nh({
      context: this.context,
      mapping: this._expFunc(t.value),
      length: 8192
    }), this._exponent = t.value;
  }
  static getDefaults() {
    return Object.assign(Hc.getDefaults(), {
      value: 1
    });
  }
  /**
   * the function which maps the waveshaper
   * @param exponent exponent value
   */
  _expFunc(t) {
    return (n) => Math.pow(Math.abs(n), t);
  }
  /**
   * The value of the exponent.
   */
  get value() {
    return this._exponent;
  }
  set value(t) {
    this._exponent = t, this._exponentScaler.setMap(this._expFunc(this._exponent));
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this._exponentScaler.dispose(), this;
  }
}
class ia {
  /**
   * @param transport The transport object which the event belongs to
   */
  constructor(t, n) {
    this.id = ia._eventId++, this._remainderTime = 0;
    const r = Object.assign(ia.getDefaults(), n);
    this.transport = t, this.callback = r.callback, this._once = r.once, this.time = Math.floor(r.time), this._remainderTime = r.time - this.time;
  }
  static getDefaults() {
    return {
      callback: un,
      once: !1,
      time: 0
    };
  }
  /**
   * Get the time and remainder time.
   */
  get floatTime() {
    return this.time + this._remainderTime;
  }
  /**
   * Invoke the event callback.
   * @param  time  The AudioContext time in seconds of the event
   */
  invoke(t) {
    if (this.callback) {
      const n = this.transport.bpm.getDurationOfTicks(1, t);
      this.callback(t + this._remainderTime * n), this._once && this.transport.clear(this.id);
    }
  }
  /**
   * Clean up
   */
  dispose() {
    return this.callback = void 0, this;
  }
}
ia._eventId = 0;
class Hy extends ia {
  /**
   * @param transport The transport object which the event belongs to
   */
  constructor(t, n) {
    super(t, n), this._currentId = -1, this._nextId = -1, this._nextTick = this.time, this._boundRestart = this._restart.bind(this);
    const r = Object.assign(Hy.getDefaults(), n);
    this.duration = r.duration, this._interval = r.interval, this._nextTick = r.time, this.transport.on("start", this._boundRestart), this.transport.on("loopStart", this._boundRestart), this.transport.on("ticks", this._boundRestart), this.context = this.transport.context, this._restart();
  }
  static getDefaults() {
    return Object.assign({}, ia.getDefaults(), {
      duration: 1 / 0,
      interval: 1,
      once: !1
    });
  }
  /**
   * Invoke the callback. Returns the tick time which
   * the next event should be scheduled at.
   * @param  time  The AudioContext time in seconds of the event
   */
  invoke(t) {
    this._createEvents(t), super.invoke(t);
  }
  /**
   * Create an event on the transport on the nextTick
   */
  _createEvent() {
    return bp(this._nextTick, this.floatTime + this.duration) ? this.transport.scheduleOnce(this.invoke.bind(this), new or(this.context, this._nextTick).toSeconds()) : -1;
  }
  /**
   * Push more events onto the timeline to keep up with the position of the timeline
   */
  _createEvents(t) {
    bp(this._nextTick + this._interval, this.floatTime + this.duration) && (this._nextTick += this._interval, this._currentId = this._nextId, this._nextId = this.transport.scheduleOnce(this.invoke.bind(this), new or(this.context, this._nextTick).toSeconds()));
  }
  /**
   * Re-compute the events when the transport time has changed from a start/ticks/loopStart event
   */
  _restart(t) {
    this.transport.clear(this._currentId), this.transport.clear(this._nextId), this._nextTick = this.floatTime;
    const n = this.transport.getTicksAtTime(t);
    Gc(n, this.time) && (this._nextTick = this.floatTime + Math.ceil((n - this.floatTime) / this._interval) * this._interval), this._currentId = this._createEvent(), this._nextTick += this._interval, this._nextId = this._createEvent();
  }
  /**
   * Clean up
   */
  dispose() {
    return super.dispose(), this.transport.clear(this._currentId), this.transport.clear(this._nextId), this.transport.off("start", this._boundRestart), this.transport.off("loopStart", this._boundRestart), this.transport.off("ticks", this._boundRestart), this;
  }
}
class om extends jr {
  constructor() {
    const t = Re(om.getDefaults(), arguments);
    super(t), this.name = "Transport", this._loop = new iP(!1), this._loopStart = 0, this._loopEnd = 0, this._scheduledEvents = {}, this._timeline = new Ps(), this._repeatedEvents = new nP(), this._syncedSignals = [], this._swingAmount = 0, this._ppq = t.ppq, this._clock = new sm({
      callback: this._processTick.bind(this),
      context: this.context,
      frequency: 0,
      units: "bpm"
    }), this._bindClockEvents(), this.bpm = this._clock.frequency, this._clock.frequency.multiplier = t.ppq, this.bpm.setValueAtTime(t.bpm, 0), qn(this, "bpm"), this._timeSignature = t.timeSignature, this._swingTicks = t.ppq / 2;
  }
  static getDefaults() {
    return Object.assign(jr.getDefaults(), {
      bpm: 120,
      loopEnd: "4m",
      loopStart: 0,
      ppq: 192,
      swing: 0,
      swingSubdivision: "8n",
      timeSignature: 4
    });
  }
  //-------------------------------------
  // 	TICKS
  //-------------------------------------
  /**
   * called on every tick
   * @param  tickTime clock relative tick time
   */
  _processTick(t, n) {
    if (this._loop.get(t) && n >= this._loopEnd && (this.emit("loopEnd", t), this._clock.setTicksAtTime(this._loopStart, t), n = this._loopStart, this.emit("loopStart", t, this._clock.getSecondsAtTime(t)), this.emit("loop", t)), this._swingAmount > 0 && n % this._ppq !== 0 && // not on a downbeat
    n % (this._swingTicks * 2) !== 0) {
      const r = n % (this._swingTicks * 2) / (this._swingTicks * 2), i = Math.sin(r * Math.PI) * this._swingAmount;
      t += new or(this.context, this._swingTicks * 2 / 3).toSeconds() * i;
    }
    n2(!0), this._timeline.forEachAtTime(n, (r) => r.invoke(t)), n2(!1);
  }
  //-------------------------------------
  // 	SCHEDULABLE EVENTS
  //-------------------------------------
  /**
   * Schedule an event along the timeline.
   * @param callback The callback to be invoked at the time.
   * @param time The time to invoke the callback at.
   * @return The id of the event which can be used for canceling the event.
   * @example
   * // schedule an event on the 16th measure
   * Tone.getTransport().schedule((time) => {
   * 	// invoked on measure 16
   * 	console.log("measure 16!");
   * }, "16:0:0");
   */
  schedule(t, n) {
    const r = new ia(this, {
      callback: t,
      time: new Pc(this.context, n).toTicks()
    });
    return this._addEvent(r, this._timeline);
  }
  /**
   * Schedule a repeated event along the timeline. The event will fire
   * at the `interval` starting at the `startTime` and for the specified
   * `duration`.
   * @param  callback   The callback to invoke.
   * @param  interval   The duration between successive callbacks. Must be a positive number.
   * @param  startTime  When along the timeline the events should start being invoked.
   * @param  duration How long the event should repeat.
   * @return  The ID of the scheduled event. Use this to cancel the event.
   * @example
   * const osc = new Tone.Oscillator().toDestination().start();
   * // a callback invoked every eighth note after the first measure
   * Tone.getTransport().scheduleRepeat((time) => {
   * 	osc.start(time).stop(time + 0.1);
   * }, "8n", "1m");
   */
  scheduleRepeat(t, n, r, i = 1 / 0) {
    const s = new Hy(this, {
      callback: t,
      duration: new as(this.context, i).toTicks(),
      interval: new as(this.context, n).toTicks(),
      time: new Pc(this.context, r).toTicks()
    });
    return this._addEvent(s, this._repeatedEvents);
  }
  /**
   * Schedule an event that will be removed after it is invoked.
   * @param callback The callback to invoke once.
   * @param time The time the callback should be invoked.
   * @returns The ID of the scheduled event.
   */
  scheduleOnce(t, n) {
    const r = new ia(this, {
      callback: t,
      once: !0,
      time: new Pc(this.context, n).toTicks()
    });
    return this._addEvent(r, this._timeline);
  }
  /**
   * Clear the passed in event id from the timeline
   * @param eventId The id of the event.
   */
  clear(t) {
    if (this._scheduledEvents.hasOwnProperty(t)) {
      const n = this._scheduledEvents[t.toString()];
      n.timeline.remove(n.event), n.event.dispose(), delete this._scheduledEvents[t.toString()];
    }
    return this;
  }
  /**
   * Add an event to the correct timeline. Keep track of the
   * timeline it was added to.
   * @returns the event id which was just added
   */
  _addEvent(t, n) {
    return this._scheduledEvents[t.id.toString()] = {
      event: t,
      timeline: n
    }, n.add(t), t.id;
  }
  /**
   * Remove scheduled events from the timeline after
   * the given time. Repeated events will be removed
   * if their startTime is after the given time
   * @param after Clear all events after this time.
   */
  cancel(t = 0) {
    const n = this.toTicks(t);
    return this._timeline.forEachFrom(n, (r) => this.clear(r.id)), this._repeatedEvents.forEachFrom(n, (r) => this.clear(r.id)), this;
  }
  //-------------------------------------
  // 	START/STOP/PAUSE
  //-------------------------------------
  /**
   * Bind start/stop/pause events from the clock and emit them.
   */
  _bindClockEvents() {
    this._clock.on("start", (t, n) => {
      n = new or(this.context, n).toSeconds(), this.emit("start", t, n);
    }), this._clock.on("stop", (t) => {
      this.emit("stop", t);
    }), this._clock.on("pause", (t) => {
      this.emit("pause", t);
    });
  }
  /**
   * Returns the playback state of the source, either "started", "stopped", or "paused"
   */
  get state() {
    return this._clock.getStateAtTime(this.now());
  }
  /**
   * Start the transport and all sources synced to the transport.
   * @param  time The time when the transport should start.
   * @param  offset The timeline offset to start the transport.
   * @example
   * // start the transport in one second starting at beginning of the 5th measure.
   * Tone.getTransport().start("+1", "4:0:0");
   */
  start(t, n) {
    this.context.resume();
    let r;
    return Be(n) && (r = this.toTicks(n)), this._clock.start(t, r), this;
  }
  /**
   * Stop the transport and all sources synced to the transport.
   * @param time The time when the transport should stop.
   * @example
   * Tone.getTransport().stop();
   */
  stop(t) {
    return this._clock.stop(t), this;
  }
  /**
   * Pause the transport and all sources synced to the transport.
   */
  pause(t) {
    return this._clock.pause(t), this;
  }
  /**
   * Toggle the current state of the transport. If it is
   * started, it will stop it, otherwise it will start the Transport.
   * @param  time The time of the event
   */
  toggle(t) {
    return t = this.toSeconds(t), this._clock.getStateAtTime(t) !== "started" ? this.start(t) : this.stop(t), this;
  }
  //-------------------------------------
  // 	SETTERS/GETTERS
  //-------------------------------------
  /**
   * The time signature as just the numerator over 4.
   * For example 4/4 would be just 4 and 6/8 would be 3.
   * @example
   * // common time
   * Tone.getTransport().timeSignature = 4;
   * // 7/8
   * Tone.getTransport().timeSignature = [7, 8];
   * // this will be reduced to a single number
   * Tone.getTransport().timeSignature; // returns 3.5
   */
  get timeSignature() {
    return this._timeSignature;
  }
  set timeSignature(t) {
    ii(t) && (t = t[0] / t[1] * 4), this._timeSignature = t;
  }
  /**
   * When the Transport.loop = true, this is the starting position of the loop.
   */
  get loopStart() {
    return new as(this.context, this._loopStart, "i").toSeconds();
  }
  set loopStart(t) {
    this._loopStart = this.toTicks(t);
  }
  /**
   * When the Transport.loop = true, this is the ending position of the loop.
   */
  get loopEnd() {
    return new as(this.context, this._loopEnd, "i").toSeconds();
  }
  set loopEnd(t) {
    this._loopEnd = this.toTicks(t);
  }
  /**
   * If the transport loops or not.
   */
  get loop() {
    return this._loop.get(this.now());
  }
  set loop(t) {
    this._loop.set(t, this.now());
  }
  /**
   * Set the loop start and stop at the same time.
   * @example
   * // loop over the first measure
   * Tone.getTransport().setLoopPoints(0, "1m");
   * Tone.getTransport().loop = true;
   */
  setLoopPoints(t, n) {
    return this.loopStart = t, this.loopEnd = n, this;
  }
  /**
   * The swing value. Between 0-1 where 1 equal to the note + half the subdivision.
   */
  get swing() {
    return this._swingAmount;
  }
  set swing(t) {
    this._swingAmount = t;
  }
  /**
   * Set the subdivision which the swing will be applied to.
   * The default value is an 8th note. Value must be less
   * than a quarter note.
   */
  get swingSubdivision() {
    return new or(this.context, this._swingTicks).toNotation();
  }
  set swingSubdivision(t) {
    this._swingTicks = this.toTicks(t);
  }
  /**
   * The Transport's position in Bars:Beats:Sixteenths.
   * Setting the value will jump to that position right away.
   */
  get position() {
    const t = this.now(), n = this._clock.getTicksAtTime(t);
    return new or(this.context, n).toBarsBeatsSixteenths();
  }
  set position(t) {
    const n = this.toTicks(t);
    this.ticks = n;
  }
  /**
   * The Transport's position in seconds.
   * Setting the value will jump to that position right away.
   */
  get seconds() {
    return this._clock.seconds;
  }
  set seconds(t) {
    const n = this.now(), r = this._clock.frequency.timeToTicks(t, n);
    this.ticks = r;
  }
  /**
   * The Transport's loop position as a normalized value. Always
   * returns 0 if the Transport.loop = false.
   */
  get progress() {
    if (this.loop) {
      const t = this.now();
      return (this._clock.getTicksAtTime(t) - this._loopStart) / (this._loopEnd - this._loopStart);
    } else
      return 0;
  }
  /**
   * The Transport's current tick position.
   */
  get ticks() {
    return this._clock.ticks;
  }
  set ticks(t) {
    if (this._clock.ticks !== t) {
      const n = this.now();
      if (this.state === "started") {
        const r = this._clock.getTicksAtTime(n), i = this._clock.frequency.getDurationOfTicks(Math.ceil(r) - r, n), s = n + i;
        this.emit("stop", s), this._clock.setTicksAtTime(t, s), this.emit("start", s, this._clock.getSecondsAtTime(s));
      } else
        this.emit("ticks", n), this._clock.setTicksAtTime(t, n);
    }
  }
  /**
   * Get the clock's ticks at the given time.
   * @param  time  When to get the tick value
   * @return The tick value at the given time.
   */
  getTicksAtTime(t) {
    return this._clock.getTicksAtTime(t);
  }
  /**
   * Return the elapsed seconds at the given time.
   * @param  time  When to get the elapsed seconds
   * @return  The number of elapsed seconds
   */
  getSecondsAtTime(t) {
    return this._clock.getSecondsAtTime(t);
  }
  /**
   * Pulses Per Quarter note. This is the smallest resolution
   * the Transport timing supports. This should be set once
   * on initialization and not set again. Changing this value
   * after other objects have been created can cause problems.
   */
  get PPQ() {
    return this._clock.frequency.multiplier;
  }
  set PPQ(t) {
    this._clock.frequency.multiplier = t;
  }
  //-------------------------------------
  // 	SYNCING
  //-------------------------------------
  /**
   * Returns the time aligned to the next subdivision
   * of the Transport. If the Transport is not started,
   * it will return 0.
   * Note: this will not work precisely during tempo ramps.
   * @param  subdivision  The subdivision to quantize to
   * @return  The context time of the next subdivision.
   * @example
   * // the transport must be started, otherwise returns 0
   * Tone.getTransport().start();
   * Tone.getTransport().nextSubdivision("4n");
   */
  nextSubdivision(t) {
    if (t = this.toTicks(t), this.state !== "started")
      return 0;
    {
      const n = this.now(), r = this.getTicksAtTime(n), i = t - r % t;
      return this._clock.nextTickTime(i, n);
    }
  }
  /**
   * Attaches the signal to the tempo control signal so that
   * any changes in the tempo will change the signal in the same
   * ratio.
   *
   * @param signal
   * @param ratio Optionally pass in the ratio between the two signals.
   * 			Otherwise it will be computed based on their current values.
   */
  syncSignal(t, n) {
    const r = this.now();
    let i = this.bpm, s = 1 / (60 / i.getValueAtTime(r) / this.PPQ), l = [];
    if (t.units === "time") {
      const u = 0.015625 / s, d = new Lr(u), h = new qy(-1), p = new Lr(u);
      i.chain(d, h, p), i = p, s = 1 / s, l = [d, h, p];
    }
    n || (t.getValueAtTime(r) !== 0 ? n = t.getValueAtTime(r) / s : n = 0);
    const c = new Lr(n);
    return i.connect(c), c.connect(t._param), l.push(c), this._syncedSignals.push({
      initial: t.value,
      nodes: l,
      signal: t
    }), t.value = 0, this;
  }
  /**
   * Unsyncs a previously synced signal from the transport's control.
   * @see {@link syncSignal}.
   */
  unsyncSignal(t) {
    for (let n = this._syncedSignals.length - 1; n >= 0; n--) {
      const r = this._syncedSignals[n];
      r.signal === t && (r.nodes.forEach((i) => i.dispose()), r.signal.value = r.initial, this._syncedSignals.splice(n, 1));
    }
    return this;
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this._clock.dispose(), Q5(this, "bpm"), this._timeline.dispose(), this._repeatedEvents.dispose(), this;
  }
}
Mh.mixin(om);
nm((e) => {
  e.transport = new om({ context: e });
});
rm((e) => {
  e.transport.dispose();
});
class ki extends qe {
  constructor(t) {
    super(t), this.input = void 0, this._state = new Oh("stopped"), this._synced = !1, this._scheduled = [], this._syncedStart = un, this._syncedStop = un, this._state.memory = 100, this._state.increasing = !0, this._volume = this.output = new ou({
      context: this.context,
      mute: t.mute,
      volume: t.volume
    }), this.volume = this._volume.volume, qn(this, "volume"), this.onstop = t.onstop;
  }
  static getDefaults() {
    return Object.assign(qe.getDefaults(), {
      mute: !1,
      onstop: un,
      volume: 0
    });
  }
  /**
   * Returns the playback state of the source, either "started" or "stopped".
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/ahntone_c3.mp3", () => {
   * 	player.start();
   * 	console.log(player.state);
   * }).toDestination();
   */
  get state() {
    return this._synced ? this.context.transport.state === "started" ? this._state.getValueAtTime(this.context.transport.seconds) : "stopped" : this._state.getValueAtTime(this.now());
  }
  /**
   * Mute the output.
   * @example
   * const osc = new Tone.Oscillator().toDestination().start();
   * // mute the output
   * osc.mute = true;
   */
  get mute() {
    return this._volume.mute;
  }
  set mute(t) {
    this._volume.mute = t;
  }
  /**
   * Ensure that the scheduled time is not before the current time.
   * Should only be used when scheduled unsynced.
   */
  _clampToCurrentTime(t) {
    return this._synced ? t : Math.max(t, this.context.currentTime);
  }
  /**
   * Start the source at the specified time. If no time is given,
   * start the source now.
   * @param  time When the source should be started.
   * @example
   * const source = new Tone.Oscillator().toDestination();
   * source.start("+0.5"); // starts the source 0.5 seconds from now
   */
  start(t, n, r) {
    let i = wi(t) && this._synced ? this.context.transport.seconds : this.toSeconds(t);
    if (i = this._clampToCurrentTime(i), !this._synced && this._state.getValueAtTime(i) === "started")
      we(Gc(i, this._state.get(i).time), "Start time must be strictly greater than previous start time"), this._state.cancel(i), this._state.setStateAtTime("started", i), this.log("restart", i), this.restart(i, n, r);
    else if (this.log("start", i), this._state.setStateAtTime("started", i), this._synced) {
      const s = this._state.get(i);
      s && (s.offset = this.toSeconds(Ns(n, 0)), s.duration = r ? this.toSeconds(r) : void 0);
      const l = this.context.transport.schedule((c) => {
        this._start(c, n, r);
      }, i);
      this._scheduled.push(l), this.context.transport.state === "started" && this.context.transport.getSecondsAtTime(this.immediate()) > i && this._syncedStart(this.now(), this.context.transport.seconds);
    } else
      G5(this.context), this._start(i, n, r);
    return this;
  }
  /**
   * Stop the source at the specified time. If no time is given,
   * stop the source now.
   * @param  time When the source should be stopped.
   * @example
   * const source = new Tone.Oscillator().toDestination();
   * source.start();
   * source.stop("+0.5"); // stops the source 0.5 seconds from now
   */
  stop(t) {
    let n = wi(t) && this._synced ? this.context.transport.seconds : this.toSeconds(t);
    if (n = this._clampToCurrentTime(n), this._state.getValueAtTime(n) === "started" || Be(this._state.getNextState("started", n))) {
      if (this.log("stop", n), !this._synced)
        this._stop(n);
      else {
        const r = this.context.transport.schedule(this._stop.bind(this), n);
        this._scheduled.push(r);
      }
      this._state.cancel(n), this._state.setStateAtTime("stopped", n);
    }
    return this;
  }
  /**
   * Restart the source.
   */
  restart(t, n, r) {
    return t = this.toSeconds(t), this._state.getValueAtTime(t) === "started" && (this._state.cancel(t), this._restart(t, n, r)), this;
  }
  /**
   * Sync the source to the Transport so that all subsequent
   * calls to `start` and `stop` are synced to the TransportTime
   * instead of the AudioContext time.
   *
   * @example
   * const osc = new Tone.Oscillator().toDestination();
   * // sync the source so that it plays between 0 and 0.3 on the Transport's timeline
   * osc.sync().start(0).stop(0.3);
   * // start the transport.
   * Tone.Transport.start();
   * // set it to loop once a second
   * Tone.Transport.loop = true;
   * Tone.Transport.loopEnd = 1;
   */
  sync() {
    return this._synced || (this._synced = !0, this._syncedStart = (t, n) => {
      if (Gc(n, 0)) {
        const r = this._state.get(n);
        if (r && r.state === "started" && r.time !== n) {
          const i = n - this.toSeconds(r.time);
          let s;
          r.duration && (s = this.toSeconds(r.duration) - i), this._start(t, this.toSeconds(r.offset) + i, s);
        }
      }
    }, this._syncedStop = (t) => {
      const n = this.context.transport.getSecondsAtTime(Math.max(t - this.sampleTime, 0));
      this._state.getValueAtTime(n) === "started" && this._stop(t);
    }, this.context.transport.on("start", this._syncedStart), this.context.transport.on("loopStart", this._syncedStart), this.context.transport.on("stop", this._syncedStop), this.context.transport.on("pause", this._syncedStop), this.context.transport.on("loopEnd", this._syncedStop)), this;
  }
  /**
   * Unsync the source to the Transport.
   * @see {@link sync}
   */
  unsync() {
    return this._synced && (this.context.transport.off("stop", this._syncedStop), this.context.transport.off("pause", this._syncedStop), this.context.transport.off("loopEnd", this._syncedStop), this.context.transport.off("start", this._syncedStart), this.context.transport.off("loopStart", this._syncedStart)), this._synced = !1, this._scheduled.forEach((t) => this.context.transport.clear(t)), this._scheduled = [], this._state.cancel(0), this._stop(0), this;
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this.onstop = un, this.unsync(), this._volume.dispose(), this._state.dispose(), this;
  }
}
class am extends qc {
  constructor() {
    const t = Re(am.getDefaults(), arguments, ["url", "onload"]);
    super(t), this.name = "ToneBufferSource", this._source = this.context.createBufferSource(), this._internalChannels = [this._source], this._sourceStarted = !1, this._sourceStopped = !1, su(this._source, this._gainNode), this._source.onended = () => this._stopSource(), this.playbackRate = new Pn({
      context: this.context,
      param: this._source.playbackRate,
      units: "positive",
      value: t.playbackRate
    }), this.loop = t.loop, this.loopStart = t.loopStart, this.loopEnd = t.loopEnd, this._buffer = new Sn(t.url, t.onload, t.onerror), this._internalChannels.push(this._source);
  }
  static getDefaults() {
    return Object.assign(qc.getDefaults(), {
      url: new Sn(),
      loop: !1,
      loopEnd: 0,
      loopStart: 0,
      onload: un,
      onerror: un,
      playbackRate: 1
    });
  }
  /**
   * The fadeIn time of the amplitude envelope.
   */
  get fadeIn() {
    return this._fadeIn;
  }
  set fadeIn(t) {
    this._fadeIn = t;
  }
  /**
   * The fadeOut time of the amplitude envelope.
   */
  get fadeOut() {
    return this._fadeOut;
  }
  set fadeOut(t) {
    this._fadeOut = t;
  }
  /**
   * The curve applied to the fades, either "linear" or "exponential"
   */
  get curve() {
    return this._curve;
  }
  set curve(t) {
    this._curve = t;
  }
  /**
   * Start the buffer
   * @param  time When the player should start.
   * @param  offset The offset from the beginning of the sample to start at.
   * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)
   * @param  gain  The gain to play the buffer back at.
   */
  start(t, n, r, i = 1) {
    we(this.buffer.loaded, "buffer is either not set or not loaded");
    const s = this.toSeconds(t);
    this._startGain(s, i), this.loop ? n = Ns(n, this.loopStart) : n = Ns(n, 0);
    let l = Math.max(this.toSeconds(n), 0);
    if (this.loop) {
      const c = this.toSeconds(this.loopEnd) || this.buffer.duration, u = this.toSeconds(this.loopStart), d = c - u;
      C0(l, c) && (l = (l - u) % d + u), os(l, this.buffer.duration) && (l = 0);
    }
    if (this._source.buffer = this.buffer.get(), this._source.loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration, bp(l, this.buffer.duration) && (this._sourceStarted = !0, this._source.start(s, l)), Be(r)) {
      let c = this.toSeconds(r);
      c = Math.max(c, 0), this.stop(s + c);
    }
    return this;
  }
  _stopSource(t) {
    !this._sourceStopped && this._sourceStarted && (this._sourceStopped = !0, this._source.stop(this.toSeconds(t)), this._onended());
  }
  /**
   * If loop is true, the loop will start at this position.
   */
  get loopStart() {
    return this._source.loopStart;
  }
  set loopStart(t) {
    this._source.loopStart = this.toSeconds(t);
  }
  /**
   * If loop is true, the loop will end at this position.
   */
  get loopEnd() {
    return this._source.loopEnd;
  }
  set loopEnd(t) {
    this._source.loopEnd = this.toSeconds(t);
  }
  /**
   * The audio buffer belonging to the player.
   */
  get buffer() {
    return this._buffer;
  }
  set buffer(t) {
    this._buffer.set(t);
  }
  /**
   * If the buffer should loop once it's over.
   */
  get loop() {
    return this._source.loop;
  }
  set loop(t) {
    this._source.loop = t, this._sourceStarted && this.cancelStop();
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this._source.onended = null, this._source.disconnect(), this._buffer.dispose(), this.playbackRate.dispose(), this;
  }
}
function _l(e, t) {
  return nr(this, void 0, void 0, function* () {
    const n = t / e.context.sampleRate, r = new Iy(1, n, e.context.sampleRate);
    return new e.constructor(Object.assign(e.get(), {
      // should do 2 iterations
      frequency: 2 / n,
      // zero out the detune
      detune: 0,
      context: r
    })).toDestination().start(0), (yield r.render()).getChannelData(0);
  });
}
class Wy extends qc {
  constructor() {
    const t = Re(Wy.getDefaults(), arguments, ["frequency", "type"]);
    super(t), this.name = "ToneOscillatorNode", this._oscillator = this.context.createOscillator(), this._internalChannels = [this._oscillator], su(this._oscillator, this._gainNode), this.type = t.type, this.frequency = new Pn({
      context: this.context,
      param: this._oscillator.frequency,
      units: "frequency",
      value: t.frequency
    }), this.detune = new Pn({
      context: this.context,
      param: this._oscillator.detune,
      units: "cents",
      value: t.detune
    }), qn(this, ["frequency", "detune"]);
  }
  static getDefaults() {
    return Object.assign(qc.getDefaults(), {
      detune: 0,
      frequency: 440,
      type: "sine"
    });
  }
  /**
   * Start the oscillator node at the given time
   * @param  time When to start the oscillator
   */
  start(t) {
    const n = this.toSeconds(t);
    return this.log("start", n), this._startGain(n), this._oscillator.start(n), this;
  }
  _stopSource(t) {
    this._oscillator.stop(t);
  }
  /**
   * Sets an arbitrary custom periodic waveform given a PeriodicWave.
   * @param  periodicWave PeriodicWave should be created with context.createPeriodicWave
   */
  setPeriodicWave(t) {
    return this._oscillator.setPeriodicWave(t), this;
  }
  /**
   * The oscillator type. Either 'sine', 'sawtooth', 'square', or 'triangle'
   */
  get type() {
    return this._oscillator.type;
  }
  set type(t) {
    this._oscillator.type = t;
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this.state === "started" && this.stop(), this._oscillator.disconnect(), this.frequency.dispose(), this.detune.dispose(), this;
  }
}
class er extends ki {
  constructor() {
    const t = Re(er.getDefaults(), arguments, ["frequency", "type"]);
    super(t), this.name = "Oscillator", this._oscillator = null, this.frequency = new br({
      context: this.context,
      units: "frequency",
      value: t.frequency
    }), qn(this, "frequency"), this.detune = new br({
      context: this.context,
      units: "cents",
      value: t.detune
    }), qn(this, "detune"), this._partials = t.partials, this._partialCount = t.partialCount, this._type = t.type, t.partialCount && t.type !== "custom" && (this._type = this.baseType + t.partialCount.toString()), this.phase = t.phase;
  }
  static getDefaults() {
    return Object.assign(ki.getDefaults(), {
      detune: 0,
      frequency: 440,
      partialCount: 0,
      partials: [],
      phase: 0,
      type: "sine"
    });
  }
  /**
   * start the oscillator
   */
  _start(t) {
    const n = this.toSeconds(t), r = new Wy({
      context: this.context,
      onended: () => this.onstop(this)
    });
    this._oscillator = r, this._wave ? this._oscillator.setPeriodicWave(this._wave) : this._oscillator.type = this._type, this._oscillator.connect(this.output), this.frequency.connect(this._oscillator.frequency), this.detune.connect(this._oscillator.detune), this._oscillator.start(n);
  }
  /**
   * stop the oscillator
   */
  _stop(t) {
    const n = this.toSeconds(t);
    this._oscillator && this._oscillator.stop(n);
  }
  /**
   * Restart the oscillator. Does not stop the oscillator, but instead
   * just cancels any scheduled 'stop' from being invoked.
   */
  _restart(t) {
    const n = this.toSeconds(t);
    return this.log("restart", n), this._oscillator && this._oscillator.cancelStop(), this._state.cancel(n), this;
  }
  /**
   * Sync the signal to the Transport's bpm. Any changes to the transports bpm,
   * will also affect the oscillators frequency.
   * @example
   * const osc = new Tone.Oscillator().toDestination().start();
   * osc.frequency.value = 440;
   * // the ratio between the bpm and the frequency will be maintained
   * osc.syncFrequency();
   * // double the tempo
   * Tone.Transport.bpm.value *= 2;
   * // the frequency of the oscillator is doubled to 880
   */
  syncFrequency() {
    return this.context.transport.syncSignal(this.frequency), this;
  }
  /**
   * Unsync the oscillator's frequency from the Transport.
   * @see {@link syncFrequency}
   */
  unsyncFrequency() {
    return this.context.transport.unsyncSignal(this.frequency), this;
  }
  /**
   * Get a cached periodic wave. Avoids having to recompute
   * the oscillator values when they have already been computed
   * with the same values.
   */
  _getCachedPeriodicWave() {
    if (this._type === "custom")
      return er._periodicWaveCache.find((n) => n.phase === this._phase && zN(n.partials, this._partials));
    {
      const t = er._periodicWaveCache.find((n) => n.type === this._type && n.phase === this._phase);
      return this._partialCount = t ? t.partialCount : this._partialCount, t;
    }
  }
  get type() {
    return this._type;
  }
  set type(t) {
    this._type = t;
    const n = ["sine", "square", "sawtooth", "triangle"].indexOf(t) !== -1;
    if (this._phase === 0 && n)
      this._wave = void 0, this._partialCount = 0, this._oscillator !== null && (this._oscillator.type = t);
    else {
      const r = this._getCachedPeriodicWave();
      if (Be(r)) {
        const { partials: i, wave: s } = r;
        this._wave = s, this._partials = i, this._oscillator !== null && this._oscillator.setPeriodicWave(this._wave);
      } else {
        const [i, s] = this._getRealImaginary(t, this._phase), l = this.context.createPeriodicWave(i, s);
        this._wave = l, this._oscillator !== null && this._oscillator.setPeriodicWave(this._wave), er._periodicWaveCache.push({
          imag: s,
          partialCount: this._partialCount,
          partials: this._partials,
          phase: this._phase,
          real: i,
          type: this._type,
          wave: this._wave
        }), er._periodicWaveCache.length > 100 && er._periodicWaveCache.shift();
      }
    }
  }
  get baseType() {
    return this._type.replace(this.partialCount.toString(), "");
  }
  set baseType(t) {
    this.partialCount && this._type !== "custom" && t !== "custom" ? this.type = t + this.partialCount : this.type = t;
  }
  get partialCount() {
    return this._partialCount;
  }
  set partialCount(t) {
    ra(t, 0);
    let n = this._type;
    const r = /^(sine|triangle|square|sawtooth)(\d+)$/.exec(this._type);
    if (r && (n = r[1]), this._type !== "custom")
      t === 0 ? this.type = n : this.type = n + t.toString();
    else {
      const i = new Float32Array(t);
      this._partials.forEach((s, l) => i[l] = s), this._partials = Array.from(i), this.type = this._type;
    }
  }
  /**
   * Returns the real and imaginary components based
   * on the oscillator type.
   * @returns [real: Float32Array, imaginary: Float32Array]
   */
  _getRealImaginary(t, n) {
    let i = 2048;
    const s = new Float32Array(i), l = new Float32Array(i);
    let c = 1;
    if (t === "custom") {
      if (c = this._partials.length + 1, this._partialCount = this._partials.length, i = c, this._partials.length === 0)
        return [s, l];
    } else {
      const u = /^(sine|triangle|square|sawtooth)(\d+)$/.exec(t);
      u ? (c = parseInt(u[2], 10) + 1, this._partialCount = parseInt(u[2], 10), t = u[1], c = Math.max(c, 2), i = c) : this._partialCount = 0, this._partials = [];
    }
    for (let u = 1; u < i; ++u) {
      const d = 2 / (u * Math.PI);
      let h;
      switch (t) {
        case "sine":
          h = u <= c ? 1 : 0, this._partials[u - 1] = h;
          break;
        case "square":
          h = u & 1 ? 2 * d : 0, this._partials[u - 1] = h;
          break;
        case "sawtooth":
          h = d * (u & 1 ? 1 : -1), this._partials[u - 1] = h;
          break;
        case "triangle":
          u & 1 ? h = 2 * (d * d) * (u - 1 >> 1 & 1 ? -1 : 1) : h = 0, this._partials[u - 1] = h;
          break;
        case "custom":
          h = this._partials[u - 1];
          break;
        default:
          throw new TypeError("Oscillator: invalid type: " + t);
      }
      h !== 0 ? (s[u] = -h * Math.sin(n * u), l[u] = h * Math.cos(n * u)) : (s[u] = 0, l[u] = 0);
    }
    return [s, l];
  }
  /**
   * Compute the inverse FFT for a given phase.
   */
  _inverseFFT(t, n, r) {
    let i = 0;
    const s = t.length;
    for (let l = 0; l < s; l++)
      i += t[l] * Math.cos(l * r) + n[l] * Math.sin(l * r);
    return i;
  }
  /**
   * Returns the initial value of the oscillator when stopped.
   * E.g. a "sine" oscillator with phase = 90 would return an initial value of -1.
   */
  getInitialValue() {
    const [t, n] = this._getRealImaginary(this._type, 0);
    let r = 0;
    const i = Math.PI * 2, s = 32;
    for (let l = 0; l < s; l++)
      r = Math.max(this._inverseFFT(t, n, l / s * i), r);
    return VN(-this._inverseFFT(t, n, this._phase) / r, -1, 1);
  }
  get partials() {
    return this._partials.slice(0, this.partialCount);
  }
  set partials(t) {
    this._partials = t, this._partialCount = this._partials.length, t.length && (this.type = "custom");
  }
  get phase() {
    return this._phase * (180 / Math.PI);
  }
  set phase(t) {
    this._phase = t * Math.PI / 180, this.type = this._type;
  }
  asArray() {
    return nr(this, arguments, void 0, function* (t = 1024) {
      return _l(this, t);
    });
  }
  dispose() {
    return super.dispose(), this._oscillator !== null && this._oscillator.dispose(), this._wave = void 0, this.frequency.dispose(), this.detune.dispose(), this;
  }
}
er._periodicWaveCache = [];
class sP extends Hc {
  constructor() {
    super(...arguments), this.name = "AudioToGain", this._norm = new Nh({
      context: this.context,
      mapping: (t) => (t + 1) / 2
    }), this.input = this._norm, this.output = this._norm;
  }
  /**
   * clean up
   */
  dispose() {
    return super.dispose(), this._norm.dispose(), this;
  }
}
class Wc extends br {
  constructor() {
    const t = Re(Wc.getDefaults(), arguments, ["value"]);
    super(t), this.name = "Multiply", this.override = !1, this._mult = this.input = this.output = new Lr({
      context: this.context,
      minValue: t.minValue,
      maxValue: t.maxValue
    }), this.factor = this._param = this._mult.gain, this.factor.setValueAtTime(t.value, 0);
  }
  static getDefaults() {
    return Object.assign(br.getDefaults(), {
      value: 0
    });
  }
  dispose() {
    return super.dispose(), this._mult.dispose(), this;
  }
}
class lm extends ki {
  constructor() {
    const t = Re(lm.getDefaults(), arguments, ["frequency", "type", "modulationType"]);
    super(t), this.name = "AMOscillator", this._modulationScale = new sP({ context: this.context }), this._modulationNode = new Lr({
      context: this.context
    }), this._carrier = new er({
      context: this.context,
      detune: t.detune,
      frequency: t.frequency,
      onstop: () => this.onstop(this),
      phase: t.phase,
      type: t.type
    }), this.frequency = this._carrier.frequency, this.detune = this._carrier.detune, this._modulator = new er({
      context: this.context,
      phase: t.phase,
      type: t.modulationType
    }), this.harmonicity = new Wc({
      context: this.context,
      units: "positive",
      value: t.harmonicity
    }), this.frequency.chain(this.harmonicity, this._modulator.frequency), this._modulator.chain(this._modulationScale, this._modulationNode.gain), this._carrier.chain(this._modulationNode, this.output), qn(this, ["frequency", "detune", "harmonicity"]);
  }
  static getDefaults() {
    return Object.assign(er.getDefaults(), {
      harmonicity: 1,
      modulationType: "square"
    });
  }
  /**
   * start the oscillator
   */
  _start(t) {
    this._modulator.start(t), this._carrier.start(t);
  }
  /**
   * stop the oscillator
   */
  _stop(t) {
    this._modulator.stop(t), this._carrier.stop(t);
  }
  _restart(t) {
    this._modulator.restart(t), this._carrier.restart(t);
  }
  /**
   * The type of the carrier oscillator
   */
  get type() {
    return this._carrier.type;
  }
  set type(t) {
    this._carrier.type = t;
  }
  get baseType() {
    return this._carrier.baseType;
  }
  set baseType(t) {
    this._carrier.baseType = t;
  }
  get partialCount() {
    return this._carrier.partialCount;
  }
  set partialCount(t) {
    this._carrier.partialCount = t;
  }
  /**
   * The type of the modulator oscillator
   */
  get modulationType() {
    return this._modulator.type;
  }
  set modulationType(t) {
    this._modulator.type = t;
  }
  get phase() {
    return this._carrier.phase;
  }
  set phase(t) {
    this._carrier.phase = t, this._modulator.phase = t;
  }
  get partials() {
    return this._carrier.partials;
  }
  set partials(t) {
    this._carrier.partials = t;
  }
  asArray() {
    return nr(this, arguments, void 0, function* (t = 1024) {
      return _l(this, t);
    });
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this.frequency.dispose(), this.detune.dispose(), this.harmonicity.dispose(), this._carrier.dispose(), this._modulator.dispose(), this._modulationNode.dispose(), this._modulationScale.dispose(), this;
  }
}
class cm extends ki {
  constructor() {
    const t = Re(cm.getDefaults(), arguments, ["frequency", "type", "modulationType"]);
    super(t), this.name = "FMOscillator", this._modulationNode = new Lr({
      context: this.context,
      gain: 0
    }), this._carrier = new er({
      context: this.context,
      detune: t.detune,
      frequency: 0,
      onstop: () => this.onstop(this),
      phase: t.phase,
      type: t.type
    }), this.detune = this._carrier.detune, this.frequency = new br({
      context: this.context,
      units: "frequency",
      value: t.frequency
    }), this._modulator = new er({
      context: this.context,
      phase: t.phase,
      type: t.modulationType
    }), this.harmonicity = new Wc({
      context: this.context,
      units: "positive",
      value: t.harmonicity
    }), this.modulationIndex = new Wc({
      context: this.context,
      units: "positive",
      value: t.modulationIndex
    }), this.frequency.connect(this._carrier.frequency), this.frequency.chain(this.harmonicity, this._modulator.frequency), this.frequency.chain(this.modulationIndex, this._modulationNode), this._modulator.connect(this._modulationNode.gain), this._modulationNode.connect(this._carrier.frequency), this._carrier.connect(this.output), this.detune.connect(this._modulator.detune), qn(this, [
      "modulationIndex",
      "frequency",
      "detune",
      "harmonicity"
    ]);
  }
  static getDefaults() {
    return Object.assign(er.getDefaults(), {
      harmonicity: 1,
      modulationIndex: 2,
      modulationType: "square"
    });
  }
  /**
   * start the oscillator
   */
  _start(t) {
    this._modulator.start(t), this._carrier.start(t);
  }
  /**
   * stop the oscillator
   */
  _stop(t) {
    this._modulator.stop(t), this._carrier.stop(t);
  }
  _restart(t) {
    return this._modulator.restart(t), this._carrier.restart(t), this;
  }
  get type() {
    return this._carrier.type;
  }
  set type(t) {
    this._carrier.type = t;
  }
  get baseType() {
    return this._carrier.baseType;
  }
  set baseType(t) {
    this._carrier.baseType = t;
  }
  get partialCount() {
    return this._carrier.partialCount;
  }
  set partialCount(t) {
    this._carrier.partialCount = t;
  }
  /**
   * The type of the modulator oscillator
   */
  get modulationType() {
    return this._modulator.type;
  }
  set modulationType(t) {
    this._modulator.type = t;
  }
  get phase() {
    return this._carrier.phase;
  }
  set phase(t) {
    this._carrier.phase = t, this._modulator.phase = t;
  }
  get partials() {
    return this._carrier.partials;
  }
  set partials(t) {
    this._carrier.partials = t;
  }
  asArray() {
    return nr(this, arguments, void 0, function* (t = 1024) {
      return _l(this, t);
    });
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this.frequency.dispose(), this.harmonicity.dispose(), this._carrier.dispose(), this._modulator.dispose(), this._modulationNode.dispose(), this.modulationIndex.dispose(), this;
  }
}
class Ph extends ki {
  constructor() {
    const t = Re(Ph.getDefaults(), arguments, ["frequency", "width"]);
    super(t), this.name = "PulseOscillator", this._widthGate = new Lr({
      context: this.context,
      gain: 0
    }), this._thresh = new Nh({
      context: this.context,
      mapping: (n) => n <= 0 ? -1 : 1
    }), this.width = new br({
      context: this.context,
      units: "audioRange",
      value: t.width
    }), this._triangle = new er({
      context: this.context,
      detune: t.detune,
      frequency: t.frequency,
      onstop: () => this.onstop(this),
      phase: t.phase,
      type: "triangle"
    }), this.frequency = this._triangle.frequency, this.detune = this._triangle.detune, this._triangle.chain(this._thresh, this.output), this.width.chain(this._widthGate, this._thresh), qn(this, ["width", "frequency", "detune"]);
  }
  static getDefaults() {
    return Object.assign(ki.getDefaults(), {
      detune: 0,
      frequency: 440,
      phase: 0,
      type: "pulse",
      width: 0.2
    });
  }
  /**
   * start the oscillator
   */
  _start(t) {
    t = this.toSeconds(t), this._triangle.start(t), this._widthGate.gain.setValueAtTime(1, t);
  }
  /**
   * stop the oscillator
   */
  _stop(t) {
    t = this.toSeconds(t), this._triangle.stop(t), this._widthGate.gain.cancelScheduledValues(t), this._widthGate.gain.setValueAtTime(0, t);
  }
  _restart(t) {
    this._triangle.restart(t), this._widthGate.gain.cancelScheduledValues(t), this._widthGate.gain.setValueAtTime(1, t);
  }
  /**
   * The phase of the oscillator in degrees.
   */
  get phase() {
    return this._triangle.phase;
  }
  set phase(t) {
    this._triangle.phase = t;
  }
  /**
   * The type of the oscillator. Always returns "pulse".
   */
  get type() {
    return "pulse";
  }
  /**
   * The baseType of the oscillator. Always returns "pulse".
   */
  get baseType() {
    return "pulse";
  }
  /**
   * The partials of the waveform. Cannot set partials for this waveform type
   */
  get partials() {
    return [];
  }
  /**
   * No partials for this waveform type.
   */
  get partialCount() {
    return 0;
  }
  /**
   * *Internal use* The carrier oscillator type is fed through the
   * waveshaper node to create the pulse. Using different carrier oscillators
   * changes oscillator's behavior.
   */
  set carrierType(t) {
    this._triangle.type = t;
  }
  asArray() {
    return nr(this, arguments, void 0, function* (t = 1024) {
      return _l(this, t);
    });
  }
  /**
   * Clean up method.
   */
  dispose() {
    return super.dispose(), this._triangle.dispose(), this.width.dispose(), this._widthGate.dispose(), this._thresh.dispose(), this;
  }
}
class um extends ki {
  constructor() {
    const t = Re(um.getDefaults(), arguments, ["frequency", "type", "spread"]);
    super(t), this.name = "FatOscillator", this._oscillators = [], this.frequency = new br({
      context: this.context,
      units: "frequency",
      value: t.frequency
    }), this.detune = new br({
      context: this.context,
      units: "cents",
      value: t.detune
    }), this._spread = t.spread, this._type = t.type, this._phase = t.phase, this._partials = t.partials, this._partialCount = t.partialCount, this.count = t.count, qn(this, ["frequency", "detune"]);
  }
  static getDefaults() {
    return Object.assign(er.getDefaults(), {
      count: 3,
      spread: 20,
      type: "sawtooth"
    });
  }
  /**
   * start the oscillator
   */
  _start(t) {
    t = this.toSeconds(t), this._forEach((n) => n.start(t));
  }
  /**
   * stop the oscillator
   */
  _stop(t) {
    t = this.toSeconds(t), this._forEach((n) => n.stop(t));
  }
  _restart(t) {
    this._forEach((n) => n.restart(t));
  }
  /**
   * Iterate over all of the oscillators
   */
  _forEach(t) {
    for (let n = 0; n < this._oscillators.length; n++)
      t(this._oscillators[n], n);
  }
  /**
   * The type of the oscillator
   */
  get type() {
    return this._type;
  }
  set type(t) {
    this._type = t, this._forEach((n) => n.type = t);
  }
  /**
   * The detune spread between the oscillators. If "count" is
   * set to 3 oscillators and the "spread" is set to 40,
   * the three oscillators would be detuned like this: [-20, 0, 20]
   * for a total detune spread of 40 cents.
   * @example
   * const fatOsc = new Tone.FatOscillator().toDestination().start();
   * fatOsc.spread = 70;
   */
  get spread() {
    return this._spread;
  }
  set spread(t) {
    if (this._spread = t, this._oscillators.length > 1) {
      const n = -t / 2, r = t / (this._oscillators.length - 1);
      this._forEach((i, s) => i.detune.value = n + r * s);
    }
  }
  /**
   * The number of detuned oscillators. Must be an integer greater than 1.
   * @example
   * const fatOsc = new Tone.FatOscillator("C#3", "sawtooth").toDestination().start();
   * // use 4 sawtooth oscillators
   * fatOsc.count = 4;
   */
  get count() {
    return this._oscillators.length;
  }
  set count(t) {
    if (ra(t, 1), this._oscillators.length !== t) {
      this._forEach((n) => n.dispose()), this._oscillators = [];
      for (let n = 0; n < t; n++) {
        const r = new er({
          context: this.context,
          volume: -6 - t * 1.1,
          type: this._type,
          phase: this._phase + n / t * 360,
          partialCount: this._partialCount,
          onstop: n === 0 ? () => this.onstop(this) : un
        });
        this.type === "custom" && (r.partials = this._partials), this.frequency.connect(r.frequency), this.detune.connect(r.detune), r.detune.overridden = !1, r.connect(this.output), this._oscillators[n] = r;
      }
      this.spread = this._spread, this.state === "started" && this._forEach((n) => n.start());
    }
  }
  get phase() {
    return this._phase;
  }
  set phase(t) {
    this._phase = t, this._forEach((n, r) => n.phase = this._phase + r / this.count * 360);
  }
  get baseType() {
    return this._oscillators[0].baseType;
  }
  set baseType(t) {
    this._forEach((n) => n.baseType = t), this._type = this._oscillators[0].type;
  }
  get partials() {
    return this._oscillators[0].partials;
  }
  set partials(t) {
    this._partials = t, this._partialCount = this._partials.length, t.length && (this._type = "custom", this._forEach((n) => n.partials = t));
  }
  get partialCount() {
    return this._oscillators[0].partialCount;
  }
  set partialCount(t) {
    this._partialCount = t, this._forEach((n) => n.partialCount = t), this._type = this._oscillators[0].type;
  }
  asArray() {
    return nr(this, arguments, void 0, function* (t = 1024) {
      return _l(this, t);
    });
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this.frequency.dispose(), this.detune.dispose(), this._forEach((t) => t.dispose()), this;
  }
}
class dm extends ki {
  constructor() {
    const t = Re(dm.getDefaults(), arguments, ["frequency", "modulationFrequency"]);
    super(t), this.name = "PWMOscillator", this.sourceType = "pwm", this._scale = new Wc({
      context: this.context,
      value: 2
    }), this._pulse = new Ph({
      context: this.context,
      frequency: t.modulationFrequency
    }), this._pulse.carrierType = "sine", this.modulationFrequency = this._pulse.frequency, this._modulator = new er({
      context: this.context,
      detune: t.detune,
      frequency: t.frequency,
      onstop: () => this.onstop(this),
      phase: t.phase
    }), this.frequency = this._modulator.frequency, this.detune = this._modulator.detune, this._modulator.chain(this._scale, this._pulse.width), this._pulse.connect(this.output), qn(this, ["modulationFrequency", "frequency", "detune"]);
  }
  static getDefaults() {
    return Object.assign(ki.getDefaults(), {
      detune: 0,
      frequency: 440,
      modulationFrequency: 0.4,
      phase: 0,
      type: "pwm"
    });
  }
  /**
   * start the oscillator
   */
  _start(t) {
    t = this.toSeconds(t), this._modulator.start(t), this._pulse.start(t);
  }
  /**
   * stop the oscillator
   */
  _stop(t) {
    t = this.toSeconds(t), this._modulator.stop(t), this._pulse.stop(t);
  }
  /**
   * restart the oscillator
   */
  _restart(t) {
    this._modulator.restart(t), this._pulse.restart(t);
  }
  /**
   * The type of the oscillator. Always returns "pwm".
   */
  get type() {
    return "pwm";
  }
  /**
   * The baseType of the oscillator. Always returns "pwm".
   */
  get baseType() {
    return "pwm";
  }
  /**
   * The partials of the waveform. Cannot set partials for this waveform type
   */
  get partials() {
    return [];
  }
  /**
   * No partials for this waveform type.
   */
  get partialCount() {
    return 0;
  }
  /**
   * The phase of the oscillator in degrees.
   */
  get phase() {
    return this._modulator.phase;
  }
  set phase(t) {
    this._modulator.phase = t;
  }
  asArray() {
    return nr(this, arguments, void 0, function* (t = 1024) {
      return _l(this, t);
    });
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this._pulse.dispose(), this._scale.dispose(), this._modulator.dispose(), this;
  }
}
const i2 = {
  am: lm,
  fat: um,
  fm: cm,
  oscillator: er,
  pulse: Ph,
  pwm: dm
};
class Sp extends ki {
  constructor() {
    const t = Re(Sp.getDefaults(), arguments, ["frequency", "type"]);
    super(t), this.name = "OmniOscillator", this.frequency = new br({
      context: this.context,
      units: "frequency",
      value: t.frequency
    }), this.detune = new br({
      context: this.context,
      units: "cents",
      value: t.detune
    }), qn(this, ["frequency", "detune"]), this.set(t);
  }
  static getDefaults() {
    return Object.assign(er.getDefaults(), cm.getDefaults(), lm.getDefaults(), um.getDefaults(), Ph.getDefaults(), dm.getDefaults());
  }
  /**
   * start the oscillator
   */
  _start(t) {
    this._oscillator.start(t);
  }
  /**
   * start the oscillator
   */
  _stop(t) {
    this._oscillator.stop(t);
  }
  _restart(t) {
    return this._oscillator.restart(t), this;
  }
  /**
   * The type of the oscillator. Can be any of the basic types: sine, square, triangle, sawtooth. Or
   * prefix the basic types with "fm", "am", or "fat" to use the FMOscillator, AMOscillator or FatOscillator
   * types. The oscillator could also be set to "pwm" or "pulse". All of the parameters of the
   * oscillator's class are accessible when the oscillator is set to that type, but throws an error
   * when it's not.
   * @example
   * const omniOsc = new Tone.OmniOscillator().toDestination().start();
   * omniOsc.type = "pwm";
   * // modulationFrequency is parameter which is available
   * // only when the type is "pwm".
   * omniOsc.modulationFrequency.value = 0.5;
   */
  get type() {
    let t = "";
    return ["am", "fm", "fat"].some((n) => this._sourceType === n) && (t = this._sourceType), t + this._oscillator.type;
  }
  set type(t) {
    t.substr(0, 2) === "fm" ? (this._createNewOscillator("fm"), this._oscillator = this._oscillator, this._oscillator.type = t.substr(2)) : t.substr(0, 2) === "am" ? (this._createNewOscillator("am"), this._oscillator = this._oscillator, this._oscillator.type = t.substr(2)) : t.substr(0, 3) === "fat" ? (this._createNewOscillator("fat"), this._oscillator = this._oscillator, this._oscillator.type = t.substr(3)) : t === "pwm" ? (this._createNewOscillator("pwm"), this._oscillator = this._oscillator) : t === "pulse" ? this._createNewOscillator("pulse") : (this._createNewOscillator("oscillator"), this._oscillator = this._oscillator, this._oscillator.type = t);
  }
  /**
   * The value is an empty array when the type is not "custom".
   * This is not available on "pwm" and "pulse" oscillator types.
   * @see {@link Oscillator.partials}
   */
  get partials() {
    return this._oscillator.partials;
  }
  set partials(t) {
    !this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm") && (this._oscillator.partials = t);
  }
  get partialCount() {
    return this._oscillator.partialCount;
  }
  set partialCount(t) {
    !this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm") && (this._oscillator.partialCount = t);
  }
  set(t) {
    return Reflect.has(t, "type") && t.type && (this.type = t.type), super.set(t), this;
  }
  /**
   * connect the oscillator to the frequency and detune signals
   */
  _createNewOscillator(t) {
    if (t !== this._sourceType) {
      this._sourceType = t;
      const n = i2[t], r = this.now();
      if (this._oscillator) {
        const i = this._oscillator;
        i.stop(r), this.context.setTimeout(() => i.dispose(), this.blockTime);
      }
      this._oscillator = new n({
        context: this.context
      }), this.frequency.connect(this._oscillator.frequency), this.detune.connect(this._oscillator.detune), this._oscillator.connect(this.output), this._oscillator.onstop = () => this.onstop(this), this.state === "started" && this._oscillator.start(r);
    }
  }
  get phase() {
    return this._oscillator.phase;
  }
  set phase(t) {
    this._oscillator.phase = t;
  }
  /**
   * The source type of the oscillator.
   * @example
   * const omniOsc = new Tone.OmniOscillator(440, "fmsquare");
   * console.log(omniOsc.sourceType); // 'fm'
   */
  get sourceType() {
    return this._sourceType;
  }
  set sourceType(t) {
    let n = "sine";
    this._oscillator.type !== "pwm" && this._oscillator.type !== "pulse" && (n = this._oscillator.type), t === "fm" ? this.type = "fm" + n : t === "am" ? this.type = "am" + n : t === "fat" ? this.type = "fat" + n : t === "oscillator" ? this.type = n : t === "pulse" ? this.type = "pulse" : t === "pwm" && (this.type = "pwm");
  }
  _getOscType(t, n) {
    return t instanceof i2[n];
  }
  /**
   * The base type of the oscillator.
   * @see {@link Oscillator.baseType}
   * @example
   * const omniOsc = new Tone.OmniOscillator(440, "fmsquare4");
   * console.log(omniOsc.sourceType, omniOsc.baseType, omniOsc.partialCount);
   */
  get baseType() {
    return this._oscillator.baseType;
  }
  set baseType(t) {
    !this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm") && t !== "pulse" && t !== "pwm" && (this._oscillator.baseType = t);
  }
  /**
   * The width of the oscillator when sourceType === "pulse".
   * @see {@link PWMOscillator}
   */
  get width() {
    if (this._getOscType(this._oscillator, "pulse"))
      return this._oscillator.width;
  }
  /**
   * The number of detuned oscillators when sourceType === "fat".
   * @see {@link FatOscillator.count}
   */
  get count() {
    if (this._getOscType(this._oscillator, "fat"))
      return this._oscillator.count;
  }
  set count(t) {
    this._getOscType(this._oscillator, "fat") && Bs(t) && (this._oscillator.count = t);
  }
  /**
   * The detune spread between the oscillators when sourceType === "fat".
   * @see {@link FatOscillator.count}
   */
  get spread() {
    if (this._getOscType(this._oscillator, "fat"))
      return this._oscillator.spread;
  }
  set spread(t) {
    this._getOscType(this._oscillator, "fat") && Bs(t) && (this._oscillator.spread = t);
  }
  /**
   * The type of the modulator oscillator. Only if the oscillator is set to "am" or "fm" types.
   * @see {@link AMOscillator} or {@link FMOscillator}
   */
  get modulationType() {
    if (this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am"))
      return this._oscillator.modulationType;
  }
  set modulationType(t) {
    (this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am")) && _o(t) && (this._oscillator.modulationType = t);
  }
  /**
   * The modulation index when the sourceType === "fm"
   * @see {@link FMOscillator}.
   */
  get modulationIndex() {
    if (this._getOscType(this._oscillator, "fm"))
      return this._oscillator.modulationIndex;
  }
  /**
   * Harmonicity is the frequency ratio between the carrier and the modulator oscillators.
   * @see {@link AMOscillator} or {@link FMOscillator}
   */
  get harmonicity() {
    if (this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am"))
      return this._oscillator.harmonicity;
  }
  /**
   * The modulationFrequency Signal of the oscillator when sourceType === "pwm"
   * see {@link PWMOscillator}
   * @min 0.1
   * @max 5
   */
  get modulationFrequency() {
    if (this._getOscType(this._oscillator, "pwm"))
      return this._oscillator.modulationFrequency;
  }
  asArray() {
    return nr(this, arguments, void 0, function* (t = 1024) {
      return _l(this, t);
    });
  }
  dispose() {
    return super.dispose(), this.detune.dispose(), this.frequency.dispose(), this._oscillator.dispose(), this;
  }
}
function rx(e, t = 1 / 0) {
  const n = /* @__PURE__ */ new WeakMap();
  return function(r, i) {
    Reflect.defineProperty(r, i, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        return n.get(this);
      },
      set: function(s) {
        ra(s, e, t), n.set(this, s);
      }
    });
  };
}
function To(e, t = 1 / 0) {
  const n = /* @__PURE__ */ new WeakMap();
  return function(r, i) {
    Reflect.defineProperty(r, i, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        return n.get(this);
      },
      set: function(s) {
        ra(this.toSeconds(s), e, t), n.set(this, s);
      }
    });
  };
}
class Dh extends ki {
  constructor() {
    const t = Re(Dh.getDefaults(), arguments, [
      "url",
      "onload"
    ]);
    super(t), this.name = "Player", this._activeSources = /* @__PURE__ */ new Set(), this._buffer = new Sn({
      onload: this._onload.bind(this, t.onload),
      onerror: t.onerror,
      reverse: t.reverse,
      url: t.url
    }), this.autostart = t.autostart, this._loop = t.loop, this._loopStart = t.loopStart, this._loopEnd = t.loopEnd, this._playbackRate = t.playbackRate, this.fadeIn = t.fadeIn, this.fadeOut = t.fadeOut;
  }
  static getDefaults() {
    return Object.assign(ki.getDefaults(), {
      autostart: !1,
      fadeIn: 0,
      fadeOut: 0,
      loop: !1,
      loopEnd: 0,
      loopStart: 0,
      onload: un,
      onerror: un,
      playbackRate: 1,
      reverse: !1
    });
  }
  /**
   * Load the audio file as an audio buffer.
   * Decodes the audio asynchronously and invokes
   * the callback once the audio buffer loads.
   * Note: this does not need to be called if a url
   * was passed in to the constructor. Only use this
   * if you want to manually load a new url.
   * @param url The url of the buffer to load. Filetype support depends on the browser.
   */
  load(t) {
    return nr(this, void 0, void 0, function* () {
      return yield this._buffer.load(t), this._onload(), this;
    });
  }
  /**
   * Internal callback when the buffer is loaded.
   */
  _onload(t = un) {
    t(), this.autostart && this.start();
  }
  /**
   * Internal callback when the buffer is done playing.
   */
  _onSourceEnd(t) {
    this.onstop(this), this._activeSources.delete(t), this._activeSources.size === 0 && !this._synced && this._state.getValueAtTime(this.now()) === "started" && (this._state.cancel(this.now()), this._state.setStateAtTime("stopped", this.now()));
  }
  /**
   * Play the buffer at the given startTime. Optionally add an offset
   * and/or duration which will play the buffer from a position
   * within the buffer for the given duration.
   *
   * @param  time When the player should start.
   * @param  offset The offset from the beginning of the sample to start at.
   * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)
   */
  start(t, n, r) {
    return super.start(t, n, r), this;
  }
  /**
   * Internal start method
   */
  _start(t, n, r) {
    this._loop ? n = Ns(n, this._loopStart) : n = Ns(n, 0);
    const i = this.toSeconds(n), s = r;
    r = Ns(r, Math.max(this._buffer.duration - i, 0));
    let l = this.toSeconds(r);
    l = l / this._playbackRate, t = this.toSeconds(t);
    const c = new am({
      url: this._buffer,
      context: this.context,
      fadeIn: this.fadeIn,
      fadeOut: this.fadeOut,
      loop: this._loop,
      loopEnd: this._loopEnd,
      loopStart: this._loopStart,
      onended: this._onSourceEnd.bind(this),
      playbackRate: this._playbackRate
    }).connect(this.output);
    !this._loop && !this._synced && (this._state.cancel(t + l), this._state.setStateAtTime("stopped", t + l, {
      implicitEnd: !0
    })), this._activeSources.add(c), this._loop && wi(s) ? c.start(t, i) : c.start(t, i, l - this.toSeconds(this.fadeOut));
  }
  /**
   * Stop playback.
   */
  _stop(t) {
    const n = this.toSeconds(t);
    this._activeSources.forEach((r) => r.stop(n));
  }
  /**
   * Stop and then restart the player from the beginning (or offset)
   * @param  time When the player should start.
   * @param  offset The offset from the beginning of the sample to start at.
   * @param  duration How long the sample should play. If no duration is given,
   * 					it will default to the full length of the sample (minus any offset)
   */
  restart(t, n, r) {
    return super.restart(t, n, r), this;
  }
  _restart(t, n, r) {
    var i;
    (i = [...this._activeSources].pop()) === null || i === void 0 || i.stop(t), this._start(t, n, r);
  }
  /**
   * Seek to a specific time in the player's buffer. If the
   * source is no longer playing at that time, it will stop.
   * @param offset The time to seek to.
   * @param when The time for the seek event to occur.
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/gurgling_theremin_1.mp3", () => {
   * 	player.start();
   * 	// seek to the offset in 1 second from now
   * 	player.seek(0.4, "+1");
   * }).toDestination();
   */
  seek(t, n) {
    const r = this.toSeconds(n);
    if (this._state.getValueAtTime(r) === "started") {
      const i = this.toSeconds(t);
      this._stop(r), this._start(r, i);
    }
    return this;
  }
  /**
   * Set the loop start and end. Will only loop if loop is set to true.
   * @param loopStart The loop start time
   * @param loopEnd The loop end time
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/malevoices_aa2_F3.mp3").toDestination();
   * // loop between the given points
   * player.setLoopPoints(0.2, 0.3);
   * player.loop = true;
   * player.autostart = true;
   */
  setLoopPoints(t, n) {
    return this.loopStart = t, this.loopEnd = n, this;
  }
  /**
   * If loop is true, the loop will start at this position.
   */
  get loopStart() {
    return this._loopStart;
  }
  set loopStart(t) {
    this._loopStart = t, this.buffer.loaded && ra(this.toSeconds(t), 0, this.buffer.duration), this._activeSources.forEach((n) => {
      n.loopStart = t;
    });
  }
  /**
   * If loop is true, the loop will end at this position.
   */
  get loopEnd() {
    return this._loopEnd;
  }
  set loopEnd(t) {
    this._loopEnd = t, this.buffer.loaded && ra(this.toSeconds(t), 0, this.buffer.duration), this._activeSources.forEach((n) => {
      n.loopEnd = t;
    });
  }
  /**
   * The audio buffer belonging to the player.
   */
  get buffer() {
    return this._buffer;
  }
  set buffer(t) {
    this._buffer.set(t);
  }
  /**
   * If the buffer should loop once it's over.
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/drum-samples/breakbeat.mp3").toDestination();
   * player.loop = true;
   * player.autostart = true;
   */
  get loop() {
    return this._loop;
  }
  set loop(t) {
    if (this._loop !== t && (this._loop = t, this._activeSources.forEach((n) => {
      n.loop = t;
    }), t)) {
      const n = this._state.getNextState("stopped", this.now());
      n && this._state.cancel(n.time);
    }
  }
  /**
   * Normal speed is 1. The pitch will change with the playback rate.
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/femalevoices_aa2_A5.mp3").toDestination();
   * // play at 1/4 speed
   * player.playbackRate = 0.25;
   * // play as soon as the buffer is loaded
   * player.autostart = true;
   */
  get playbackRate() {
    return this._playbackRate;
  }
  set playbackRate(t) {
    this._playbackRate = t;
    const n = this.now(), r = this._state.getNextState("stopped", n);
    r && r.implicitEnd && (this._state.cancel(r.time), this._activeSources.forEach((i) => i.cancelStop())), this._activeSources.forEach((i) => {
      i.playbackRate.setValueAtTime(t, n);
    });
  }
  /**
   * If the buffer should be reversed. Note that this sets the underlying {@link ToneAudioBuffer.reverse}, so
   * if multiple players are pointing at the same ToneAudioBuffer, they will all be reversed.
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/chime_1.mp3").toDestination();
   * player.autostart = true;
   * player.reverse = true;
   */
  get reverse() {
    return this._buffer.reverse;
  }
  set reverse(t) {
    this._buffer.reverse = t;
  }
  /**
   * If the buffer is loaded
   */
  get loaded() {
    return this._buffer.loaded;
  }
  dispose() {
    return super.dispose(), this._activeSources.forEach((t) => t.dispose()), this._activeSources.clear(), this._buffer.dispose(), this;
  }
}
hs([
  To(0)
], Dh.prototype, "fadeIn", void 0);
hs([
  To(0)
], Dh.prototype, "fadeOut", void 0);
class la extends qe {
  constructor() {
    const t = Re(la.getDefaults(), arguments, ["attack", "decay", "sustain", "release"]);
    super(t), this.name = "Envelope", this._sig = new br({
      context: this.context,
      value: 0
    }), this.output = this._sig, this.input = void 0, this.attack = t.attack, this.decay = t.decay, this.sustain = t.sustain, this.release = t.release, this.attackCurve = t.attackCurve, this.releaseCurve = t.releaseCurve, this.decayCurve = t.decayCurve;
  }
  static getDefaults() {
    return Object.assign(qe.getDefaults(), {
      attack: 0.01,
      attackCurve: "linear",
      decay: 0.1,
      decayCurve: "exponential",
      release: 1,
      releaseCurve: "exponential",
      sustain: 0.5
    });
  }
  /**
   * Read the current value of the envelope. Useful for
   * synchronizing visual output to the envelope.
   */
  get value() {
    return this.getValueAtTime(this.now());
  }
  /**
   * Get the curve
   * @param  curve
   * @param  direction  In/Out
   * @return The curve name
   */
  _getCurve(t, n) {
    if (_o(t))
      return t;
    {
      let r;
      for (r in Bf)
        if (Bf[r][n] === t)
          return r;
      return t;
    }
  }
  /**
   * Assign a the curve to the given name using the direction
   * @param  name
   * @param  direction In/Out
   * @param  curve
   */
  _setCurve(t, n, r) {
    if (_o(r) && Reflect.has(Bf, r)) {
      const i = Bf[r];
      ta(i) ? t !== "_decayCurve" && (this[t] = i[n]) : this[t] = i;
    } else if (ii(r) && t !== "_decayCurve")
      this[t] = r;
    else
      throw new Error("Envelope: invalid curve: " + r);
  }
  /**
   * The shape of the attack.
   * Can be any of these strings:
   * * "linear"
   * * "exponential"
   * * "sine"
   * * "cosine"
   * * "bounce"
   * * "ripple"
   * * "step"
   *
   * Can also be an array which describes the curve. Values
   * in the array are evenly subdivided and linearly
   * interpolated over the duration of the attack.
   * @example
   * return Tone.Offline(() => {
   * 	const env = new Tone.Envelope(0.4).toDestination();
   * 	env.attackCurve = "linear";
   * 	env.triggerAttack();
   * }, 1, 1);
   */
  get attackCurve() {
    return this._getCurve(this._attackCurve, "In");
  }
  set attackCurve(t) {
    this._setCurve("_attackCurve", "In", t);
  }
  /**
   * The shape of the release. See the attack curve types.
   * @example
   * return Tone.Offline(() => {
   * 	const env = new Tone.Envelope({
   * 		release: 0.8
   * 	}).toDestination();
   * 	env.triggerAttack();
   * 	// release curve could also be defined by an array
   * 	env.releaseCurve = [1, 0.3, 0.4, 0.2, 0.7, 0];
   * 	env.triggerRelease(0.2);
   * }, 1, 1);
   */
  get releaseCurve() {
    return this._getCurve(this._releaseCurve, "Out");
  }
  set releaseCurve(t) {
    this._setCurve("_releaseCurve", "Out", t);
  }
  /**
   * The shape of the decay either "linear" or "exponential"
   * @example
   * return Tone.Offline(() => {
   * 	const env = new Tone.Envelope({
   * 		sustain: 0.1,
   * 		decay: 0.5
   * 	}).toDestination();
   * 	env.decayCurve = "linear";
   * 	env.triggerAttack();
   * }, 1, 1);
   */
  get decayCurve() {
    return this._getCurve(this._decayCurve, "Out");
  }
  set decayCurve(t) {
    this._setCurve("_decayCurve", "Out", t);
  }
  /**
   * Trigger the attack/decay portion of the ADSR envelope.
   * @param  time When the attack should start.
   * @param velocity The velocity of the envelope scales the vales.
   *                             number between 0-1
   * @example
   * const env = new Tone.AmplitudeEnvelope().toDestination();
   * const osc = new Tone.Oscillator().connect(env).start();
   * // trigger the attack 0.5 seconds from now with a velocity of 0.2
   * env.triggerAttack("+0.5", 0.2);
   */
  triggerAttack(t, n = 1) {
    this.log("triggerAttack", t, n), t = this.toSeconds(t);
    let i = this.toSeconds(this.attack);
    const s = this.toSeconds(this.decay), l = this.getValueAtTime(t);
    if (l > 0) {
      const c = 1 / i;
      i = (1 - l) / c;
    }
    if (i < this.sampleTime)
      this._sig.cancelScheduledValues(t), this._sig.setValueAtTime(n, t);
    else if (this._attackCurve === "linear")
      this._sig.linearRampTo(n, i, t);
    else if (this._attackCurve === "exponential")
      this._sig.targetRampTo(n, i, t);
    else {
      this._sig.cancelAndHoldAtTime(t);
      let c = this._attackCurve;
      for (let u = 1; u < c.length; u++)
        if (c[u - 1] <= l && l <= c[u]) {
          c = this._attackCurve.slice(u), c[0] = l;
          break;
        }
      this._sig.setValueCurveAtTime(c, t, i, n);
    }
    if (s && this.sustain < 1) {
      const c = n * this.sustain, u = t + i;
      this.log("decay", u), this._decayCurve === "linear" ? this._sig.linearRampToValueAtTime(c, s + u) : this._sig.exponentialApproachValueAtTime(c, u, s);
    }
    return this;
  }
  /**
   * Triggers the release of the envelope.
   * @param  time When the release portion of the envelope should start.
   * @example
   * const env = new Tone.AmplitudeEnvelope().toDestination();
   * const osc = new Tone.Oscillator({
   * 	type: "sawtooth"
   * }).connect(env).start();
   * env.triggerAttack();
   * // trigger the release half a second after the attack
   * env.triggerRelease("+0.5");
   */
  triggerRelease(t) {
    this.log("triggerRelease", t), t = this.toSeconds(t);
    const n = this.getValueAtTime(t);
    if (n > 0) {
      const r = this.toSeconds(this.release);
      r < this.sampleTime ? this._sig.setValueAtTime(0, t) : this._releaseCurve === "linear" ? this._sig.linearRampTo(0, r, t) : this._releaseCurve === "exponential" ? this._sig.targetRampTo(0, r, t) : (we(ii(this._releaseCurve), "releaseCurve must be either 'linear', 'exponential' or an array"), this._sig.cancelAndHoldAtTime(t), this._sig.setValueCurveAtTime(this._releaseCurve, t, r, n));
    }
    return this;
  }
  /**
   * Get the scheduled value at the given time. This will
   * return the unconverted (raw) value.
   * @example
   * const env = new Tone.Envelope(0.5, 1, 0.4, 2);
   * env.triggerAttackRelease(2);
   * setInterval(() => console.log(env.getValueAtTime(Tone.now())), 100);
   */
  getValueAtTime(t) {
    return this._sig.getValueAtTime(t);
  }
  /**
   * triggerAttackRelease is shorthand for triggerAttack, then waiting
   * some duration, then triggerRelease.
   * @param duration The duration of the sustain.
   * @param time When the attack should be triggered.
   * @param velocity The velocity of the envelope.
   * @example
   * const env = new Tone.AmplitudeEnvelope().toDestination();
   * const osc = new Tone.Oscillator().connect(env).start();
   * // trigger the release 0.5 seconds after the attack
   * env.triggerAttackRelease(0.5);
   */
  triggerAttackRelease(t, n, r = 1) {
    return n = this.toSeconds(n), this.triggerAttack(n, r), this.triggerRelease(n + this.toSeconds(t)), this;
  }
  /**
   * Cancels all scheduled envelope changes after the given time.
   */
  cancel(t) {
    return this._sig.cancelScheduledValues(this.toSeconds(t)), this;
  }
  /**
   * Connect the envelope to a destination node.
   */
  connect(t, n = 0, r = 0) {
    return jy(this, t, n, r), this;
  }
  /**
   * Render the envelope curve to an array of the given length.
   * Good for visualizing the envelope curve. Rescales the duration of the
   * envelope to fit the length.
   */
  asArray() {
    return nr(this, arguments, void 0, function* (t = 1024) {
      const n = t / this.context.sampleRate, r = new Iy(1, n, this.context.sampleRate), i = this.toSeconds(this.attack) + this.toSeconds(this.decay), s = i + this.toSeconds(this.release), l = s * 0.1, c = s + l, u = new this.constructor(Object.assign(this.get(), {
        attack: n * this.toSeconds(this.attack) / c,
        decay: n * this.toSeconds(this.decay) / c,
        release: n * this.toSeconds(this.release) / c,
        context: r
      }));
      return u._sig.toDestination(), u.triggerAttackRelease(n * (i + l) / c, 0), (yield r.render()).getChannelData(0);
    });
  }
  dispose() {
    return super.dispose(), this._sig.dispose(), this;
  }
}
hs([
  To(0)
], la.prototype, "attack", void 0);
hs([
  To(0)
], la.prototype, "decay", void 0);
hs([
  rx(0, 1)
], la.prototype, "sustain", void 0);
hs([
  To(0)
], la.prototype, "release", void 0);
const Bf = (() => {
  let t, n;
  const r = [];
  for (t = 0; t < 128; t++)
    r[t] = Math.sin(t / 127 * (Math.PI / 2));
  const i = [], s = 6.4;
  for (t = 0; t < 127; t++) {
    n = t / 127;
    const v = Math.sin(n * (Math.PI * 2) * s - Math.PI / 2) + 1;
    i[t] = v / 10 + n * 0.83;
  }
  i[127] = 1;
  const l = [], c = 5;
  for (t = 0; t < 128; t++)
    l[t] = Math.ceil(t / 127 * c) / c;
  const u = [];
  for (t = 0; t < 128; t++)
    n = t / 127, u[t] = 0.5 * (1 - Math.cos(Math.PI * n));
  const d = [];
  for (t = 0; t < 128; t++) {
    n = t / 127;
    const v = Math.pow(n, 3) * 4 + 0.2, m = Math.cos(v * Math.PI * 2 * n);
    d[t] = Math.abs(m * (1 - n));
  }
  function h(v) {
    const m = new Array(v.length);
    for (let g = 0; g < v.length; g++)
      m[g] = 1 - v[g];
    return m;
  }
  function p(v) {
    return v.slice(0).reverse();
  }
  return {
    bounce: {
      In: h(d),
      Out: d
    },
    cosine: {
      In: r,
      Out: p(r)
    },
    exponential: "exponential",
    linear: "linear",
    ripple: {
      In: i,
      Out: h(i)
    },
    sine: {
      In: u,
      Out: h(u)
    },
    step: {
      In: l,
      Out: h(l)
    }
  };
})();
let $c = class ix extends qe {
  constructor() {
    const t = Re(ix.getDefaults(), arguments);
    super(t), this._scheduledEvents = [], this._synced = !1, this._original_triggerAttack = this.triggerAttack, this._original_triggerRelease = this.triggerRelease, this._syncedRelease = (n) => this._original_triggerRelease(n), this._volume = this.output = new ou({
      context: this.context,
      volume: t.volume
    }), this.volume = this._volume.volume, qn(this, "volume");
  }
  static getDefaults() {
    return Object.assign(qe.getDefaults(), {
      volume: 0
    });
  }
  /**
   * Sync the instrument to the Transport. All subsequent calls of
   * {@link triggerAttack} and {@link triggerRelease} will be scheduled along the transport.
   * @example
   * const fmSynth = new Tone.FMSynth().toDestination();
   * fmSynth.volume.value = -6;
   * fmSynth.sync();
   * // schedule 3 notes when the transport first starts
   * fmSynth.triggerAttackRelease("C4", "8n", 0);
   * fmSynth.triggerAttackRelease("E4", "8n", "8n");
   * fmSynth.triggerAttackRelease("G4", "8n", "4n");
   * // start the transport to hear the notes
   * Tone.Transport.start();
   */
  sync() {
    return this._syncState() && (this._syncMethod("triggerAttack", 1), this._syncMethod("triggerRelease", 0), this.context.transport.on("stop", this._syncedRelease), this.context.transport.on("pause", this._syncedRelease), this.context.transport.on("loopEnd", this._syncedRelease)), this;
  }
  /**
   * set _sync
   */
  _syncState() {
    let t = !1;
    return this._synced || (this._synced = !0, t = !0), t;
  }
  /**
   * Wrap the given method so that it can be synchronized
   * @param method Which method to wrap and sync
   * @param  timePosition What position the time argument appears in
   */
  _syncMethod(t, n) {
    const r = this["_original_" + t] = this[t];
    this[t] = (...i) => {
      const s = i[n], l = this.context.transport.schedule((c) => {
        i[n] = c, r.apply(this, i);
      }, s);
      this._scheduledEvents.push(l);
    };
  }
  /**
   * Unsync the instrument from the Transport
   */
  unsync() {
    return this._scheduledEvents.forEach((t) => this.context.transport.clear(t)), this._scheduledEvents = [], this._synced && (this._synced = !1, this.triggerAttack = this._original_triggerAttack, this.triggerRelease = this._original_triggerRelease, this.context.transport.off("stop", this._syncedRelease), this.context.transport.off("pause", this._syncedRelease), this.context.transport.off("loopEnd", this._syncedRelease)), this;
  }
  /**
   * Trigger the attack and then the release after the duration.
   * @param  note     The note to trigger.
   * @param  duration How long the note should be held for before
   *                         triggering the release. This value must be greater than 0.
   * @param time  When the note should be triggered.
   * @param  velocity The velocity the note should be triggered at.
   * @example
   * const synth = new Tone.Synth().toDestination();
   * // trigger "C4" for the duration of an 8th note
   * synth.triggerAttackRelease("C4", "8n");
   */
  triggerAttackRelease(t, n, r, i) {
    const s = this.toSeconds(r), l = this.toSeconds(n);
    return this.triggerAttack(t, s, i), this.triggerRelease(s + l), this;
  }
  /**
   * clean up
   * @returns {Instrument} this
   */
  dispose() {
    return super.dispose(), this._volume.dispose(), this.unsync(), this._scheduledEvents = [], this;
  }
};
class gl extends $c {
  constructor() {
    const t = Re(gl.getDefaults(), arguments);
    super(t), this.portamento = t.portamento, this.onsilence = t.onsilence;
  }
  static getDefaults() {
    return Object.assign($c.getDefaults(), {
      detune: 0,
      onsilence: un,
      portamento: 0
    });
  }
  /**
   * Trigger the attack of the note optionally with a given velocity.
   * @param  note The note to trigger.
   * @param  time When the note should start.
   * @param  velocity The velocity determines how "loud" the note will be.
   * @example
   * const synth = new Tone.Synth().toDestination();
   * // trigger the note a half second from now at half velocity
   * synth.triggerAttack("C4", "+0.5", 0.5);
   */
  triggerAttack(t, n, r = 1) {
    this.log("triggerAttack", t, n, r);
    const i = this.toSeconds(n);
    return this._triggerEnvelopeAttack(i, r), this.setNote(t, i), this;
  }
  /**
   * Trigger the release portion of the envelope.
   * @param  time If no time is given, the release happens immediately.
   * @example
   * const synth = new Tone.Synth().toDestination();
   * synth.triggerAttack("C4");
   * // trigger the release a second from now
   * synth.triggerRelease("+1");
   */
  triggerRelease(t) {
    this.log("triggerRelease", t);
    const n = this.toSeconds(t);
    return this._triggerEnvelopeRelease(n), this;
  }
  /**
   * Set the note at the given time. If no time is given, the note
   * will set immediately.
   * @param note The note to change to.
   * @param  time The time when the note should be set.
   * @example
   * const synth = new Tone.Synth().toDestination();
   * synth.triggerAttack("C4");
   * // change to F#6 in one quarter note from now.
   * synth.setNote("F#6", "+4n");
   */
  setNote(t, n) {
    const r = this.toSeconds(n), i = t instanceof ei ? t.toFrequency() : t;
    if (this.portamento > 0 && this.getLevelAtTime(r) > 0.05) {
      const s = this.toSeconds(this.portamento);
      this.frequency.exponentialRampTo(i, s, r);
    } else
      this.frequency.setValueAtTime(i, r);
    return this;
  }
}
hs([
  To(0)
], gl.prototype, "portamento", void 0);
class $y extends la {
  constructor() {
    super(Re($y.getDefaults(), arguments, [
      "attack",
      "decay",
      "sustain",
      "release"
    ])), this.name = "AmplitudeEnvelope", this._gainNode = new Lr({
      context: this.context,
      gain: 0
    }), this.output = this._gainNode, this.input = this._gainNode, this._sig.connect(this._gainNode.gain), this.output = this._gainNode, this.input = this._gainNode;
  }
  /**
   * Clean up
   */
  dispose() {
    return super.dispose(), this._gainNode.dispose(), this;
  }
}
class Kc extends gl {
  constructor() {
    const t = Re(Kc.getDefaults(), arguments);
    super(t), this.name = "Synth", this.oscillator = new Sp(Object.assign({
      context: this.context,
      detune: t.detune,
      onstop: () => this.onsilence(this)
    }, t.oscillator)), this.frequency = this.oscillator.frequency, this.detune = this.oscillator.detune, this.envelope = new $y(Object.assign({
      context: this.context
    }, t.envelope)), this.oscillator.chain(this.envelope, this.output), qn(this, ["oscillator", "frequency", "detune", "envelope"]);
  }
  static getDefaults() {
    return Object.assign(gl.getDefaults(), {
      envelope: Object.assign(T0(la.getDefaults(), Object.keys(qe.getDefaults())), {
        attack: 5e-3,
        decay: 0.1,
        release: 1,
        sustain: 0.3
      }),
      oscillator: Object.assign(T0(Sp.getDefaults(), [
        ...Object.keys(ki.getDefaults()),
        "frequency",
        "detune"
      ]), {
        type: "triangle"
      })
    });
  }
  /**
   * start the attack portion of the envelope
   * @param time the time the attack should start
   * @param velocity the velocity of the note (0-1)
   */
  _triggerEnvelopeAttack(t, n) {
    if (this.envelope.triggerAttack(t, n), this.oscillator.start(t), this.envelope.sustain === 0) {
      const r = this.toSeconds(this.envelope.attack), i = this.toSeconds(this.envelope.decay);
      this.oscillator.stop(t + r + i);
    }
  }
  /**
   * start the release portion of the envelope
   * @param time the time the release should start
   */
  _triggerEnvelopeRelease(t) {
    this.envelope.triggerRelease(t), this.oscillator.stop(t + this.toSeconds(this.envelope.release));
  }
  getLevelAtTime(t) {
    return t = this.toSeconds(t), this.envelope.getValueAtTime(t);
  }
  /**
   * clean up
   */
  dispose() {
    return super.dispose(), this.oscillator.dispose(), this.envelope.dispose(), this;
  }
}
class hm extends Kc {
  constructor() {
    const t = Re(hm.getDefaults(), arguments);
    super(t), this.name = "MembraneSynth", this.portamento = 0, this.pitchDecay = t.pitchDecay, this.octaves = t.octaves, qn(this, ["oscillator", "envelope"]);
  }
  static getDefaults() {
    return dl(gl.getDefaults(), Kc.getDefaults(), {
      envelope: {
        attack: 1e-3,
        attackCurve: "exponential",
        decay: 0.4,
        release: 1.4,
        sustain: 0.01
      },
      octaves: 10,
      oscillator: {
        type: "sine"
      },
      pitchDecay: 0.05
    });
  }
  setNote(t, n) {
    const r = this.toSeconds(n), i = this.toFrequency(t instanceof ei ? t.toFrequency() : t), s = i * this.octaves;
    return this.oscillator.frequency.setValueAtTime(s, r), this.oscillator.frequency.exponentialRampToValueAtTime(i, r + this.toSeconds(this.pitchDecay)), this;
  }
  dispose() {
    return super.dispose(), this;
  }
}
hs([
  rx(0)
], hm.prototype, "octaves", void 0);
hs([
  To(0)
], hm.prototype, "pitchDecay", void 0);
const sx = /* @__PURE__ */ new Set();
function Ky(e) {
  sx.add(e);
}
function ox(e, t) {
  const n = (
    /* javascript */
    `registerProcessor("${e}", ${t})`
  );
  sx.add(n);
}
const oP = (
  /* javascript */
  `
	/**
	 * The base AudioWorkletProcessor for use in Tone.js. Works with the {@link ToneAudioWorklet}. 
	 */
	class ToneAudioWorkletProcessor extends AudioWorkletProcessor {

		constructor(options) {
			
			super(options);
			/**
			 * If the processor was disposed or not. Keep alive until it's disposed.
			 */
			this.disposed = false;
		   	/** 
			 * The number of samples in the processing block
			 */
			this.blockSize = 128;
			/**
			 * the sample rate
			 */
			this.sampleRate = sampleRate;

			this.port.onmessage = (event) => {
				// when it receives a dispose 
				if (event.data === "dispose") {
					this.disposed = true;
				}
			};
		}
	}
`
);
Ky(oP);
const aP = (
  /* javascript */
  `
	/**
	 * Abstract class for a single input/output processor. 
	 * has a 'generate' function which processes one sample at a time
	 */
	class SingleIOProcessor extends ToneAudioWorkletProcessor {

		constructor(options) {
			super(Object.assign(options, {
				numberOfInputs: 1,
				numberOfOutputs: 1
			}));
			/**
			 * Holds the name of the parameter and a single value of that
			 * parameter at the current sample
			 * @type { [name: string]: number }
			 */
			this.params = {}
		}

		/**
		 * Generate an output sample from the input sample and parameters
		 * @abstract
		 * @param input number
		 * @param channel number
		 * @param parameters { [name: string]: number }
		 * @returns number
		 */
		generate(){}

		/**
		 * Update the private params object with the 
		 * values of the parameters at the given index
		 * @param parameters { [name: string]: Float32Array },
		 * @param index number
		 */
		updateParams(parameters, index) {
			for (const paramName in parameters) {
				const param = parameters[paramName];
				if (param.length > 1) {
					this.params[paramName] = parameters[paramName][index];
				} else {
					this.params[paramName] = parameters[paramName][0];
				}
			}
		}

		/**
		 * Process a single frame of the audio
		 * @param inputs Float32Array[][]
		 * @param outputs Float32Array[][]
		 */
		process(inputs, outputs, parameters) {
			const input = inputs[0];
			const output = outputs[0];
			// get the parameter values
			const channelCount = Math.max(input && input.length || 0, output.length);
			for (let sample = 0; sample < this.blockSize; sample++) {
				this.updateParams(parameters, sample);
				for (let channel = 0; channel < channelCount; channel++) {
					const inputSample = input && input.length ? input[channel][sample] : 0;
					output[channel][sample] = this.generate(inputSample, channel, this.params);
				}
			}
			return !this.disposed;
		}
	};
`
);
Ky(aP);
const lP = (
  /* javascript */
  `
	/**
	 * A multichannel buffer for use within an AudioWorkletProcessor as a delay line
	 */
	class DelayLine {
		
		constructor(size, channels) {
			this.buffer = [];
			this.writeHead = []
			this.size = size;

			// create the empty channels
			for (let i = 0; i < channels; i++) {
				this.buffer[i] = new Float32Array(this.size);
				this.writeHead[i] = 0;
			}
		}

		/**
		 * Push a value onto the end
		 * @param channel number
		 * @param value number
		 */
		push(channel, value) {
			this.writeHead[channel] += 1;
			if (this.writeHead[channel] > this.size) {
				this.writeHead[channel] = 0;
			}
			this.buffer[channel][this.writeHead[channel]] = value;
		}

		/**
		 * Get the recorded value of the channel given the delay
		 * @param channel number
		 * @param delay number delay samples
		 */
		get(channel, delay) {
			let readHead = this.writeHead[channel] - Math.floor(delay);
			if (readHead < 0) {
				readHead += this.size;
			}
			return this.buffer[channel][readHead];
		}
	}
`
);
Ky(lP);
const cP = "feedback-comb-filter", uP = (
  /* javascript */
  `
	class FeedbackCombFilterWorklet extends SingleIOProcessor {

		constructor(options) {
			super(options);
			this.delayLine = new DelayLine(this.sampleRate, options.channelCount || 2);
		}

		static get parameterDescriptors() {
			return [{
				name: "delayTime",
				defaultValue: 0.1,
				minValue: 0,
				maxValue: 1,
				automationRate: "k-rate"
			}, {
				name: "feedback",
				defaultValue: 0.5,
				minValue: 0,
				maxValue: 0.9999,
				automationRate: "k-rate"
			}];
		}

		generate(input, channel, parameters) {
			const delayedSample = this.delayLine.get(channel, parameters.delayTime * this.sampleRate);
			this.delayLine.push(channel, input + delayedSample * parameters.feedback);
			return delayedSample;
		}
	}
`
);
ox(cP, uP);
class Yy extends $c {
  constructor() {
    const t = Re(Yy.getDefaults(), arguments, ["voice", "options"]);
    super(t), this.name = "PolySynth", this._availableVoices = [], this._activeVoices = [], this._voices = [], this._gcTimeout = -1, this._averageActiveVoices = 0, this._syncedRelease = (i) => this.releaseAll(i), we(!Bs(t.voice), "DEPRECATED: The polyphony count is no longer the first argument.");
    const n = t.voice.getDefaults();
    this.options = Object.assign(n, t.options), this.voice = t.voice, this.maxPolyphony = t.maxPolyphony, this._dummyVoice = this._getNextAvailableVoice();
    const r = this._voices.indexOf(this._dummyVoice);
    this._voices.splice(r, 1), this._gcTimeout = this.context.setInterval(this._collectGarbage.bind(this), 1);
  }
  static getDefaults() {
    return Object.assign($c.getDefaults(), {
      maxPolyphony: 32,
      options: {},
      voice: Kc
    });
  }
  /**
   * The number of active voices.
   */
  get activeVoices() {
    return this._activeVoices.length;
  }
  /**
   * Invoked when the source is done making sound, so that it can be
   * readded to the pool of available voices
   */
  _makeVoiceAvailable(t) {
    this._availableVoices.push(t);
    const n = this._activeVoices.findIndex((r) => r.voice === t);
    this._activeVoices.splice(n, 1);
  }
  /**
   * Get an available voice from the pool of available voices.
   * If one is not available and the maxPolyphony limit is reached,
   * steal a voice, otherwise return null.
   */
  _getNextAvailableVoice() {
    if (this._availableVoices.length)
      return this._availableVoices.shift();
    if (this._voices.length < this.maxPolyphony) {
      const t = new this.voice(Object.assign(this.options, {
        context: this.context,
        onsilence: this._makeVoiceAvailable.bind(this)
      }));
      return we(t instanceof gl, "Voice must extend Monophonic class"), t.connect(this.output), this._voices.push(t), t;
    } else
      em("Max polyphony exceeded. Note dropped.");
  }
  /**
   * Occasionally check if there are any allocated voices which can be cleaned up.
   */
  _collectGarbage() {
    if (this._averageActiveVoices = Math.max(this._averageActiveVoices * 0.95, this.activeVoices), this._availableVoices.length && this._voices.length > Math.ceil(this._averageActiveVoices + 1)) {
      const t = this._availableVoices.shift(), n = this._voices.indexOf(t);
      this._voices.splice(n, 1), this.context.isOffline || t.dispose();
    }
  }
  /**
   * Internal method which triggers the attack
   */
  _triggerAttack(t, n, r) {
    t.forEach((i) => {
      const s = new _p(this.context, i).toMidi(), l = this._getNextAvailableVoice();
      l && (l.triggerAttack(i, n, r), this._activeVoices.push({
        midi: s,
        voice: l,
        released: !1
      }), this.log("triggerAttack", i, n));
    });
  }
  /**
   * Internal method which triggers the release
   */
  _triggerRelease(t, n) {
    t.forEach((r) => {
      const i = new _p(this.context, r).toMidi(), s = this._activeVoices.find(({ midi: l, released: c }) => l === i && !c);
      s && (s.voice.triggerRelease(n), s.released = !0, this.log("triggerRelease", r, n));
    });
  }
  /**
   * Schedule the attack/release events. If the time is in the future, then it should set a timeout
   * to wait for just-in-time scheduling
   */
  _scheduleEvent(t, n, r, i) {
    we(!this.disposed, "Synth was already disposed"), r <= this.now() ? t === "attack" ? this._triggerAttack(n, r, i) : this._triggerRelease(n, r) : this.context.setTimeout(() => {
      this.disposed || this._scheduleEvent(t, n, r, i);
    }, r - this.now());
  }
  /**
   * Trigger the attack portion of the note
   * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.
   * @param  time  The start time of the note.
   * @param velocity The velocity of the note.
   * @example
   * const synth = new Tone.PolySynth(Tone.FMSynth).toDestination();
   * // trigger a chord immediately with a velocity of 0.2
   * synth.triggerAttack(["Ab3", "C4", "F5"], Tone.now(), 0.2);
   */
  triggerAttack(t, n, r) {
    Array.isArray(t) || (t = [t]);
    const i = this.toSeconds(n);
    return this._scheduleEvent("attack", t, i, r), this;
  }
  /**
   * Trigger the release of the note. Unlike monophonic instruments,
   * a note (or array of notes) needs to be passed in as the first argument.
   * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.
   * @param  time  When the release will be triggered.
   * @example
   * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();
   * poly.triggerAttack(["Ab3", "C4", "F5"]);
   * // trigger the release of the given notes.
   * poly.triggerRelease(["Ab3", "C4"], "+1");
   * poly.triggerRelease("F5", "+3");
   */
  triggerRelease(t, n) {
    Array.isArray(t) || (t = [t]);
    const r = this.toSeconds(n);
    return this._scheduleEvent("release", t, r), this;
  }
  /**
   * Trigger the attack and release after the specified duration
   * @param  notes The notes to play. Accepts a single  Frequency or an array of frequencies.
   * @param  duration the duration of the note
   * @param  time  if no time is given, defaults to now
   * @param  velocity the velocity of the attack (0-1)
   * @example
   * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();
   * // can pass in an array of durations as well
   * poly.triggerAttackRelease(["Eb3", "G4", "Bb4", "D5"], [4, 3, 2, 1]);
   */
  triggerAttackRelease(t, n, r, i) {
    const s = this.toSeconds(r);
    if (this.triggerAttack(t, s, i), ii(n)) {
      we(ii(t), "If the duration is an array, the notes must also be an array"), t = t;
      for (let l = 0; l < t.length; l++) {
        const c = n[Math.min(l, n.length - 1)], u = this.toSeconds(c);
        we(u > 0, "The duration must be greater than 0"), this.triggerRelease(t[l], s + u);
      }
    } else {
      const l = this.toSeconds(n);
      we(l > 0, "The duration must be greater than 0"), this.triggerRelease(t, s + l);
    }
    return this;
  }
  sync() {
    return this._syncState() && (this._syncMethod("triggerAttack", 1), this._syncMethod("triggerRelease", 1), this.context.transport.on("stop", this._syncedRelease), this.context.transport.on("pause", this._syncedRelease), this.context.transport.on("loopEnd", this._syncedRelease)), this;
  }
  /**
   * Set a member/attribute of the voices
   * @example
   * const poly = new Tone.PolySynth().toDestination();
   * // set all of the voices using an options object for the synth type
   * poly.set({
   * 	envelope: {
   * 		attack: 0.25
   * 	}
   * });
   * poly.triggerAttackRelease("Bb3", 0.2);
   */
  set(t) {
    const n = T0(t, [
      "onsilence",
      "context"
    ]);
    return this.options = dl(this.options, n), this._voices.forEach((r) => r.set(n)), this._dummyVoice.set(n), this;
  }
  get() {
    return this._dummyVoice.get();
  }
  /**
   * Trigger the release portion of all the currently active voices immediately.
   * Useful for silencing the synth.
   */
  releaseAll(t) {
    const n = this.toSeconds(t);
    return this._activeVoices.forEach(({ voice: r }) => {
      r.triggerRelease(n);
    }), this;
  }
  dispose() {
    return super.dispose(), this._dummyVoice.dispose(), this._voices.forEach((t) => t.dispose()), this._activeVoices = [], this._availableVoices = [], this.context.clearInterval(this._gcTimeout), this;
  }
}
class Ih extends $c {
  constructor() {
    const t = Re(Ih.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls");
    super(t), this.name = "Sampler", this._activeSources = /* @__PURE__ */ new Map();
    const n = {};
    Object.keys(t.urls).forEach((r) => {
      const i = parseInt(r, 10);
      if (we(If(r) || Bs(i) && isFinite(i), `url key is neither a note or midi pitch: ${r}`), If(r)) {
        const s = new ei(this.context, r).toMidi();
        n[s] = t.urls[r];
      } else Bs(i) && isFinite(i) && (n[i] = t.urls[i]);
    }), this._buffers = new Gy({
      urls: n,
      onload: t.onload,
      baseUrl: t.baseUrl,
      onerror: t.onerror
    }), this.attack = t.attack, this.release = t.release, this.curve = t.curve, this._buffers.loaded && Promise.resolve().then(t.onload);
  }
  static getDefaults() {
    return Object.assign($c.getDefaults(), {
      attack: 0,
      baseUrl: "",
      curve: "exponential",
      onload: un,
      onerror: un,
      release: 0.1,
      urls: {}
    });
  }
  /**
   * Returns the difference in steps between the given midi note at the closets sample.
   */
  _findClosest(t) {
    let r = 0;
    for (; r < 96; ) {
      if (this._buffers.has(t + r))
        return -r;
      if (this._buffers.has(t - r))
        return r;
      r++;
    }
    throw new Error(`No available buffers for note: ${t}`);
  }
  /**
   * @param  notes	The note to play, or an array of notes.
   * @param  time     When to play the note
   * @param  velocity The velocity to play the sample back.
   */
  triggerAttack(t, n, r = 1) {
    return this.log("triggerAttack", t, n, r), Array.isArray(t) || (t = [t]), t.forEach((i) => {
      const s = ex(new ei(this.context, i).toFrequency()), l = Math.round(s), c = s - l, u = this._findClosest(l), d = l - u, h = this._buffers.get(d), p = tx(u + c), v = new am({
        url: h,
        context: this.context,
        curve: this.curve,
        fadeIn: this.attack,
        fadeOut: this.release,
        playbackRate: p
      }).connect(this.output);
      v.start(n, 0, h.duration / p, r), ii(this._activeSources.get(l)) || this._activeSources.set(l, []), this._activeSources.get(l).push(v), v.onended = () => {
        if (this._activeSources && this._activeSources.has(l)) {
          const m = this._activeSources.get(l), g = m.indexOf(v);
          g !== -1 && m.splice(g, 1);
        }
      };
    }), this;
  }
  /**
   * @param  notes	The note to release, or an array of notes.
   * @param  time     	When to release the note.
   */
  triggerRelease(t, n) {
    return this.log("triggerRelease", t, n), Array.isArray(t) || (t = [t]), t.forEach((r) => {
      const i = new ei(this.context, r).toMidi();
      if (this._activeSources.has(i) && this._activeSources.get(i).length) {
        const s = this._activeSources.get(i);
        n = this.toSeconds(n), s.forEach((l) => {
          l.stop(n);
        }), this._activeSources.set(i, []);
      }
    }), this;
  }
  /**
   * Release all currently active notes.
   * @param  time     	When to release the notes.
   */
  releaseAll(t) {
    const n = this.toSeconds(t);
    return this._activeSources.forEach((r) => {
      for (; r.length; )
        r.shift().stop(n);
    }), this;
  }
  sync() {
    return this._syncState() && (this._syncMethod("triggerAttack", 1), this._syncMethod("triggerRelease", 1)), this;
  }
  /**
   * Invoke the attack phase, then after the duration, invoke the release.
   * @param  notes	The note to play and release, or an array of notes.
   * @param  duration The time the note should be held
   * @param  time     When to start the attack
   * @param  velocity The velocity of the attack
   */
  triggerAttackRelease(t, n, r, i = 1) {
    const s = this.toSeconds(r);
    return this.triggerAttack(t, s, i), ii(n) ? (we(ii(t), "notes must be an array when duration is array"), t.forEach((l, c) => {
      const u = n[Math.min(c, n.length - 1)];
      this.triggerRelease(l, s + this.toSeconds(u));
    })) : this.triggerRelease(t, s + this.toSeconds(n)), this;
  }
  /**
   * Add a note to the sampler.
   * @param  note      The buffer's pitch.
   * @param  url  Either the url of the buffer, or a buffer which will be added with the given name.
   * @param  callback  The callback to invoke when the url is loaded.
   */
  add(t, n, r) {
    if (we(If(t) || isFinite(t), `note must be a pitch or midi: ${t}`), If(t)) {
      const i = new ei(this.context, t).toMidi();
      this._buffers.add(i, n, r);
    } else
      this._buffers.add(t, n, r);
    return this;
  }
  /**
   * If the buffers are loaded or not
   */
  get loaded() {
    return this._buffers.loaded;
  }
  /**
   * Clean up
   */
  dispose() {
    return super.dispose(), this._buffers.dispose(), this._activeSources.forEach((t) => {
      t.forEach((n) => n.dispose());
    }), this._activeSources.clear(), this;
  }
}
hs([
  To(0)
], Ih.prototype, "attack", void 0);
hs([
  To(0)
], Ih.prototype, "release", void 0);
class Rc extends jr {
  constructor() {
    const t = Re(Rc.getDefaults(), arguments, ["callback", "value"]);
    super(t), this.name = "ToneEvent", this._state = new Oh("stopped"), this._startOffset = 0, this._loop = t.loop, this.callback = t.callback, this.value = t.value, this._loopStart = this.toTicks(t.loopStart), this._loopEnd = this.toTicks(t.loopEnd), this._playbackRate = t.playbackRate, this._probability = t.probability, this._humanize = t.humanize, this.mute = t.mute, this._playbackRate = t.playbackRate, this._state.increasing = !0, this._rescheduleEvents();
  }
  static getDefaults() {
    return Object.assign(jr.getDefaults(), {
      callback: un,
      humanize: !1,
      loop: !1,
      loopEnd: "1m",
      loopStart: 0,
      mute: !1,
      playbackRate: 1,
      probability: 1,
      value: null
    });
  }
  /**
   * Reschedule all of the events along the timeline
   * with the updated values.
   * @param after Only reschedules events after the given time.
   */
  _rescheduleEvents(t = -1) {
    this._state.forEachFrom(t, (n) => {
      let r;
      if (n.state === "started") {
        n.id !== -1 && this.context.transport.clear(n.id);
        const i = n.time + Math.round(this.startOffset / this._playbackRate);
        if (this._loop === !0 || Bs(this._loop) && this._loop > 1) {
          r = 1 / 0, Bs(this._loop) && (r = this._loop * this._getLoopDuration());
          const s = this._state.getAfter(i);
          s !== null && (r = Math.min(r, s.time - i)), r !== 1 / 0 && (r = new or(this.context, r));
          const l = new or(this.context, this._getLoopDuration());
          n.id = this.context.transport.scheduleRepeat(this._tick.bind(this), l, new or(this.context, i), r);
        } else
          n.id = this.context.transport.schedule(this._tick.bind(this), new or(this.context, i));
      }
    });
  }
  /**
   * Returns the playback state of the note, either "started" or "stopped".
   */
  get state() {
    return this._state.getValueAtTime(this.context.transport.ticks);
  }
  /**
   * The start from the scheduled start time.
   */
  get startOffset() {
    return this._startOffset;
  }
  set startOffset(t) {
    this._startOffset = t;
  }
  /**
   * The probability of the notes being triggered.
   */
  get probability() {
    return this._probability;
  }
  set probability(t) {
    this._probability = t;
  }
  /**
   * If set to true, will apply small random variation
   * to the callback time. If the value is given as a time, it will randomize
   * by that amount.
   * @example
   * const event = new Tone.ToneEvent();
   * event.humanize = true;
   */
  get humanize() {
    return this._humanize;
  }
  set humanize(t) {
    this._humanize = t;
  }
  /**
   * Start the note at the given time.
   * @param  time  When the event should start.
   */
  start(t) {
    const n = this.toTicks(t);
    return this._state.getValueAtTime(n) === "stopped" && (this._state.add({
      id: -1,
      state: "started",
      time: n
    }), this._rescheduleEvents(n)), this;
  }
  /**
   * Stop the Event at the given time.
   * @param  time  When the event should stop.
   */
  stop(t) {
    this.cancel(t);
    const n = this.toTicks(t);
    if (this._state.getValueAtTime(n) === "started") {
      this._state.setStateAtTime("stopped", n, { id: -1 });
      const r = this._state.getBefore(n);
      let i = n;
      r !== null && (i = r.time), this._rescheduleEvents(i);
    }
    return this;
  }
  /**
   * Cancel all scheduled events greater than or equal to the given time
   * @param  time  The time after which events will be cancel.
   */
  cancel(t) {
    t = Ns(t, -1 / 0);
    const n = this.toTicks(t);
    return this._state.forEachFrom(n, (r) => {
      this.context.transport.clear(r.id);
    }), this._state.cancel(n), this;
  }
  /**
   * The callback function invoker. Also
   * checks if the Event is done playing
   * @param  time  The time of the event in seconds
   */
  _tick(t) {
    const n = this.context.transport.getTicksAtTime(t);
    if (!this.mute && this._state.getValueAtTime(n) === "started") {
      if (this.probability < 1 && Math.random() > this.probability)
        return;
      if (this.humanize) {
        let r = 0.02;
        V5(this.humanize) || (r = this.toSeconds(this.humanize)), t += (Math.random() * 2 - 1) * r;
      }
      this.callback(t, this.value);
    }
  }
  /**
   * Get the duration of the loop.
   */
  _getLoopDuration() {
    return (this._loopEnd - this._loopStart) / this._playbackRate;
  }
  /**
   * If the note should loop or not
   * between ToneEvent.loopStart and
   * ToneEvent.loopEnd. If set to true,
   * the event will loop indefinitely,
   * if set to a number greater than 1
   * it will play a specific number of
   * times, if set to false, 0 or 1, the
   * part will only play once.
   */
  get loop() {
    return this._loop;
  }
  set loop(t) {
    this._loop = t, this._rescheduleEvents();
  }
  /**
   * The playback rate of the event. Defaults to 1.
   * @example
   * const note = new Tone.ToneEvent();
   * note.loop = true;
   * // repeat the note twice as fast
   * note.playbackRate = 2;
   */
  get playbackRate() {
    return this._playbackRate;
  }
  set playbackRate(t) {
    this._playbackRate = t, this._rescheduleEvents();
  }
  /**
   * The loopEnd point is the time the event will loop
   * if ToneEvent.loop is true.
   */
  get loopEnd() {
    return new or(this.context, this._loopEnd).toSeconds();
  }
  set loopEnd(t) {
    this._loopEnd = this.toTicks(t), this._loop && this._rescheduleEvents();
  }
  /**
   * The time when the loop should start.
   */
  get loopStart() {
    return new or(this.context, this._loopStart).toSeconds();
  }
  set loopStart(t) {
    this._loopStart = this.toTicks(t), this._loop && this._rescheduleEvents();
  }
  /**
   * The current progress of the loop interval.
   * Returns 0 if the event is not started yet or
   * it is not set to loop.
   */
  get progress() {
    if (this._loop) {
      const t = this.context.transport.ticks, n = this._state.get(t);
      if (n !== null && n.state === "started") {
        const r = this._getLoopDuration();
        return (t - n.time) % r / r;
      } else
        return 0;
    } else
      return 0;
  }
  dispose() {
    return super.dispose(), this.cancel(), this._state.dispose(), this;
  }
}
class xp extends Rc {
  constructor() {
    const t = Re(xp.getDefaults(), arguments, [
      "callback",
      "events"
    ]);
    super(t), this.name = "Part", this._state = new Oh("stopped"), this._events = /* @__PURE__ */ new Set(), this._state.increasing = !0, t.events.forEach((n) => {
      ii(n) ? this.add(n[0], n[1]) : this.add(n);
    });
  }
  static getDefaults() {
    return Object.assign(Rc.getDefaults(), {
      events: []
    });
  }
  /**
   * Start the part at the given time.
   * @param  time    When to start the part.
   * @param  offset  The offset from the start of the part to begin playing at.
   */
  start(t, n) {
    const r = this.toTicks(t);
    if (this._state.getValueAtTime(r) !== "started") {
      n = Ns(n, this._loop ? this._loopStart : 0), this._loop ? n = Ns(n, this._loopStart) : n = Ns(n, 0);
      const i = this.toTicks(n);
      this._state.add({
        id: -1,
        offset: i,
        state: "started",
        time: r
      }), this._forEach((s) => {
        this._startNote(s, r, i);
      });
    }
    return this;
  }
  /**
   * Start the event in the given event at the correct time given
   * the ticks and offset and looping.
   * @param  event
   * @param  ticks
   * @param  offset
   */
  _startNote(t, n, r) {
    n -= r, this._loop ? t.startOffset >= this._loopStart && t.startOffset < this._loopEnd ? (t.startOffset < r && (n += this._getLoopDuration()), t.start(new or(this.context, n))) : t.startOffset < this._loopStart && t.startOffset >= r && (t.loop = !1, t.start(new or(this.context, n))) : t.startOffset >= r && t.start(new or(this.context, n));
  }
  get startOffset() {
    return this._startOffset;
  }
  set startOffset(t) {
    this._startOffset = t, this._forEach((n) => {
      n.startOffset += this._startOffset;
    });
  }
  /**
   * Stop the part at the given time.
   * @param  time  When to stop the part.
   */
  stop(t) {
    const n = this.toTicks(t);
    return this._state.cancel(n), this._state.setStateAtTime("stopped", n), this._forEach((r) => {
      r.stop(t);
    }), this;
  }
  /**
   * Get/Set an Event's value at the given time.
   * If a value is passed in and no event exists at
   * the given time, one will be created with that value.
   * If two events are at the same time, the first one will
   * be returned.
   * @example
   * const part = new Tone.Part();
   * part.at("1m"); // returns the part at the first measure
   * part.at("2m", "C2"); // set the value at "2m" to C2.
   * // if an event didn't exist at that time, it will be created.
   * @param time The time of the event to get or set.
   * @param value If a value is passed in, the value of the event at the given time will be set to it.
   */
  at(t, n) {
    const r = new Pc(this.context, t).toTicks(), i = new or(this.context, 1).toSeconds(), s = this._events.values();
    let l = s.next();
    for (; !l.done; ) {
      const c = l.value;
      if (Math.abs(r - c.startOffset) < i)
        return Be(n) && (c.value = n), c;
      l = s.next();
    }
    return Be(n) ? (this.add(t, n), this.at(t)) : null;
  }
  add(t, n) {
    t instanceof Object && Reflect.has(t, "time") && (n = t, t = n.time);
    const r = this.toTicks(t);
    let i;
    return n instanceof Rc ? (i = n, i.callback = this._tick.bind(this)) : i = new Rc({
      callback: this._tick.bind(this),
      context: this.context,
      value: n
    }), i.startOffset = r, i.set({
      humanize: this.humanize,
      loop: this.loop,
      loopEnd: this.loopEnd,
      loopStart: this.loopStart,
      playbackRate: this.playbackRate,
      probability: this.probability
    }), this._events.add(i), this._restartEvent(i), this;
  }
  /**
   * Restart the given event
   */
  _restartEvent(t) {
    this._state.forEach((n) => {
      n.state === "started" ? this._startNote(t, n.time, n.offset) : t.stop(new or(this.context, n.time));
    });
  }
  remove(t, n) {
    return ta(t) && t.hasOwnProperty("time") && (n = t, t = n.time), t = this.toTicks(t), this._events.forEach((r) => {
      r.startOffset === t && (wi(n) || Be(n) && r.value === n) && (this._events.delete(r), r.dispose());
    }), this;
  }
  /**
   * Remove all of the notes from the group.
   */
  clear() {
    return this._forEach((t) => t.dispose()), this._events.clear(), this;
  }
  /**
   * Cancel scheduled state change events: i.e. "start" and "stop".
   * @param after The time after which to cancel the scheduled events.
   */
  cancel(t) {
    return this._forEach((n) => n.cancel(t)), this._state.cancel(this.toTicks(t)), this;
  }
  /**
   * Iterate over all of the events
   */
  _forEach(t) {
    return this._events && this._events.forEach((n) => {
      n instanceof xp ? n._forEach(t) : t(n);
    }), this;
  }
  /**
   * Set the attribute of all of the events
   * @param  attr  the attribute to set
   * @param  value      The value to set it to
   */
  _setAll(t, n) {
    this._forEach((r) => {
      r[t] = n;
    });
  }
  /**
   * Internal tick method
   * @param  time  The time of the event in seconds
   */
  _tick(t, n) {
    this.mute || this.callback(t, n);
  }
  /**
   * Determine if the event should be currently looping
   * given the loop boundries of this Part.
   * @param  event  The event to test
   */
  _testLoopBoundries(t) {
    this._loop && (t.startOffset < this._loopStart || t.startOffset >= this._loopEnd) ? t.cancel(0) : t.state === "stopped" && this._restartEvent(t);
  }
  get probability() {
    return this._probability;
  }
  set probability(t) {
    this._probability = t, this._setAll("probability", t);
  }
  get humanize() {
    return this._humanize;
  }
  set humanize(t) {
    this._humanize = t, this._setAll("humanize", t);
  }
  /**
   * If the part should loop or not
   * between Part.loopStart and
   * Part.loopEnd. If set to true,
   * the part will loop indefinitely,
   * if set to a number greater than 1
   * it will play a specific number of
   * times, if set to false, 0 or 1, the
   * part will only play once.
   * @example
   * const part = new Tone.Part();
   * // loop the part 8 times
   * part.loop = 8;
   */
  get loop() {
    return this._loop;
  }
  set loop(t) {
    this._loop = t, this._forEach((n) => {
      n.loopStart = this.loopStart, n.loopEnd = this.loopEnd, n.loop = t, this._testLoopBoundries(n);
    });
  }
  /**
   * The loopEnd point determines when it will
   * loop if Part.loop is true.
   */
  get loopEnd() {
    return new or(this.context, this._loopEnd).toSeconds();
  }
  set loopEnd(t) {
    this._loopEnd = this.toTicks(t), this._loop && this._forEach((n) => {
      n.loopEnd = t, this._testLoopBoundries(n);
    });
  }
  /**
   * The loopStart point determines when it will
   * loop if Part.loop is true.
   */
  get loopStart() {
    return new or(this.context, this._loopStart).toSeconds();
  }
  set loopStart(t) {
    this._loopStart = this.toTicks(t), this._loop && this._forEach((n) => {
      n.loopStart = this.loopStart, this._testLoopBoundries(n);
    });
  }
  /**
   * The playback rate of the part
   */
  get playbackRate() {
    return this._playbackRate;
  }
  set playbackRate(t) {
    this._playbackRate = t, this._setAll("playbackRate", t);
  }
  /**
   * The number of scheduled notes in the part.
   */
  get length() {
    return this._events.size;
  }
  dispose() {
    return super.dispose(), this.clear(), this;
  }
}
class Xy extends qe {
  constructor() {
    const t = Re(Xy.getDefaults(), arguments, [
      "pan"
    ]);
    super(t), this.name = "Panner", this._panner = this.context.createStereoPanner(), this.input = this._panner, this.output = this._panner, this.pan = new Pn({
      context: this.context,
      param: this._panner.pan,
      value: t.pan,
      minValue: -1,
      maxValue: 1
    }), this._panner.channelCount = t.channelCount, this._panner.channelCountMode = "explicit", qn(this, "pan");
  }
  static getDefaults() {
    return Object.assign(qe.getDefaults(), {
      pan: 0,
      channelCount: 1
    });
  }
  dispose() {
    return super.dispose(), this._panner.disconnect(), this.pan.dispose(), this;
  }
}
const dP = "bit-crusher", hP = (
  /* javascript */
  `
	class BitCrusherWorklet extends SingleIOProcessor {

		static get parameterDescriptors() {
			return [{
				name: "bits",
				defaultValue: 12,
				minValue: 1,
				maxValue: 16,
				automationRate: 'k-rate'
			}];
		}

		generate(input, _channel, parameters) {
			const step = Math.pow(0.5, parameters.bits - 1);
			const val = step * Math.floor(input / step + 0.5);
			return val;
		}
	}
`
);
ox(dP, hP);
class Jn extends qe {
  constructor() {
    const t = Re(Jn.getDefaults(), arguments, [
      "solo"
    ]);
    super(t), this.name = "Solo", this.input = this.output = new Lr({
      context: this.context
    }), Jn._allSolos.has(this.context) || Jn._allSolos.set(this.context, /* @__PURE__ */ new Set()), Jn._allSolos.get(this.context).add(this), this.solo = t.solo;
  }
  static getDefaults() {
    return Object.assign(qe.getDefaults(), {
      solo: !1
    });
  }
  /**
   * Isolates this instance and mutes all other instances of Solo.
   * Only one instance can be soloed at a time. A soloed
   * instance will report `solo=false` when another instance is soloed.
   */
  get solo() {
    return this._isSoloed();
  }
  set solo(t) {
    t ? this._addSolo() : this._removeSolo(), Jn._allSolos.get(this.context).forEach((n) => n._updateSolo());
  }
  /**
   * If the current instance is muted, i.e. another instance is soloed
   */
  get muted() {
    return this.input.gain.value === 0;
  }
  /**
   * Add this to the soloed array
   */
  _addSolo() {
    Jn._soloed.has(this.context) || Jn._soloed.set(this.context, /* @__PURE__ */ new Set()), Jn._soloed.get(this.context).add(this);
  }
  /**
   * Remove this from the soloed array
   */
  _removeSolo() {
    Jn._soloed.has(this.context) && Jn._soloed.get(this.context).delete(this);
  }
  /**
   * Is this on the soloed array
   */
  _isSoloed() {
    return Jn._soloed.has(this.context) && Jn._soloed.get(this.context).has(this);
  }
  /**
   * Returns true if no one is soloed
   */
  _noSolos() {
    return !Jn._soloed.has(this.context) || // or has a solo set but doesn't include any items
    Jn._soloed.has(this.context) && Jn._soloed.get(this.context).size === 0;
  }
  /**
   * Solo the current instance and unsolo all other instances.
   */
  _updateSolo() {
    this._isSoloed() ? this.input.gain.value = 1 : this._noSolos() ? this.input.gain.value = 1 : this.input.gain.value = 0;
  }
  dispose() {
    return super.dispose(), Jn._allSolos.get(this.context).delete(this), this._removeSolo(), this;
  }
}
Jn._allSolos = /* @__PURE__ */ new Map();
Jn._soloed = /* @__PURE__ */ new Map();
class Qy extends qe {
  constructor() {
    const t = Re(Qy.getDefaults(), arguments, [
      "pan",
      "volume"
    ]);
    super(t), this.name = "PanVol", this._panner = this.input = new Xy({
      context: this.context,
      pan: t.pan,
      channelCount: t.channelCount
    }), this.pan = this._panner.pan, this._volume = this.output = new ou({
      context: this.context,
      volume: t.volume
    }), this.volume = this._volume.volume, this._panner.connect(this._volume), this.mute = t.mute, qn(this, ["pan", "volume"]);
  }
  static getDefaults() {
    return Object.assign(qe.getDefaults(), {
      mute: !1,
      pan: 0,
      volume: 0,
      channelCount: 1
    });
  }
  /**
   * Mute/unmute the volume
   */
  get mute() {
    return this._volume.mute;
  }
  set mute(t) {
    this._volume.mute = t;
  }
  dispose() {
    return super.dispose(), this._panner.dispose(), this.pan.dispose(), this._volume.dispose(), this.volume.dispose(), this;
  }
}
class po extends qe {
  constructor() {
    const t = Re(po.getDefaults(), arguments, [
      "volume",
      "pan"
    ]);
    super(t), this.name = "Channel", this._solo = this.input = new Jn({
      solo: t.solo,
      context: this.context
    }), this._panVol = this.output = new Qy({
      context: this.context,
      pan: t.pan,
      volume: t.volume,
      mute: t.mute,
      channelCount: t.channelCount
    }), this.pan = this._panVol.pan, this.volume = this._panVol.volume, this._solo.connect(this._panVol), qn(this, ["pan", "volume"]);
  }
  static getDefaults() {
    return Object.assign(qe.getDefaults(), {
      pan: 0,
      volume: 0,
      mute: !1,
      solo: !1,
      channelCount: 1
    });
  }
  /**
   * Solo/unsolo the channel. Soloing is only relative to other {@link Channel}s and {@link Solo} instances
   */
  get solo() {
    return this._solo.solo;
  }
  set solo(t) {
    this._solo.solo = t;
  }
  /**
   * If the current instance is muted, i.e. another instance is soloed,
   * or the channel is muted
   */
  get muted() {
    return this._solo.muted || this.mute;
  }
  /**
   * Mute/unmute the volume
   */
  get mute() {
    return this._panVol.mute;
  }
  set mute(t) {
    this._panVol.mute = t;
  }
  /**
   * Get the gain node belonging to the bus name. Create it if
   * it doesn't exist
   * @param name The bus name
   */
  _getBus(t) {
    return po.buses.has(t) || po.buses.set(t, new Lr({ context: this.context })), po.buses.get(t);
  }
  /**
   * Send audio to another channel using a string. `send` is a lot like
   * {@link connect}, except it uses a string instead of an object. This can
   * be useful in large applications to decouple sections since {@link send}
   * and {@link receive} can be invoked separately in order to connect an object
   * @param name The channel name to send the audio
   * @param volume The amount of the signal to send.
   * 	Defaults to 0db, i.e. send the entire signal
   * @returns Returns the gain node of this connection.
   */
  send(t, n = 0) {
    const r = this._getBus(t), i = new Lr({
      context: this.context,
      units: "decibels",
      gain: n
    });
    return this.connect(i), i.connect(r), i;
  }
  /**
   * Receive audio from a channel which was connected with {@link send}.
   * @param name The channel name to receive audio from.
   */
  receive(t) {
    return this._getBus(t).connect(this), this;
  }
  dispose() {
    return super.dispose(), this._panVol.dispose(), this.pan.dispose(), this.volume.dispose(), this._solo.dispose(), this;
  }
}
po.buses = /* @__PURE__ */ new Map();
function s2() {
  return Kr().now();
}
const yl = Kr().transport;
function An() {
  return Kr().transport;
}
Kr().destination;
Kr().destination;
Kr().listener;
Kr().draw;
Kr();
function fP() {
  return Sn.loaded();
}
class pP {
  constructor() {
    xe(this, "currentProject");
  }
  createProject(t) {
    return this.currentProject = {
      id: crypto.randomUUID(),
      name: t,
      tempo: 120,
      timeSignature: [4, 4],
      key: "C",
      tracks: []
    }, this.currentProject;
  }
  setProjectName(t) {
    this.currentProject && (this.currentProject.name = t);
  }
  getCurrentProject() {
    return this.currentProject;
  }
  addTrack(t, n = "audio") {
    if (!this.currentProject)
      throw new Error("No project loaded");
    const r = {
      id: crypto.randomUUID(),
      name: t,
      type: n,
      volume: 80,
      pan: 0,
      muted: !1,
      soloed: !1
    };
    return this.currentProject.tracks.push(r), r;
  }
  /**
   * Add a track with a specific ID and properties (for loading saved projects)
   * This ensures track IDs and settings are preserved across saves
   */
  addTrackWithProperties(t) {
    if (!this.currentProject)
      throw new Error("No project loaded");
    const n = {
      id: t.id,
      name: t.name,
      type: t.type,
      volume: t.volume ?? 80,
      pan: t.pan ?? 0,
      muted: t.muted ?? !1,
      soloed: t.soloed ?? !1
    };
    return this.currentProject.tracks.push(n), n;
  }
  getTrackById(t) {
    var n;
    return (n = this.currentProject) == null ? void 0 : n.tracks.find((r) => r.id === t);
  }
  removeTrack(t) {
    this.currentProject && (this.currentProject.tracks = this.currentProject.tracks.filter(
      (n) => n.id !== t
    ));
  }
  setTempo(t) {
    this.currentProject && (this.currentProject.tempo = t);
  }
  setTimeSignature(t, n) {
    this.currentProject && (this.currentProject.timeSignature = [t, n]);
  }
  setKey(t) {
    this.currentProject && (this.currentProject.key = t);
  }
}
function Jo(e, t = !1) {
  if (t || e <= 0) return -1 / 0;
  const n = Math.max(0, Math.min(100, e));
  if (n === 80) return 0;
  if (n > 80)
    return (n - 80) / 20 * 6;
  {
    const r = n / 80;
    return r === 0 ? -1 / 0 : -60 * (1 - r * r * r);
  }
}
const rl = class rl {
  constructor() {
    xe(this, "mainOutput");
    xe(this, "tracks");
    this.mainOutput = new po().toDestination(), this.tracks = /* @__PURE__ */ new Map();
  }
  static getInstance() {
    return rl.instance || (rl.instance = new rl()), rl.instance;
  }
  async initialize() {
    try {
      console.log("AudioEngine: Starting Tone.js"), await J5(), Kr().resume(), console.log("AudioEngine: Tone.js started successfully");
    } catch (t) {
      throw console.error("AudioEngine: Failed to start Tone.js:", t), t;
    }
  }
  async createTrack(t, n, r) {
    console.log(`Creating track ${t}, cleaning up existing...`), this.removeTrack(t);
    const i = new po().connect(this.mainOutput), s = 80;
    i.volume.value = Jo(s, !1), r && r.name.split(".")[0];
    const l = {
      id: t,
      name: n,
      channel: i,
      volume: s,
      pan: 0,
      muted: !1,
      soloed: !1
    };
    if (r) {
      console.log(`Loading audio file for track ${t}`);
      const c = await r.arrayBuffer(), u = new Dh({
        url: URL.createObjectURL(new Blob([c])),
        loop: !1,
        autostart: !1
      }).connect(i);
      l.player = u, await fP(), console.log(`Audio loaded for track ${t}`);
    }
    return this.tracks.set(t, l), l;
  }
  removeTrack(t) {
    const n = this.tracks.get(t);
    n && (n.player && (n.player.stop(), n.player.dispose()), n.channel.dispose(), this.tracks.delete(t));
  }
  setTrackVolume(t, n) {
    const r = this.tracks.get(t);
    if (r) {
      r.volume = n;
      const i = Jo(n, r.muted);
      r.channel.volume.value = i, r.player && (r.player.volume.value = i);
    }
  }
  setTrackPan(t, n) {
    const r = this.tracks.get(t);
    if (r) {
      r.pan = n;
      const i = n / 100;
      r.channel.pan.value = i;
    }
  }
  setTrackMute(t, n) {
    const r = this.tracks.get(t);
    r && (r.muted = n, r.channel.volume.value = Jo(r.volume, n), r.player && (r.player.volume.value = Jo(r.volume, n)));
  }
  getAllTracks() {
    return Array.from(this.tracks.values());
  }
  setMasterVolume(t) {
    this.mainOutput.volume.value = t;
  }
  // Stops all playback and should only be used for full stop, not pause
  stopAllPlayback() {
    console.log("Stopping all playback (full stop)"), this.tracks.forEach((t, n) => {
      t.player && (console.log(`Stopping player for track ${n}`), t.player.state === "started" && t.player.stop());
    });
  }
  // Add a method specifically for pausing (doesn't actually stop the players)
  pauseAllPlayback() {
    console.log("Pausing all playback (maintain position)"), this.tracks.forEach((t, n) => {
      t.player && t.player.state === "started" && console.log(`Track ${n} player synced with paused transport`);
    });
  }
  // Add method to update track name
  setTrackName(t, n) {
    const r = this.tracks.get(t);
    r && (r.name = n);
  }
  // Set a track's position on the timeline
  setTrackPosition(t, n, r) {
    const i = this.tracks.get(t);
    i && (i.position = { x: n, y: r }, console.log(`AudioEngine: Set track ${t} position to x:${n}, y:${r}`));
  }
  // Set a track's solo state
  setTrackSolo(t, n) {
    const r = this.tracks.get(t);
    r && (r.soloed = n, n ? this.tracks.forEach((i) => {
      i.id !== t && !i.soloed && (i.channel.volume.value = -1 / 0);
    }) : this.tracks.forEach((i) => {
      !i.muted && !i.soloed && (i.channel.volume.value = Jo(i.volume, !1));
    }));
  }
};
xe(rl, "instance");
let Tp = rl;
const il = class il {
  // 10ms fade
  constructor() {
    xe(this, "audioEngine");
    xe(this, "isStarting", !1);
    xe(this, "maxPosition", 3600);
    // Track the IDs of scheduled events so we can clean them up
    xe(this, "scheduledEvents", []);
    this.audioEngine = Tp.getInstance(), An().bpm.value = 120;
  }
  get position() {
    return An().seconds;
  }
  get isPlaying() {
    return An().state === "started";
  }
  get tempo() {
    return An().bpm.value;
  }
  /**
   * Converts a track's UI position (in pixels) to a time offset (in seconds)
   * This is crucial for properly aligning tracks on the timeline
   */
  getTrackTimeOffset(t) {
    return fy(t, An().bpm.value);
  }
  /**
   * Calculates the correct playback time for a track based on:
   * 1. Current transport position
   * 2. Track's position on the timeline
   * 
   * @param transportTime Global transport time
   * @param trackX The track's X position in pixels
   * @returns The adjusted playback position in seconds
   */
  calculateTrackPlayPosition(t, n) {
    const r = this.getTrackTimeOffset(n);
    return t < r ? -1 : t - r;
  }
  async play() {
    if (!this.isStarting) {
      this.isStarting = !0;
      try {
        await J5(), this.clearScheduledEvents();
        let t = An().seconds;
        console.log(`Starting playback at transport position: ${t}s`), this.audioEngine.getAllTracks().forEach((r) => {
          r.player && (r.player.state === "started" && r.player.stop(), r.player.unsync(), r.player.volume.cancelScheduledValues(s2()));
        }), this.audioEngine.getAllTracks().forEach((r) => {
          var c;
          if (!r.player) return;
          const i = ((c = r.position) == null ? void 0 : c.x) || 0, s = this.getTrackTimeOffset(i);
          t = An().seconds;
          const l = t - s;
          if (console.log(`URGENT DEBUG - Track ${r.id} position calculation:`, {
            formula: `transportPosition (${t}s) - trackOffset (${s}s) = trackPlayTime (${l}s)`,
            trackX: i,
            transportPositionSource: "direct from Tone.Transport.seconds",
            trackPlayTimeExplanation: l >= 0 ? `Play track from ${l}s offset` : `Schedule track to start in ${Math.abs(l)}s`
          }), console.log(`Track ${r.id} timing calculations:`, {
            transportPosition: t,
            trackX: i,
            trackOffset: s,
            trackPlayTime: l,
            formula: `${t}s - ${s}s = ${l}s`
          }), l >= 0) {
            console.log(`Track ${r.id} starting now from position ${l}s (offset: ${s}s)`);
            try {
              r.player.state === "started" && r.player.stop(), r.player.unsync(), r.player.volume.value = Jo(r.volume, r.muted), console.log(`REVISED APPROACH: Starting track ${r.id} from ${l}s`), r.player.start("+0", l), r.player.sync(), console.log(`Successfully started track ${r.id} at offset ${l}s`);
            } catch (u) {
              console.error(`Error starting track ${r.id}:`, u);
            }
          } else {
            const u = Math.abs(l);
            console.log(`Track ${r.id} will start in ${u}s (at transport time ${s}s)`);
            try {
              r.player.unsync();
              const h = `+${u + 0.01}`;
              console.log(`Scheduling track ${r.id} to start in ${h} seconds`);
              const p = yl.schedule((v) => {
                var m, g, b, x;
                try {
                  console.log(`EXECUTING SCHEDULE: Track ${r.id} at time ${v}`), ((m = r.player) == null ? void 0 : m.state) === "started" && r.player.stop(), (g = r.player) == null || g.unsync(), r.player.volume.value = Jo(r.volume, r.muted), (b = r.player) == null || b.start(v, 0), (x = r.player) == null || x.sync(), console.log(`Track ${r.id} started at scheduled time ${v}`);
                } catch (w) {
                  console.error(`Error starting scheduled track ${r.id}:`, w);
                }
              }, h);
              this.scheduledEvents.push(p);
            } catch (d) {
              console.error(`Error scheduling track ${r.id}:`, d);
            }
          }
          console.log(`Prepared player for track ${r.id}, position: ${i}px`);
        }), An().state === "started" && (console.log("Transport was already running, pausing before restart"), An().pause()), console.log(`Transport position before start: ${An().seconds}s`), An().start(), console.log("Transport started, state:", An().state);
      } catch (t) {
        console.error("Error starting playback:", t), this.stop();
      } finally {
        this.isStarting = !1;
      }
    }
  }
  // Clear any scheduled events (called when stopping, seeking, or starting playback)
  clearScheduledEvents() {
    console.log(`Clearing all scheduled events (${this.scheduledEvents.length})`), this.scheduledEvents.forEach((t) => {
      yl.clear(t);
    }), this.scheduledEvents = [];
  }
  pause() {
    console.log("Pausing playback at position:", this.position), this.clearScheduledEvents(), this.audioEngine.getAllTracks().forEach((n) => {
      n.player && n.player.volume.rampTo(-1 / 0, il.FADE_TIME);
    });
    const t = this.position;
    setTimeout(() => {
      An().pause(), this.audioEngine.getAllTracks().forEach((n) => {
        n.player && n.player.state === "started" && (n.player.stop(), n.player.unsync());
      }), console.log("Transport: Paused at position", t);
    }, il.FADE_TIME * 1e3);
  }
  stop() {
    console.log("Stopping transport and resetting position to 0"), this.isStarting = !1, this.clearScheduledEvents(), this.audioEngine.getAllTracks().forEach((t) => {
      t.player && t.player.volume.rampTo(-1 / 0, il.FADE_TIME);
    }), setTimeout(() => {
      An().stop(), An().seconds = 0, this.audioEngine.stopAllPlayback(), this.audioEngine.getAllTracks().forEach((t) => {
        t.player && (t.player.unsync(), console.log(`Reset player for track ${t.id}`));
      }), console.log("Transport: Successfully reset to position 0");
    }, il.FADE_TIME * 1e3);
  }
  seek(t) {
    t = Math.max(0, Math.min(t, this.maxPosition));
    const n = this.isPlaying, r = this.position;
    console.log(`SEEKING: From ${r}s to ${t}s (delta: ${t - r}s)`), An().stop(), this.clearScheduledEvents(), this.audioEngine.getAllTracks().forEach((i) => {
      i.player && (i.player.state === "started" && i.player.stop(), i.player.unsync(), i.player.volume.cancelScheduledValues(s2()), i.player.volume.value = Jo(i.volume, i.muted));
    }), An().seconds = t, console.log(`Transport position set to ${t}s, verified: ${An().seconds}s`), Math.abs(An().seconds - t) > 1e-3 && (console.warn("Transport position didn't set properly - forcing again"), An().seconds = t), n && setTimeout(() => {
      console.log(`Restarting playback from position: ${An().seconds}s`), this.play();
    }, 30);
  }
  setTempo(t) {
    const n = Math.max(20, Math.min(t, 300));
    An().bpm.value = n;
  }
  dispose() {
    this.stop(), An().dispose();
  }
  async loadAudioFile(t, n) {
    var r;
    try {
      await this.audioEngine.createTrack(t, n.name, n);
      const i = this.audioEngine.getAllTracks().find((l) => l.id === t);
      if (!(i != null && i.player))
        throw new Error(`Failed to create player for track ${t}`);
      const s = ((r = i.player.buffer) == null ? void 0 : r.duration) ?? 0;
      this.maxPosition = Math.max(this.maxPosition, s);
    } catch (i) {
      throw console.error(`Failed to load audio file for track ${t}:`, i), i;
    }
  }
  removeTrack(t) {
    this.maxPosition = Math.max(
      0,
      ...this.audioEngine.getAllTracks().filter((n) => n.id !== t).map((n) => {
        var r, i;
        return ((i = (r = n.player) == null ? void 0 : r.buffer) == null ? void 0 : i.duration) ?? 0;
      })
    );
  }
  setPosition(t) {
    this.seek(t);
  }
  /**
   * Handle track position changes during playback
   * This recalculates and adjusts the playback for a specific track that was moved
   */
  handleTrackPositionChange(t, n) {
    if (!this.isPlaying) {
      console.log(`Track ${t} position changed, but not playing - no action needed`);
      return;
    }
    const r = this.audioEngine.getAllTracks().find((l) => l.id === t);
    if (!r || !r.player) {
      console.log(`Track ${t} not found or has no player`);
      return;
    }
    console.log(`Handling position change for track ${t} to x:${n}px during playback`);
    const i = this.position;
    console.log(`Pausing playback at ${i}s and recalculating all tracks`);
    const s = this.isPlaying;
    this.clearScheduledEvents(), this.audioEngine.getAllTracks().forEach((l) => {
      l.player && (l.player.state === "started" && l.player.stop(), l.player.unsync());
    }), An().pause(), An().seconds = i, s && setTimeout(() => {
      console.log(`Restarting playback at position ${i}s with new track positions`), this.play();
    }, 20);
  }
};
// Default to 1 hour (3600 seconds) as safety
xe(il, "FADE_TIME", 0.01);
let E0 = il;
var Qa = {}, Ff = {}, Eg, o2;
function mP() {
  if (o2) return Eg;
  o2 = 1;
  function e(i) {
    var s = new r(i), l = s.readChunk();
    if (l.id != "MThd")
      throw "Bad MIDI file.  Expected 'MHdr', got: '" + l.id + "'";
    for (var c = t(l.data), u = [], d = 0; !s.eof() && d < c.numTracks; d++) {
      var h = s.readChunk();
      if (h.id != "MTrk")
        throw "Bad MIDI file.  Expected 'MTrk', got: '" + h.id + "'";
      var p = n(h.data);
      u.push(p);
    }
    return {
      header: c,
      tracks: u
    };
  }
  function t(i) {
    var s = new r(i), l = s.readUInt16(), c = s.readUInt16(), u = {
      format: l,
      numTracks: c
    }, d = s.readUInt16();
    return d & 32768 ? (u.framesPerSecond = 256 - (d >> 8), u.ticksPerFrame = d & 255) : u.ticksPerBeat = d, u;
  }
  function n(i) {
    for (var s = new r(i), l = []; !s.eof(); ) {
      var c = d();
      l.push(c);
    }
    return l;
    var u;
    function d() {
      var h = {};
      h.deltaTime = s.readVarInt();
      var p = s.readUInt8();
      if ((p & 240) === 240)
        if (p === 255) {
          h.meta = !0;
          var v = s.readUInt8(), m = s.readVarInt();
          switch (v) {
            case 0:
              if (h.type = "sequenceNumber", m !== 2) throw "Expected length for sequenceNumber event is 2, got " + m;
              return h.number = s.readUInt16(), h;
            case 1:
              return h.type = "text", h.text = s.readString(m), h;
            case 2:
              return h.type = "copyrightNotice", h.text = s.readString(m), h;
            case 3:
              return h.type = "trackName", h.text = s.readString(m), h;
            case 4:
              return h.type = "instrumentName", h.text = s.readString(m), h;
            case 5:
              return h.type = "lyrics", h.text = s.readString(m), h;
            case 6:
              return h.type = "marker", h.text = s.readString(m), h;
            case 7:
              return h.type = "cuePoint", h.text = s.readString(m), h;
            case 32:
              if (h.type = "channelPrefix", m != 1) throw "Expected length for channelPrefix event is 1, got " + m;
              return h.channel = s.readUInt8(), h;
            case 33:
              if (h.type = "portPrefix", m != 1) throw "Expected length for portPrefix event is 1, got " + m;
              return h.port = s.readUInt8(), h;
            case 47:
              if (h.type = "endOfTrack", m != 0) throw "Expected length for endOfTrack event is 0, got " + m;
              return h;
            case 81:
              if (h.type = "setTempo", m != 3) throw "Expected length for setTempo event is 3, got " + m;
              return h.microsecondsPerBeat = s.readUInt24(), h;
            case 84:
              if (h.type = "smpteOffset", m != 5) throw "Expected length for smpteOffset event is 5, got " + m;
              var g = s.readUInt8(), b = { 0: 24, 32: 25, 64: 29, 96: 30 };
              return h.frameRate = b[g & 96], h.hour = g & 31, h.min = s.readUInt8(), h.sec = s.readUInt8(), h.frame = s.readUInt8(), h.subFrame = s.readUInt8(), h;
            case 88:
              if (h.type = "timeSignature", m != 2 && m != 4) throw "Expected length for timeSignature event is 4 or 2, got " + m;
              return h.numerator = s.readUInt8(), h.denominator = 1 << s.readUInt8(), m === 4 ? (h.metronome = s.readUInt8(), h.thirtyseconds = s.readUInt8()) : (h.metronome = 36, h.thirtyseconds = 8), h;
            case 89:
              if (h.type = "keySignature", m != 2) throw "Expected length for keySignature event is 2, got " + m;
              return h.key = s.readInt8(), h.scale = s.readUInt8(), h;
            case 127:
              return h.type = "sequencerSpecific", h.data = s.readBytes(m), h;
            default:
              return h.type = "unknownMeta", h.data = s.readBytes(m), h.metatypeByte = v, h;
          }
        } else if (p == 240) {
          h.type = "sysEx";
          var m = s.readVarInt();
          return h.data = s.readBytes(m), h;
        } else if (p == 247) {
          h.type = "endSysEx";
          var m = s.readVarInt();
          return h.data = s.readBytes(m), h;
        } else
          throw "Unrecognised MIDI event type byte: " + p;
      else {
        var x;
        if ((p & 128) === 0) {
          if (u === null)
            throw "Running status byte encountered before status byte";
          x = p, p = u, h.running = !0;
        } else
          x = s.readUInt8(), u = p;
        var w = p >> 4;
        switch (h.channel = p & 15, w) {
          case 8:
            return h.type = "noteOff", h.noteNumber = x, h.velocity = s.readUInt8(), h;
          case 9:
            var T = s.readUInt8();
            return h.type = T === 0 ? "noteOff" : "noteOn", h.noteNumber = x, h.velocity = T, T === 0 && (h.byte9 = !0), h;
          case 10:
            return h.type = "noteAftertouch", h.noteNumber = x, h.amount = s.readUInt8(), h;
          case 11:
            return h.type = "controller", h.controllerType = x, h.value = s.readUInt8(), h;
          case 12:
            return h.type = "programChange", h.programNumber = x, h;
          case 13:
            return h.type = "channelAftertouch", h.amount = x, h;
          case 14:
            return h.type = "pitchBend", h.value = x + (s.readUInt8() << 7) - 8192, h;
          default:
            throw "Unrecognised MIDI event type: " + w;
        }
      }
    }
  }
  function r(i) {
    this.buffer = i, this.bufferLen = this.buffer.length, this.pos = 0;
  }
  return r.prototype.eof = function() {
    return this.pos >= this.bufferLen;
  }, r.prototype.readUInt8 = function() {
    var i = this.buffer[this.pos];
    return this.pos += 1, i;
  }, r.prototype.readInt8 = function() {
    var i = this.readUInt8();
    return i & 128 ? i - 256 : i;
  }, r.prototype.readUInt16 = function() {
    var i = this.readUInt8(), s = this.readUInt8();
    return (i << 8) + s;
  }, r.prototype.readInt16 = function() {
    var i = this.readUInt16();
    return i & 32768 ? i - 65536 : i;
  }, r.prototype.readUInt24 = function() {
    var i = this.readUInt8(), s = this.readUInt8(), l = this.readUInt8();
    return (i << 16) + (s << 8) + l;
  }, r.prototype.readInt24 = function() {
    var i = this.readUInt24();
    return i & 8388608 ? i - 16777216 : i;
  }, r.prototype.readUInt32 = function() {
    var i = this.readUInt8(), s = this.readUInt8(), l = this.readUInt8(), c = this.readUInt8();
    return (i << 24) + (s << 16) + (l << 8) + c;
  }, r.prototype.readBytes = function(i) {
    var s = this.buffer.slice(this.pos, this.pos + i);
    return this.pos += i, s;
  }, r.prototype.readString = function(i) {
    var s = this.readBytes(i);
    return String.fromCharCode.apply(null, s);
  }, r.prototype.readVarInt = function() {
    for (var i = 0; !this.eof(); ) {
      var s = this.readUInt8();
      if (s & 128)
        i += s & 127, i <<= 7;
      else
        return i + s;
    }
    return i;
  }, r.prototype.readChunk = function() {
    var i = this.readString(4), s = this.readUInt32(), l = this.readBytes(s);
    return {
      id: i,
      length: s,
      data: l
    };
  }, Eg = e, Eg;
}
var Ag, a2;
function gP() {
  if (a2) return Ag;
  a2 = 1;
  function e(s, l) {
    if (typeof s != "object")
      throw "Invalid MIDI data";
    l = l || {};
    var c = s.header || {}, u = s.tracks || [], d, h = u.length, p = new i();
    for (t(p, c, h), d = 0; d < h; d++)
      n(p, u[d], l);
    return p.buffer;
  }
  function t(s, l, c) {
    var u = l.format == null ? 1 : l.format, d = 128;
    l.timeDivision ? d = l.timeDivision : l.ticksPerFrame && l.framesPerSecond ? d = -(l.framesPerSecond & 255) << 8 | l.ticksPerFrame & 255 : l.ticksPerBeat && (d = l.ticksPerBeat & 32767);
    var h = new i();
    h.writeUInt16(u), h.writeUInt16(c), h.writeUInt16(d), s.writeChunk("MThd", h.buffer);
  }
  function n(s, l, c) {
    var u = new i(), d, h = l.length, p = null;
    for (d = 0; d < h; d++)
      (c.running === !1 || !c.running && !l[d].running) && (p = null), p = r(u, l[d], p, c.useByte9ForNoteOff);
    s.writeChunk("MTrk", u.buffer);
  }
  function r(s, l, c, u) {
    var d = l.type, h = l.deltaTime, p = l.text || "", v = l.data || [], m = null;
    switch (s.writeVarInt(h), d) {
      // meta events
      case "sequenceNumber":
        s.writeUInt8(255), s.writeUInt8(0), s.writeVarInt(2), s.writeUInt16(l.number);
        break;
      case "text":
        s.writeUInt8(255), s.writeUInt8(1), s.writeVarInt(p.length), s.writeString(p);
        break;
      case "copyrightNotice":
        s.writeUInt8(255), s.writeUInt8(2), s.writeVarInt(p.length), s.writeString(p);
        break;
      case "trackName":
        s.writeUInt8(255), s.writeUInt8(3), s.writeVarInt(p.length), s.writeString(p);
        break;
      case "instrumentName":
        s.writeUInt8(255), s.writeUInt8(4), s.writeVarInt(p.length), s.writeString(p);
        break;
      case "lyrics":
        s.writeUInt8(255), s.writeUInt8(5), s.writeVarInt(p.length), s.writeString(p);
        break;
      case "marker":
        s.writeUInt8(255), s.writeUInt8(6), s.writeVarInt(p.length), s.writeString(p);
        break;
      case "cuePoint":
        s.writeUInt8(255), s.writeUInt8(7), s.writeVarInt(p.length), s.writeString(p);
        break;
      case "channelPrefix":
        s.writeUInt8(255), s.writeUInt8(32), s.writeVarInt(1), s.writeUInt8(l.channel);
        break;
      case "portPrefix":
        s.writeUInt8(255), s.writeUInt8(33), s.writeVarInt(1), s.writeUInt8(l.port);
        break;
      case "endOfTrack":
        s.writeUInt8(255), s.writeUInt8(47), s.writeVarInt(0);
        break;
      case "setTempo":
        s.writeUInt8(255), s.writeUInt8(81), s.writeVarInt(3), s.writeUInt24(l.microsecondsPerBeat);
        break;
      case "smpteOffset":
        s.writeUInt8(255), s.writeUInt8(84), s.writeVarInt(5);
        var g = { 24: 0, 25: 32, 29: 64, 30: 96 }, b = l.hour & 31 | g[l.frameRate];
        s.writeUInt8(b), s.writeUInt8(l.min), s.writeUInt8(l.sec), s.writeUInt8(l.frame), s.writeUInt8(l.subFrame);
        break;
      case "timeSignature":
        s.writeUInt8(255), s.writeUInt8(88), s.writeVarInt(4), s.writeUInt8(l.numerator);
        var x = Math.floor(Math.log(l.denominator) / Math.LN2) & 255;
        s.writeUInt8(x), s.writeUInt8(l.metronome), s.writeUInt8(l.thirtyseconds || 8);
        break;
      case "keySignature":
        s.writeUInt8(255), s.writeUInt8(89), s.writeVarInt(2), s.writeInt8(l.key), s.writeUInt8(l.scale);
        break;
      case "sequencerSpecific":
        s.writeUInt8(255), s.writeUInt8(127), s.writeVarInt(v.length), s.writeBytes(v);
        break;
      case "unknownMeta":
        l.metatypeByte != null && (s.writeUInt8(255), s.writeUInt8(l.metatypeByte), s.writeVarInt(v.length), s.writeBytes(v));
        break;
      // system-exclusive
      case "sysEx":
        s.writeUInt8(240), s.writeVarInt(v.length), s.writeBytes(v);
        break;
      case "endSysEx":
        s.writeUInt8(247), s.writeVarInt(v.length), s.writeBytes(v);
        break;
      // channel events
      case "noteOff":
        var w = u !== !1 && l.byte9 || u && l.velocity == 0 ? 144 : 128;
        m = w | l.channel, m !== c && s.writeUInt8(m), s.writeUInt8(l.noteNumber), s.writeUInt8(l.velocity);
        break;
      case "noteOn":
        m = 144 | l.channel, m !== c && s.writeUInt8(m), s.writeUInt8(l.noteNumber), s.writeUInt8(l.velocity);
        break;
      case "noteAftertouch":
        m = 160 | l.channel, m !== c && s.writeUInt8(m), s.writeUInt8(l.noteNumber), s.writeUInt8(l.amount);
        break;
      case "controller":
        m = 176 | l.channel, m !== c && s.writeUInt8(m), s.writeUInt8(l.controllerType), s.writeUInt8(l.value);
        break;
      case "programChange":
        m = 192 | l.channel, m !== c && s.writeUInt8(m), s.writeUInt8(l.programNumber);
        break;
      case "channelAftertouch":
        m = 208 | l.channel, m !== c && s.writeUInt8(m), s.writeUInt8(l.amount);
        break;
      case "pitchBend":
        m = 224 | l.channel, m !== c && s.writeUInt8(m);
        var T = 8192 + l.value, S = T & 127, C = T >> 7 & 127;
        s.writeUInt8(S), s.writeUInt8(C);
        break;
      default:
        throw "Unrecognized event type: " + d;
    }
    return m;
  }
  function i() {
    this.buffer = [];
  }
  return i.prototype.writeUInt8 = function(s) {
    this.buffer.push(s & 255);
  }, i.prototype.writeInt8 = i.prototype.writeUInt8, i.prototype.writeUInt16 = function(s) {
    var l = s >> 8 & 255, c = s & 255;
    this.writeUInt8(l), this.writeUInt8(c);
  }, i.prototype.writeInt16 = i.prototype.writeUInt16, i.prototype.writeUInt24 = function(s) {
    var l = s >> 16 & 255, c = s >> 8 & 255, u = s & 255;
    this.writeUInt8(l), this.writeUInt8(c), this.writeUInt8(u);
  }, i.prototype.writeInt24 = i.prototype.writeUInt24, i.prototype.writeUInt32 = function(s) {
    var l = s >> 24 & 255, c = s >> 16 & 255, u = s >> 8 & 255, d = s & 255;
    this.writeUInt8(l), this.writeUInt8(c), this.writeUInt8(u), this.writeUInt8(d);
  }, i.prototype.writeInt32 = i.prototype.writeUInt32, i.prototype.writeBytes = function(s) {
    this.buffer = this.buffer.concat(Array.prototype.slice.call(s, 0));
  }, i.prototype.writeString = function(s) {
    var l, c = s.length, u = [];
    for (l = 0; l < c; l++)
      u.push(s.codePointAt(l));
    this.writeBytes(u);
  }, i.prototype.writeVarInt = function(s) {
    if (s < 0) throw "Cannot write negative variable-length integer";
    if (s <= 127)
      this.writeUInt8(s);
    else {
      var l = s, c = [];
      for (c.push(l & 127), l >>= 7; l; ) {
        var u = l & 127 | 128;
        c.push(u), l >>= 7;
      }
      this.writeBytes(c.reverse());
    }
  }, i.prototype.writeChunk = function(s, l) {
    this.writeString(s), this.writeUInt32(l.length), this.writeBytes(l);
  }, Ag = e, Ag;
}
var l2;
function ax() {
  return l2 || (l2 = 1, Ff.parseMidi = mP(), Ff.writeMidi = gP()), Ff;
}
var kg = {}, Za = {}, c2;
function lx() {
  if (c2) return Za;
  c2 = 1, Object.defineProperty(Za, "__esModule", { value: !0 }), Za.insert = Za.search = void 0;
  function e(n, r, i) {
    i === void 0 && (i = "ticks");
    var s = 0, l = n.length, c = l;
    if (l > 0 && n[l - 1][i] <= r)
      return l - 1;
    for (; s < c; ) {
      var u = Math.floor(s + (c - s) / 2), d = n[u], h = n[u + 1];
      if (d[i] === r) {
        for (var p = u; p < n.length; p++) {
          var v = n[p];
          v[i] === r && (u = p);
        }
        return u;
      } else {
        if (d[i] < r && h[i] > r)
          return u;
        d[i] > r ? c = u : d[i] < r && (s = u + 1);
      }
    }
    return -1;
  }
  Za.search = e;
  function t(n, r, i) {
    if (i === void 0 && (i = "ticks"), n.length) {
      var s = e(n, r[i], i);
      n.splice(s + 1, 0, r);
    } else
      n.push(r);
  }
  return Za.insert = t, Za;
}
var u2;
function A0() {
  return u2 || (u2 = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.Header = e.keySignatureKeys = void 0;
    var t = lx(), n = /* @__PURE__ */ new WeakMap();
    e.keySignatureKeys = [
      "Cb",
      "Gb",
      "Db",
      "Ab",
      "Eb",
      "Bb",
      "F",
      "C",
      "G",
      "D",
      "A",
      "E",
      "B",
      "F#",
      "C#"
    ];
    var r = (
      /** @class */
      function() {
        function i(s) {
          var l = this;
          if (this.tempos = [], this.timeSignatures = [], this.keySignatures = [], this.meta = [], this.name = "", n.set(this, 480), s) {
            n.set(this, s.header.ticksPerBeat), s.tracks.forEach(function(u) {
              u.forEach(function(d) {
                d.meta && (d.type === "timeSignature" ? l.timeSignatures.push({
                  ticks: d.absoluteTime,
                  timeSignature: [
                    d.numerator,
                    d.denominator
                  ]
                }) : d.type === "setTempo" ? l.tempos.push({
                  bpm: 6e7 / d.microsecondsPerBeat,
                  ticks: d.absoluteTime
                }) : d.type === "keySignature" && l.keySignatures.push({
                  key: e.keySignatureKeys[d.key + 7],
                  scale: d.scale === 0 ? "major" : "minor",
                  ticks: d.absoluteTime
                }));
              });
            });
            var c = 0;
            s.tracks[0].forEach(function(u) {
              c += u.deltaTime, u.meta && (u.type === "trackName" ? l.name = u.text : (u.type === "text" || u.type === "cuePoint" || u.type === "marker" || u.type === "lyrics") && l.meta.push({
                text: u.text,
                ticks: c,
                type: u.type
              }));
            }), this.update();
          }
        }
        return i.prototype.update = function() {
          var s = this, l = 0, c = 0;
          this.tempos.sort(function(u, d) {
            return u.ticks - d.ticks;
          }), this.tempos.forEach(function(u, d) {
            var h = d > 0 ? s.tempos[d - 1].bpm : s.tempos[0].bpm, p = u.ticks / s.ppq - c, v = 60 / h * p;
            u.time = v + l, l = u.time, c += p;
          }), this.timeSignatures.sort(function(u, d) {
            return u.ticks - d.ticks;
          }), this.timeSignatures.forEach(function(u, d) {
            var h = d > 0 ? s.timeSignatures[d - 1] : s.timeSignatures[0], p = (u.ticks - h.ticks) / s.ppq, v = p / h.timeSignature[0] / (h.timeSignature[1] / 4);
            h.measures = h.measures || 0, u.measures = v + h.measures;
          });
        }, i.prototype.ticksToSeconds = function(s) {
          var l = (0, t.search)(this.tempos, s);
          if (l !== -1) {
            var c = this.tempos[l], u = c.time, d = (s - c.ticks) / this.ppq;
            return u + 60 / c.bpm * d;
          } else {
            var h = s / this.ppq;
            return 60 / 120 * h;
          }
        }, i.prototype.ticksToMeasures = function(s) {
          var l = (0, t.search)(this.timeSignatures, s);
          if (l !== -1) {
            var c = this.timeSignatures[l], u = (s - c.ticks) / this.ppq;
            return c.measures + u / (c.timeSignature[0] / c.timeSignature[1]) / 4;
          } else
            return s / this.ppq / 4;
        }, Object.defineProperty(i.prototype, "ppq", {
          /**
           * The number of ticks per quarter note.
           */
          get: function() {
            return n.get(this);
          },
          enumerable: !1,
          configurable: !0
        }), i.prototype.secondsToTicks = function(s) {
          var l = (0, t.search)(this.tempos, s, "time");
          if (l !== -1) {
            var c = this.tempos[l], u = c.time, d = s - u, h = d / (60 / c.bpm);
            return Math.round(c.ticks + h * this.ppq);
          } else {
            var p = s / 0.5;
            return Math.round(p * this.ppq);
          }
        }, i.prototype.toJSON = function() {
          return {
            keySignatures: this.keySignatures,
            meta: this.meta,
            name: this.name,
            ppq: this.ppq,
            tempos: this.tempos.map(function(s) {
              return {
                bpm: s.bpm,
                ticks: s.ticks
              };
            }),
            timeSignatures: this.timeSignatures
          };
        }, i.prototype.fromJSON = function(s) {
          this.name = s.name, this.tempos = s.tempos.map(function(l) {
            return Object.assign({}, l);
          }), this.timeSignatures = s.timeSignatures.map(function(l) {
            return Object.assign({}, l);
          }), this.keySignatures = s.keySignatures.map(function(l) {
            return Object.assign({}, l);
          }), this.meta = s.meta.map(function(l) {
            return Object.assign({}, l);
          }), n.set(this, s.ppq), this.update();
        }, i.prototype.setTempo = function(s) {
          this.tempos = [
            {
              bpm: s,
              ticks: 0
            }
          ], this.update();
        }, i;
      }()
    );
    e.Header = r;
  }(kg)), kg;
}
var Xu = {}, Rg = {}, d2;
function cx() {
  return d2 || (d2 = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ControlChange = e.controlChangeIds = e.controlChangeNames = void 0, e.controlChangeNames = {
      1: "modulationWheel",
      2: "breath",
      4: "footController",
      5: "portamentoTime",
      7: "volume",
      8: "balance",
      10: "pan",
      64: "sustain",
      65: "portamentoTime",
      66: "sostenuto",
      67: "softPedal",
      68: "legatoFootswitch",
      84: "portamentoControl"
    }, e.controlChangeIds = Object.keys(e.controlChangeNames).reduce(function(i, s) {
      return i[e.controlChangeNames[s]] = s, i;
    }, {});
    var t = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap(), r = (
      /** @class */
      function() {
        function i(s, l) {
          t.set(this, l), n.set(this, s.controllerType), this.ticks = s.absoluteTime, this.value = s.value;
        }
        return Object.defineProperty(i.prototype, "number", {
          /**
           * The controller number
           */
          get: function() {
            return n.get(this);
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(i.prototype, "name", {
          /**
           * return the common name of the control number if it exists
           */
          get: function() {
            return e.controlChangeNames[this.number] ? e.controlChangeNames[this.number] : null;
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(i.prototype, "time", {
          /**
           * The time of the event in seconds
           */
          get: function() {
            var s = t.get(this);
            return s.ticksToSeconds(this.ticks);
          },
          set: function(s) {
            var l = t.get(this);
            this.ticks = l.secondsToTicks(s);
          },
          enumerable: !1,
          configurable: !0
        }), i.prototype.toJSON = function() {
          return {
            number: this.number,
            ticks: this.ticks,
            time: this.time,
            value: this.value
          };
        }, i;
      }()
    );
    e.ControlChange = r;
  }(Rg)), Rg;
}
var Qu = {}, h2;
function yP() {
  if (h2) return Qu;
  h2 = 1, Object.defineProperty(Qu, "__esModule", { value: !0 }), Qu.createControlChanges = void 0;
  var e = cx();
  function t() {
    return new Proxy({}, {
      // tslint:disable-next-line: typedef
      get: function(n, r) {
        if (n[r])
          return n[r];
        if (e.controlChangeIds.hasOwnProperty(r))
          return n[e.controlChangeIds[r]];
      },
      // tslint:disable-next-line: typedef
      set: function(n, r, i) {
        return e.controlChangeIds.hasOwnProperty(r) ? n[e.controlChangeIds[r]] = i : n[r] = i, !0;
      }
    });
  }
  return Qu.createControlChanges = t, Qu;
}
var Zu = {}, f2;
function vP() {
  if (f2) return Zu;
  f2 = 1, Object.defineProperty(Zu, "__esModule", { value: !0 }), Zu.PitchBend = void 0;
  var e = /* @__PURE__ */ new WeakMap(), t = (
    /** @class */
    function() {
      function n(r, i) {
        e.set(this, i), this.ticks = r.absoluteTime, this.value = r.value;
      }
      return Object.defineProperty(n.prototype, "time", {
        /**
         * The time of the event in seconds
         */
        get: function() {
          var r = e.get(this);
          return r.ticksToSeconds(this.ticks);
        },
        set: function(r) {
          var i = e.get(this);
          this.ticks = i.secondsToTicks(r);
        },
        enumerable: !1,
        configurable: !0
      }), n.prototype.toJSON = function() {
        return {
          ticks: this.ticks,
          time: this.time,
          value: this.value
        };
      }, n;
    }()
  );
  return Zu.PitchBend = t, Zu;
}
var Ju = {}, lo = {}, p2;
function bP() {
  return p2 || (p2 = 1, Object.defineProperty(lo, "__esModule", { value: !0 }), lo.DrumKitByPatchID = lo.InstrumentFamilyByID = lo.instrumentByPatchID = void 0, lo.instrumentByPatchID = [
    "acoustic grand piano",
    "bright acoustic piano",
    "electric grand piano",
    "honky-tonk piano",
    "electric piano 1",
    "electric piano 2",
    "harpsichord",
    "clavi",
    "celesta",
    "glockenspiel",
    "music box",
    "vibraphone",
    "marimba",
    "xylophone",
    "tubular bells",
    "dulcimer",
    "drawbar organ",
    "percussive organ",
    "rock organ",
    "church organ",
    "reed organ",
    "accordion",
    "harmonica",
    "tango accordion",
    "acoustic guitar (nylon)",
    "acoustic guitar (steel)",
    "electric guitar (jazz)",
    "electric guitar (clean)",
    "electric guitar (muted)",
    "overdriven guitar",
    "distortion guitar",
    "guitar harmonics",
    "acoustic bass",
    "electric bass (finger)",
    "electric bass (pick)",
    "fretless bass",
    "slap bass 1",
    "slap bass 2",
    "synth bass 1",
    "synth bass 2",
    "violin",
    "viola",
    "cello",
    "contrabass",
    "tremolo strings",
    "pizzicato strings",
    "orchestral harp",
    "timpani",
    "string ensemble 1",
    "string ensemble 2",
    "synthstrings 1",
    "synthstrings 2",
    "choir aahs",
    "voice oohs",
    "synth voice",
    "orchestra hit",
    "trumpet",
    "trombone",
    "tuba",
    "muted trumpet",
    "french horn",
    "brass section",
    "synthbrass 1",
    "synthbrass 2",
    "soprano sax",
    "alto sax",
    "tenor sax",
    "baritone sax",
    "oboe",
    "english horn",
    "bassoon",
    "clarinet",
    "piccolo",
    "flute",
    "recorder",
    "pan flute",
    "blown bottle",
    "shakuhachi",
    "whistle",
    "ocarina",
    "lead 1 (square)",
    "lead 2 (sawtooth)",
    "lead 3 (calliope)",
    "lead 4 (chiff)",
    "lead 5 (charang)",
    "lead 6 (voice)",
    "lead 7 (fifths)",
    "lead 8 (bass + lead)",
    "pad 1 (new age)",
    "pad 2 (warm)",
    "pad 3 (polysynth)",
    "pad 4 (choir)",
    "pad 5 (bowed)",
    "pad 6 (metallic)",
    "pad 7 (halo)",
    "pad 8 (sweep)",
    "fx 1 (rain)",
    "fx 2 (soundtrack)",
    "fx 3 (crystal)",
    "fx 4 (atmosphere)",
    "fx 5 (brightness)",
    "fx 6 (goblins)",
    "fx 7 (echoes)",
    "fx 8 (sci-fi)",
    "sitar",
    "banjo",
    "shamisen",
    "koto",
    "kalimba",
    "bag pipe",
    "fiddle",
    "shanai",
    "tinkle bell",
    "agogo",
    "steel drums",
    "woodblock",
    "taiko drum",
    "melodic tom",
    "synth drum",
    "reverse cymbal",
    "guitar fret noise",
    "breath noise",
    "seashore",
    "bird tweet",
    "telephone ring",
    "helicopter",
    "applause",
    "gunshot"
  ], lo.InstrumentFamilyByID = [
    "piano",
    "chromatic percussion",
    "organ",
    "guitar",
    "bass",
    "strings",
    "ensemble",
    "brass",
    "reed",
    "pipe",
    "synth lead",
    "synth pad",
    "synth effects",
    "world",
    "percussive",
    "sound effects"
  ], lo.DrumKitByPatchID = {
    0: "standard kit",
    8: "room kit",
    16: "power kit",
    24: "electronic kit",
    25: "tr-808 kit",
    32: "jazz kit",
    40: "brush kit",
    48: "orchestra kit",
    56: "sound fx kit"
  }), lo;
}
var m2;
function _P() {
  if (m2) return Ju;
  m2 = 1, Object.defineProperty(Ju, "__esModule", { value: !0 }), Ju.Instrument = void 0;
  var e = bP(), t = /* @__PURE__ */ new WeakMap(), n = (
    /** @class */
    function() {
      function r(i, s) {
        if (this.number = 0, t.set(this, s), this.number = 0, i) {
          var l = i.find(function(c) {
            return c.type === "programChange";
          });
          l && (this.number = l.programNumber);
        }
      }
      return Object.defineProperty(r.prototype, "name", {
        /**
         * The common name of the instrument.
         */
        get: function() {
          return this.percussion ? e.DrumKitByPatchID[this.number] : e.instrumentByPatchID[this.number];
        },
        set: function(i) {
          var s = e.instrumentByPatchID.indexOf(i);
          s !== -1 && (this.number = s);
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "family", {
        /**
         * The instrument family, e.g. "piano".
         */
        get: function() {
          return this.percussion ? "drums" : e.InstrumentFamilyByID[Math.floor(this.number / 8)];
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(r.prototype, "percussion", {
        /**
         * If the instrument is a percussion instrument.
         */
        get: function() {
          var i = t.get(this);
          return i.channel === 9;
        },
        enumerable: !1,
        configurable: !0
      }), r.prototype.toJSON = function() {
        return {
          family: this.family,
          number: this.number,
          name: this.name
        };
      }, r.prototype.fromJSON = function(i) {
        this.number = i.number;
      }, r;
    }()
  );
  return Ju.Instrument = n, Ju;
}
var td = {}, g2;
function SP() {
  if (g2) return td;
  g2 = 1, Object.defineProperty(td, "__esModule", { value: !0 }), td.Note = void 0;
  function e(l) {
    var c = Math.floor(l / 12) - 1;
    return t(l) + c.toString();
  }
  function t(l) {
    var c = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"], u = l % 12;
    return c[u];
  }
  function n(l) {
    var c = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
    return c.indexOf(l);
  }
  var r = /* @__PURE__ */ function() {
    var l = /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i, c = {
      // tslint:disable-next-line: object-literal-sort-keys
      cbb: -2,
      cb: -1,
      c: 0,
      "c#": 1,
      cx: 2,
      dbb: 0,
      db: 1,
      d: 2,
      "d#": 3,
      dx: 4,
      ebb: 2,
      eb: 3,
      e: 4,
      "e#": 5,
      ex: 6,
      fbb: 3,
      fb: 4,
      f: 5,
      "f#": 6,
      fx: 7,
      gbb: 5,
      gb: 6,
      g: 7,
      "g#": 8,
      gx: 9,
      abb: 7,
      ab: 8,
      a: 9,
      "a#": 10,
      ax: 11,
      bbb: 9,
      bb: 10,
      b: 11,
      "b#": 12,
      bx: 13
    };
    return function(u) {
      var d = l.exec(u), h = d[1], p = d[2], v = c[h.toLowerCase()];
      return v + (parseInt(p, 10) + 1) * 12;
    };
  }(), i = /* @__PURE__ */ new WeakMap(), s = (
    /** @class */
    function() {
      function l(c, u, d) {
        i.set(this, d), this.midi = c.midi, this.velocity = c.velocity, this.noteOffVelocity = u.velocity, this.ticks = c.ticks, this.durationTicks = u.ticks - c.ticks;
      }
      return Object.defineProperty(l.prototype, "name", {
        /**
         * The note name and octave in scientific pitch notation, e.g. "C4".
         */
        get: function() {
          return e(this.midi);
        },
        set: function(c) {
          this.midi = r(c);
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(l.prototype, "octave", {
        /**
         * The notes octave number.
         */
        get: function() {
          return Math.floor(this.midi / 12) - 1;
        },
        set: function(c) {
          var u = c - this.octave;
          this.midi += u * 12;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(l.prototype, "pitch", {
        /**
         * The pitch class name. e.g. "A".
         */
        get: function() {
          return t(this.midi);
        },
        set: function(c) {
          this.midi = 12 * (this.octave + 1) + n(c);
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(l.prototype, "duration", {
        /**
         * The duration of the segment in seconds.
         */
        get: function() {
          var c = i.get(this);
          return c.ticksToSeconds(this.ticks + this.durationTicks) - c.ticksToSeconds(this.ticks);
        },
        set: function(c) {
          var u = i.get(this), d = u.secondsToTicks(this.time + c);
          this.durationTicks = d - this.ticks;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(l.prototype, "time", {
        /**
         * The time of the event in seconds.
         */
        get: function() {
          var c = i.get(this);
          return c.ticksToSeconds(this.ticks);
        },
        set: function(c) {
          var u = i.get(this);
          this.ticks = u.secondsToTicks(c);
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(l.prototype, "bars", {
        /**
         * The number of measures (and partial measures) to this beat.
         * Takes into account time signature changes.
         * @readonly
         */
        get: function() {
          var c = i.get(this);
          return c.ticksToMeasures(this.ticks);
        },
        enumerable: !1,
        configurable: !0
      }), l.prototype.toJSON = function() {
        return {
          duration: this.duration,
          durationTicks: this.durationTicks,
          midi: this.midi,
          name: this.name,
          ticks: this.ticks,
          time: this.time,
          velocity: this.velocity
        };
      }, l;
    }()
  );
  return td.Note = s, td;
}
var y2;
function v2() {
  if (y2) return Xu;
  y2 = 1, Object.defineProperty(Xu, "__esModule", { value: !0 }), Xu.Track = void 0;
  var e = lx(), t = cx(), n = yP(), r = vP(), i = _P(), s = SP(), l = /* @__PURE__ */ new WeakMap(), c = (
    /** @class */
    function() {
      function u(d, h) {
        var p = this;
        if (this.name = "", this.notes = [], this.controlChanges = (0, n.createControlChanges)(), this.pitchBends = [], l.set(this, h), d) {
          var v = d.find(function(C) {
            return C.type === "trackName";
          });
          this.name = v ? v.text : "";
        }
        if (this.instrument = new i.Instrument(d, this), this.channel = 0, d) {
          for (var m = d.filter(function(C) {
            return C.type === "noteOn";
          }), g = d.filter(function(C) {
            return C.type === "noteOff";
          }), b = function() {
            var C = m.shift();
            x.channel = C.channel;
            var E = g.findIndex(function(B) {
              return B.noteNumber === C.noteNumber && B.absoluteTime >= C.absoluteTime;
            });
            if (E !== -1) {
              var O = g.splice(E, 1)[0];
              x.addNote({
                durationTicks: O.absoluteTime - C.absoluteTime,
                midi: C.noteNumber,
                noteOffVelocity: O.velocity / 127,
                ticks: C.absoluteTime,
                velocity: C.velocity / 127
              });
            }
          }, x = this; m.length; )
            b();
          var w = d.filter(function(C) {
            return C.type === "controller";
          });
          w.forEach(function(C) {
            p.addCC({
              number: C.controllerType,
              ticks: C.absoluteTime,
              value: C.value / 127
            });
          });
          var T = d.filter(function(C) {
            return C.type === "pitchBend";
          });
          T.forEach(function(C) {
            p.addPitchBend({
              ticks: C.absoluteTime,
              // Scale the value between -2^13 to 2^13 to -2 to 2.
              value: C.value / Math.pow(2, 13)
            });
          });
          var S = d.find(function(C) {
            return C.type === "endOfTrack";
          });
          this.endOfTrackTicks = S !== void 0 ? S.absoluteTime : void 0;
        }
      }
      return u.prototype.addNote = function(d) {
        var h = l.get(this), p = new s.Note({
          midi: 0,
          ticks: 0,
          velocity: 1
        }, {
          ticks: 0,
          velocity: 0
        }, h);
        return Object.assign(p, d), (0, e.insert)(this.notes, p, "ticks"), this;
      }, u.prototype.addCC = function(d) {
        var h = l.get(this), p = new t.ControlChange({
          controllerType: d.number
        }, h);
        return delete d.number, Object.assign(p, d), Array.isArray(this.controlChanges[p.number]) || (this.controlChanges[p.number] = []), (0, e.insert)(this.controlChanges[p.number], p, "ticks"), this;
      }, u.prototype.addPitchBend = function(d) {
        var h = l.get(this), p = new r.PitchBend({}, h);
        return Object.assign(p, d), (0, e.insert)(this.pitchBends, p, "ticks"), this;
      }, Object.defineProperty(u.prototype, "duration", {
        /**
         * The end time of the last event in the track.
         */
        get: function() {
          if (!this.notes.length)
            return 0;
          for (var d = this.notes[this.notes.length - 1].time + this.notes[this.notes.length - 1].duration, h = 0; h < this.notes.length - 1; h++) {
            var p = this.notes[h].time + this.notes[h].duration;
            d < p && (d = p);
          }
          return d;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(u.prototype, "durationTicks", {
        /**
         * The end time of the last event in the track in ticks.
         */
        get: function() {
          if (!this.notes.length)
            return 0;
          for (var d = this.notes[this.notes.length - 1].ticks + this.notes[this.notes.length - 1].durationTicks, h = 0; h < this.notes.length - 1; h++) {
            var p = this.notes[h].ticks + this.notes[h].durationTicks;
            d < p && (d = p);
          }
          return d;
        },
        enumerable: !1,
        configurable: !0
      }), u.prototype.fromJSON = function(d) {
        var h = this;
        this.name = d.name, this.channel = d.channel, this.instrument = new i.Instrument(void 0, this), this.instrument.fromJSON(d.instrument), d.endOfTrackTicks !== void 0 && (this.endOfTrackTicks = d.endOfTrackTicks);
        for (var p in d.controlChanges)
          d.controlChanges[p] && d.controlChanges[p].forEach(function(v) {
            h.addCC({
              number: v.number,
              ticks: v.ticks,
              value: v.value
            });
          });
        d.notes.forEach(function(v) {
          h.addNote({
            durationTicks: v.durationTicks,
            midi: v.midi,
            ticks: v.ticks,
            velocity: v.velocity
          });
        });
      }, u.prototype.toJSON = function() {
        for (var d = {}, h = 0; h < 127; h++)
          this.controlChanges.hasOwnProperty(h) && (d[h] = this.controlChanges[h].map(function(v) {
            return v.toJSON();
          }));
        var p = {
          channel: this.channel,
          controlChanges: d,
          pitchBends: this.pitchBends.map(function(v) {
            return v.toJSON();
          }),
          instrument: this.instrument.toJSON(),
          name: this.name,
          notes: this.notes.map(function(v) {
            return v.toJSON();
          })
        };
        return this.endOfTrackTicks !== void 0 && (p.endOfTrackTicks = this.endOfTrackTicks), p;
      }, u;
    }()
  );
  return Xu.Track = c, Xu;
}
var Ja = {};
function xP(e) {
  var t = [];
  return ux(e, t), t;
}
function ux(e, t) {
  for (var n = 0; n < e.length; n++) {
    var r = e[n];
    Array.isArray(r) ? ux(r, t) : t.push(r);
  }
}
const TP = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  flatten: xP
}, Symbol.toStringTag, { value: "Module" })), CP = /* @__PURE__ */ xT(TP);
var b2;
function wP() {
  if (b2) return Ja;
  b2 = 1;
  var e = Ja && Ja.__spreadArray || function(w, T, S) {
    if (S || arguments.length === 2) for (var C = 0, E = T.length, O; C < E; C++)
      (O || !(C in T)) && (O || (O = Array.prototype.slice.call(T, 0, C)), O[C] = T[C]);
    return w.concat(O || Array.prototype.slice.call(T));
  };
  Object.defineProperty(Ja, "__esModule", { value: !0 }), Ja.encode = void 0;
  var t = ax(), n = A0(), r = CP;
  function i(w, T) {
    return [
      {
        absoluteTime: w.ticks,
        channel: T,
        deltaTime: 0,
        noteNumber: w.midi,
        type: "noteOn",
        velocity: Math.floor(w.velocity * 127)
      },
      {
        absoluteTime: w.ticks + w.durationTicks,
        channel: T,
        deltaTime: 0,
        noteNumber: w.midi,
        type: "noteOff",
        velocity: Math.floor(w.noteOffVelocity * 127)
      }
    ];
  }
  function s(w) {
    return (0, r.flatten)(w.notes.map(function(T) {
      return i(T, w.channel);
    }));
  }
  function l(w, T) {
    return {
      absoluteTime: w.ticks,
      channel: T,
      controllerType: w.number,
      deltaTime: 0,
      type: "controller",
      value: Math.floor(w.value * 127)
    };
  }
  function c(w) {
    for (var T = [], S = 0; S < 127; S++)
      w.controlChanges.hasOwnProperty(S) && w.controlChanges[S].forEach(function(C) {
        T.push(l(C, w.channel));
      });
    return T;
  }
  function u(w, T) {
    return {
      absoluteTime: w.ticks,
      channel: T,
      deltaTime: 0,
      type: "pitchBend",
      value: w.value
    };
  }
  function d(w) {
    var T = [];
    return w.pitchBends.forEach(function(S) {
      T.push(u(S, w.channel));
    }), T;
  }
  function h(w) {
    return {
      absoluteTime: 0,
      channel: w.channel,
      deltaTime: 0,
      programNumber: w.instrument.number,
      type: "programChange"
    };
  }
  function p(w) {
    return {
      absoluteTime: 0,
      deltaTime: 0,
      meta: !0,
      text: w,
      type: "trackName"
    };
  }
  function v(w) {
    return {
      absoluteTime: w.ticks,
      deltaTime: 0,
      meta: !0,
      microsecondsPerBeat: Math.floor(6e7 / w.bpm),
      type: "setTempo"
    };
  }
  function m(w) {
    return {
      absoluteTime: w.ticks,
      deltaTime: 0,
      denominator: w.timeSignature[1],
      meta: !0,
      metronome: 24,
      numerator: w.timeSignature[0],
      thirtyseconds: 8,
      type: "timeSignature"
    };
  }
  function g(w) {
    var T = n.keySignatureKeys.indexOf(w.key);
    return {
      absoluteTime: w.ticks,
      deltaTime: 0,
      key: T + 7,
      meta: !0,
      scale: w.scale === "major" ? 0 : 1,
      type: "keySignature"
    };
  }
  function b(w) {
    return {
      absoluteTime: w.ticks,
      deltaTime: 0,
      meta: !0,
      text: w.text,
      type: w.type
    };
  }
  function x(w) {
    var T = {
      header: {
        format: 1,
        numTracks: w.tracks.length + 1,
        ticksPerBeat: w.header.ppq
      },
      tracks: e([
        e(e(e(e([
          // The name data.
          {
            absoluteTime: 0,
            deltaTime: 0,
            meta: !0,
            text: w.header.name,
            type: "trackName"
          }
        ], w.header.keySignatures.map(function(S) {
          return g(S);
        }), !0), w.header.meta.map(function(S) {
          return b(S);
        }), !0), w.header.tempos.map(function(S) {
          return v(S);
        }), !0), w.header.timeSignatures.map(function(S) {
          return m(S);
        }), !0)
      ], w.tracks.map(function(S) {
        return e(e(e([
          // Add the name
          p(S.name),
          // the instrument
          h(S)
        ], s(S), !0), c(S), !0), d(S), !0);
      }), !0)
    };
    return T.tracks = T.tracks.map(function(S) {
      S = S.sort(function(E, O) {
        return E.absoluteTime - O.absoluteTime;
      });
      var C = 0;
      return S.forEach(function(E) {
        E.deltaTime = E.absoluteTime - C, C = E.absoluteTime, delete E.absoluteTime;
      }), S.push({
        deltaTime: 0,
        meta: !0,
        type: "endOfTrack"
      }), S;
    }), new Uint8Array((0, t.writeMidi)(T));
  }
  return Ja.encode = x, Ja;
}
var _2;
function EP() {
  return _2 || (_2 = 1, function(e) {
    var t = Qa && Qa.__awaiter || function(p, v, m, g) {
      function b(x) {
        return x instanceof m ? x : new m(function(w) {
          w(x);
        });
      }
      return new (m || (m = Promise))(function(x, w) {
        function T(E) {
          try {
            C(g.next(E));
          } catch (O) {
            w(O);
          }
        }
        function S(E) {
          try {
            C(g.throw(E));
          } catch (O) {
            w(O);
          }
        }
        function C(E) {
          E.done ? x(E.value) : b(E.value).then(T, S);
        }
        C((g = g.apply(p, v || [])).next());
      });
    }, n = Qa && Qa.__generator || function(p, v) {
      var m = { label: 0, sent: function() {
        if (x[0] & 1) throw x[1];
        return x[1];
      }, trys: [], ops: [] }, g, b, x, w;
      return w = { next: T(0), throw: T(1), return: T(2) }, typeof Symbol == "function" && (w[Symbol.iterator] = function() {
        return this;
      }), w;
      function T(C) {
        return function(E) {
          return S([C, E]);
        };
      }
      function S(C) {
        if (g) throw new TypeError("Generator is already executing.");
        for (; m; ) try {
          if (g = 1, b && (x = C[0] & 2 ? b.return : C[0] ? b.throw || ((x = b.return) && x.call(b), 0) : b.next) && !(x = x.call(b, C[1])).done) return x;
          switch (b = 0, x && (C = [C[0] & 2, x.value]), C[0]) {
            case 0:
            case 1:
              x = C;
              break;
            case 4:
              return m.label++, { value: C[1], done: !1 };
            case 5:
              m.label++, b = C[1], C = [0];
              continue;
            case 7:
              C = m.ops.pop(), m.trys.pop();
              continue;
            default:
              if (x = m.trys, !(x = x.length > 0 && x[x.length - 1]) && (C[0] === 6 || C[0] === 2)) {
                m = 0;
                continue;
              }
              if (C[0] === 3 && (!x || C[1] > x[0] && C[1] < x[3])) {
                m.label = C[1];
                break;
              }
              if (C[0] === 6 && m.label < x[1]) {
                m.label = x[1], x = C;
                break;
              }
              if (x && m.label < x[2]) {
                m.label = x[2], m.ops.push(C);
                break;
              }
              x[2] && m.ops.pop(), m.trys.pop();
              continue;
          }
          C = v.call(p, m);
        } catch (E) {
          C = [6, E], b = 0;
        } finally {
          g = x = 0;
        }
        if (C[0] & 5) throw C[1];
        return { value: C[0] ? C[1] : void 0, done: !0 };
      }
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), e.Header = e.Track = e.Midi = void 0;
    var r = ax(), i = A0(), s = v2(), l = wP(), c = (
      /** @class */
      function() {
        function p(v) {
          var m = this, g = null;
          if (v) {
            var b = v instanceof ArrayBuffer ? new Uint8Array(v) : v;
            g = (0, r.parseMidi)(b), g.tracks.forEach(function(x) {
              var w = 0;
              x.forEach(function(T) {
                w += T.deltaTime, T.absoluteTime = w;
              });
            }), g.tracks = h(g.tracks);
          }
          this.header = new i.Header(g), this.tracks = [], v && (this.tracks = g.tracks.map(function(x) {
            return new s.Track(x, m.header);
          }), g.header.format === 1 && this.tracks[0].duration === 0 && this.tracks.shift());
        }
        return p.fromUrl = function(v) {
          return t(this, void 0, void 0, function() {
            var m, g;
            return n(this, function(b) {
              switch (b.label) {
                case 0:
                  return [4, fetch(v)];
                case 1:
                  return m = b.sent(), m.ok ? [4, m.arrayBuffer()] : [3, 3];
                case 2:
                  return g = b.sent(), [2, new p(g)];
                case 3:
                  throw new Error("Could not load '".concat(v, "'"));
              }
            });
          });
        }, Object.defineProperty(p.prototype, "name", {
          /**
           * The name of the midi file, taken from the first track.
           */
          get: function() {
            return this.header.name;
          },
          set: function(v) {
            this.header.name = v;
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(p.prototype, "duration", {
          /**
           * The total length of the file in seconds.
           */
          get: function() {
            var v = this.tracks.map(function(m) {
              return m.duration;
            });
            return Math.max.apply(Math, v);
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(p.prototype, "durationTicks", {
          /**
           * The total length of the file in ticks.
           */
          get: function() {
            var v = this.tracks.map(function(m) {
              return m.durationTicks;
            });
            return Math.max.apply(Math, v);
          },
          enumerable: !1,
          configurable: !0
        }), p.prototype.addTrack = function() {
          var v = new s.Track(void 0, this.header);
          return this.tracks.push(v), v;
        }, p.prototype.toArray = function() {
          return (0, l.encode)(this);
        }, p.prototype.toJSON = function() {
          return {
            header: this.header.toJSON(),
            tracks: this.tracks.map(function(v) {
              return v.toJSON();
            })
          };
        }, p.prototype.fromJSON = function(v) {
          var m = this;
          this.header = new i.Header(), this.header.fromJSON(v.header), this.tracks = v.tracks.map(function(g) {
            var b = new s.Track(void 0, m.header);
            return b.fromJSON(g), b;
          });
        }, p.prototype.clone = function() {
          var v = new p();
          return v.fromJSON(this.toJSON()), v;
        }, p;
      }()
    );
    e.Midi = c;
    var u = v2();
    Object.defineProperty(e, "Track", { enumerable: !0, get: function() {
      return u.Track;
    } });
    var d = A0();
    Object.defineProperty(e, "Header", { enumerable: !0, get: function() {
      return d.Header;
    } });
    function h(p) {
      for (var v = [], m = 0; m < p.length; m++)
        for (var g = v.length, b = /* @__PURE__ */ new Map(), x = Array(16).fill(0), w = 0, T = p[m]; w < T.length; w++) {
          var S = T[w], C = g, E = S.channel;
          if (E !== void 0) {
            S.type === "programChange" && (x[E] = S.programNumber);
            var O = x[E], B = "".concat(O, " ").concat(E);
            b.has(B) ? C = b.get(B) : (C = g + b.size, b.set(B, C));
          }
          v[C] || v.push([]), v[C].push(S);
        }
      return v;
    }
  }(Qa)), Qa;
}
var S2 = EP(), jf, AP = new Uint8Array(16);
function kP() {
  if (!jf && (jf = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto), !jf))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return jf(AP);
}
const RP = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function MP(e) {
  return typeof e == "string" && RP.test(e);
}
var Cr = [];
for (var Mg = 0; Mg < 256; ++Mg)
  Cr.push((Mg + 256).toString(16).substr(1));
function OP(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = (Cr[e[t + 0]] + Cr[e[t + 1]] + Cr[e[t + 2]] + Cr[e[t + 3]] + "-" + Cr[e[t + 4]] + Cr[e[t + 5]] + "-" + Cr[e[t + 6]] + Cr[e[t + 7]] + "-" + Cr[e[t + 8]] + Cr[e[t + 9]] + "-" + Cr[e[t + 10]] + Cr[e[t + 11]] + Cr[e[t + 12]] + Cr[e[t + 13]] + Cr[e[t + 14]] + Cr[e[t + 15]]).toLowerCase();
  if (!MP(n))
    throw TypeError("Stringified UUID is invalid");
  return n;
}
function Og(e, t, n) {
  e = e || {};
  var r = e.random || (e.rng || kP)();
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, OP(r);
}
var Yf = { exports: {} }, NP = Yf.exports, x2;
function PP() {
  return x2 || (x2 = 1, function(e, t) {
    (function(n, r) {
      e.exports = r();
    })(NP, function() {
      var n = function(y, A) {
        return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(P, U) {
          P.__proto__ = U;
        } || function(P, U) {
          for (var q in U) Object.prototype.hasOwnProperty.call(U, q) && (P[q] = U[q]);
        })(y, A);
      }, r = function() {
        return (r = Object.assign || function(y) {
          for (var A, P = 1, U = arguments.length; P < U; P++) for (var q in A = arguments[P]) Object.prototype.hasOwnProperty.call(A, q) && (y[q] = A[q]);
          return y;
        }).apply(this, arguments);
      };
      function i(y, A, P) {
        for (var U, q = 0, $ = A.length; q < $; q++) !U && q in A || ((U = U || Array.prototype.slice.call(A, 0, q))[q] = A[q]);
        return y.concat(U || Array.prototype.slice.call(A));
      }
      var s = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : Kg, l = Object.keys, c = Array.isArray;
      function u(y, A) {
        return typeof A != "object" || l(A).forEach(function(P) {
          y[P] = A[P];
        }), y;
      }
      typeof Promise > "u" || s.Promise || (s.Promise = Promise);
      var d = Object.getPrototypeOf, h = {}.hasOwnProperty;
      function p(y, A) {
        return h.call(y, A);
      }
      function v(y, A) {
        typeof A == "function" && (A = A(d(y))), (typeof Reflect > "u" ? l : Reflect.ownKeys)(A).forEach(function(P) {
          g(y, P, A[P]);
        });
      }
      var m = Object.defineProperty;
      function g(y, A, P, U) {
        m(y, A, u(P && p(P, "get") && typeof P.get == "function" ? { get: P.get, set: P.set, configurable: !0 } : { value: P, configurable: !0, writable: !0 }, U));
      }
      function b(y) {
        return { from: function(A) {
          return y.prototype = Object.create(A.prototype), g(y.prototype, "constructor", y), { extend: v.bind(null, y.prototype) };
        } };
      }
      var x = Object.getOwnPropertyDescriptor, w = [].slice;
      function T(y, A, P) {
        return w.call(y, A, P);
      }
      function S(y, A) {
        return A(y);
      }
      function C(y) {
        if (!y) throw new Error("Assertion Failed");
      }
      function E(y) {
        s.setImmediate ? setImmediate(y) : setTimeout(y, 0);
      }
      function O(y, A) {
        if (typeof A == "string" && p(y, A)) return y[A];
        if (!A) return y;
        if (typeof A != "string") {
          for (var P = [], U = 0, q = A.length; U < q; ++U) {
            var $ = O(y, A[U]);
            P.push($);
          }
          return P;
        }
        var nt = A.indexOf(".");
        if (nt !== -1) {
          var it = y[A.substr(0, nt)];
          return it == null ? void 0 : O(it, A.substr(nt + 1));
        }
      }
      function B(y, A, P) {
        if (y && A !== void 0 && !("isFrozen" in Object && Object.isFrozen(y))) if (typeof A != "string" && "length" in A) {
          C(typeof P != "string" && "length" in P);
          for (var U = 0, q = A.length; U < q; ++U) B(y, A[U], P[U]);
        } else {
          var $, nt, it = A.indexOf(".");
          it !== -1 ? ($ = A.substr(0, it), (nt = A.substr(it + 1)) === "" ? P === void 0 ? c(y) && !isNaN(parseInt($)) ? y.splice($, 1) : delete y[$] : y[$] = P : B(it = !(it = y[$]) || !p(y, $) ? y[$] = {} : it, nt, P)) : P === void 0 ? c(y) && !isNaN(parseInt(A)) ? y.splice(A, 1) : delete y[A] : y[A] = P;
        }
      }
      function N(y) {
        var A, P = {};
        for (A in y) p(y, A) && (P[A] = y[A]);
        return P;
      }
      var L = [].concat;
      function k(y) {
        return L.apply([], y);
      }
      var Bt = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(k([8, 16, 32, 64].map(function(y) {
        return ["Int", "Uint", "Float"].map(function(A) {
          return A + y + "Array";
        });
      }))).filter(function(y) {
        return s[y];
      }), F = new Set(Bt.map(function(y) {
        return s[y];
      })), G = null;
      function M(y) {
        return G = /* @__PURE__ */ new WeakMap(), y = function A(P) {
          if (!P || typeof P != "object") return P;
          var U = G.get(P);
          if (U) return U;
          if (c(P)) {
            U = [], G.set(P, U);
            for (var q = 0, $ = P.length; q < $; ++q) U.push(A(P[q]));
          } else if (F.has(P.constructor)) U = P;
          else {
            var nt, it = d(P);
            for (nt in U = it === Object.prototype ? {} : Object.create(it), G.set(P, U), P) p(P, nt) && (U[nt] = A(P[nt]));
          }
          return U;
        }(y), G = null, y;
      }
      var j = {}.toString;
      function D(y) {
        return j.call(y).slice(8, -1);
      }
      var z = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", H = typeof z == "symbol" ? function(y) {
        var A;
        return y != null && (A = y[z]) && A.apply(y);
      } : function() {
        return null;
      };
      function X(y, A) {
        return A = y.indexOf(A), 0 <= A && y.splice(A, 1), 0 <= A;
      }
      var Y = {};
      function V(y) {
        var A, P, U, q;
        if (arguments.length === 1) {
          if (c(y)) return y.slice();
          if (this === Y && typeof y == "string") return [y];
          if (q = H(y)) {
            for (P = []; !(U = q.next()).done; ) P.push(U.value);
            return P;
          }
          if (y == null) return [y];
          if (typeof (A = y.length) != "number") return [y];
          for (P = new Array(A); A--; ) P[A] = y[A];
          return P;
        }
        for (A = arguments.length, P = new Array(A); A--; ) P[A] = arguments[A];
        return P;
      }
      var Z = typeof Symbol < "u" ? function(y) {
        return y[Symbol.toStringTag] === "AsyncFunction";
      } : function() {
        return !1;
      }, Nt = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], fr = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(Nt), ct = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
      function et(y, A) {
        this.name = y, this.message = A;
      }
      function rt(y, A) {
        return y + ". Errors: " + Object.keys(A).map(function(P) {
          return A[P].toString();
        }).filter(function(P, U, q) {
          return q.indexOf(P) === U;
        }).join(`
`);
      }
      function st(y, A, P, U) {
        this.failures = A, this.failedKeys = U, this.successCount = P, this.message = rt(y, A);
      }
      function yt(y, A) {
        this.name = "BulkError", this.failures = Object.keys(A).map(function(P) {
          return A[P];
        }), this.failuresByPos = A, this.message = rt(y, this.failures);
      }
      b(et).from(Error).extend({ toString: function() {
        return this.name + ": " + this.message;
      } }), b(st).from(et), b(yt).from(et);
      var J = fr.reduce(function(y, A) {
        return y[A] = A + "Error", y;
      }, {}), tt = et, ot = fr.reduce(function(y, A) {
        var P = A + "Error";
        function U(q, $) {
          this.name = P, q ? typeof q == "string" ? (this.message = "".concat(q).concat($ ? `
 ` + $ : ""), this.inner = $ || null) : typeof q == "object" && (this.message = "".concat(q.name, " ").concat(q.message), this.inner = q) : (this.message = ct[A] || P, this.inner = null);
        }
        return b(U).from(tt), y[A] = U, y;
      }, {});
      ot.Syntax = SyntaxError, ot.Type = TypeError, ot.Range = RangeError;
      var Tt = Nt.reduce(function(y, A) {
        return y[A + "Error"] = ot[A], y;
      }, {}), Ct = fr.reduce(function(y, A) {
        return ["Syntax", "Type", "Range"].indexOf(A) === -1 && (y[A + "Error"] = ot[A]), y;
      }, {});
      function bt() {
      }
      function Ht(y) {
        return y;
      }
      function $t(y, A) {
        return y == null || y === Ht ? A : function(P) {
          return A(y(P));
        };
      }
      function wt(y, A) {
        return function() {
          y.apply(this, arguments), A.apply(this, arguments);
        };
      }
      function Wt(y, A) {
        return y === bt ? A : function() {
          var P = y.apply(this, arguments);
          P !== void 0 && (arguments[0] = P);
          var U = this.onsuccess, q = this.onerror;
          this.onsuccess = null, this.onerror = null;
          var $ = A.apply(this, arguments);
          return U && (this.onsuccess = this.onsuccess ? wt(U, this.onsuccess) : U), q && (this.onerror = this.onerror ? wt(q, this.onerror) : q), $ !== void 0 ? $ : P;
        };
      }
      function Ut(y, A) {
        return y === bt ? A : function() {
          y.apply(this, arguments);
          var P = this.onsuccess, U = this.onerror;
          this.onsuccess = this.onerror = null, A.apply(this, arguments), P && (this.onsuccess = this.onsuccess ? wt(P, this.onsuccess) : P), U && (this.onerror = this.onerror ? wt(U, this.onerror) : U);
        };
      }
      function ne(y, A) {
        return y === bt ? A : function(P) {
          var U = y.apply(this, arguments);
          u(P, U);
          var q = this.onsuccess, $ = this.onerror;
          return this.onsuccess = null, this.onerror = null, P = A.apply(this, arguments), q && (this.onsuccess = this.onsuccess ? wt(q, this.onsuccess) : q), $ && (this.onerror = this.onerror ? wt($, this.onerror) : $), U === void 0 ? P === void 0 ? void 0 : P : u(U, P);
        };
      }
      function ce(y, A) {
        return y === bt ? A : function() {
          return A.apply(this, arguments) !== !1 && y.apply(this, arguments);
        };
      }
      function re(y, A) {
        return y === bt ? A : function() {
          var P = y.apply(this, arguments);
          if (P && typeof P.then == "function") {
            for (var U = this, q = arguments.length, $ = new Array(q); q--; ) $[q] = arguments[q];
            return P.then(function() {
              return A.apply(U, $);
            });
          }
          return A.apply(this, arguments);
        };
      }
      Ct.ModifyError = st, Ct.DexieError = et, Ct.BulkError = yt;
      var le = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
      function Lt(y) {
        le = y;
      }
      var ye = {}, be = 100, Bt = typeof Promise > "u" ? [] : function() {
        var y = Promise.resolve();
        if (typeof crypto > "u" || !crypto.subtle) return [y, d(y), y];
        var A = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
        return [A, d(A), y];
      }(), Nt = Bt[0], fr = Bt[1], Bt = Bt[2], fr = fr && fr.then, Rt = Nt && Nt.constructor, Dt = !!Bt, jt = function(y, A) {
        Pe.push([y, A]), Vt && (queueMicrotask(_e), Vt = !1);
      }, Ft = !0, Vt = !0, Yt = [], ee = [], fe = Ht, ie = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: bt, pgp: !1, env: {}, finalize: bt }, zt = ie, Pe = [], je = 0, cr = [];
      function se(y) {
        if (typeof this != "object") throw new TypeError("Promises must be constructed via new");
        this._listeners = [], this._lib = !1;
        var A = this._PSD = zt;
        if (typeof y != "function") {
          if (y !== ye) throw new TypeError("Not a function");
          return this._state = arguments[1], this._value = arguments[2], void (this._state === !1 && Le(this, this._value));
        }
        this._state = null, this._value = null, ++A.ref, function P(U, q) {
          try {
            q(function($) {
              if (U._state === null) {
                if ($ === U) throw new TypeError("A promise cannot be resolved with itself.");
                var nt = U._lib && Nn();
                $ && typeof $.then == "function" ? P(U, function(it, ut) {
                  $ instanceof se ? $._then(it, ut) : $.then(it, ut);
                }) : (U._state = !0, U._value = $, ai(U)), nt && Ri();
              }
            }, Le.bind(null, U));
          } catch ($) {
            Le(U, $);
          }
        }(this, y);
      }
      var Sr = { get: function() {
        var y = zt, A = Xr;
        function P(U, q) {
          var $ = this, nt = !y.global && (y !== zt || A !== Xr), it = nt && !Mi(), ut = new se(function(ht, mt) {
            kr($, new on(wl(U, y, nt, it), wl(q, y, nt, it), ht, mt, y));
          });
          return this._consoleTask && (ut._consoleTask = this._consoleTask), ut;
        }
        return P.prototype = ye, P;
      }, set: function(y) {
        g(this, "then", y && y.prototype === ye ? Sr : { get: function() {
          return y;
        }, set: Sr.set });
      } };
      function on(y, A, P, U, q) {
        this.onFulfilled = typeof y == "function" ? y : null, this.onRejected = typeof A == "function" ? A : null, this.resolve = P, this.reject = U, this.psd = q;
      }
      function Le(y, A) {
        var P, U;
        ee.push(A), y._state === null && (P = y._lib && Nn(), A = fe(A), y._state = !1, y._value = A, U = y, Yt.some(function(q) {
          return q._value === U._value;
        }) || Yt.push(U), ai(y), P && Ri());
      }
      function ai(y) {
        var A = y._listeners;
        y._listeners = [];
        for (var P = 0, U = A.length; P < U; ++P) kr(y, A[P]);
        var q = y._PSD;
        --q.ref || q.finalize(), je === 0 && (++je, jt(function() {
          --je == 0 && xl();
        }, []));
      }
      function kr(y, A) {
        if (y._state !== null) {
          var P = y._state ? A.onFulfilled : A.onRejected;
          if (P === null) return (y._state ? A.resolve : A.reject)(y._value);
          ++A.psd.ref, ++je, jt(ur, [P, y, A]);
        } else y._listeners.push(A);
      }
      function ur(y, A, P) {
        try {
          var U, q = A._value;
          !A._state && ee.length && (ee = []), U = le && A._consoleTask ? A._consoleTask.run(function() {
            return y(q);
          }) : y(q), A._state || ee.indexOf(q) !== -1 || function($) {
            for (var nt = Yt.length; nt; ) if (Yt[--nt]._value === $._value) return Yt.splice(nt, 1);
          }(A), P.resolve(U);
        } catch ($) {
          P.reject($);
        } finally {
          --je == 0 && xl(), --P.psd.ref || P.psd.finalize();
        }
      }
      function _e() {
        Ki(ie, function() {
          Nn() && Ri();
        });
      }
      function Nn() {
        var y = Ft;
        return Vt = Ft = !1, y;
      }
      function Ri() {
        var y, A, P;
        do
          for (; 0 < Pe.length; ) for (y = Pe, Pe = [], P = y.length, A = 0; A < P; ++A) {
            var U = y[A];
            U[0].apply(null, U[1]);
          }
        while (0 < Pe.length);
        Vt = Ft = !0;
      }
      function xl() {
        var y = Yt;
        Yt = [], y.forEach(function(U) {
          U._PSD.onunhandled.call(null, U._value, U);
        });
        for (var A = cr.slice(0), P = A.length; P; ) A[--P]();
      }
      function ua(y) {
        return new se(ye, !1, y);
      }
      function dn(y, A) {
        var P = zt;
        return function() {
          var U = Nn(), q = zt;
          try {
            return ms(P, !0), y.apply(this, arguments);
          } catch ($) {
            A && A($);
          } finally {
            ms(q, !1), U && Ri();
          }
        };
      }
      v(se.prototype, { then: Sr, _then: function(y, A) {
        kr(this, new on(null, null, y, A, zt));
      }, catch: function(y) {
        if (arguments.length === 1) return this.then(null, y);
        var A = y, P = arguments[1];
        return typeof A == "function" ? this.then(null, function(U) {
          return (U instanceof A ? P : ua)(U);
        }) : this.then(null, function(U) {
          return (U && U.name === A ? P : ua)(U);
        });
      }, finally: function(y) {
        return this.then(function(A) {
          return se.resolve(y()).then(function() {
            return A;
          });
        }, function(A) {
          return se.resolve(y()).then(function() {
            return ua(A);
          });
        });
      }, timeout: function(y, A) {
        var P = this;
        return y < 1 / 0 ? new se(function(U, q) {
          var $ = setTimeout(function() {
            return q(new ot.Timeout(A));
          }, y);
          P.then(U, q).finally(clearTimeout.bind(null, $));
        }) : this;
      } }), typeof Symbol < "u" && Symbol.toStringTag && g(se.prototype, Symbol.toStringTag, "Dexie.Promise"), ie.env = Cl(), v(se, { all: function() {
        var y = V.apply(null, arguments).map(ha);
        return new se(function(A, P) {
          y.length === 0 && A([]);
          var U = y.length;
          y.forEach(function(q, $) {
            return se.resolve(q).then(function(nt) {
              y[$] = nt, --U || A(y);
            }, P);
          });
        });
      }, resolve: function(y) {
        return y instanceof se ? y : y && typeof y.then == "function" ? new se(function(A, P) {
          y.then(A, P);
        }) : new se(ye, !0, y);
      }, reject: ua, race: function() {
        var y = V.apply(null, arguments).map(ha);
        return new se(function(A, P) {
          y.map(function(U) {
            return se.resolve(U).then(A, P);
          });
        });
      }, PSD: { get: function() {
        return zt;
      }, set: function(y) {
        return zt = y;
      } }, totalEchoes: { get: function() {
        return Xr;
      } }, newPSD: an, usePSD: Ki, scheduler: { get: function() {
        return jt;
      }, set: function(y) {
        jt = y;
      } }, rejectionMapper: { get: function() {
        return fe;
      }, set: function(y) {
        fe = y;
      } }, follow: function(y, A) {
        return new se(function(P, U) {
          return an(function(q, $) {
            var nt = zt;
            nt.unhandleds = [], nt.onunhandled = $, nt.finalize = wt(function() {
              var it, ut = this;
              it = function() {
                ut.unhandleds.length === 0 ? q() : $(ut.unhandleds[0]);
              }, cr.push(function ht() {
                it(), cr.splice(cr.indexOf(ht), 1);
              }), ++je, jt(function() {
                --je == 0 && xl();
              }, []);
            }, nt.finalize), y();
          }, A, P, U);
        });
      } }), Rt && (Rt.allSettled && g(se, "allSettled", function() {
        var y = V.apply(null, arguments).map(ha);
        return new se(function(A) {
          y.length === 0 && A([]);
          var P = y.length, U = new Array(P);
          y.forEach(function(q, $) {
            return se.resolve(q).then(function(nt) {
              return U[$] = { status: "fulfilled", value: nt };
            }, function(nt) {
              return U[$] = { status: "rejected", reason: nt };
            }).then(function() {
              return --P || A(U);
            });
          });
        });
      }), Rt.any && typeof AggregateError < "u" && g(se, "any", function() {
        var y = V.apply(null, arguments).map(ha);
        return new se(function(A, P) {
          y.length === 0 && P(new AggregateError([]));
          var U = y.length, q = new Array(U);
          y.forEach(function($, nt) {
            return se.resolve($).then(function(it) {
              return A(it);
            }, function(it) {
              q[nt] = it, --U || P(new AggregateError(q));
            });
          });
        });
      }), Rt.withResolvers && (se.withResolvers = Rt.withResolvers));
      var Dn = { awaits: 0, echoes: 0, id: 0 }, fs = 0, da = [], li = 0, Xr = 0, Tl = 0;
      function an(y, A, P, U) {
        var q = zt, $ = Object.create(q);
        return $.parent = q, $.ref = 0, $.global = !1, $.id = ++Tl, ie.env, $.env = Dt ? { Promise: se, PromiseProp: { value: se, configurable: !0, writable: !0 }, all: se.all, race: se.race, allSettled: se.allSettled, any: se.any, resolve: se.resolve, reject: se.reject } : {}, A && u($, A), ++q.ref, $.finalize = function() {
          --this.parent.ref || this.parent.finalize();
        }, U = Ki($, y, P, U), $.ref === 0 && $.finalize(), U;
      }
      function ps() {
        return Dn.id || (Dn.id = ++fs), ++Dn.awaits, Dn.echoes += be, Dn.id;
      }
      function Mi() {
        return !!Dn.awaits && (--Dn.awaits == 0 && (Dn.id = 0), Dn.echoes = Dn.awaits * be, !0);
      }
      function ha(y) {
        return Dn.echoes && y && y.constructor === Rt ? (ps(), y.then(function(A) {
          return Mi(), A;
        }, function(A) {
          return Mi(), Me(A);
        })) : y;
      }
      function Bh() {
        var y = da[da.length - 1];
        da.pop(), ms(y, !1);
      }
      function ms(y, A) {
        var P, U = zt;
        (A ? !Dn.echoes || li++ && y === zt : !li || --li && y === zt) || queueMicrotask(A ? (function(q) {
          ++Xr, Dn.echoes && --Dn.echoes != 0 || (Dn.echoes = Dn.awaits = Dn.id = 0), da.push(zt), ms(q, !0);
        }).bind(null, y) : Bh), y !== zt && (zt = y, U === ie && (ie.env = Cl()), Dt && (P = ie.env.Promise, A = y.env, (U.global || y.global) && (Object.defineProperty(s, "Promise", A.PromiseProp), P.all = A.all, P.race = A.race, P.resolve = A.resolve, P.reject = A.reject, A.allSettled && (P.allSettled = A.allSettled), A.any && (P.any = A.any))));
      }
      function Cl() {
        var y = s.Promise;
        return Dt ? { Promise: y, PromiseProp: Object.getOwnPropertyDescriptor(s, "Promise"), all: y.all, race: y.race, allSettled: y.allSettled, any: y.any, resolve: y.resolve, reject: y.reject } : {};
      }
      function Ki(y, A, P, U, q) {
        var $ = zt;
        try {
          return ms(y, !0), A(P, U, q);
        } finally {
          ms($, !1);
        }
      }
      function wl(y, A, P, U) {
        return typeof y != "function" ? y : function() {
          var q = zt;
          P && ps(), ms(A, !0);
          try {
            return y.apply(this, arguments);
          } finally {
            ms(q, !1), U && queueMicrotask(Mi);
          }
        };
      }
      function dr(y) {
        Promise === Rt && Dn.echoes === 0 ? li === 0 ? y() : enqueueNativeMicroTask(y) : setTimeout(y, 0);
      }
      ("" + fr).indexOf("[native code]") === -1 && (ps = Mi = bt);
      var Me = se.reject, ci = "", Qr = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", El = "String expected.", Rr = [], Us = "__dbnames", fa = "readonly", pa = "readwrite";
      function gs(y, A) {
        return y ? A ? function() {
          return y.apply(this, arguments) && A.apply(this, arguments);
        } : y : A;
      }
      var au = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 };
      function ma(y) {
        return typeof y != "string" || /\./.test(y) ? function(A) {
          return A;
        } : function(A) {
          return A[y] === void 0 && y in A && delete (A = M(A))[y], A;
        };
      }
      function lu() {
        throw ot.Type();
      }
      function ze(y, A) {
        try {
          var P = cu(y), U = cu(A);
          if (P !== U) return P === "Array" ? 1 : U === "Array" ? -1 : P === "binary" ? 1 : U === "binary" ? -1 : P === "string" ? 1 : U === "string" ? -1 : P === "Date" ? 1 : U !== "Date" ? NaN : -1;
          switch (P) {
            case "number":
            case "Date":
            case "string":
              return A < y ? 1 : y < A ? -1 : 0;
            case "binary":
              return function(q, $) {
                for (var nt = q.length, it = $.length, ut = nt < it ? nt : it, ht = 0; ht < ut; ++ht) if (q[ht] !== $[ht]) return q[ht] < $[ht] ? -1 : 1;
                return nt === it ? 0 : nt < it ? -1 : 1;
              }(Al(y), Al(A));
            case "Array":
              return function(q, $) {
                for (var nt = q.length, it = $.length, ut = nt < it ? nt : it, ht = 0; ht < ut; ++ht) {
                  var mt = ze(q[ht], $[ht]);
                  if (mt !== 0) return mt;
                }
                return nt === it ? 0 : nt < it ? -1 : 1;
              }(y, A);
          }
        } catch {
        }
        return NaN;
      }
      function cu(y) {
        var A = typeof y;
        return A != "object" ? A : ArrayBuffer.isView(y) ? "binary" : (y = D(y), y === "ArrayBuffer" ? "binary" : y);
      }
      function Al(y) {
        return y instanceof Uint8Array ? y : ArrayBuffer.isView(y) ? new Uint8Array(y.buffer, y.byteOffset, y.byteLength) : new Uint8Array(y);
      }
      var uu = (gn.prototype._trans = function(y, A, P) {
        var U = this._tx || zt.trans, q = this.name, $ = le && typeof console < "u" && console.createTask && console.createTask("Dexie: ".concat(y === "readonly" ? "read" : "write", " ").concat(this.name));
        function nt(ht, mt, at) {
          if (!at.schema[q]) throw new ot.NotFound("Table " + q + " not part of transaction");
          return A(at.idbtrans, at);
        }
        var it = Nn();
        try {
          var ut = U && U.db._novip === this.db._novip ? U === zt.trans ? U._promise(y, nt, P) : an(function() {
            return U._promise(y, nt, P);
          }, { trans: U, transless: zt.transless || zt }) : function ht(mt, at, gt, dt) {
            if (mt.idbdb && (mt._state.openComplete || zt.letThrough || mt._vip)) {
              var pt = mt._createTransaction(at, gt, mt._dbSchema);
              try {
                pt.create(), mt._state.PR1398_maxLoop = 3;
              } catch (_t) {
                return _t.name === J.InvalidState && mt.isOpen() && 0 < --mt._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), mt.close({ disableAutoOpen: !1 }), mt.open().then(function() {
                  return ht(mt, at, gt, dt);
                })) : Me(_t);
              }
              return pt._promise(at, function(_t, ft) {
                return an(function() {
                  return zt.trans = pt, dt(_t, ft, pt);
                });
              }).then(function(_t) {
                if (at === "readwrite") try {
                  pt.idbtrans.commit();
                } catch {
                }
                return at === "readonly" ? _t : pt._completion.then(function() {
                  return _t;
                });
              });
            }
            if (mt._state.openComplete) return Me(new ot.DatabaseClosed(mt._state.dbOpenError));
            if (!mt._state.isBeingOpened) {
              if (!mt._state.autoOpen) return Me(new ot.DatabaseClosed());
              mt.open().catch(bt);
            }
            return mt._state.dbReadyPromise.then(function() {
              return ht(mt, at, gt, dt);
            });
          }(this.db, y, [this.name], nt);
          return $ && (ut._consoleTask = $, ut = ut.catch(function(ht) {
            return console.trace(ht), Me(ht);
          })), ut;
        } finally {
          it && Ri();
        }
      }, gn.prototype.get = function(y, A) {
        var P = this;
        return y && y.constructor === Object ? this.where(y).first(A) : y == null ? Me(new ot.Type("Invalid argument to Table.get()")) : this._trans("readonly", function(U) {
          return P.core.get({ trans: U, key: y }).then(function(q) {
            return P.hook.reading.fire(q);
          });
        }).then(A);
      }, gn.prototype.where = function(y) {
        if (typeof y == "string") return new this.db.WhereClause(this, y);
        if (c(y)) return new this.db.WhereClause(this, "[".concat(y.join("+"), "]"));
        var A = l(y);
        if (A.length === 1) return this.where(A[0]).equals(y[A[0]]);
        var P = this.schema.indexes.concat(this.schema.primKey).filter(function(it) {
          if (it.compound && A.every(function(ht) {
            return 0 <= it.keyPath.indexOf(ht);
          })) {
            for (var ut = 0; ut < A.length; ++ut) if (A.indexOf(it.keyPath[ut]) === -1) return !1;
            return !0;
          }
          return !1;
        }).sort(function(it, ut) {
          return it.keyPath.length - ut.keyPath.length;
        })[0];
        if (P && this.db._maxKey !== ci) {
          var $ = P.keyPath.slice(0, A.length);
          return this.where($).equals($.map(function(ut) {
            return y[ut];
          }));
        }
        !P && le && console.warn("The query ".concat(JSON.stringify(y), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(A.join("+"), "]"));
        var U = this.schema.idxByName;
        function q(it, ut) {
          return ze(it, ut) === 0;
        }
        var nt = A.reduce(function(at, ut) {
          var ht = at[0], mt = at[1], at = U[ut], gt = y[ut];
          return [ht || at, ht || !at ? gs(mt, at && at.multi ? function(dt) {
            return dt = O(dt, ut), c(dt) && dt.some(function(pt) {
              return q(gt, pt);
            });
          } : function(dt) {
            return q(gt, O(dt, ut));
          }) : mt];
        }, [null, null]), $ = nt[0], nt = nt[1];
        return $ ? this.where($.name).equals(y[$.keyPath]).filter(nt) : P ? this.filter(nt) : this.where(A).equals("");
      }, gn.prototype.filter = function(y) {
        return this.toCollection().and(y);
      }, gn.prototype.count = function(y) {
        return this.toCollection().count(y);
      }, gn.prototype.offset = function(y) {
        return this.toCollection().offset(y);
      }, gn.prototype.limit = function(y) {
        return this.toCollection().limit(y);
      }, gn.prototype.each = function(y) {
        return this.toCollection().each(y);
      }, gn.prototype.toArray = function(y) {
        return this.toCollection().toArray(y);
      }, gn.prototype.toCollection = function() {
        return new this.db.Collection(new this.db.WhereClause(this));
      }, gn.prototype.orderBy = function(y) {
        return new this.db.Collection(new this.db.WhereClause(this, c(y) ? "[".concat(y.join("+"), "]") : y));
      }, gn.prototype.reverse = function() {
        return this.toCollection().reverse();
      }, gn.prototype.mapToClass = function(y) {
        var A, P = this.db, U = this.name;
        function q() {
          return A !== null && A.apply(this, arguments) || this;
        }
        (this.schema.mappedClass = y).prototype instanceof lu && (function(ut, ht) {
          if (typeof ht != "function" && ht !== null) throw new TypeError("Class extends value " + String(ht) + " is not a constructor or null");
          function mt() {
            this.constructor = ut;
          }
          n(ut, ht), ut.prototype = ht === null ? Object.create(ht) : (mt.prototype = ht.prototype, new mt());
        }(q, A = y), Object.defineProperty(q.prototype, "db", { get: function() {
          return P;
        }, enumerable: !1, configurable: !0 }), q.prototype.table = function() {
          return U;
        }, y = q);
        for (var $ = /* @__PURE__ */ new Set(), nt = y.prototype; nt; nt = d(nt)) Object.getOwnPropertyNames(nt).forEach(function(ut) {
          return $.add(ut);
        });
        function it(ut) {
          if (!ut) return ut;
          var ht, mt = Object.create(y.prototype);
          for (ht in ut) if (!$.has(ht)) try {
            mt[ht] = ut[ht];
          } catch {
          }
          return mt;
        }
        return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = it, this.hook("reading", it), y;
      }, gn.prototype.defineClass = function() {
        return this.mapToClass(function(y) {
          u(this, y);
        });
      }, gn.prototype.add = function(y, A) {
        var P = this, U = this.schema.primKey, q = U.auto, $ = U.keyPath, nt = y;
        return $ && q && (nt = ma($)(y)), this._trans("readwrite", function(it) {
          return P.core.mutate({ trans: it, type: "add", keys: A != null ? [A] : null, values: [nt] });
        }).then(function(it) {
          return it.numFailures ? se.reject(it.failures[0]) : it.lastResult;
        }).then(function(it) {
          if ($) try {
            B(y, $, it);
          } catch {
          }
          return it;
        });
      }, gn.prototype.update = function(y, A) {
        return typeof y != "object" || c(y) ? this.where(":id").equals(y).modify(A) : (y = O(y, this.schema.primKey.keyPath), y === void 0 ? Me(new ot.InvalidArgument("Given object does not contain its primary key")) : this.where(":id").equals(y).modify(A));
      }, gn.prototype.put = function(y, A) {
        var P = this, U = this.schema.primKey, q = U.auto, $ = U.keyPath, nt = y;
        return $ && q && (nt = ma($)(y)), this._trans("readwrite", function(it) {
          return P.core.mutate({ trans: it, type: "put", values: [nt], keys: A != null ? [A] : null });
        }).then(function(it) {
          return it.numFailures ? se.reject(it.failures[0]) : it.lastResult;
        }).then(function(it) {
          if ($) try {
            B(y, $, it);
          } catch {
          }
          return it;
        });
      }, gn.prototype.delete = function(y) {
        var A = this;
        return this._trans("readwrite", function(P) {
          return A.core.mutate({ trans: P, type: "delete", keys: [y] });
        }).then(function(P) {
          return P.numFailures ? se.reject(P.failures[0]) : void 0;
        });
      }, gn.prototype.clear = function() {
        var y = this;
        return this._trans("readwrite", function(A) {
          return y.core.mutate({ trans: A, type: "deleteRange", range: au });
        }).then(function(A) {
          return A.numFailures ? se.reject(A.failures[0]) : void 0;
        });
      }, gn.prototype.bulkGet = function(y) {
        var A = this;
        return this._trans("readonly", function(P) {
          return A.core.getMany({ keys: y, trans: P }).then(function(U) {
            return U.map(function(q) {
              return A.hook.reading.fire(q);
            });
          });
        });
      }, gn.prototype.bulkAdd = function(y, A, P) {
        var U = this, q = Array.isArray(A) ? A : void 0, $ = (P = P || (q ? void 0 : A)) ? P.allKeys : void 0;
        return this._trans("readwrite", function(nt) {
          var ht = U.schema.primKey, it = ht.auto, ht = ht.keyPath;
          if (ht && q) throw new ot.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
          if (q && q.length !== y.length) throw new ot.InvalidArgument("Arguments objects and keys must have the same length");
          var ut = y.length, ht = ht && it ? y.map(ma(ht)) : y;
          return U.core.mutate({ trans: nt, type: "add", keys: q, values: ht, wantResults: $ }).then(function(pt) {
            var at = pt.numFailures, gt = pt.results, dt = pt.lastResult, pt = pt.failures;
            if (at === 0) return $ ? gt : dt;
            throw new yt("".concat(U.name, ".bulkAdd(): ").concat(at, " of ").concat(ut, " operations failed"), pt);
          });
        });
      }, gn.prototype.bulkPut = function(y, A, P) {
        var U = this, q = Array.isArray(A) ? A : void 0, $ = (P = P || (q ? void 0 : A)) ? P.allKeys : void 0;
        return this._trans("readwrite", function(nt) {
          var ht = U.schema.primKey, it = ht.auto, ht = ht.keyPath;
          if (ht && q) throw new ot.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
          if (q && q.length !== y.length) throw new ot.InvalidArgument("Arguments objects and keys must have the same length");
          var ut = y.length, ht = ht && it ? y.map(ma(ht)) : y;
          return U.core.mutate({ trans: nt, type: "put", keys: q, values: ht, wantResults: $ }).then(function(pt) {
            var at = pt.numFailures, gt = pt.results, dt = pt.lastResult, pt = pt.failures;
            if (at === 0) return $ ? gt : dt;
            throw new yt("".concat(U.name, ".bulkPut(): ").concat(at, " of ").concat(ut, " operations failed"), pt);
          });
        });
      }, gn.prototype.bulkUpdate = function(y) {
        var A = this, P = this.core, U = y.map(function(nt) {
          return nt.key;
        }), q = y.map(function(nt) {
          return nt.changes;
        }), $ = [];
        return this._trans("readwrite", function(nt) {
          return P.getMany({ trans: nt, keys: U, cache: "clone" }).then(function(it) {
            var ut = [], ht = [];
            y.forEach(function(at, gt) {
              var dt = at.key, pt = at.changes, _t = it[gt];
              if (_t) {
                for (var ft = 0, xt = Object.keys(pt); ft < xt.length; ft++) {
                  var kt = xt[ft], Et = pt[kt];
                  if (kt === A.schema.primKey.keyPath) {
                    if (ze(Et, dt) !== 0) throw new ot.Constraint("Cannot update primary key in bulkUpdate()");
                  } else B(_t, kt, Et);
                }
                $.push(gt), ut.push(dt), ht.push(_t);
              }
            });
            var mt = ut.length;
            return P.mutate({ trans: nt, type: "put", keys: ut, values: ht, updates: { keys: U, changeSpecs: q } }).then(function(at) {
              var gt = at.numFailures, dt = at.failures;
              if (gt === 0) return mt;
              for (var pt = 0, _t = Object.keys(dt); pt < _t.length; pt++) {
                var ft, xt = _t[pt], kt = $[Number(xt)];
                kt != null && (ft = dt[xt], delete dt[xt], dt[kt] = ft);
              }
              throw new yt("".concat(A.name, ".bulkUpdate(): ").concat(gt, " of ").concat(mt, " operations failed"), dt);
            });
          });
        });
      }, gn.prototype.bulkDelete = function(y) {
        var A = this, P = y.length;
        return this._trans("readwrite", function(U) {
          return A.core.mutate({ trans: U, type: "delete", keys: y });
        }).then(function(nt) {
          var q = nt.numFailures, $ = nt.lastResult, nt = nt.failures;
          if (q === 0) return $;
          throw new yt("".concat(A.name, ".bulkDelete(): ").concat(q, " of ").concat(P, " operations failed"), nt);
        });
      }, gn);
      function gn() {
      }
      function Co(y) {
        function A(nt, it) {
          if (it) {
            for (var ut = arguments.length, ht = new Array(ut - 1); --ut; ) ht[ut - 1] = arguments[ut];
            return P[nt].subscribe.apply(null, ht), y;
          }
          if (typeof nt == "string") return P[nt];
        }
        var P = {};
        A.addEventType = $;
        for (var U = 1, q = arguments.length; U < q; ++U) $(arguments[U]);
        return A;
        function $(nt, it, ut) {
          if (typeof nt != "object") {
            var ht;
            it = it || ce;
            var mt = { subscribers: [], fire: ut = ut || bt, subscribe: function(at) {
              mt.subscribers.indexOf(at) === -1 && (mt.subscribers.push(at), mt.fire = it(mt.fire, at));
            }, unsubscribe: function(at) {
              mt.subscribers = mt.subscribers.filter(function(gt) {
                return gt !== at;
              }), mt.fire = mt.subscribers.reduce(it, ut);
            } };
            return P[nt] = A[nt] = mt;
          }
          l(ht = nt).forEach(function(at) {
            var gt = ht[at];
            if (c(gt)) $(at, ht[at][0], ht[at][1]);
            else {
              if (gt !== "asap") throw new ot.InvalidArgument("Invalid event config");
              var dt = $(at, Ht, function() {
                for (var pt = arguments.length, _t = new Array(pt); pt--; ) _t[pt] = arguments[pt];
                dt.subscribers.forEach(function(ft) {
                  E(function() {
                    ft.apply(null, _t);
                  });
                });
              });
            }
          });
        }
      }
      function wo(y, A) {
        return b(A).from({ prototype: y }), A;
      }
      function Vs(y, A) {
        return !(y.filter || y.algorithm || y.or) && (A ? y.justLimit : !y.replayFilter);
      }
      function ga(y, A) {
        y.filter = gs(y.filter, A);
      }
      function kl(y, A, P) {
        var U = y.replayFilter;
        y.replayFilter = U ? function() {
          return gs(U(), A());
        } : A, y.justLimit = P && !U;
      }
      function ya(y, A) {
        if (y.isPrimKey) return A.primaryKey;
        var P = A.getIndexByKeyPath(y.index);
        if (!P) throw new ot.Schema("KeyPath " + y.index + " on object store " + A.name + " is not indexed");
        return P;
      }
      function du(y, A, P) {
        var U = ya(y, A.schema);
        return A.openCursor({ trans: P, values: !y.keysOnly, reverse: y.dir === "prev", unique: !!y.unique, query: { index: U, range: y.range } });
      }
      function va(y, A, P, U) {
        var q = y.replayFilter ? gs(y.filter, y.replayFilter()) : y.filter;
        if (y.or) {
          var $ = {}, nt = function(it, ut, ht) {
            var mt, at;
            q && !q(ut, ht, function(gt) {
              return ut.stop(gt);
            }, function(gt) {
              return ut.fail(gt);
            }) || ((at = "" + (mt = ut.primaryKey)) == "[object ArrayBuffer]" && (at = "" + new Uint8Array(mt)), p($, at) || ($[at] = !0, A(it, ut, ht)));
          };
          return Promise.all([y.or._iterate(nt, P), hu(du(y, U, P), y.algorithm, nt, !y.keysOnly && y.valueMapper)]);
        }
        return hu(du(y, U, P), gs(y.algorithm, q), A, !y.keysOnly && y.valueMapper);
      }
      function hu(y, A, P, U) {
        var q = dn(U ? function($, nt, it) {
          return P(U($), nt, it);
        } : P);
        return y.then(function($) {
          if ($) return $.start(function() {
            var nt = function() {
              return $.continue();
            };
            A && !A($, function(it) {
              return nt = it;
            }, function(it) {
              $.stop(it), nt = bt;
            }, function(it) {
              $.fail(it), nt = bt;
            }) || q($.value, $, function(it) {
              return nt = it;
            }), nt();
          });
        });
      }
      var ba = (fu.prototype.execute = function(y) {
        var A = this["@@propmod"];
        if (A.add !== void 0) {
          var P = A.add;
          if (c(P)) return i(i([], c(y) ? y : [], !0), P).sort();
          if (typeof P == "number") return (Number(y) || 0) + P;
          if (typeof P == "bigint") try {
            return BigInt(y) + P;
          } catch {
            return BigInt(0) + P;
          }
          throw new TypeError("Invalid term ".concat(P));
        }
        if (A.remove !== void 0) {
          var U = A.remove;
          if (c(U)) return c(y) ? y.filter(function(q) {
            return !U.includes(q);
          }).sort() : [];
          if (typeof U == "number") return Number(y) - U;
          if (typeof U == "bigint") try {
            return BigInt(y) - U;
          } catch {
            return BigInt(0) - U;
          }
          throw new TypeError("Invalid subtrahend ".concat(U));
        }
        return P = (P = A.replacePrefix) === null || P === void 0 ? void 0 : P[0], P && typeof y == "string" && y.startsWith(P) ? A.replacePrefix[1] + y.substring(P.length) : y;
      }, fu);
      function fu(y) {
        this["@@propmod"] = y;
      }
      var Eo = (Ke.prototype._read = function(y, A) {
        var P = this._ctx;
        return P.error ? P.table._trans(null, Me.bind(null, P.error)) : P.table._trans("readonly", y).then(A);
      }, Ke.prototype._write = function(y) {
        var A = this._ctx;
        return A.error ? A.table._trans(null, Me.bind(null, A.error)) : A.table._trans("readwrite", y, "locked");
      }, Ke.prototype._addAlgorithm = function(y) {
        var A = this._ctx;
        A.algorithm = gs(A.algorithm, y);
      }, Ke.prototype._iterate = function(y, A) {
        return va(this._ctx, y, A, this._ctx.table.core);
      }, Ke.prototype.clone = function(y) {
        var A = Object.create(this.constructor.prototype), P = Object.create(this._ctx);
        return y && u(P, y), A._ctx = P, A;
      }, Ke.prototype.raw = function() {
        return this._ctx.valueMapper = null, this;
      }, Ke.prototype.each = function(y) {
        var A = this._ctx;
        return this._read(function(P) {
          return va(A, y, P, A.table.core);
        });
      }, Ke.prototype.count = function(y) {
        var A = this;
        return this._read(function(P) {
          var U = A._ctx, q = U.table.core;
          if (Vs(U, !0)) return q.count({ trans: P, query: { index: ya(U, q.schema), range: U.range } }).then(function(nt) {
            return Math.min(nt, U.limit);
          });
          var $ = 0;
          return va(U, function() {
            return ++$, !1;
          }, P, q).then(function() {
            return $;
          });
        }).then(y);
      }, Ke.prototype.sortBy = function(y, A) {
        var P = y.split(".").reverse(), U = P[0], q = P.length - 1;
        function $(ut, ht) {
          return ht ? $(ut[P[ht]], ht - 1) : ut[U];
        }
        var nt = this._ctx.dir === "next" ? 1 : -1;
        function it(ut, ht) {
          return ze($(ut, q), $(ht, q)) * nt;
        }
        return this.toArray(function(ut) {
          return ut.sort(it);
        }).then(A);
      }, Ke.prototype.toArray = function(y) {
        var A = this;
        return this._read(function(P) {
          var U = A._ctx;
          if (U.dir === "next" && Vs(U, !0) && 0 < U.limit) {
            var q = U.valueMapper, $ = ya(U, U.table.core.schema);
            return U.table.core.query({ trans: P, limit: U.limit, values: !0, query: { index: $, range: U.range } }).then(function(it) {
              return it = it.result, q ? it.map(q) : it;
            });
          }
          var nt = [];
          return va(U, function(it) {
            return nt.push(it);
          }, P, U.table.core).then(function() {
            return nt;
          });
        }, y);
      }, Ke.prototype.offset = function(y) {
        var A = this._ctx;
        return y <= 0 || (A.offset += y, Vs(A) ? kl(A, function() {
          var P = y;
          return function(U, q) {
            return P === 0 || (P === 1 ? --P : q(function() {
              U.advance(P), P = 0;
            }), !1);
          };
        }) : kl(A, function() {
          var P = y;
          return function() {
            return --P < 0;
          };
        })), this;
      }, Ke.prototype.limit = function(y) {
        return this._ctx.limit = Math.min(this._ctx.limit, y), kl(this._ctx, function() {
          var A = y;
          return function(P, U, q) {
            return --A <= 0 && U(q), 0 <= A;
          };
        }, !0), this;
      }, Ke.prototype.until = function(y, A) {
        return ga(this._ctx, function(P, U, q) {
          return !y(P.value) || (U(q), A);
        }), this;
      }, Ke.prototype.first = function(y) {
        return this.limit(1).toArray(function(A) {
          return A[0];
        }).then(y);
      }, Ke.prototype.last = function(y) {
        return this.reverse().first(y);
      }, Ke.prototype.filter = function(y) {
        var A;
        return ga(this._ctx, function(P) {
          return y(P.value);
        }), (A = this._ctx).isMatch = gs(A.isMatch, y), this;
      }, Ke.prototype.and = function(y) {
        return this.filter(y);
      }, Ke.prototype.or = function(y) {
        return new this.db.WhereClause(this._ctx.table, y, this);
      }, Ke.prototype.reverse = function() {
        return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
      }, Ke.prototype.desc = function() {
        return this.reverse();
      }, Ke.prototype.eachKey = function(y) {
        var A = this._ctx;
        return A.keysOnly = !A.isMatch, this.each(function(P, U) {
          y(U.key, U);
        });
      }, Ke.prototype.eachUniqueKey = function(y) {
        return this._ctx.unique = "unique", this.eachKey(y);
      }, Ke.prototype.eachPrimaryKey = function(y) {
        var A = this._ctx;
        return A.keysOnly = !A.isMatch, this.each(function(P, U) {
          y(U.primaryKey, U);
        });
      }, Ke.prototype.keys = function(y) {
        var A = this._ctx;
        A.keysOnly = !A.isMatch;
        var P = [];
        return this.each(function(U, q) {
          P.push(q.key);
        }).then(function() {
          return P;
        }).then(y);
      }, Ke.prototype.primaryKeys = function(y) {
        var A = this._ctx;
        if (A.dir === "next" && Vs(A, !0) && 0 < A.limit) return this._read(function(U) {
          var q = ya(A, A.table.core.schema);
          return A.table.core.query({ trans: U, values: !1, limit: A.limit, query: { index: q, range: A.range } });
        }).then(function(U) {
          return U.result;
        }).then(y);
        A.keysOnly = !A.isMatch;
        var P = [];
        return this.each(function(U, q) {
          P.push(q.primaryKey);
        }).then(function() {
          return P;
        }).then(y);
      }, Ke.prototype.uniqueKeys = function(y) {
        return this._ctx.unique = "unique", this.keys(y);
      }, Ke.prototype.firstKey = function(y) {
        return this.limit(1).keys(function(A) {
          return A[0];
        }).then(y);
      }, Ke.prototype.lastKey = function(y) {
        return this.reverse().firstKey(y);
      }, Ke.prototype.distinct = function() {
        var y = this._ctx, y = y.index && y.table.schema.idxByName[y.index];
        if (!y || !y.multi) return this;
        var A = {};
        return ga(this._ctx, function(q) {
          var U = q.primaryKey.toString(), q = p(A, U);
          return A[U] = !0, !q;
        }), this;
      }, Ke.prototype.modify = function(y) {
        var A = this, P = this._ctx;
        return this._write(function(U) {
          var q, $, nt;
          nt = typeof y == "function" ? y : (q = l(y), $ = q.length, function(ft) {
            for (var xt = !1, kt = 0; kt < $; ++kt) {
              var Et = q[kt], Pt = y[Et], Gt = O(ft, Et);
              Pt instanceof ba ? (B(ft, Et, Pt.execute(Gt)), xt = !0) : Gt !== Pt && (B(ft, Et, Pt), xt = !0);
            }
            return xt;
          });
          var it = P.table.core, at = it.schema.primaryKey, ut = at.outbound, ht = at.extractKey, mt = 200, at = A.db._options.modifyChunkSize;
          at && (mt = typeof at == "object" ? at[it.name] || at["*"] || 200 : at);
          function gt(ft, Et) {
            var kt = Et.failures, Et = Et.numFailures;
            pt += ft - Et;
            for (var Pt = 0, Gt = l(kt); Pt < Gt.length; Pt++) {
              var Jt = Gt[Pt];
              dt.push(kt[Jt]);
            }
          }
          var dt = [], pt = 0, _t = [];
          return A.clone().primaryKeys().then(function(ft) {
            function xt(Et) {
              var Pt = Math.min(mt, ft.length - Et);
              return it.getMany({ trans: U, keys: ft.slice(Et, Et + Pt), cache: "immutable" }).then(function(Gt) {
                for (var Jt = [], qt = [], Qt = ut ? [] : null, oe = [], Xt = 0; Xt < Pt; ++Xt) {
                  var ue = Gt[Xt], ve = { value: M(ue), primKey: ft[Et + Xt] };
                  nt.call(ve, ve.value, ve) !== !1 && (ve.value == null ? oe.push(ft[Et + Xt]) : ut || ze(ht(ue), ht(ve.value)) === 0 ? (qt.push(ve.value), ut && Qt.push(ft[Et + Xt])) : (oe.push(ft[Et + Xt]), Jt.push(ve.value)));
                }
                return Promise.resolve(0 < Jt.length && it.mutate({ trans: U, type: "add", values: Jt }).then(function(Ae) {
                  for (var Te in Ae.failures) oe.splice(parseInt(Te), 1);
                  gt(Jt.length, Ae);
                })).then(function() {
                  return (0 < qt.length || kt && typeof y == "object") && it.mutate({ trans: U, type: "put", keys: Qt, values: qt, criteria: kt, changeSpec: typeof y != "function" && y, isAdditionalChunk: 0 < Et }).then(function(Ae) {
                    return gt(qt.length, Ae);
                  });
                }).then(function() {
                  return (0 < oe.length || kt && y === Ao) && it.mutate({ trans: U, type: "delete", keys: oe, criteria: kt, isAdditionalChunk: 0 < Et }).then(function(Ae) {
                    return gt(oe.length, Ae);
                  });
                }).then(function() {
                  return ft.length > Et + Pt && xt(Et + mt);
                });
              });
            }
            var kt = Vs(P) && P.limit === 1 / 0 && (typeof y != "function" || y === Ao) && { index: P.index, range: P.range };
            return xt(0).then(function() {
              if (0 < dt.length) throw new st("Error modifying one or more objects", dt, pt, _t);
              return ft.length;
            });
          });
        });
      }, Ke.prototype.delete = function() {
        var y = this._ctx, A = y.range;
        return Vs(y) && (y.isPrimKey || A.type === 3) ? this._write(function(P) {
          var U = y.table.core.schema.primaryKey, q = A;
          return y.table.core.count({ trans: P, query: { index: U, range: q } }).then(function($) {
            return y.table.core.mutate({ trans: P, type: "deleteRange", range: q }).then(function(nt) {
              var it = nt.failures;
              if (nt.lastResult, nt.results, nt = nt.numFailures, nt) throw new st("Could not delete some values", Object.keys(it).map(function(ut) {
                return it[ut];
              }), $ - nt);
              return $ - nt;
            });
          });
        }) : this.modify(Ao);
      }, Ke);
      function Ke() {
      }
      var Ao = function(y, A) {
        return A.value = null;
      };
      function Rl(y, A) {
        return y < A ? -1 : y === A ? 0 : 1;
      }
      function Fh(y, A) {
        return A < y ? -1 : y === A ? 0 : 1;
      }
      function xr(y, A, P) {
        return y = y instanceof Ml ? new y.Collection(y) : y, y._ctx.error = new (P || TypeError)(A), y;
      }
      function Gs(y) {
        return new y.Collection(y, function() {
          return pu("");
        }).limit(0);
      }
      function _a(y, A, P, U) {
        var q, $, nt, it, ut, ht, mt, at = P.length;
        if (!P.every(function(pt) {
          return typeof pt == "string";
        })) return xr(y, El);
        function gt(pt) {
          q = pt === "next" ? function(ft) {
            return ft.toUpperCase();
          } : function(ft) {
            return ft.toLowerCase();
          }, $ = pt === "next" ? function(ft) {
            return ft.toLowerCase();
          } : function(ft) {
            return ft.toUpperCase();
          }, nt = pt === "next" ? Rl : Fh;
          var _t = P.map(function(ft) {
            return { lower: $(ft), upper: q(ft) };
          }).sort(function(ft, xt) {
            return nt(ft.lower, xt.lower);
          });
          it = _t.map(function(ft) {
            return ft.upper;
          }), ut = _t.map(function(ft) {
            return ft.lower;
          }), mt = (ht = pt) === "next" ? "" : U;
        }
        gt("next"), y = new y.Collection(y, function() {
          return Yi(it[0], ut[at - 1] + U);
        }), y._ondirectionchange = function(pt) {
          gt(pt);
        };
        var dt = 0;
        return y._addAlgorithm(function(pt, _t, ft) {
          var xt = pt.key;
          if (typeof xt != "string") return !1;
          var kt = $(xt);
          if (A(kt, ut, dt)) return !0;
          for (var Et = null, Pt = dt; Pt < at; ++Pt) {
            var Gt = function(Jt, qt, Qt, oe, Xt, ue) {
              for (var ve = Math.min(Jt.length, oe.length), Ae = -1, Te = 0; Te < ve; ++Te) {
                var Or = qt[Te];
                if (Or !== oe[Te]) return Xt(Jt[Te], Qt[Te]) < 0 ? Jt.substr(0, Te) + Qt[Te] + Qt.substr(Te + 1) : Xt(Jt[Te], oe[Te]) < 0 ? Jt.substr(0, Te) + oe[Te] + Qt.substr(Te + 1) : 0 <= Ae ? Jt.substr(0, Ae) + qt[Ae] + Qt.substr(Ae + 1) : null;
                Xt(Jt[Te], Or) < 0 && (Ae = Te);
              }
              return ve < oe.length && ue === "next" ? Jt + Qt.substr(Jt.length) : ve < Jt.length && ue === "prev" ? Jt.substr(0, Qt.length) : Ae < 0 ? null : Jt.substr(0, Ae) + oe[Ae] + Qt.substr(Ae + 1);
            }(xt, kt, it[Pt], ut[Pt], nt, ht);
            Gt === null && Et === null ? dt = Pt + 1 : (Et === null || 0 < nt(Et, Gt)) && (Et = Gt);
          }
          return _t(Et !== null ? function() {
            pt.continue(Et + mt);
          } : ft), !1;
        }), y;
      }
      function Yi(y, A, P, U) {
        return { type: 2, lower: y, upper: A, lowerOpen: P, upperOpen: U };
      }
      function pu(y) {
        return { type: 1, lower: y, upper: y };
      }
      var Ml = (Object.defineProperty(Wn.prototype, "Collection", { get: function() {
        return this._ctx.table.db.Collection;
      }, enumerable: !1, configurable: !0 }), Wn.prototype.between = function(y, A, P, U) {
        P = P !== !1, U = U === !0;
        try {
          return 0 < this._cmp(y, A) || this._cmp(y, A) === 0 && (P || U) && (!P || !U) ? Gs(this) : new this.Collection(this, function() {
            return Yi(y, A, !P, !U);
          });
        } catch {
          return xr(this, Qr);
        }
      }, Wn.prototype.equals = function(y) {
        return y == null ? xr(this, Qr) : new this.Collection(this, function() {
          return pu(y);
        });
      }, Wn.prototype.above = function(y) {
        return y == null ? xr(this, Qr) : new this.Collection(this, function() {
          return Yi(y, void 0, !0);
        });
      }, Wn.prototype.aboveOrEqual = function(y) {
        return y == null ? xr(this, Qr) : new this.Collection(this, function() {
          return Yi(y, void 0, !1);
        });
      }, Wn.prototype.below = function(y) {
        return y == null ? xr(this, Qr) : new this.Collection(this, function() {
          return Yi(void 0, y, !1, !0);
        });
      }, Wn.prototype.belowOrEqual = function(y) {
        return y == null ? xr(this, Qr) : new this.Collection(this, function() {
          return Yi(void 0, y);
        });
      }, Wn.prototype.startsWith = function(y) {
        return typeof y != "string" ? xr(this, El) : this.between(y, y + ci, !0, !0);
      }, Wn.prototype.startsWithIgnoreCase = function(y) {
        return y === "" ? this.startsWith(y) : _a(this, function(A, P) {
          return A.indexOf(P[0]) === 0;
        }, [y], ci);
      }, Wn.prototype.equalsIgnoreCase = function(y) {
        return _a(this, function(A, P) {
          return A === P[0];
        }, [y], "");
      }, Wn.prototype.anyOfIgnoreCase = function() {
        var y = V.apply(Y, arguments);
        return y.length === 0 ? Gs(this) : _a(this, function(A, P) {
          return P.indexOf(A) !== -1;
        }, y, "");
      }, Wn.prototype.startsWithAnyOfIgnoreCase = function() {
        var y = V.apply(Y, arguments);
        return y.length === 0 ? Gs(this) : _a(this, function(A, P) {
          return P.some(function(U) {
            return A.indexOf(U) === 0;
          });
        }, y, ci);
      }, Wn.prototype.anyOf = function() {
        var y = this, A = V.apply(Y, arguments), P = this._cmp;
        try {
          A.sort(P);
        } catch {
          return xr(this, Qr);
        }
        if (A.length === 0) return Gs(this);
        var U = new this.Collection(this, function() {
          return Yi(A[0], A[A.length - 1]);
        });
        U._ondirectionchange = function($) {
          P = $ === "next" ? y._ascending : y._descending, A.sort(P);
        };
        var q = 0;
        return U._addAlgorithm(function($, nt, it) {
          for (var ut = $.key; 0 < P(ut, A[q]); ) if (++q === A.length) return nt(it), !1;
          return P(ut, A[q]) === 0 || (nt(function() {
            $.continue(A[q]);
          }), !1);
        }), U;
      }, Wn.prototype.notEqual = function(y) {
        return this.inAnyRange([[-1 / 0, y], [y, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 });
      }, Wn.prototype.noneOf = function() {
        var y = V.apply(Y, arguments);
        if (y.length === 0) return new this.Collection(this);
        try {
          y.sort(this._ascending);
        } catch {
          return xr(this, Qr);
        }
        var A = y.reduce(function(P, U) {
          return P ? P.concat([[P[P.length - 1][1], U]]) : [[-1 / 0, U]];
        }, null);
        return A.push([y[y.length - 1], this.db._maxKey]), this.inAnyRange(A, { includeLowers: !1, includeUppers: !1 });
      }, Wn.prototype.inAnyRange = function(xt, A) {
        var P = this, U = this._cmp, q = this._ascending, $ = this._descending, nt = this._min, it = this._max;
        if (xt.length === 0) return Gs(this);
        if (!xt.every(function(kt) {
          return kt[0] !== void 0 && kt[1] !== void 0 && q(kt[0], kt[1]) <= 0;
        })) return xr(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", ot.InvalidArgument);
        var ut = !A || A.includeLowers !== !1, ht = A && A.includeUppers === !0, mt, at = q;
        function gt(kt, Et) {
          return at(kt[0], Et[0]);
        }
        try {
          (mt = xt.reduce(function(kt, Et) {
            for (var Pt = 0, Gt = kt.length; Pt < Gt; ++Pt) {
              var Jt = kt[Pt];
              if (U(Et[0], Jt[1]) < 0 && 0 < U(Et[1], Jt[0])) {
                Jt[0] = nt(Jt[0], Et[0]), Jt[1] = it(Jt[1], Et[1]);
                break;
              }
            }
            return Pt === Gt && kt.push(Et), kt;
          }, [])).sort(gt);
        } catch {
          return xr(this, Qr);
        }
        var dt = 0, pt = ht ? function(kt) {
          return 0 < q(kt, mt[dt][1]);
        } : function(kt) {
          return 0 <= q(kt, mt[dt][1]);
        }, _t = ut ? function(kt) {
          return 0 < $(kt, mt[dt][0]);
        } : function(kt) {
          return 0 <= $(kt, mt[dt][0]);
        }, ft = pt, xt = new this.Collection(this, function() {
          return Yi(mt[0][0], mt[mt.length - 1][1], !ut, !ht);
        });
        return xt._ondirectionchange = function(kt) {
          at = kt === "next" ? (ft = pt, q) : (ft = _t, $), mt.sort(gt);
        }, xt._addAlgorithm(function(kt, Et, Pt) {
          for (var Gt, Jt = kt.key; ft(Jt); ) if (++dt === mt.length) return Et(Pt), !1;
          return !pt(Gt = Jt) && !_t(Gt) || (P._cmp(Jt, mt[dt][1]) === 0 || P._cmp(Jt, mt[dt][0]) === 0 || Et(function() {
            at === q ? kt.continue(mt[dt][0]) : kt.continue(mt[dt][1]);
          }), !1);
        }), xt;
      }, Wn.prototype.startsWithAnyOf = function() {
        var y = V.apply(Y, arguments);
        return y.every(function(A) {
          return typeof A == "string";
        }) ? y.length === 0 ? Gs(this) : this.inAnyRange(y.map(function(A) {
          return [A, A + ci];
        })) : xr(this, "startsWithAnyOf() only works with strings");
      }, Wn);
      function Wn() {
      }
      function ui(y) {
        return dn(function(A) {
          return qs(A), y(A.target.error), !1;
        });
      }
      function qs(y) {
        y.stopPropagation && y.stopPropagation(), y.preventDefault && y.preventDefault();
      }
      var ko = "storagemutated", Ol = "x-storagemutated-1", Xi = Co(null, ko), mu = (di.prototype._lock = function() {
        return C(!zt.global), ++this._reculock, this._reculock !== 1 || zt.global || (zt.lockOwnerFor = this), this;
      }, di.prototype._unlock = function() {
        if (C(!zt.global), --this._reculock == 0) for (zt.global || (zt.lockOwnerFor = null); 0 < this._blockedFuncs.length && !this._locked(); ) {
          var y = this._blockedFuncs.shift();
          try {
            Ki(y[1], y[0]);
          } catch {
          }
        }
        return this;
      }, di.prototype._locked = function() {
        return this._reculock && zt.lockOwnerFor !== this;
      }, di.prototype.create = function(y) {
        var A = this;
        if (!this.mode) return this;
        var P = this.db.idbdb, U = this.db._state.dbOpenError;
        if (C(!this.idbtrans), !y && !P) switch (U && U.name) {
          case "DatabaseClosedError":
            throw new ot.DatabaseClosed(U);
          case "MissingAPIError":
            throw new ot.MissingAPI(U.message, U);
          default:
            throw new ot.OpenFailed(U);
        }
        if (!this.active) throw new ot.TransactionInactive();
        return C(this._completion._state === null), (y = this.idbtrans = y || (this.db.core || P).transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })).onerror = dn(function(q) {
          qs(q), A._reject(y.error);
        }), y.onabort = dn(function(q) {
          qs(q), A.active && A._reject(new ot.Abort(y.error)), A.active = !1, A.on("abort").fire(q);
        }), y.oncomplete = dn(function() {
          A.active = !1, A._resolve(), "mutatedParts" in y && Xi.storagemutated.fire(y.mutatedParts);
        }), this;
      }, di.prototype._promise = function(y, A, P) {
        var U = this;
        if (y === "readwrite" && this.mode !== "readwrite") return Me(new ot.ReadOnly("Transaction is readonly"));
        if (!this.active) return Me(new ot.TransactionInactive());
        if (this._locked()) return new se(function($, nt) {
          U._blockedFuncs.push([function() {
            U._promise(y, A, P).then($, nt);
          }, zt]);
        });
        if (P) return an(function() {
          var $ = new se(function(nt, it) {
            U._lock();
            var ut = A(nt, it, U);
            ut && ut.then && ut.then(nt, it);
          });
          return $.finally(function() {
            return U._unlock();
          }), $._lib = !0, $;
        });
        var q = new se(function($, nt) {
          var it = A($, nt, U);
          it && it.then && it.then($, nt);
        });
        return q._lib = !0, q;
      }, di.prototype._root = function() {
        return this.parent ? this.parent._root() : this;
      }, di.prototype.waitFor = function(y) {
        var A, P = this._root(), U = se.resolve(y);
        P._waitingFor ? P._waitingFor = P._waitingFor.then(function() {
          return U;
        }) : (P._waitingFor = U, P._waitingQueue = [], A = P.idbtrans.objectStore(P.storeNames[0]), function $() {
          for (++P._spinCount; P._waitingQueue.length; ) P._waitingQueue.shift()();
          P._waitingFor && (A.get(-1 / 0).onsuccess = $);
        }());
        var q = P._waitingFor;
        return new se(function($, nt) {
          U.then(function(it) {
            return P._waitingQueue.push(dn($.bind(null, it)));
          }, function(it) {
            return P._waitingQueue.push(dn(nt.bind(null, it)));
          }).finally(function() {
            P._waitingFor === q && (P._waitingFor = null);
          });
        });
      }, di.prototype.abort = function() {
        this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new ot.Abort()));
      }, di.prototype.table = function(y) {
        var A = this._memoizedTables || (this._memoizedTables = {});
        if (p(A, y)) return A[y];
        var P = this.schema[y];
        if (!P) throw new ot.NotFound("Table " + y + " not part of transaction");
        return P = new this.db.Table(y, P, this), P.core = this.db.core.table(y), A[y] = P;
      }, di);
      function di() {
      }
      function Nl(y, A, P, U, q, $, nt) {
        return { name: y, keyPath: A, unique: P, multi: U, auto: q, compound: $, src: (P && !nt ? "&" : "") + (U ? "*" : "") + (q ? "++" : "") + jh(A) };
      }
      function jh(y) {
        return typeof y == "string" ? y : y ? "[" + [].join.call(y, "+") + "]" : "";
      }
      function gu(y, A, P) {
        return { name: y, primKey: A, indexes: P, mappedClass: null, idxByName: (U = function(q) {
          return [q.name, q];
        }, P.reduce(function(q, $, nt) {
          return nt = U($, nt), nt && (q[nt[0]] = nt[1]), q;
        }, {})) };
        var U;
      }
      var Ro = function(y) {
        try {
          return y.only([[]]), Ro = function() {
            return [[]];
          }, [[]];
        } catch {
          return Ro = function() {
            return ci;
          }, ci;
        }
      };
      function Hs(y) {
        return y == null ? function() {
        } : typeof y == "string" ? (A = y).split(".").length === 1 ? function(P) {
          return P[A];
        } : function(P) {
          return O(P, A);
        } : function(P) {
          return O(P, y);
        };
        var A;
      }
      function Pl(y) {
        return [].slice.call(y);
      }
      var Dl = 0;
      function Mo(y) {
        return y == null ? ":id" : typeof y == "string" ? y : "[".concat(y.join("+"), "]");
      }
      function Lh(y, A, ut) {
        function U(ft) {
          if (ft.type === 3) return null;
          if (ft.type === 4) throw new Error("Cannot convert never type to IDBKeyRange");
          var dt = ft.lower, pt = ft.upper, _t = ft.lowerOpen, ft = ft.upperOpen;
          return dt === void 0 ? pt === void 0 ? null : A.upperBound(pt, !!ft) : pt === void 0 ? A.lowerBound(dt, !!_t) : A.bound(dt, pt, !!_t, !!ft);
        }
        function q(gt) {
          var dt, pt = gt.name;
          return { name: pt, schema: gt, mutate: function(_t) {
            var ft = _t.trans, xt = _t.type, kt = _t.keys, Et = _t.values, Pt = _t.range;
            return new Promise(function(Gt, Jt) {
              Gt = dn(Gt);
              var qt = ft.objectStore(pt), Qt = qt.keyPath == null, oe = xt === "put" || xt === "add";
              if (!oe && xt !== "delete" && xt !== "deleteRange") throw new Error("Invalid operation type: " + xt);
              var Xt, ue = (kt || Et || { length: 1 }).length;
              if (kt && Et && kt.length !== Et.length) throw new Error("Given keys array must have same length as given values array.");
              if (ue === 0) return Gt({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
              function ve(pr) {
                ++Or, qs(pr);
              }
              var Ae = [], Te = [], Or = 0;
              if (xt === "deleteRange") {
                if (Pt.type === 4) return Gt({ numFailures: Or, failures: Te, results: [], lastResult: void 0 });
                Pt.type === 3 ? Ae.push(Xt = qt.clear()) : Ae.push(Xt = qt.delete(U(Pt)));
              } else {
                var Qt = oe ? Qt ? [Et, kt] : [Et, null] : [kt, null], Ce = Qt[0], Bn = Qt[1];
                if (oe) for (var ir = 0; ir < ue; ++ir) Ae.push(Xt = Bn && Bn[ir] !== void 0 ? qt[xt](Ce[ir], Bn[ir]) : qt[xt](Ce[ir])), Xt.onerror = ve;
                else for (ir = 0; ir < ue; ++ir) Ae.push(Xt = qt[xt](Ce[ir])), Xt.onerror = ve;
              }
              function Qs(pr) {
                pr = pr.target.result, Ae.forEach(function(ns, Da) {
                  return ns.error != null && (Te[Da] = ns.error);
                }), Gt({ numFailures: Or, failures: Te, results: xt === "delete" ? kt : Ae.map(function(ns) {
                  return ns.result;
                }), lastResult: pr });
              }
              Xt.onerror = function(pr) {
                ve(pr), Qs(pr);
              }, Xt.onsuccess = Qs;
            });
          }, getMany: function(_t) {
            var ft = _t.trans, xt = _t.keys;
            return new Promise(function(kt, Et) {
              kt = dn(kt);
              for (var Pt, Gt = ft.objectStore(pt), Jt = xt.length, qt = new Array(Jt), Qt = 0, oe = 0, Xt = function(Ae) {
                Ae = Ae.target, qt[Ae._pos] = Ae.result, ++oe === Qt && kt(qt);
              }, ue = ui(Et), ve = 0; ve < Jt; ++ve) xt[ve] != null && ((Pt = Gt.get(xt[ve]))._pos = ve, Pt.onsuccess = Xt, Pt.onerror = ue, ++Qt);
              Qt === 0 && kt(qt);
            });
          }, get: function(_t) {
            var ft = _t.trans, xt = _t.key;
            return new Promise(function(kt, Et) {
              kt = dn(kt);
              var Pt = ft.objectStore(pt).get(xt);
              Pt.onsuccess = function(Gt) {
                return kt(Gt.target.result);
              }, Pt.onerror = ui(Et);
            });
          }, query: (dt = ht, function(_t) {
            return new Promise(function(ft, xt) {
              ft = dn(ft);
              var kt, Et, Pt, Qt = _t.trans, Gt = _t.values, Jt = _t.limit, Xt = _t.query, qt = Jt === 1 / 0 ? void 0 : Jt, oe = Xt.index, Xt = Xt.range, Qt = Qt.objectStore(pt), oe = oe.isPrimaryKey ? Qt : Qt.index(oe.name), Xt = U(Xt);
              if (Jt === 0) return ft({ result: [] });
              dt ? ((qt = Gt ? oe.getAll(Xt, qt) : oe.getAllKeys(Xt, qt)).onsuccess = function(ue) {
                return ft({ result: ue.target.result });
              }, qt.onerror = ui(xt)) : (kt = 0, Et = !Gt && "openKeyCursor" in oe ? oe.openKeyCursor(Xt) : oe.openCursor(Xt), Pt = [], Et.onsuccess = function(ue) {
                var ve = Et.result;
                return ve ? (Pt.push(Gt ? ve.value : ve.primaryKey), ++kt === Jt ? ft({ result: Pt }) : void ve.continue()) : ft({ result: Pt });
              }, Et.onerror = ui(xt));
            });
          }), openCursor: function(_t) {
            var ft = _t.trans, xt = _t.values, kt = _t.query, Et = _t.reverse, Pt = _t.unique;
            return new Promise(function(Gt, Jt) {
              Gt = dn(Gt);
              var oe = kt.index, qt = kt.range, Qt = ft.objectStore(pt), Qt = oe.isPrimaryKey ? Qt : Qt.index(oe.name), oe = Et ? Pt ? "prevunique" : "prev" : Pt ? "nextunique" : "next", Xt = !xt && "openKeyCursor" in Qt ? Qt.openKeyCursor(U(qt), oe) : Qt.openCursor(U(qt), oe);
              Xt.onerror = ui(Jt), Xt.onsuccess = dn(function(ue) {
                var ve, Ae, Te, Or, Ce = Xt.result;
                Ce ? (Ce.___id = ++Dl, Ce.done = !1, ve = Ce.continue.bind(Ce), Ae = (Ae = Ce.continuePrimaryKey) && Ae.bind(Ce), Te = Ce.advance.bind(Ce), Or = function() {
                  throw new Error("Cursor not stopped");
                }, Ce.trans = ft, Ce.stop = Ce.continue = Ce.continuePrimaryKey = Ce.advance = function() {
                  throw new Error("Cursor not started");
                }, Ce.fail = dn(Jt), Ce.next = function() {
                  var Bn = this, ir = 1;
                  return this.start(function() {
                    return ir-- ? Bn.continue() : Bn.stop();
                  }).then(function() {
                    return Bn;
                  });
                }, Ce.start = function(Bn) {
                  function ir() {
                    if (Xt.result) try {
                      Bn();
                    } catch (pr) {
                      Ce.fail(pr);
                    }
                    else Ce.done = !0, Ce.start = function() {
                      throw new Error("Cursor behind last entry");
                    }, Ce.stop();
                  }
                  var Qs = new Promise(function(pr, ns) {
                    pr = dn(pr), Xt.onerror = ui(ns), Ce.fail = ns, Ce.stop = function(Da) {
                      Ce.stop = Ce.continue = Ce.continuePrimaryKey = Ce.advance = Or, pr(Da);
                    };
                  });
                  return Xt.onsuccess = dn(function(pr) {
                    Xt.onsuccess = ir, ir();
                  }), Ce.continue = ve, Ce.continuePrimaryKey = Ae, Ce.advance = Te, ir(), Qs;
                }, Gt(Ce)) : Gt(null);
              }, Jt);
            });
          }, count: function(_t) {
            var ft = _t.query, xt = _t.trans, kt = ft.index, Et = ft.range;
            return new Promise(function(Pt, Gt) {
              var Jt = xt.objectStore(pt), qt = kt.isPrimaryKey ? Jt : Jt.index(kt.name), Jt = U(Et), qt = Jt ? qt.count(Jt) : qt.count();
              qt.onsuccess = dn(function(Qt) {
                return Pt(Qt.target.result);
              }), qt.onerror = ui(Gt);
            });
          } };
        }
        var $, nt, it, mt = (nt = ut, it = Pl(($ = y).objectStoreNames), { schema: { name: $.name, tables: it.map(function(gt) {
          return nt.objectStore(gt);
        }).map(function(gt) {
          var dt = gt.keyPath, ft = gt.autoIncrement, pt = c(dt), _t = {}, ft = { name: gt.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: dt == null, compound: pt, keyPath: dt, autoIncrement: ft, unique: !0, extractKey: Hs(dt) }, indexes: Pl(gt.indexNames).map(function(xt) {
            return gt.index(xt);
          }).map(function(Pt) {
            var kt = Pt.name, Et = Pt.unique, Gt = Pt.multiEntry, Pt = Pt.keyPath, Gt = { name: kt, compound: c(Pt), keyPath: Pt, unique: Et, multiEntry: Gt, extractKey: Hs(Pt) };
            return _t[Mo(Pt)] = Gt;
          }), getIndexByKeyPath: function(xt) {
            return _t[Mo(xt)];
          } };
          return _t[":id"] = ft.primaryKey, dt != null && (_t[Mo(dt)] = ft.primaryKey), ft;
        }) }, hasGetAll: 0 < it.length && "getAll" in nt.objectStore(it[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) }), ut = mt.schema, ht = mt.hasGetAll, mt = ut.tables.map(q), at = {};
        return mt.forEach(function(gt) {
          return at[gt.name] = gt;
        }), { stack: "dbcore", transaction: y.transaction.bind(y), table: function(gt) {
          if (!at[gt]) throw new Error("Table '".concat(gt, "' not found"));
          return at[gt];
        }, MIN_KEY: -1 / 0, MAX_KEY: Ro(A), schema: ut };
      }
      function yu(y, A, P, U) {
        var q = P.IDBKeyRange;
        return P.indexedDB, { dbcore: (U = Lh(A, q, U), y.dbcore.reduce(function($, nt) {
          return nt = nt.create, r(r({}, $), nt($));
        }, U)) };
      }
      function Sa(y, U) {
        var P = U.db, U = yu(y._middlewares, P, y._deps, U);
        y.core = U.dbcore, y.tables.forEach(function(q) {
          var $ = q.name;
          y.core.schema.tables.some(function(nt) {
            return nt.name === $;
          }) && (q.core = y.core.table($), y[$] instanceof y.Table && (y[$].core = q.core));
        });
      }
      function xa(y, A, P, U) {
        P.forEach(function(q) {
          var $ = U[q];
          A.forEach(function(nt) {
            var it = function ut(ht, mt) {
              return x(ht, mt) || (ht = d(ht)) && ut(ht, mt);
            }(nt, q);
            (!it || "value" in it && it.value === void 0) && (nt === y.Transaction.prototype || nt instanceof y.Transaction ? g(nt, q, { get: function() {
              return this.table(q);
            }, set: function(ut) {
              m(this, q, { value: ut, writable: !0, configurable: !0, enumerable: !0 });
            } }) : nt[q] = new y.Table(q, $));
          });
        });
      }
      function Qi(y, A) {
        A.forEach(function(P) {
          for (var U in P) P[U] instanceof y.Table && delete P[U];
        });
      }
      function Il(y, A) {
        return y._cfg.version - A._cfg.version;
      }
      function zh(y, A, P, U) {
        var q = y._dbSchema;
        P.objectStoreNames.contains("$meta") && !q.$meta && (q.$meta = gu("$meta", bu("")[0], []), y._storeNames.push("$meta"));
        var $ = y._createTransaction("readwrite", y._storeNames, q);
        $.create(P), $._completion.catch(U);
        var nt = $._reject.bind($), it = zt.transless || zt;
        an(function() {
          return zt.trans = $, zt.transless = it, A !== 0 ? (Sa(y, P), ht = A, ((ut = $).storeNames.includes("$meta") ? ut.table("$meta").get("version").then(function(mt) {
            return mt ?? ht;
          }) : se.resolve(ht)).then(function(mt) {
            return gt = mt, dt = $, pt = P, _t = [], mt = (at = y)._versions, ft = at._dbSchema = Ta(0, at.idbdb, pt), (mt = mt.filter(function(xt) {
              return xt._cfg.version >= gt;
            })).length !== 0 ? (mt.forEach(function(xt) {
              _t.push(function() {
                var kt = ft, Et = xt._cfg.dbschema;
                Ca(at, kt, pt), Ca(at, Et, pt), ft = at._dbSchema = Et;
                var Pt = Bl(kt, Et);
                Pt.add.forEach(function(oe) {
                  Fl(pt, oe[0], oe[1].primKey, oe[1].indexes);
                }), Pt.change.forEach(function(oe) {
                  if (oe.recreate) throw new ot.Upgrade("Not yet support for changing primary key");
                  var Xt = pt.objectStore(oe.name);
                  oe.add.forEach(function(ue) {
                    return In(Xt, ue);
                  }), oe.change.forEach(function(ue) {
                    Xt.deleteIndex(ue.name), In(Xt, ue);
                  }), oe.del.forEach(function(ue) {
                    return Xt.deleteIndex(ue);
                  });
                });
                var Gt = xt._cfg.contentUpgrade;
                if (Gt && xt._cfg.version > gt) {
                  Sa(at, pt), dt._memoizedTables = {};
                  var Jt = N(Et);
                  Pt.del.forEach(function(oe) {
                    Jt[oe] = kt[oe];
                  }), Qi(at, [at.Transaction.prototype]), xa(at, [at.Transaction.prototype], l(Jt), Jt), dt.schema = Jt;
                  var qt, Qt = Z(Gt);
                  return Qt && ps(), Pt = se.follow(function() {
                    var oe;
                    (qt = Gt(dt)) && Qt && (oe = Mi.bind(null, null), qt.then(oe, oe));
                  }), qt && typeof qt.then == "function" ? se.resolve(qt) : Pt.then(function() {
                    return qt;
                  });
                }
              }), _t.push(function(kt) {
                var Et, Pt, Gt = xt._cfg.dbschema;
                Et = Gt, Pt = kt, [].slice.call(Pt.db.objectStoreNames).forEach(function(Jt) {
                  return Et[Jt] == null && Pt.db.deleteObjectStore(Jt);
                }), Qi(at, [at.Transaction.prototype]), xa(at, [at.Transaction.prototype], at._storeNames, at._dbSchema), dt.schema = at._dbSchema;
              }), _t.push(function(kt) {
                at.idbdb.objectStoreNames.contains("$meta") && (Math.ceil(at.idbdb.version / 10) === xt._cfg.version ? (at.idbdb.deleteObjectStore("$meta"), delete at._dbSchema.$meta, at._storeNames = at._storeNames.filter(function(Et) {
                  return Et !== "$meta";
                })) : kt.objectStore("$meta").put(xt._cfg.version, "version"));
              });
            }), function xt() {
              return _t.length ? se.resolve(_t.shift()(dt.idbtrans)).then(xt) : se.resolve();
            }().then(function() {
              Uh(ft, pt);
            })) : se.resolve();
            var at, gt, dt, pt, _t, ft;
          }).catch(nt)) : (l(q).forEach(function(mt) {
            Fl(P, mt, q[mt].primKey, q[mt].indexes);
          }), Sa(y, P), void se.follow(function() {
            return y.on.populate.fire($);
          }).catch(nt));
          var ut, ht;
        });
      }
      function vu(y, A) {
        Uh(y._dbSchema, A), A.db.version % 10 != 0 || A.objectStoreNames.contains("$meta") || A.db.createObjectStore("$meta").add(Math.ceil(A.db.version / 10 - 1), "version");
        var P = Ta(0, y.idbdb, A);
        Ca(y, y._dbSchema, A);
        for (var U = 0, q = Bl(P, y._dbSchema).change; U < q.length; U++) {
          var $ = function(nt) {
            if (nt.change.length || nt.recreate) return console.warn("Unable to patch indexes of table ".concat(nt.name, " because it has changes on the type of index or primary key.")), { value: void 0 };
            var it = A.objectStore(nt.name);
            nt.add.forEach(function(ut) {
              le && console.debug("Dexie upgrade patch: Creating missing index ".concat(nt.name, ".").concat(ut.src)), In(it, ut);
            });
          }(q[U]);
          if (typeof $ == "object") return $.value;
        }
      }
      function Bl(y, A) {
        var P, U = { del: [], add: [], change: [] };
        for (P in y) A[P] || U.del.push(P);
        for (P in A) {
          var q = y[P], $ = A[P];
          if (q) {
            var nt = { name: P, def: $, recreate: !1, del: [], add: [], change: [] };
            if ("" + (q.primKey.keyPath || "") != "" + ($.primKey.keyPath || "") || q.primKey.auto !== $.primKey.auto) nt.recreate = !0, U.change.push(nt);
            else {
              var it = q.idxByName, ut = $.idxByName, ht = void 0;
              for (ht in it) ut[ht] || nt.del.push(ht);
              for (ht in ut) {
                var mt = it[ht], at = ut[ht];
                mt ? mt.src !== at.src && nt.change.push(at) : nt.add.push(at);
              }
              (0 < nt.del.length || 0 < nt.add.length || 0 < nt.change.length) && U.change.push(nt);
            }
          } else U.add.push([P, $]);
        }
        return U;
      }
      function Fl(y, A, P, U) {
        var q = y.db.createObjectStore(A, P.keyPath ? { keyPath: P.keyPath, autoIncrement: P.auto } : { autoIncrement: P.auto });
        return U.forEach(function($) {
          return In(q, $);
        }), q;
      }
      function Uh(y, A) {
        l(y).forEach(function(P) {
          A.db.objectStoreNames.contains(P) || (le && console.debug("Dexie: Creating missing table", P), Fl(A, P, y[P].primKey, y[P].indexes));
        });
      }
      function In(y, A) {
        y.createIndex(A.name, A.keyPath, { unique: A.unique, multiEntry: A.multi });
      }
      function Ta(y, A, P) {
        var U = {};
        return T(A.objectStoreNames, 0).forEach(function(q) {
          for (var $ = P.objectStore(q), nt = Nl(jh(ht = $.keyPath), ht || "", !0, !1, !!$.autoIncrement, ht && typeof ht != "string", !0), it = [], ut = 0; ut < $.indexNames.length; ++ut) {
            var mt = $.index($.indexNames[ut]), ht = mt.keyPath, mt = Nl(mt.name, ht, !!mt.unique, !!mt.multiEntry, !1, ht && typeof ht != "string", !1);
            it.push(mt);
          }
          U[q] = gu(q, nt, it);
        }), U;
      }
      function Ca(y, A, P) {
        for (var U = P.db.objectStoreNames, q = 0; q < U.length; ++q) {
          var $ = U[q], nt = P.objectStore($);
          y._hasGetAll = "getAll" in nt;
          for (var it = 0; it < nt.indexNames.length; ++it) {
            var ut = nt.indexNames[it], ht = nt.index(ut).keyPath, mt = typeof ht == "string" ? ht : "[" + T(ht).join("+") + "]";
            !A[$] || (ht = A[$].idxByName[mt]) && (ht.name = ut, delete A[$].idxByName[mt], A[$].idxByName[ut] = ht);
          }
        }
        typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && s.WorkerGlobalScope && s instanceof s.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (y._hasGetAll = !1);
      }
      function bu(y) {
        return y.split(",").map(function(A, P) {
          var U = (A = A.trim()).replace(/([&*]|\+\+)/g, ""), q = /^\[/.test(U) ? U.match(/^\[(.*)\]$/)[1].split("+") : U;
          return Nl(U, q || null, /\&/.test(A), /\*/.test(A), /\+\+/.test(A), c(q), P === 0);
        });
      }
      var Vh = (wa.prototype._parseStoresSpec = function(y, A) {
        l(y).forEach(function(P) {
          if (y[P] !== null) {
            var U = bu(y[P]), q = U.shift();
            if (q.unique = !0, q.multi) throw new ot.Schema("Primary key cannot be multi-valued");
            U.forEach(function($) {
              if ($.auto) throw new ot.Schema("Only primary key can be marked as autoIncrement (++)");
              if (!$.keyPath) throw new ot.Schema("Index must have a name and cannot be an empty string");
            }), A[P] = gu(P, q, U);
          }
        });
      }, wa.prototype.stores = function(P) {
        var A = this.db;
        this._cfg.storesSource = this._cfg.storesSource ? u(this._cfg.storesSource, P) : P;
        var P = A._versions, U = {}, q = {};
        return P.forEach(function($) {
          u(U, $._cfg.storesSource), q = $._cfg.dbschema = {}, $._parseStoresSpec(U, q);
        }), A._dbSchema = q, Qi(A, [A._allTables, A, A.Transaction.prototype]), xa(A, [A._allTables, A, A.Transaction.prototype, this._cfg.tables], l(q), q), A._storeNames = l(q), this;
      }, wa.prototype.upgrade = function(y) {
        return this._cfg.contentUpgrade = re(this._cfg.contentUpgrade || bt, y), this;
      }, wa);
      function wa() {
      }
      function Ws(y, A) {
        var P = y._dbNamesDB;
        return P || (P = y._dbNamesDB = new fi(Us, { addons: [], indexedDB: y, IDBKeyRange: A })).version(1).stores({ dbnames: "name" }), P.table("dbnames");
      }
      function Ea(y) {
        return y && typeof y.databases == "function";
      }
      function jl(y) {
        return an(function() {
          return zt.letThrough = !0, y();
        });
      }
      function Ll(y) {
        return !("from" in y);
      }
      var rr = function(y, A) {
        if (!this) {
          var P = new rr();
          return y && "d" in y && u(P, y), P;
        }
        u(this, arguments.length ? { d: 1, from: y, to: 1 < arguments.length ? A : y } : { d: 0 });
      };
      function $s(y, A, P) {
        var U = ze(A, P);
        if (!isNaN(U)) {
          if (0 < U) throw RangeError();
          if (Ll(y)) return u(y, { from: A, to: P, d: 1 });
          var q = y.l, U = y.r;
          if (ze(P, y.from) < 0) return q ? $s(q, A, P) : y.l = { from: A, to: P, d: 1, l: null, r: null }, zl(y);
          if (0 < ze(A, y.to)) return U ? $s(U, A, P) : y.r = { from: A, to: P, d: 1, l: null, r: null }, zl(y);
          ze(A, y.from) < 0 && (y.from = A, y.l = null, y.d = U ? U.d + 1 : 1), 0 < ze(P, y.to) && (y.to = P, y.r = null, y.d = y.l ? y.l.d + 1 : 1), P = !y.r, q && !y.l && Ks(y, q), U && P && Ks(y, U);
        }
      }
      function Ks(y, A) {
        Ll(A) || function P(U, ut) {
          var $ = ut.from, nt = ut.to, it = ut.l, ut = ut.r;
          $s(U, $, nt), it && P(U, it), ut && P(U, ut);
        }(y, A);
      }
      function _u(y, A) {
        var P = Oo(A), U = P.next();
        if (U.done) return !1;
        for (var q = U.value, $ = Oo(y), nt = $.next(q.from), it = nt.value; !U.done && !nt.done; ) {
          if (ze(it.from, q.to) <= 0 && 0 <= ze(it.to, q.from)) return !0;
          ze(q.from, it.from) < 0 ? q = (U = P.next(it.from)).value : it = (nt = $.next(q.from)).value;
        }
        return !1;
      }
      function Oo(y) {
        var A = Ll(y) ? null : { s: 0, n: y };
        return { next: function(P) {
          for (var U = 0 < arguments.length; A; ) switch (A.s) {
            case 0:
              if (A.s = 1, U) for (; A.n.l && ze(P, A.n.from) < 0; ) A = { up: A, n: A.n.l, s: 1 };
              else for (; A.n.l; ) A = { up: A, n: A.n.l, s: 1 };
            case 1:
              if (A.s = 2, !U || ze(P, A.n.to) <= 0) return { value: A.n, done: !1 };
            case 2:
              if (A.n.r) {
                A.s = 3, A = { up: A, n: A.n.r, s: 0 };
                continue;
              }
            case 3:
              A = A.up;
          }
          return { done: !0 };
        } };
      }
      function zl(y) {
        var A, P, U = (((A = y.r) === null || A === void 0 ? void 0 : A.d) || 0) - (((P = y.l) === null || P === void 0 ? void 0 : P.d) || 0), q = 1 < U ? "r" : U < -1 ? "l" : "";
        q && (A = q == "r" ? "l" : "r", P = r({}, y), U = y[q], y.from = U.from, y.to = U.to, y[q] = U[q], P[q] = U[A], (y[A] = P).d = Ul(P)), y.d = Ul(y);
      }
      function Ul(P) {
        var A = P.r, P = P.l;
        return (A ? P ? Math.max(A.d, P.d) : A.d : P ? P.d : 0) + 1;
      }
      function Aa(y, A) {
        return l(A).forEach(function(P) {
          y[P] ? Ks(y[P], A[P]) : y[P] = function U(q) {
            var $, nt, it = {};
            for ($ in q) p(q, $) && (nt = q[$], it[$] = !nt || typeof nt != "object" || F.has(nt.constructor) ? nt : U(nt));
            return it;
          }(A[P]);
        }), y;
      }
      function ka(y, A) {
        return y.all || A.all || Object.keys(y).some(function(P) {
          return A[P] && _u(A[P], y[P]);
        });
      }
      v(rr.prototype, ((fr = { add: function(y) {
        return Ks(this, y), this;
      }, addKey: function(y) {
        return $s(this, y, y), this;
      }, addKeys: function(y) {
        var A = this;
        return y.forEach(function(P) {
          return $s(A, P, P);
        }), this;
      }, hasKey: function(y) {
        var A = Oo(this).next(y).value;
        return A && ze(A.from, y) <= 0 && 0 <= ze(A.to, y);
      } })[z] = function() {
        return Oo(this);
      }, fr));
      var ys = {}, hi = {}, Ra = !1;
      function Vl(y) {
        Aa(hi, y), Ra || (Ra = !0, setTimeout(function() {
          Ra = !1, Gl(hi, !(hi = {}));
        }, 0));
      }
      function Gl(y, A) {
        A === void 0 && (A = !1);
        var P = /* @__PURE__ */ new Set();
        if (y.all) for (var U = 0, q = Object.values(ys); U < q.length; U++) Zi(nt = q[U], y, P, A);
        else for (var $ in y) {
          var nt, it = /^idb\:\/\/(.*)\/(.*)\//.exec($);
          it && ($ = it[1], it = it[2], (nt = ys["idb://".concat($, "/").concat(it)]) && Zi(nt, y, P, A));
        }
        P.forEach(function(ut) {
          return ut();
        });
      }
      function Zi(y, A, P, U) {
        for (var q = [], $ = 0, nt = Object.entries(y.queries.query); $ < nt.length; $++) {
          for (var it = nt[$], ut = it[0], ht = [], mt = 0, at = it[1]; mt < at.length; mt++) {
            var gt = at[mt];
            ka(A, gt.obsSet) ? gt.subscribers.forEach(function(ft) {
              return P.add(ft);
            }) : U && ht.push(gt);
          }
          U && q.push([ut, ht]);
        }
        if (U) for (var dt = 0, pt = q; dt < pt.length; dt++) {
          var _t = pt[dt], ut = _t[0], ht = _t[1];
          y.queries.query[ut] = ht;
        }
      }
      function Ji(y) {
        var A = y._state, P = y._deps.indexedDB;
        if (A.isBeingOpened || y.idbdb) return A.dbReadyPromise.then(function() {
          return A.dbOpenError ? Me(A.dbOpenError) : y;
        });
        A.isBeingOpened = !0, A.dbOpenError = null, A.openComplete = !1;
        var U = A.openCanceller, q = Math.round(10 * y.verno), $ = !1;
        function nt() {
          if (A.openCanceller !== U) throw new ot.DatabaseClosed("db.open() was cancelled");
        }
        function it() {
          return new se(function(gt, dt) {
            if (nt(), !P) throw new ot.MissingAPI();
            var pt = y.name, _t = A.autoSchema || !q ? P.open(pt) : P.open(pt, q);
            if (!_t) throw new ot.MissingAPI();
            _t.onerror = ui(dt), _t.onblocked = dn(y._fireOnBlocked), _t.onupgradeneeded = dn(function(ft) {
              var xt;
              mt = _t.transaction, A.autoSchema && !y._options.allowEmptyDB ? (_t.onerror = qs, mt.abort(), _t.result.close(), (xt = P.deleteDatabase(pt)).onsuccess = xt.onerror = dn(function() {
                dt(new ot.NoSuchDatabase("Database ".concat(pt, " doesnt exist")));
              })) : (mt.onerror = ui(dt), ft = ft.oldVersion > Math.pow(2, 62) ? 0 : ft.oldVersion, at = ft < 1, y.idbdb = _t.result, $ && vu(y, mt), zh(y, ft / 10, mt, dt));
            }, dt), _t.onsuccess = dn(function() {
              mt = null;
              var ft, xt, kt, Et, Pt, Gt = y.idbdb = _t.result, Jt = T(Gt.objectStoreNames);
              if (0 < Jt.length) try {
                var qt = Gt.transaction((Et = Jt).length === 1 ? Et[0] : Et, "readonly");
                if (A.autoSchema) xt = Gt, kt = qt, (ft = y).verno = xt.version / 10, kt = ft._dbSchema = Ta(0, xt, kt), ft._storeNames = T(xt.objectStoreNames, 0), xa(ft, [ft._allTables], l(kt), kt);
                else if (Ca(y, y._dbSchema, qt), ((Pt = Bl(Ta(0, (Pt = y).idbdb, qt), Pt._dbSchema)).add.length || Pt.change.some(function(Qt) {
                  return Qt.add.length || Qt.change.length;
                })) && !$) return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."), Gt.close(), q = Gt.version + 1, $ = !0, gt(it());
                Sa(y, qt);
              } catch {
              }
              Rr.push(y), Gt.onversionchange = dn(function(Qt) {
                A.vcFired = !0, y.on("versionchange").fire(Qt);
              }), Gt.onclose = dn(function(Qt) {
                y.on("close").fire(Qt);
              }), at && (Pt = y._deps, qt = pt, Gt = Pt.indexedDB, Pt = Pt.IDBKeyRange, Ea(Gt) || qt === Us || Ws(Gt, Pt).put({ name: qt }).catch(bt)), gt();
            }, dt);
          }).catch(function(gt) {
            switch (gt == null ? void 0 : gt.name) {
              case "UnknownError":
                if (0 < A.PR1398_maxLoop) return A.PR1398_maxLoop--, console.warn("Dexie: Workaround for Chrome UnknownError on open()"), it();
                break;
              case "VersionError":
                if (0 < q) return q = 0, it();
            }
            return se.reject(gt);
          });
        }
        var ut, ht = A.dbReadyResolve, mt = null, at = !1;
        return se.race([U, (typeof navigator > "u" ? se.resolve() : !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(gt) {
          function dt() {
            return indexedDB.databases().finally(gt);
          }
          ut = setInterval(dt, 100), dt();
        }).finally(function() {
          return clearInterval(ut);
        }) : Promise.resolve()).then(it)]).then(function() {
          return nt(), A.onReadyBeingFired = [], se.resolve(jl(function() {
            return y.on.ready.fire(y.vip);
          })).then(function gt() {
            if (0 < A.onReadyBeingFired.length) {
              var dt = A.onReadyBeingFired.reduce(re, bt);
              return A.onReadyBeingFired = [], se.resolve(jl(function() {
                return dt(y.vip);
              })).then(gt);
            }
          });
        }).finally(function() {
          A.openCanceller === U && (A.onReadyBeingFired = null, A.isBeingOpened = !1);
        }).catch(function(gt) {
          A.dbOpenError = gt;
          try {
            mt && mt.abort();
          } catch {
          }
          return U === A.openCanceller && y._close(), Me(gt);
        }).finally(function() {
          A.openComplete = !0, ht();
        }).then(function() {
          var gt;
          return at && (gt = {}, y.tables.forEach(function(dt) {
            dt.schema.indexes.forEach(function(pt) {
              pt.name && (gt["idb://".concat(y.name, "/").concat(dt.name, "/").concat(pt.name)] = new rr(-1 / 0, [[[]]]));
            }), gt["idb://".concat(y.name, "/").concat(dt.name, "/")] = gt["idb://".concat(y.name, "/").concat(dt.name, "/:dels")] = new rr(-1 / 0, [[[]]]);
          }), Xi(ko).fire(gt), Gl(gt, !0)), y;
        });
      }
      function Ma(y) {
        function A($) {
          return y.next($);
        }
        var P = q(A), U = q(function($) {
          return y.throw($);
        });
        function q($) {
          return function(ut) {
            var it = $(ut), ut = it.value;
            return it.done ? ut : ut && typeof ut.then == "function" ? ut.then(P, U) : c(ut) ? Promise.all(ut).then(P, U) : P(ut);
          };
        }
        return q(A)();
      }
      function No(y, A, P) {
        for (var U = c(y) ? y.slice() : [y], q = 0; q < P; ++q) U.push(A);
        return U;
      }
      var Oa = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(y) {
        return r(r({}, y), { table: function(A) {
          var P = y.table(A), U = P.schema, q = {}, $ = [];
          function nt(at, gt, dt) {
            var pt = Mo(at), _t = q[pt] = q[pt] || [], ft = at == null ? 0 : typeof at == "string" ? 1 : at.length, xt = 0 < gt, xt = r(r({}, dt), { name: xt ? "".concat(pt, "(virtual-from:").concat(dt.name, ")") : dt.name, lowLevelIndex: dt, isVirtual: xt, keyTail: gt, keyLength: ft, extractKey: Hs(at), unique: !xt && dt.unique });
            return _t.push(xt), xt.isPrimaryKey || $.push(xt), 1 < ft && nt(ft === 2 ? at[0] : at.slice(0, ft - 1), gt + 1, dt), _t.sort(function(kt, Et) {
              return kt.keyTail - Et.keyTail;
            }), xt;
          }
          A = nt(U.primaryKey.keyPath, 0, U.primaryKey), q[":id"] = [A];
          for (var it = 0, ut = U.indexes; it < ut.length; it++) {
            var ht = ut[it];
            nt(ht.keyPath, 0, ht);
          }
          function mt(at) {
            var gt, dt = at.query.index;
            return dt.isVirtual ? r(r({}, at), { query: { index: dt.lowLevelIndex, range: (gt = at.query.range, dt = dt.keyTail, { type: gt.type === 1 ? 2 : gt.type, lower: No(gt.lower, gt.lowerOpen ? y.MAX_KEY : y.MIN_KEY, dt), lowerOpen: !0, upper: No(gt.upper, gt.upperOpen ? y.MIN_KEY : y.MAX_KEY, dt), upperOpen: !0 }) } }) : at;
          }
          return r(r({}, P), { schema: r(r({}, U), { primaryKey: A, indexes: $, getIndexByKeyPath: function(at) {
            return (at = q[Mo(at)]) && at[0];
          } }), count: function(at) {
            return P.count(mt(at));
          }, query: function(at) {
            return P.query(mt(at));
          }, openCursor: function(at) {
            var gt = at.query.index, dt = gt.keyTail, pt = gt.isVirtual, _t = gt.keyLength;
            return pt ? P.openCursor(mt(at)).then(function(xt) {
              return xt && ft(xt);
            }) : P.openCursor(at);
            function ft(xt) {
              return Object.create(xt, { continue: { value: function(kt) {
                kt != null ? xt.continue(No(kt, at.reverse ? y.MAX_KEY : y.MIN_KEY, dt)) : at.unique ? xt.continue(xt.key.slice(0, _t).concat(at.reverse ? y.MIN_KEY : y.MAX_KEY, dt)) : xt.continue();
              } }, continuePrimaryKey: { value: function(kt, Et) {
                xt.continuePrimaryKey(No(kt, y.MAX_KEY, dt), Et);
              } }, primaryKey: { get: function() {
                return xt.primaryKey;
              } }, key: { get: function() {
                var kt = xt.key;
                return _t === 1 ? kt[0] : kt.slice(0, _t);
              } }, value: { get: function() {
                return xt.value;
              } } });
            }
          } });
        } });
      } };
      function Po(y, A, P, U) {
        return P = P || {}, U = U || "", l(y).forEach(function(q) {
          var $, nt, it;
          p(A, q) ? ($ = y[q], nt = A[q], typeof $ == "object" && typeof nt == "object" && $ && nt ? (it = D($)) !== D(nt) ? P[U + q] = A[q] : it === "Object" ? Po($, nt, P, U + q + ".") : $ !== nt && (P[U + q] = A[q]) : $ !== nt && (P[U + q] = A[q])) : P[U + q] = void 0;
        }), l(A).forEach(function(q) {
          p(y, q) || (P[U + q] = A[q]);
        }), P;
      }
      function ts(y, A) {
        return A.type === "delete" ? A.keys : A.keys || A.values.map(y.extractKey);
      }
      var hr = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function(y) {
        return r(r({}, y), { table: function(A) {
          var P = y.table(A), U = P.schema.primaryKey;
          return r(r({}, P), { mutate: function(q) {
            var $ = zt.trans, nt = $.table(A).hook, it = nt.deleting, ut = nt.creating, ht = nt.updating;
            switch (q.type) {
              case "add":
                if (ut.fire === bt) break;
                return $._promise("readwrite", function() {
                  return mt(q);
                }, !0);
              case "put":
                if (ut.fire === bt && ht.fire === bt) break;
                return $._promise("readwrite", function() {
                  return mt(q);
                }, !0);
              case "delete":
                if (it.fire === bt) break;
                return $._promise("readwrite", function() {
                  return mt(q);
                }, !0);
              case "deleteRange":
                if (it.fire === bt) break;
                return $._promise("readwrite", function() {
                  return function at(gt, dt, pt) {
                    return P.query({ trans: gt, values: !1, query: { index: U, range: dt }, limit: pt }).then(function(_t) {
                      var ft = _t.result;
                      return mt({ type: "delete", keys: ft, trans: gt }).then(function(xt) {
                        return 0 < xt.numFailures ? Promise.reject(xt.failures[0]) : ft.length < pt ? { failures: [], numFailures: 0, lastResult: void 0 } : at(gt, r(r({}, dt), { lower: ft[ft.length - 1], lowerOpen: !0 }), pt);
                      });
                    });
                  }(q.trans, q.range, 1e4);
                }, !0);
            }
            return P.mutate(q);
            function mt(at) {
              var gt, dt, pt, _t = zt.trans, ft = at.keys || ts(U, at);
              if (!ft) throw new Error("Keys missing");
              return (at = at.type === "add" || at.type === "put" ? r(r({}, at), { keys: ft }) : r({}, at)).type !== "delete" && (at.values = i([], at.values)), at.keys && (at.keys = i([], at.keys)), gt = P, pt = ft, ((dt = at).type === "add" ? Promise.resolve([]) : gt.getMany({ trans: dt.trans, keys: pt, cache: "immutable" })).then(function(xt) {
                var kt = ft.map(function(Et, Pt) {
                  var Gt, Jt, qt, Qt = xt[Pt], oe = { onerror: null, onsuccess: null };
                  return at.type === "delete" ? it.fire.call(oe, Et, Qt, _t) : at.type === "add" || Qt === void 0 ? (Gt = ut.fire.call(oe, Et, at.values[Pt], _t), Et == null && Gt != null && (at.keys[Pt] = Et = Gt, U.outbound || B(at.values[Pt], U.keyPath, Et))) : (Gt = Po(Qt, at.values[Pt]), (Jt = ht.fire.call(oe, Gt, Et, Qt, _t)) && (qt = at.values[Pt], Object.keys(Jt).forEach(function(Xt) {
                    p(qt, Xt) ? qt[Xt] = Jt[Xt] : B(qt, Xt, Jt[Xt]);
                  }))), oe;
                });
                return P.mutate(at).then(function(Et) {
                  for (var Pt = Et.failures, Gt = Et.results, Jt = Et.numFailures, Et = Et.lastResult, qt = 0; qt < ft.length; ++qt) {
                    var Qt = (Gt || ft)[qt], oe = kt[qt];
                    Qt == null ? oe.onerror && oe.onerror(Pt[qt]) : oe.onsuccess && oe.onsuccess(at.type === "put" && xt[qt] ? at.values[qt] : Qt);
                  }
                  return { failures: Pt, results: Gt, numFailures: Jt, lastResult: Et };
                }).catch(function(Et) {
                  return kt.forEach(function(Pt) {
                    return Pt.onerror && Pt.onerror(Et);
                  }), Promise.reject(Et);
                });
              });
            }
          } });
        } });
      } };
      function Na(y, A, P) {
        try {
          if (!A || A.keys.length < y.length) return null;
          for (var U = [], q = 0, $ = 0; q < A.keys.length && $ < y.length; ++q) ze(A.keys[q], y[$]) === 0 && (U.push(P ? M(A.values[q]) : A.values[q]), ++$);
          return U.length === y.length ? U : null;
        } catch {
          return null;
        }
      }
      var Gh = { stack: "dbcore", level: -1, create: function(y) {
        return { table: function(A) {
          var P = y.table(A);
          return r(r({}, P), { getMany: function(U) {
            if (!U.cache) return P.getMany(U);
            var q = Na(U.keys, U.trans._cache, U.cache === "clone");
            return q ? se.resolve(q) : P.getMany(U).then(function($) {
              return U.trans._cache = { keys: U.keys, values: U.cache === "clone" ? M($) : $ }, $;
            });
          }, mutate: function(U) {
            return U.type !== "add" && (U.trans._cache = null), P.mutate(U);
          } });
        } };
      } };
      function ql(y, A) {
        return y.trans.mode === "readonly" && !!y.subscr && !y.trans.explicit && y.trans.db._options.cache !== "disabled" && !A.schema.primaryKey.outbound;
      }
      function Do(y, A) {
        switch (y) {
          case "query":
            return A.values && !A.unique;
          case "get":
          case "getMany":
          case "count":
          case "openCursor":
            return !1;
        }
      }
      var Su = { stack: "dbcore", level: 0, name: "Observability", create: function(y) {
        var A = y.schema.name, P = new rr(y.MIN_KEY, y.MAX_KEY);
        return r(r({}, y), { transaction: function(U, q, $) {
          if (zt.subscr && q !== "readonly") throw new ot.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(zt.querier));
          return y.transaction(U, q, $);
        }, table: function(U) {
          var q = y.table(U), $ = q.schema, nt = $.primaryKey, at = $.indexes, it = nt.extractKey, ut = nt.outbound, ht = nt.autoIncrement && at.filter(function(dt) {
            return dt.compound && dt.keyPath.includes(nt.keyPath);
          }), mt = r(r({}, q), { mutate: function(dt) {
            function pt(Xt) {
              return Xt = "idb://".concat(A, "/").concat(U, "/").concat(Xt), Et[Xt] || (Et[Xt] = new rr());
            }
            var _t, ft, xt, kt = dt.trans, Et = dt.mutatedParts || (dt.mutatedParts = {}), Pt = pt(""), Gt = pt(":dels"), Jt = dt.type, oe = dt.type === "deleteRange" ? [dt.range] : dt.type === "delete" ? [dt.keys] : dt.values.length < 50 ? [ts(nt, dt).filter(function(Xt) {
              return Xt;
            }), dt.values] : [], qt = oe[0], Qt = oe[1], oe = dt.trans._cache;
            return c(qt) ? (Pt.addKeys(qt), (oe = Jt === "delete" || qt.length === Qt.length ? Na(qt, oe) : null) || Gt.addKeys(qt), (oe || Qt) && (_t = pt, ft = oe, xt = Qt, $.indexes.forEach(function(Xt) {
              var ue = _t(Xt.name || "");
              function ve(Te) {
                return Te != null ? Xt.extractKey(Te) : null;
              }
              function Ae(Te) {
                return Xt.multiEntry && c(Te) ? Te.forEach(function(Or) {
                  return ue.addKey(Or);
                }) : ue.addKey(Te);
              }
              (ft || xt).forEach(function(Te, Bn) {
                var Ce = ft && ve(ft[Bn]), Bn = xt && ve(xt[Bn]);
                ze(Ce, Bn) !== 0 && (Ce != null && Ae(Ce), Bn != null && Ae(Bn));
              });
            }))) : qt ? (Qt = { from: (Qt = qt.lower) !== null && Qt !== void 0 ? Qt : y.MIN_KEY, to: (Qt = qt.upper) !== null && Qt !== void 0 ? Qt : y.MAX_KEY }, Gt.add(Qt), Pt.add(Qt)) : (Pt.add(P), Gt.add(P), $.indexes.forEach(function(Xt) {
              return pt(Xt.name).add(P);
            })), q.mutate(dt).then(function(Xt) {
              return !qt || dt.type !== "add" && dt.type !== "put" || (Pt.addKeys(Xt.results), ht && ht.forEach(function(ue) {
                for (var ve = dt.values.map(function(Ce) {
                  return ue.extractKey(Ce);
                }), Ae = ue.keyPath.findIndex(function(Ce) {
                  return Ce === nt.keyPath;
                }), Te = 0, Or = Xt.results.length; Te < Or; ++Te) ve[Te][Ae] = Xt.results[Te];
                pt(ue.name).addKeys(ve);
              })), kt.mutatedParts = Aa(kt.mutatedParts || {}, Et), Xt;
            });
          } }), at = function(pt) {
            var _t = pt.query, pt = _t.index, _t = _t.range;
            return [pt, new rr((pt = _t.lower) !== null && pt !== void 0 ? pt : y.MIN_KEY, (_t = _t.upper) !== null && _t !== void 0 ? _t : y.MAX_KEY)];
          }, gt = { get: function(dt) {
            return [nt, new rr(dt.key)];
          }, getMany: function(dt) {
            return [nt, new rr().addKeys(dt.keys)];
          }, count: at, query: at, openCursor: at };
          return l(gt).forEach(function(dt) {
            mt[dt] = function(pt) {
              var _t = zt.subscr, ft = !!_t, xt = ql(zt, q) && Do(dt, pt) ? pt.obsSet = {} : _t;
              if (ft) {
                var kt = function(Qt) {
                  return Qt = "idb://".concat(A, "/").concat(U, "/").concat(Qt), xt[Qt] || (xt[Qt] = new rr());
                }, Et = kt(""), Pt = kt(":dels"), _t = gt[dt](pt), ft = _t[0], _t = _t[1];
                if ((dt === "query" && ft.isPrimaryKey && !pt.values ? Pt : kt(ft.name || "")).add(_t), !ft.isPrimaryKey) {
                  if (dt !== "count") {
                    var Gt = dt === "query" && ut && pt.values && q.query(r(r({}, pt), { values: !1 }));
                    return q[dt].apply(this, arguments).then(function(Qt) {
                      if (dt === "query") {
                        if (ut && pt.values) return Gt.then(function(ve) {
                          return ve = ve.result, Et.addKeys(ve), Qt;
                        });
                        var oe = pt.values ? Qt.result.map(it) : Qt.result;
                        (pt.values ? Et : Pt).addKeys(oe);
                      } else if (dt === "openCursor") {
                        var Xt = Qt, ue = pt.values;
                        return Xt && Object.create(Xt, { key: { get: function() {
                          return Pt.addKey(Xt.primaryKey), Xt.key;
                        } }, primaryKey: { get: function() {
                          var ve = Xt.primaryKey;
                          return Pt.addKey(ve), ve;
                        } }, value: { get: function() {
                          return ue && Et.addKey(Xt.primaryKey), Xt.value;
                        } } });
                      }
                      return Qt;
                    });
                  }
                  Pt.add(P);
                }
              }
              return q[dt].apply(this, arguments);
            };
          }), mt;
        } });
      } };
      function Pa(y, A, P) {
        if (P.numFailures === 0) return A;
        if (A.type === "deleteRange") return null;
        var U = A.keys ? A.keys.length : "values" in A && A.values ? A.values.length : 1;
        return P.numFailures === U ? null : (A = r({}, A), c(A.keys) && (A.keys = A.keys.filter(function(q, $) {
          return !($ in P.failures);
        })), "values" in A && c(A.values) && (A.values = A.values.filter(function(q, $) {
          return !($ in P.failures);
        })), A);
      }
      function Hl(y, A) {
        return P = y, ((U = A).lower === void 0 || (U.lowerOpen ? 0 < ze(P, U.lower) : 0 <= ze(P, U.lower))) && (y = y, (A = A).upper === void 0 || (A.upperOpen ? ze(y, A.upper) < 0 : ze(y, A.upper) <= 0));
        var P, U;
      }
      function Mr(y, A, gt, U, q, $) {
        if (!gt || gt.length === 0) return y;
        var nt = A.query.index, it = nt.multiEntry, ut = A.query.range, ht = U.schema.primaryKey.extractKey, mt = nt.extractKey, at = (nt.lowLevelIndex || nt).extractKey, gt = gt.reduce(function(dt, pt) {
          var _t = dt, ft = [];
          if (pt.type === "add" || pt.type === "put") for (var xt = new rr(), kt = pt.values.length - 1; 0 <= kt; --kt) {
            var Et, Pt = pt.values[kt], Gt = ht(Pt);
            xt.hasKey(Gt) || (Et = mt(Pt), (it && c(Et) ? Et.some(function(Xt) {
              return Hl(Xt, ut);
            }) : Hl(Et, ut)) && (xt.addKey(Gt), ft.push(Pt)));
          }
          switch (pt.type) {
            case "add":
              var Jt = new rr().addKeys(A.values ? dt.map(function(ue) {
                return ht(ue);
              }) : dt), _t = dt.concat(A.values ? ft.filter(function(ue) {
                return ue = ht(ue), !Jt.hasKey(ue) && (Jt.addKey(ue), !0);
              }) : ft.map(function(ue) {
                return ht(ue);
              }).filter(function(ue) {
                return !Jt.hasKey(ue) && (Jt.addKey(ue), !0);
              }));
              break;
            case "put":
              var qt = new rr().addKeys(pt.values.map(function(ue) {
                return ht(ue);
              }));
              _t = dt.filter(function(ue) {
                return !qt.hasKey(A.values ? ht(ue) : ue);
              }).concat(A.values ? ft : ft.map(function(ue) {
                return ht(ue);
              }));
              break;
            case "delete":
              var Qt = new rr().addKeys(pt.keys);
              _t = dt.filter(function(ue) {
                return !Qt.hasKey(A.values ? ht(ue) : ue);
              });
              break;
            case "deleteRange":
              var oe = pt.range;
              _t = dt.filter(function(ue) {
                return !Hl(ht(ue), oe);
              });
          }
          return _t;
        }, y);
        return gt === y ? y : (gt.sort(function(dt, pt) {
          return ze(at(dt), at(pt)) || ze(ht(dt), ht(pt));
        }), A.limit && A.limit < 1 / 0 && (gt.length > A.limit ? gt.length = A.limit : y.length === A.limit && gt.length < A.limit && (q.dirty = !0)), $ ? Object.freeze(gt) : gt);
      }
      function xu(y, A) {
        return ze(y.lower, A.lower) === 0 && ze(y.upper, A.upper) === 0 && !!y.lowerOpen == !!A.lowerOpen && !!y.upperOpen == !!A.upperOpen;
      }
      function Tu(y, A) {
        return function(P, U, q, $) {
          if (P === void 0) return U !== void 0 ? -1 : 0;
          if (U === void 0) return 1;
          if ((U = ze(P, U)) === 0) {
            if (q && $) return 0;
            if (q) return 1;
            if ($) return -1;
          }
          return U;
        }(y.lower, A.lower, y.lowerOpen, A.lowerOpen) <= 0 && 0 <= function(P, U, q, $) {
          if (P === void 0) return U !== void 0 ? 1 : 0;
          if (U === void 0) return -1;
          if ((U = ze(P, U)) === 0) {
            if (q && $) return 0;
            if (q) return -1;
            if ($) return 1;
          }
          return U;
        }(y.upper, A.upper, y.upperOpen, A.upperOpen);
      }
      function qh(y, A, P, U) {
        y.subscribers.add(P), U.addEventListener("abort", function() {
          var q, $;
          y.subscribers.delete(P), y.subscribers.size === 0 && (q = y, $ = A, setTimeout(function() {
            q.subscribers.size === 0 && X($, q);
          }, 3e3));
        });
      }
      var Hh = { stack: "dbcore", level: 0, name: "Cache", create: function(y) {
        var A = y.schema.name;
        return r(r({}, y), { transaction: function(P, U, q) {
          var $, nt, it = y.transaction(P, U, q);
          return U === "readwrite" && (nt = ($ = new AbortController()).signal, q = function(ut) {
            return function() {
              if ($.abort(), U === "readwrite") {
                for (var ht = /* @__PURE__ */ new Set(), mt = 0, at = P; mt < at.length; mt++) {
                  var gt = at[mt], dt = ys["idb://".concat(A, "/").concat(gt)];
                  if (dt) {
                    var pt = y.table(gt), _t = dt.optimisticOps.filter(function(ue) {
                      return ue.trans === it;
                    });
                    if (it._explicit && ut && it.mutatedParts) for (var ft = 0, xt = Object.values(dt.queries.query); ft < xt.length; ft++) for (var kt = 0, Et = (Jt = xt[ft]).slice(); kt < Et.length; kt++) ka((qt = Et[kt]).obsSet, it.mutatedParts) && (X(Jt, qt), qt.subscribers.forEach(function(ue) {
                      return ht.add(ue);
                    }));
                    else if (0 < _t.length) {
                      dt.optimisticOps = dt.optimisticOps.filter(function(ue) {
                        return ue.trans !== it;
                      });
                      for (var Pt = 0, Gt = Object.values(dt.queries.query); Pt < Gt.length; Pt++) for (var Jt, qt, Qt, oe = 0, Xt = (Jt = Gt[Pt]).slice(); oe < Xt.length; oe++) (qt = Xt[oe]).res != null && it.mutatedParts && (ut && !qt.dirty ? (Qt = Object.isFrozen(qt.res), Qt = Mr(qt.res, qt.req, _t, pt, qt, Qt), qt.dirty ? (X(Jt, qt), qt.subscribers.forEach(function(ue) {
                        return ht.add(ue);
                      })) : Qt !== qt.res && (qt.res = Qt, qt.promise = se.resolve({ result: Qt }))) : (qt.dirty && X(Jt, qt), qt.subscribers.forEach(function(ue) {
                        return ht.add(ue);
                      })));
                    }
                  }
                }
                ht.forEach(function(ue) {
                  return ue();
                });
              }
            };
          }, it.addEventListener("abort", q(!1), { signal: nt }), it.addEventListener("error", q(!1), { signal: nt }), it.addEventListener("complete", q(!0), { signal: nt })), it;
        }, table: function(P) {
          var U = y.table(P), q = U.schema.primaryKey;
          return r(r({}, U), { mutate: function($) {
            var nt = zt.trans;
            if (q.outbound || nt.db._options.cache === "disabled" || nt.explicit || nt.idbtrans.mode !== "readwrite") return U.mutate($);
            var it = ys["idb://".concat(A, "/").concat(P)];
            return it ? (nt = U.mutate($), $.type !== "add" && $.type !== "put" || !(50 <= $.values.length || ts(q, $).some(function(ut) {
              return ut == null;
            })) ? (it.optimisticOps.push($), $.mutatedParts && Vl($.mutatedParts), nt.then(function(ut) {
              0 < ut.numFailures && (X(it.optimisticOps, $), (ut = Pa(0, $, ut)) && it.optimisticOps.push(ut), $.mutatedParts && Vl($.mutatedParts));
            }), nt.catch(function() {
              X(it.optimisticOps, $), $.mutatedParts && Vl($.mutatedParts);
            })) : nt.then(function(ut) {
              var ht = Pa(0, r(r({}, $), { values: $.values.map(function(mt, at) {
                var gt;
                return ut.failures[at] ? mt : (mt = (gt = q.keyPath) !== null && gt !== void 0 && gt.includes(".") ? M(mt) : r({}, mt), B(mt, q.keyPath, ut.results[at]), mt);
              }) }), ut);
              it.optimisticOps.push(ht), queueMicrotask(function() {
                return $.mutatedParts && Vl($.mutatedParts);
              });
            }), nt) : U.mutate($);
          }, query: function($) {
            if (!ql(zt, U) || !Do("query", $)) return U.query($);
            var nt = ((ht = zt.trans) === null || ht === void 0 ? void 0 : ht.db._options.cache) === "immutable", at = zt, it = at.requery, ut = at.signal, ht = function(pt, _t, ft, xt) {
              var kt = ys["idb://".concat(pt, "/").concat(_t)];
              if (!kt) return [];
              if (!(_t = kt.queries[ft])) return [null, !1, kt, null];
              var Et = _t[(xt.query ? xt.query.index.name : null) || ""];
              if (!Et) return [null, !1, kt, null];
              switch (ft) {
                case "query":
                  var Pt = Et.find(function(Gt) {
                    return Gt.req.limit === xt.limit && Gt.req.values === xt.values && xu(Gt.req.query.range, xt.query.range);
                  });
                  return Pt ? [Pt, !0, kt, Et] : [Et.find(function(Gt) {
                    return ("limit" in Gt.req ? Gt.req.limit : 1 / 0) >= xt.limit && (!xt.values || Gt.req.values) && Tu(Gt.req.query.range, xt.query.range);
                  }), !1, kt, Et];
                case "count":
                  return Pt = Et.find(function(Gt) {
                    return xu(Gt.req.query.range, xt.query.range);
                  }), [Pt, !!Pt, kt, Et];
              }
            }(A, P, "query", $), mt = ht[0], at = ht[1], gt = ht[2], dt = ht[3];
            return mt && at ? mt.obsSet = $.obsSet : (at = U.query($).then(function(pt) {
              var _t = pt.result;
              if (mt && (mt.res = _t), nt) {
                for (var ft = 0, xt = _t.length; ft < xt; ++ft) Object.freeze(_t[ft]);
                Object.freeze(_t);
              } else pt.result = M(_t);
              return pt;
            }).catch(function(pt) {
              return dt && mt && X(dt, mt), Promise.reject(pt);
            }), mt = { obsSet: $.obsSet, promise: at, subscribers: /* @__PURE__ */ new Set(), type: "query", req: $, dirty: !1 }, dt ? dt.push(mt) : (dt = [mt], (gt = gt || (ys["idb://".concat(A, "/").concat(P)] = { queries: { query: {}, count: {} }, objs: /* @__PURE__ */ new Map(), optimisticOps: [], unsignaledParts: {} })).queries.query[$.query.index.name || ""] = dt)), qh(mt, dt, it, ut), mt.promise.then(function(pt) {
              return { result: Mr(pt.result, $, gt == null ? void 0 : gt.optimisticOps, U, mt, nt) };
            });
          } });
        } });
      } };
      function Io(y, A) {
        return new Proxy(y, { get: function(P, U, q) {
          return U === "db" ? A : Reflect.get(P, U, q);
        } });
      }
      var fi = (Rn.prototype.version = function(y) {
        if (isNaN(y) || y < 0.1) throw new ot.Type("Given version is not a positive number");
        if (y = Math.round(10 * y) / 10, this.idbdb || this._state.isBeingOpened) throw new ot.Schema("Cannot add version when database is open");
        this.verno = Math.max(this.verno, y);
        var A = this._versions, P = A.filter(function(U) {
          return U._cfg.version === y;
        })[0];
        return P || (P = new this.Version(y), A.push(P), A.sort(Il), P.stores({}), this._state.autoSchema = !1, P);
      }, Rn.prototype._whenReady = function(y) {
        var A = this;
        return this.idbdb && (this._state.openComplete || zt.letThrough || this._vip) ? y() : new se(function(P, U) {
          if (A._state.openComplete) return U(new ot.DatabaseClosed(A._state.dbOpenError));
          if (!A._state.isBeingOpened) {
            if (!A._state.autoOpen) return void U(new ot.DatabaseClosed());
            A.open().catch(bt);
          }
          A._state.dbReadyPromise.then(P, U);
        }).then(y);
      }, Rn.prototype.use = function(y) {
        var A = y.stack, P = y.create, U = y.level, q = y.name;
        return q && this.unuse({ stack: A, name: q }), y = this._middlewares[A] || (this._middlewares[A] = []), y.push({ stack: A, create: P, level: U ?? 10, name: q }), y.sort(function($, nt) {
          return $.level - nt.level;
        }), this;
      }, Rn.prototype.unuse = function(y) {
        var A = y.stack, P = y.name, U = y.create;
        return A && this._middlewares[A] && (this._middlewares[A] = this._middlewares[A].filter(function(q) {
          return U ? q.create !== U : !!P && q.name !== P;
        })), this;
      }, Rn.prototype.open = function() {
        var y = this;
        return Ki(ie, function() {
          return Ji(y);
        });
      }, Rn.prototype._close = function() {
        var y = this._state, A = Rr.indexOf(this);
        if (0 <= A && Rr.splice(A, 1), this.idbdb) {
          try {
            this.idbdb.close();
          } catch {
          }
          this.idbdb = null;
        }
        y.isBeingOpened || (y.dbReadyPromise = new se(function(P) {
          y.dbReadyResolve = P;
        }), y.openCanceller = new se(function(P, U) {
          y.cancelOpen = U;
        }));
      }, Rn.prototype.close = function(P) {
        var A = (P === void 0 ? { disableAutoOpen: !0 } : P).disableAutoOpen, P = this._state;
        A ? (P.isBeingOpened && P.cancelOpen(new ot.DatabaseClosed()), this._close(), P.autoOpen = !1, P.dbOpenError = new ot.DatabaseClosed()) : (this._close(), P.autoOpen = this._options.autoOpen || P.isBeingOpened, P.openComplete = !1, P.dbOpenError = null);
      }, Rn.prototype.delete = function(y) {
        var A = this;
        y === void 0 && (y = { disableAutoOpen: !0 });
        var P = 0 < arguments.length && typeof arguments[0] != "object", U = this._state;
        return new se(function(q, $) {
          function nt() {
            A.close(y);
            var it = A._deps.indexedDB.deleteDatabase(A.name);
            it.onsuccess = dn(function() {
              var ut, ht, mt;
              ut = A._deps, ht = A.name, mt = ut.indexedDB, ut = ut.IDBKeyRange, Ea(mt) || ht === Us || Ws(mt, ut).delete(ht).catch(bt), q();
            }), it.onerror = ui($), it.onblocked = A._fireOnBlocked;
          }
          if (P) throw new ot.InvalidArgument("Invalid closeOptions argument to db.delete()");
          U.isBeingOpened ? U.dbReadyPromise.then(nt) : nt();
        });
      }, Rn.prototype.backendDB = function() {
        return this.idbdb;
      }, Rn.prototype.isOpen = function() {
        return this.idbdb !== null;
      }, Rn.prototype.hasBeenClosed = function() {
        var y = this._state.dbOpenError;
        return y && y.name === "DatabaseClosed";
      }, Rn.prototype.hasFailed = function() {
        return this._state.dbOpenError !== null;
      }, Rn.prototype.dynamicallyOpened = function() {
        return this._state.autoSchema;
      }, Object.defineProperty(Rn.prototype, "tables", { get: function() {
        var y = this;
        return l(this._allTables).map(function(A) {
          return y._allTables[A];
        });
      }, enumerable: !1, configurable: !0 }), Rn.prototype.transaction = function() {
        var y = (function(A, P, U) {
          var q = arguments.length;
          if (q < 2) throw new ot.InvalidArgument("Too few arguments");
          for (var $ = new Array(q - 1); --q; ) $[q - 1] = arguments[q];
          return U = $.pop(), [A, k($), U];
        }).apply(this, arguments);
        return this._transaction.apply(this, y);
      }, Rn.prototype._transaction = function(y, A, P) {
        var U = this, q = zt.trans;
        q && q.db === this && y.indexOf("!") === -1 || (q = null);
        var $, nt, it = y.indexOf("?") !== -1;
        y = y.replace("!", "").replace("?", "");
        try {
          if (nt = A.map(function(ht) {
            if (ht = ht instanceof U.Table ? ht.name : ht, typeof ht != "string") throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
            return ht;
          }), y == "r" || y === fa) $ = fa;
          else {
            if (y != "rw" && y != pa) throw new ot.InvalidArgument("Invalid transaction mode: " + y);
            $ = pa;
          }
          if (q) {
            if (q.mode === fa && $ === pa) {
              if (!it) throw new ot.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
              q = null;
            }
            q && nt.forEach(function(ht) {
              if (q && q.storeNames.indexOf(ht) === -1) {
                if (!it) throw new ot.SubTransaction("Table " + ht + " not included in parent transaction.");
                q = null;
              }
            }), it && q && !q.active && (q = null);
          }
        } catch (ht) {
          return q ? q._promise(null, function(mt, at) {
            at(ht);
          }) : Me(ht);
        }
        var ut = (function ht(mt, at, gt, dt, pt) {
          return se.resolve().then(function() {
            var _t = zt.transless || zt, ft = mt._createTransaction(at, gt, mt._dbSchema, dt);
            if (ft.explicit = !0, _t = { trans: ft, transless: _t }, dt) ft.idbtrans = dt.idbtrans;
            else try {
              ft.create(), ft.idbtrans._explicit = !0, mt._state.PR1398_maxLoop = 3;
            } catch (Et) {
              return Et.name === J.InvalidState && mt.isOpen() && 0 < --mt._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), mt.close({ disableAutoOpen: !1 }), mt.open().then(function() {
                return ht(mt, at, gt, null, pt);
              })) : Me(Et);
            }
            var xt, kt = Z(pt);
            return kt && ps(), _t = se.follow(function() {
              var Et;
              (xt = pt.call(ft, ft)) && (kt ? (Et = Mi.bind(null, null), xt.then(Et, Et)) : typeof xt.next == "function" && typeof xt.throw == "function" && (xt = Ma(xt)));
            }, _t), (xt && typeof xt.then == "function" ? se.resolve(xt).then(function(Et) {
              return ft.active ? Et : Me(new ot.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
            }) : _t.then(function() {
              return xt;
            })).then(function(Et) {
              return dt && ft._resolve(), ft._completion.then(function() {
                return Et;
              });
            }).catch(function(Et) {
              return ft._reject(Et), Me(Et);
            });
          });
        }).bind(null, this, $, nt, q, P);
        return q ? q._promise($, ut, "lock") : zt.trans ? Ki(zt.transless, function() {
          return U._whenReady(ut);
        }) : this._whenReady(ut);
      }, Rn.prototype.table = function(y) {
        if (!p(this._allTables, y)) throw new ot.InvalidTable("Table ".concat(y, " does not exist"));
        return this._allTables[y];
      }, Rn);
      function Rn(y, A) {
        var P = this;
        this._middlewares = {}, this.verno = 0;
        var U = Rn.dependencies;
        this._options = A = r({ addons: Rn.addons, autoOpen: !0, indexedDB: U.indexedDB, IDBKeyRange: U.IDBKeyRange, cache: "cloned" }, A), this._deps = { indexedDB: A.indexedDB, IDBKeyRange: A.IDBKeyRange }, U = A.addons, this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
        var q, $, nt, it, ut, ht = { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: bt, dbReadyPromise: null, cancelOpen: bt, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3, autoOpen: A.autoOpen };
        ht.dbReadyPromise = new se(function(at) {
          ht.dbReadyResolve = at;
        }), ht.openCanceller = new se(function(at, gt) {
          ht.cancelOpen = gt;
        }), this._state = ht, this.name = y, this.on = Co(this, "populate", "blocked", "versionchange", "close", { ready: [re, bt] }), this.on.ready.subscribe = S(this.on.ready.subscribe, function(at) {
          return function(gt, dt) {
            Rn.vip(function() {
              var pt, _t = P._state;
              _t.openComplete ? (_t.dbOpenError || se.resolve().then(gt), dt && at(gt)) : _t.onReadyBeingFired ? (_t.onReadyBeingFired.push(gt), dt && at(gt)) : (at(gt), pt = P, dt || at(function ft() {
                pt.on.ready.unsubscribe(gt), pt.on.ready.unsubscribe(ft);
              }));
            });
          };
        }), this.Collection = (q = this, wo(Eo.prototype, function(xt, ft) {
          this.db = q;
          var dt = au, pt = null;
          if (ft) try {
            dt = ft();
          } catch (kt) {
            pt = kt;
          }
          var _t = xt._ctx, ft = _t.table, xt = ft.hook.reading.fire;
          this._ctx = { table: ft, index: _t.index, isPrimKey: !_t.index || ft.schema.primKey.keyPath && _t.index === ft.schema.primKey.name, range: dt, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: pt, or: _t.or, valueMapper: xt !== Ht ? xt : null };
        })), this.Table = ($ = this, wo(uu.prototype, function(at, gt, dt) {
          this.db = $, this._tx = dt, this.name = at, this.schema = gt, this.hook = $._allTables[at] ? $._allTables[at].hook : Co(null, { creating: [Wt, bt], reading: [$t, Ht], updating: [ne, bt], deleting: [Ut, bt] });
        })), this.Transaction = (nt = this, wo(mu.prototype, function(at, gt, dt, pt, _t) {
          var ft = this;
          this.db = nt, this.mode = at, this.storeNames = gt, this.schema = dt, this.chromeTransactionDurability = pt, this.idbtrans = null, this.on = Co(this, "complete", "error", "abort"), this.parent = _t || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new se(function(xt, kt) {
            ft._resolve = xt, ft._reject = kt;
          }), this._completion.then(function() {
            ft.active = !1, ft.on.complete.fire();
          }, function(xt) {
            var kt = ft.active;
            return ft.active = !1, ft.on.error.fire(xt), ft.parent ? ft.parent._reject(xt) : kt && ft.idbtrans && ft.idbtrans.abort(), Me(xt);
          });
        })), this.Version = (it = this, wo(Vh.prototype, function(at) {
          this.db = it, this._cfg = { version: at, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
        })), this.WhereClause = (ut = this, wo(Ml.prototype, function(at, gt, dt) {
          if (this.db = ut, this._ctx = { table: at, index: gt === ":id" ? null : gt, or: dt }, this._cmp = this._ascending = ze, this._descending = function(pt, _t) {
            return ze(_t, pt);
          }, this._max = function(pt, _t) {
            return 0 < ze(pt, _t) ? pt : _t;
          }, this._min = function(pt, _t) {
            return ze(pt, _t) < 0 ? pt : _t;
          }, this._IDBKeyRange = ut._deps.IDBKeyRange, !this._IDBKeyRange) throw new ot.MissingAPI();
        })), this.on("versionchange", function(at) {
          0 < at.newVersion ? console.warn("Another connection wants to upgrade database '".concat(P.name, "'. Closing db now to resume the upgrade.")) : console.warn("Another connection wants to delete database '".concat(P.name, "'. Closing db now to resume the delete request.")), P.close({ disableAutoOpen: !1 });
        }), this.on("blocked", function(at) {
          !at.newVersion || at.newVersion < at.oldVersion ? console.warn("Dexie.delete('".concat(P.name, "') was blocked")) : console.warn("Upgrade '".concat(P.name, "' blocked by other connection holding version ").concat(at.oldVersion / 10));
        }), this._maxKey = Ro(A.IDBKeyRange), this._createTransaction = function(at, gt, dt, pt) {
          return new P.Transaction(at, gt, dt, P._options.chromeTransactionDurability, pt);
        }, this._fireOnBlocked = function(at) {
          P.on("blocked").fire(at), Rr.filter(function(gt) {
            return gt.name === P.name && gt !== P && !gt._state.vcFired;
          }).map(function(gt) {
            return gt.on("versionchange").fire(at);
          });
        }, this.use(Gh), this.use(Hh), this.use(Su), this.use(Oa), this.use(hr);
        var mt = new Proxy(this, { get: function(at, gt, dt) {
          if (gt === "_vip") return !0;
          if (gt === "table") return function(_t) {
            return Io(P.table(_t), mt);
          };
          var pt = Reflect.get(at, gt, dt);
          return pt instanceof uu ? Io(pt, mt) : gt === "tables" ? pt.map(function(_t) {
            return Io(_t, mt);
          }) : gt === "_createTransaction" ? function() {
            return Io(pt.apply(this, arguments), mt);
          } : pt;
        } });
        this.vip = mt, U.forEach(function(at) {
          return at(P);
        });
      }
      var Ys, fr = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable", Cn = (Cu.prototype.subscribe = function(y, A, P) {
        return this._subscribe(y && typeof y != "function" ? y : { next: y, error: A, complete: P });
      }, Cu.prototype[fr] = function() {
        return this;
      }, Cu);
      function Cu(y) {
        this._subscribe = y;
      }
      try {
        Ys = { indexedDB: s.indexedDB || s.mozIndexedDB || s.webkitIndexedDB || s.msIndexedDB, IDBKeyRange: s.IDBKeyRange || s.webkitIDBKeyRange };
      } catch {
        Ys = { indexedDB: null, IDBKeyRange: null };
      }
      function Wh(y) {
        var A, P = !1, U = new Cn(function(q) {
          var $ = Z(y), nt, it = !1, ut = {}, ht = {}, mt = { get closed() {
            return it;
          }, unsubscribe: function() {
            it || (it = !0, nt && nt.abort(), at && Xi.storagemutated.unsubscribe(dt));
          } };
          q.start && q.start(mt);
          var at = !1, gt = function() {
            return dr(pt);
          }, dt = function(_t) {
            Aa(ut, _t), ka(ht, ut) && gt();
          }, pt = function() {
            var _t, ft, xt;
            !it && Ys.indexedDB && (ut = {}, _t = {}, nt && nt.abort(), nt = new AbortController(), xt = function(kt) {
              var Et = Nn();
              try {
                $ && ps();
                var Pt = an(y, kt);
                return Pt = $ ? Pt.finally(Mi) : Pt;
              } finally {
                Et && Ri();
              }
            }(ft = { subscr: _t, signal: nt.signal, requery: gt, querier: y, trans: null }), Promise.resolve(xt).then(function(kt) {
              P = !0, A = kt, it || ft.signal.aborted || (ut = {}, function(Et) {
                for (var Pt in Et) if (p(Et, Pt)) return;
                return 1;
              }(ht = _t) || at || (Xi(ko, dt), at = !0), dr(function() {
                return !it && q.next && q.next(kt);
              }));
            }, function(kt) {
              P = !1, ["DatabaseClosedError", "AbortError"].includes(kt == null ? void 0 : kt.name) || it || dr(function() {
                it || q.error && q.error(kt);
              });
            }));
          };
          return setTimeout(gt, 0), mt;
        });
        return U.hasValue = function() {
          return P;
        }, U.getValue = function() {
          return A;
        }, U;
      }
      var vs = fi;
      function Xs(y) {
        var A = es;
        try {
          es = !0, Xi.storagemutated.fire(y), Gl(y, !0);
        } finally {
          es = A;
        }
      }
      v(vs, r(r({}, Ct), { delete: function(y) {
        return new vs(y, { addons: [] }).delete();
      }, exists: function(y) {
        return new vs(y, { addons: [] }).open().then(function(A) {
          return A.close(), !0;
        }).catch("NoSuchDatabaseError", function() {
          return !1;
        });
      }, getDatabaseNames: function(y) {
        try {
          return A = vs.dependencies, P = A.indexedDB, A = A.IDBKeyRange, (Ea(P) ? Promise.resolve(P.databases()).then(function(U) {
            return U.map(function(q) {
              return q.name;
            }).filter(function(q) {
              return q !== Us;
            });
          }) : Ws(P, A).toCollection().primaryKeys()).then(y);
        } catch {
          return Me(new ot.MissingAPI());
        }
        var A, P;
      }, defineClass: function() {
        return function(y) {
          u(this, y);
        };
      }, ignoreTransaction: function(y) {
        return zt.trans ? Ki(zt.transless, y) : y();
      }, vip: jl, async: function(y) {
        return function() {
          try {
            var A = Ma(y.apply(this, arguments));
            return A && typeof A.then == "function" ? A : se.resolve(A);
          } catch (P) {
            return Me(P);
          }
        };
      }, spawn: function(y, A, P) {
        try {
          var U = Ma(y.apply(P, A || []));
          return U && typeof U.then == "function" ? U : se.resolve(U);
        } catch (q) {
          return Me(q);
        }
      }, currentTransaction: { get: function() {
        return zt.trans || null;
      } }, waitFor: function(y, A) {
        return A = se.resolve(typeof y == "function" ? vs.ignoreTransaction(y) : y).timeout(A || 6e4), zt.trans ? zt.trans.waitFor(A) : A;
      }, Promise: se, debug: { get: function() {
        return le;
      }, set: function(y) {
        Lt(y);
      } }, derive: b, extend: u, props: v, override: S, Events: Co, on: Xi, liveQuery: Wh, extendObservabilitySet: Aa, getByKeyPath: O, setByKeyPath: B, delByKeyPath: function(y, A) {
        typeof A == "string" ? B(y, A, void 0) : "length" in A && [].map.call(A, function(P) {
          B(y, P, void 0);
        });
      }, shallowClone: N, deepClone: M, getObjectDiff: Po, cmp: ze, asap: E, minKey: -1 / 0, addons: [], connections: Rr, errnames: J, dependencies: Ys, cache: ys, semVer: "4.0.11", version: "4.0.11".split(".").map(function(y) {
        return parseInt(y);
      }).reduce(function(y, A, P) {
        return y + A / Math.pow(10, 2 * P);
      }) })), vs.maxKey = Ro(vs.dependencies.IDBKeyRange), typeof dispatchEvent < "u" && typeof addEventListener < "u" && (Xi(ko, function(y) {
        es || (y = new CustomEvent(Ol, { detail: y }), es = !0, dispatchEvent(y), es = !1);
      }), addEventListener(Ol, function(y) {
        y = y.detail, es || Xs(y);
      }));
      var Vr, es = !1, wu = function() {
      };
      return typeof BroadcastChannel < "u" && ((wu = function() {
        (Vr = new BroadcastChannel(Ol)).onmessage = function(y) {
          return y.data && Xs(y.data);
        };
      })(), typeof Vr.unref == "function" && Vr.unref(), Xi(ko, function(y) {
        es || Vr.postMessage(y);
      })), typeof addEventListener < "u" && (addEventListener("pagehide", function(y) {
        if (!fi.disableBfCache && y.persisted) {
          le && console.debug("Dexie: handling persisted pagehide"), Vr != null && Vr.close();
          for (var A = 0, P = Rr; A < P.length; A++) P[A].close({ disableAutoOpen: !1 });
        }
      }), addEventListener("pageshow", function(y) {
        !fi.disableBfCache && y.persisted && (le && console.debug("Dexie: handling persisted pageshow"), wu(), Xs({ all: new rr(-1 / 0, [[]]) }));
      })), se.rejectionMapper = function(y, A) {
        return !y || y instanceof et || y instanceof TypeError || y instanceof SyntaxError || !y.name || !Tt[y.name] ? y : (A = new Tt[y.name](A || y.message, y), "stack" in y && g(A, "stack", { get: function() {
          return this.inner.stack;
        } }), A);
      }, Lt(le), r(fi, Object.freeze({ __proto__: null, Dexie: fi, liveQuery: Wh, Entity: lu, cmp: ze, PropModification: ba, replacePrefix: function(y, A) {
        return new ba({ replacePrefix: [y, A] });
      }, add: function(y) {
        return new ba({ add: y });
      }, remove: function(y) {
        return new ba({ remove: y });
      }, default: fi, RangeSet: rr, mergeRanges: Ks, rangesOverlap: _u }), { default: fi }), fi;
    });
  }(Yf)), Yf.exports;
}
var DP = PP();
const k0 = /* @__PURE__ */ hh(DP), T2 = Symbol.for("Dexie"), Cp = globalThis[T2] || (globalThis[T2] = k0);
if (k0.semVer !== Cp.semVer)
  throw new Error(`Two different versions of Dexie loaded in the same app: ${k0.semVer} and ${Cp.semVer}`);
const {
  liveQuery: QB,
  mergeRanges: ZB,
  rangesOverlap: JB,
  RangeSet: tF,
  cmp: eF,
  Entity: nF,
  PropModification: rF,
  replacePrefix: iF,
  add: sF,
  remove: oF
} = Cp;
class IP extends Cp {
  constructor() {
    super("BeatGenDB");
    xe(this, "audioFiles");
    xe(this, "midiFiles");
    xe(this, "drumMachineFiles");
    this.version(1).stores({
      audioFiles: "++id, name, type, createdAt, updatedAt, *tags",
      midiFiles: "++id, name, type, trackId, createdAt, updatedAt, *tags",
      drumMachineFiles: "++id, name, trackId, createdAt, updatedAt, *tags"
    }), console.log(" Database initialized:", this.name);
  }
  logOperation(n, r) {
    const i = (/* @__PURE__ */ new Date()).toISOString();
    console.log(` [${i}] ${n}:`, r);
  }
  async logDbState() {
    const n = await this.audioFiles.count(), r = await this.midiFiles.count();
    console.log(" Current DB State:", {
      audioFiles: n,
      midiFiles: r
    });
  }
  // Utility function to create file metadata
  createFileMetadata(n, r = {}) {
    const i = {
      name: n.name,
      type: n.type,
      size: n.size,
      data: n,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date(),
      ...r
    };
    return this.logOperation("Creating file metadata", {
      name: i.name,
      type: i.type,
      size: i.size,
      additionalData: r
    }), i;
  }
  // Audio File Operations
  async addAudioFile(n, r) {
    this.logOperation("Adding audio file", {
      name: n.name,
      type: n.type,
      size: n.size,
      duration: r
    });
    const i = this.createFileMetadata(n, { duration: r }), s = await this.audioFiles.add(i);
    return await this.logDbState(), s;
  }
  async getAudioFile(n) {
    this.logOperation("Getting audio file", { id: n });
    const r = await this.audioFiles.get(n);
    return this.logOperation("Retrieved audio file", {
      id: n,
      found: !!r,
      name: r == null ? void 0 : r.name
    }), r;
  }
  async getAllAudioFiles() {
    this.logOperation("Getting all audio files", {});
    const n = await this.audioFiles.toArray();
    return this.logOperation("Retrieved all audio files", {
      count: n.length,
      names: n.map((r) => r.name)
    }), n;
  }
  async updateAudioFile(n, r) {
    this.logOperation("Updating audio file", { id: n, updates: r }), r.updatedAt = /* @__PURE__ */ new Date();
    const i = await this.audioFiles.update(n, r);
    return this.logOperation("Updated audio file", { id: n, success: i > 0 }), await this.logDbState(), i;
  }
  async deleteAudioFile(n) {
    this.logOperation("Deleting audio file", { id: n }), await this.audioFiles.delete(n), await this.logDbState();
  }
  // MIDI File Operations
  async addMidiFile(n, r, i) {
    this.logOperation("Adding MIDI file", {
      name: n.name,
      type: n.type,
      size: n.size,
      tempo: r,
      timeSignature: i
    });
    const s = this.createFileMetadata(n, { tempo: r, timeSignature: i }), l = await this.midiFiles.add(s);
    return await this.logDbState(), l;
  }
  async getMidiFile(n) {
    this.logOperation("Getting MIDI file", { id: n });
    const r = await this.midiFiles.get(n);
    return this.logOperation("Retrieved MIDI file", {
      id: n,
      found: !!r,
      name: r == null ? void 0 : r.name
    }), r;
  }
  async getAllMidiFiles() {
    this.logOperation("Getting all MIDI files", {});
    const n = await this.midiFiles.toArray();
    return this.logOperation("Retrieved all MIDI files", {
      count: n.length,
      names: n.map((r) => r.name)
    }), n;
  }
  async updateMidiFile(n, r) {
    this.logOperation("Updating MIDI file", { id: n, updates: r }), r.updatedAt = /* @__PURE__ */ new Date();
    const i = await this.midiFiles.update(n, r);
    return this.logOperation("Updated MIDI file", { id: n, success: i > 0 }), await this.logDbState(), i;
  }
  async deleteMidiFile(n) {
    this.logOperation("Deleting MIDI file", { id: n }), await this.midiFiles.delete(n), await this.logDbState();
  }
  // Track-specific MIDI operations
  // Store a MIDI blob for a specific track
  async storeMidiTrackBlob(n, r, i, s, l, c) {
    this.logOperation("Storing MIDI track blob", {
      trackId: n,
      name: r,
      size: i.size,
      bpm: s,
      timeSignature: l
    });
    const u = await this.midiFiles.where("trackId").equals(n).first(), d = `${l[0]}/${l[1]}`;
    if (u)
      return await this.midiFiles.update(u.id, {
        data: i,
        type: "audio/midi",
        size: i.size,
        tempo: s,
        timeSignature: d,
        updatedAt: /* @__PURE__ */ new Date(),
        instrumentId: c
      }), this.logOperation("Updated existing MIDI track", {
        trackId: n,
        fileId: u.id
      }), await this.logDbState(), u.id;
    {
      const h = {
        name: r,
        trackId: n,
        data: i,
        type: "audio/midi",
        size: i.size,
        tempo: s,
        timeSignature: d,
        instrumentId: c,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }, p = await this.midiFiles.add(h);
      return this.logOperation("Created new MIDI track record", {
        trackId: n,
        fileId: p
      }), await this.logDbState(), p;
    }
  }
  // Get MIDI blob for a specific track
  async getMidiTrackBlob(n) {
    this.logOperation("Getting MIDI track blob", { trackId: n });
    const r = await this.midiFiles.where("trackId").equals(n).first();
    return r ? (this.logOperation("Found MIDI track blob", {
      trackId: n,
      fileId: r.id,
      size: r.size
    }), r.data) : (this.logOperation("MIDI track blob not found", { trackId: n }), null);
  }
  // Check if a track has a MIDI file
  async hasMidiTrack(n) {
    return await this.midiFiles.where("trackId").equals(n).count() > 0;
  }
  // Delete MIDI file for a specific track
  async deleteMidiTrack(n) {
    this.logOperation("Deleting MIDI track", { trackId: n }), await this.midiFiles.where("trackId").equals(n).delete(), this.logOperation("Deleted MIDI track", { trackId: n }), await this.logDbState();
  }
  // Search Operations
  async searchAudioFiles(n) {
    this.logOperation("Searching audio files", { query: n });
    const r = await this.audioFiles.where("name").startsWithIgnoreCase(n).or("tags").anyOfIgnoreCase(n).toArray();
    return this.logOperation("Search results for audio files", {
      query: n,
      count: r.length,
      names: r.map((i) => i.name)
    }), r;
  }
  async searchMidiFiles(n) {
    this.logOperation("Searching MIDI files", { query: n });
    const r = await this.midiFiles.where("name").startsWithIgnoreCase(n).or("tags").anyOfIgnoreCase(n).toArray();
    return this.logOperation("Search results for MIDI files", {
      query: n,
      count: r.length,
      names: r.map((i) => i.name)
    }), r;
  }
  // Utility function to get audio duration
  async getAudioDuration(n) {
    return this.logOperation("Getting audio duration", { name: n.name }), new Promise((r, i) => {
      const s = new Audio(), l = URL.createObjectURL(n);
      s.addEventListener("loadedmetadata", () => {
        URL.revokeObjectURL(l), this.logOperation("Got audio duration", {
          name: n.name,
          duration: s.duration
        }), r(s.duration);
      }), s.addEventListener("error", () => {
        URL.revokeObjectURL(l), this.logOperation("Error getting audio duration", {
          name: n.name,
          error: s.error
        }), i(new Error("Error loading audio file"));
      }), s.src = l;
    });
  }
  // Database cleanup
  async clearAllFiles() {
    this.logOperation("Clearing all files from database", {});
    try {
      await this.transaction("rw", this.audioFiles, this.midiFiles, async () => {
        await this.audioFiles.clear(), await this.midiFiles.clear();
      }), this.logOperation("Successfully cleared all files", {}), await this.logDbState();
    } catch (n) {
      throw this.logOperation("Failed to clear files", { error: n }), n;
    }
  }
  // Drum Machine Operations
  async addDrumMachineTrack(n, r = "Drum Machine") {
    this.logOperation("Adding drum machine track", {
      name: r,
      trackId: n
    });
    const i = {
      name: r,
      trackId: n,
      beatsPerMeasure: 4,
      // Default to 4/4 time
      stepsPerBeat: 4,
      // Default to 16th notes
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date()
    }, s = await this.drumMachineFiles.add(i);
    return await this.logDbState(), s;
  }
  async getDrumMachineTrack(n) {
    this.logOperation("Getting drum machine track", { id: n });
    const r = await this.drumMachineFiles.get(n);
    return this.logOperation("Retrieved drum machine track", {
      id: n,
      found: !!r,
      name: r == null ? void 0 : r.name
    }), r;
  }
  async getAllDrumMachineTracks() {
    this.logOperation("Getting all drum machine tracks", {});
    const n = await this.drumMachineFiles.toArray();
    return this.logOperation("Retrieved all drum machine tracks", {
      count: n.length,
      names: n.map((r) => r.name)
    }), n;
  }
  async updateDrumMachineTrack(n, r) {
    this.logOperation("Updating drum machine track", { id: n, updates: r }), r.updatedAt = /* @__PURE__ */ new Date();
    const i = await this.drumMachineFiles.update(n, r);
    return this.logOperation("Updated drum machine track", { id: n, success: i > 0 }), await this.logDbState(), i;
  }
  async deleteDrumMachineTrack(n) {
    this.logOperation("Deleting drum machine track", { id: n }), await this.drumMachineFiles.delete(n), await this.logDbState();
  }
}
const ed = new IP();
class BP {
  constructor() {
    xe(this, "activePlayback", /* @__PURE__ */ new Map());
    xe(this, "tracks", /* @__PURE__ */ new Map());
    xe(this, "subscribers", /* @__PURE__ */ new Map());
    // Track metadata
    xe(this, "currentBpm", 120);
    xe(this, "currentTimeSignature", [4, 4]);
    // Debouncing for persistence operations
    xe(this, "pendingUpdates", /* @__PURE__ */ new Map());
    xe(this, "debounceTime", 500);
  }
  // 500ms debounce time
  async loadMidiFile(t) {
    var s, l, c;
    const n = await t.arrayBuffer(), r = new S2.Midi(n);
    return {
      tracks: r.tracks.map((u) => ({
        id: Og(),
        instrumentId: u.instrument.name || "default",
        notes: u.notes.map((d) => ({
          id: Date.now(),
          row: d.midi,
          // MIDI note number
          column: Math.floor(d.time * 4),
          // Convert time to grid columns (assuming quarter notes)
          length: Math.floor(d.duration * 4),
          // Convert duration to grid units
          velocity: d.velocity,
          duration: d.duration,
          time: d.time
        })),
        name: u.name
      })),
      bpm: ((s = r.header.tempos[0]) == null ? void 0 : s.bpm) || 120,
      timeSignature: [
        ((l = r.header.timeSignatures[0]) == null ? void 0 : l.timeSignature[0]) || 4,
        ((c = r.header.timeSignatures[0]) == null ? void 0 : c.timeSignature[1]) || 4
      ]
    };
  }
  createMidiFile(t) {
    const n = new S2.Midi();
    return n.header.setTempo(t.bpm), n.header.timeSignatures.push({
      ticks: 0,
      timeSignature: t.timeSignature
    }), t.tracks.forEach((r) => {
      const i = n.addTrack();
      r.notes.forEach((s) => {
        i.addNote({
          midi: s.row,
          time: s.time,
          duration: s.duration,
          velocity: s.velocity
        });
      });
    }), new Blob([n.toArray()], { type: "audio/midi" });
  }
  midiToNotes(t) {
    return t.tracks.flatMap(
      (n) => n.notes.map((r) => ({
        id: r.id,
        row: r.row,
        column: r.column,
        length: r.length
      }))
    );
  }
  notesToMidi(t, n) {
    return {
      tracks: [{
        id: Og(),
        instrumentId: "default",
        notes: t.map((i) => ({
          ...i,
          velocity: 0.8,
          // Default velocity
          duration: i.length / 4,
          // Convert grid units to seconds
          time: i.column / 4
          // Convert grid units to seconds
        }))
      }],
      bpm: n,
      timeSignature: this.currentTimeSignature
      // Use current time signature
    };
  }
  createTrack(t, n) {
    const r = Og();
    return this.tracks.set(r, []), {
      id: r,
      instrumentId: t,
      notes: [],
      name: n
    };
  }
  // Subscribe to track updates
  subscribeToTrack(t, n) {
    this.subscribers.has(t) || this.subscribers.set(t, []);
    const r = this.subscribers.get(t) || [];
    return r.push(n), this.subscribers.set(t, r), () => {
      const i = this.subscribers.get(t) || [];
      this.subscribers.set(
        t,
        i.filter((s) => s !== n)
      );
    };
  }
  // Get notes for a track
  getNotesForTrack(t) {
    return this.tracks.get(t) || [];
  }
  schedulePlayback(t) {
    this.stopPlayback(t.id);
    const n = new xp((r, i) => {
      yl.schedule(() => {
      }, r);
    }, t.notes.map((r) => [r.time, r]));
    n.start(0), this.activePlayback.set(t.id, n);
  }
  stopPlayback(t) {
    const n = this.activePlayback.get(t);
    n && (n.dispose(), this.activePlayback.delete(t));
  }
  // BPM and time signature methods
  /**
   * Set the current BPM
   */
  setBpm(t) {
    this.currentBpm = t;
  }
  /**
   * Set the current time signature
   */
  setTimeSignature(t) {
    this.currentTimeSignature = t;
  }
  /**
   * Get the current BPM
   */
  getBpm() {
    return this.currentBpm;
  }
  /**
   * Get the current time signature
   */
  getTimeSignature() {
    return this.currentTimeSignature;
  }
  // INTEGRATED PERSISTENCE METHODS
  /**
   * Create track with persistence
   */
  async createTrackWithPersistence(t, n = `Trackkeeee ${t}`) {
    const r = this.createTrack(t, n);
    try {
      await this.createMidiFileForTrack(
        r.id,
        n,
        t,
        this.currentBpm,
        this.currentTimeSignature
      ), console.log(`MidiManager: Created persisted track ${r.id}`);
    } catch (i) {
      console.error(`MidiManager: Error creating persisted track ${r.id}:`, i);
    }
    return r;
  }
  /**
   * Update track notes and persist to DB
   */
  updateTrack(t, n) {
    console.log(`MidiManager.updateTrack: Updating track ${t} with ${n.length} notes`), this.tracks.set(t, [...n]), this.notifyTrackSubscribers(t, n), this.debouncePersistence(t, n);
  }
  /**
   * Add a single note to a track
   */
  async addNoteToTrack(t, n) {
    console.log(`MidiManager.addNoteToTrack: Adding note to track ${t}`, n);
    const i = [...this.getNotesForTrack(t), n];
    this.updateTrack(t, i);
  }
  /**
   * Remove a single note from a track by its ID
   */
  async removeNoteFromTrack(t, n) {
    console.log(`MidiManager.removeNoteFromTrack: Removing note ${n} from track ${t}`);
    const i = this.getNotesForTrack(t).filter((s) => s.id !== n);
    this.updateTrack(t, i);
  }
  /**
   * Update a single note in a track
   */
  async updateNote(t, n) {
    console.log(`MidiManager.updateNote: Updating note ${n.id} in track ${t}`);
    const i = this.getNotesForTrack(t).map(
      (s) => s.id === n.id ? n : s
    );
    this.updateTrack(t, i);
  }
  /**
   * Notify all subscribers for a specific track
   * Extracted to follow DRY principles
   */
  notifyTrackSubscribers(t, n) {
    this.subscribers.has(t) && (this.subscribers.get(t) || []).forEach((i) => i(t, n));
  }
  /**
   * Debounce persistence operations to reduce DB load
   */
  debouncePersistence(t, n) {
    this.pendingUpdates.has(t) && clearTimeout(this.pendingUpdates.get(t));
    const r = this.tracks.get(t) ? `Tracko ${t}` : `Trackee ${t}`, i = setTimeout(async () => {
      try {
        await this.updateMidiFileForTrack(
          t,
          n,
          this.currentBpm,
          this.currentTimeSignature,
          r
        ), this.pendingUpdates.delete(t);
      } catch (s) {
        console.error(`MidiManager: Error persisting track ${t}:`, s), this.pendingUpdates.delete(t);
      }
    }, this.debounceTime);
    this.pendingUpdates.set(t, i);
  }
  /**
   * Load track data from DB
   */
  async loadTrackFromDB(t) {
    try {
      console.log(`MidiManager: Loading track ${t} from DB`);
      const n = await ed.getMidiTrackBlob(t);
      if (!n)
        return console.log(`MidiManager: No MIDI file found for track ${t}`), [];
      const r = new File([n], `track_${t}.mid`, { type: "audio/midi" }), i = await this.loadMidiFile(r), s = this.midiToNotes(i);
      return s && s.length > 0 && (this.tracks.set(t, s), console.log(`MidiManager: Loaded ${s.length} notes for track ${t} from DB`)), s;
    } catch (n) {
      return console.error(`MidiManager: Error loading track ${t} from DB:`, n), [];
    }
  }
  /**
   * Delete track with persistence cleanup
   */
  async deleteTrackWithPersistence(t) {
    this.tracks.delete(t), this.subscribers.delete(t), this.stopPlayback(t);
    try {
      this.pendingUpdates.has(t) && (clearTimeout(this.pendingUpdates.get(t)), this.pendingUpdates.delete(t)), await ed.deleteMidiTrack(t), console.log(`MidiManager: Deleted persisted track ${t}`);
    } catch (n) {
      console.error(`MidiManager: Error deleting persisted track ${t}:`, n);
    }
  }
  /**
   * Create initial MIDI file for a track
   */
  async createMidiFileForTrack(t, n, r, i, s) {
    try {
      console.log(`MidiManager: Creating MIDI file for track ${t}`);
      const l = this.notesToMidi([], i);
      l.timeSignature = s;
      const c = this.createMidiFile(l);
      await ed.storeMidiTrackBlob(t, n, c, i, s, r), console.log(`MidiManager: Created MIDI file for track ${t}`);
    } catch (l) {
      throw console.error(`MidiManager: Error creating MIDI file for track ${t}:`, l), l;
    }
  }
  /**
   * Update MIDI file for a track
   */
  async updateMidiFileForTrack(t, n, r, i, s = "Midi Track") {
    try {
      console.log(`MidiManager: Updating MIDI file for track ${t} with ${n.length} notes`);
      const l = this.notesToMidi(n, r);
      l.timeSignature = i;
      const c = this.createMidiFile(l);
      await ed.storeMidiTrackBlob(t, s, c, r, i), console.log(`MidiManager: Updated MIDI file for track ${t}`);
    } catch (l) {
      throw console.error(`MidiManager: Error updating MIDI file for track ${t}:`, l), l;
    }
  }
  /**
   * Export MIDI file from DB
   */
  async exportMidiFileFromDB(t) {
    try {
      console.log(`MidiManager: Exporting track ${t} from DB`);
      const n = await ed.getMidiTrackBlob(t);
      if (n)
        return n;
      const r = this.getNotesForTrack(t);
      if (r.length > 0) {
        console.log(`MidiManager: Creating MIDI export from ${r.length} in-memory notes`);
        const i = this.notesToMidi(r, this.currentBpm);
        return this.createMidiFile(i);
      }
      return console.warn(`MidiManager: No data found for track ${t} to export`), null;
    } catch (n) {
      return console.error(`MidiManager: Error exporting track ${t}:`, n), null;
    }
  }
}
class FP {
  constructor() {
    xe(this, "instruments", /* @__PURE__ */ new Map());
  }
  async createInstrument(t) {
    let n;
    switch (t.type) {
      case "synth":
        n = new Yy(Kc, {
          ...t.settings
        }).toDestination();
        break;
      case "sampler":
        n = new Ih({
          ...t.settings
        }).toDestination();
        break;
      case "custom":
        throw new Error("Custom instruments not implemented yet");
      default:
        throw new Error(`Unknown instrument type: ${t.type}`);
    }
    const r = {
      id: t.id,
      config: t,
      toneInstrument: n
    };
    return this.instruments.set(t.id, r), r;
  }
  deleteInstrument(t) {
    const n = this.instruments.get(t);
    n && (n.toneInstrument.dispose(), this.instruments.delete(t));
  }
  getInstrument(t) {
    return this.instruments.get(t);
  }
  playNote(t, n, r, i) {
    const s = this.instruments.get(t);
    if (!s) return;
    const l = r2(n, "midi").toFrequency();
    r ? s.toneInstrument.triggerAttackRelease([l], r, i) : s.toneInstrument.triggerAttack([l], i);
  }
  stopNote(t, n, r) {
    const i = this.instruments.get(t);
    if (!i) return;
    const s = r2(n, "midi").toFrequency();
    i.toneInstrument.triggerRelease([s], r);
  }
  updateInstrumentSettings(t, n) {
    const r = this.instruments.get(t);
    r && Object.entries(n).forEach(([i, s]) => {
      typeof r.toneInstrument.set == "function" && r.toneInstrument.set({ [i]: s });
    });
  }
  dispose() {
    this.instruments.forEach((t) => {
      t.toneInstrument.dispose();
    }), this.instruments.clear();
  }
}
class jP {
  // Track change listeners
  constructor() {
    xe(this, "audioEngine");
    xe(this, "projectManager");
    xe(this, "transportController");
    xe(this, "initialized", !1);
    xe(this, "midiManager");
    xe(this, "instrumentManager");
    xe(this, "_tracks", []);
    // Array of tracks
    xe(this, "_listeners", []);
    this.audioEngine = Tp.getInstance(), this.projectManager = new pP(), this.transportController = new E0(), this.midiManager = new BP(), this.instrumentManager = new FP();
    const t = this.projectManager.getCurrentProject();
    t && (this.midiManager.setBpm(t.tempo), this.midiManager.setTimeSignature(t.timeSignature)), this.initialized = !0;
  }
  async initializeAudio() {
    if (!this.initialized)
      try {
        await this.audioEngine.initialize(), this.initialized = !0, this.syncTracksFromProjectManager();
      } catch (t) {
        throw console.error("Store: Audio initialization failed:", t), t;
      }
  }
  /**
   * Synchronize tracks from ProjectManager to our internal tracks array
   */
  syncTracksFromProjectManager() {
    const t = this.projectManager.getCurrentProject();
    t && (console.log("Synchronizing tracks from ProjectManager..."), t.tracks.forEach((n) => {
      this.addTrackToInternalState(n);
    }), console.log(`Total tracks after sync: ${this._tracks.length}`));
  }
  getTransport() {
    return this.transportController;
  }
  async createTrack(t, n, r) {
    if (!this.initialized)
      throw new Error("Store must be initialized before creating tracks");
    const i = r ? this.projectManager.addTrackWithProperties({
      id: r.id,
      name: t,
      type: n,
      volume: r.volume,
      pan: r.pan,
      muted: r.muted,
      soloed: r.soloed
    }) : this.projectManager.addTrack(t, n);
    if (n === "midi" || n === "drum")
      try {
        const s = this.projectManager.getCurrentProject();
        s && (this.midiManager.setBpm(s.tempo), await this.midiManager.createTrackWithPersistence(
          i.id,
          // Always use the track ID (whether new or existing)
          t
        ), console.log(r ? `Store: Using existing ${n} track ID: ${i.id} for persistence` : `Store: Created persisted ${n} track: ${i.id}`));
      } catch (s) {
        console.error(`Store: Error creating persisted ${n} track:`, s);
      }
    return this.addTrackToInternalState(i), i;
  }
  /**
   * Add a track to the internal _tracks array
   */
  addTrackToInternalState(t) {
    if (this._tracks.some((r) => r.id === t.id))
      return;
    const n = new po().toDestination();
    this._tracks.push({
      id: t.id,
      name: t.name,
      type: t.type,
      muted: t.muted,
      soloed: t.soloed,
      volume: t.volume,
      pan: t.pan,
      channel: n,
      position: { x: 0, y: this._tracks.length * 40 },
      // Default position
      drumPads: t.type === "drum" ? [] : void 0
    }), console.log(`Added track ${t.id} of type ${t.type} to internal state`), this._notifyListeners();
  }
  async loadAudioFile(t, n) {
    await this.transportController.loadAudioFile(t, n);
  }
  async removeTrack(t) {
    const n = this._tracks.find((r) => r.id === t);
    n && (n.type === "midi" || n.type === "drum") && await this.midiManager.deleteTrackWithPersistence(t), this.projectManager.removeTrack(t), this._tracks = this._tracks.filter((r) => r.id !== t), this.audioEngine.removeTrack(t), this._notifyListeners();
  }
  getAudioEngine() {
    return this.audioEngine;
  }
  getInstrumentManager() {
    return this.instrumentManager;
  }
  getMidiManager() {
    return this.midiManager;
  }
  /**
   * Add a listener for track changes
   */
  addListener(t) {
    this._listeners.push(t);
  }
  /**
   * Remove a listener
   */
  removeListener(t) {
    const n = this._listeners.indexOf(t);
    n !== -1 && this._listeners.splice(n, 1);
  }
  /**
   * Notify all listeners of changes
   */
  _notifyListeners() {
    this._listeners.forEach((t) => t());
  }
  /**
   * Gets the track with the specified ID
   */
  getTrackById(t) {
    return this._tracks.find((n) => n.id === t);
  }
  /**
   * Gets the drum pads for a track
   */
  getDrumPads(t) {
    const n = this._tracks.find((r) => r.id === t);
    return !n || n.type !== "drum" ? [] : (n.drumPads || (n.drumPads = []), n.drumPads);
  }
  /**
   * Toggles a drum pad on/off
   */
  toggleDrumPad(t, n, r) {
    console.log(`Store.toggleDrumPad called for track ${t}, column ${n}, row ${r}`);
    const i = this.getTrackById(t);
    if (!i || i.type !== "drum") {
      console.warn(`Cannot toggle drum pad: Track ${t} not found or not a drum track`);
      return;
    }
    i.drumPads || (i.drumPads = []);
    const s = i.drumPads.findIndex(
      (l) => l.column === n && l.row === r
    );
    s >= 0 ? (i.drumPads.splice(s, 1), console.log(`Removed drum pad at column ${n}, row ${r} for track ${t}`)) : (i.drumPads.push({
      row: r,
      column: n,
      velocity: 100
      // Default velocity
    }), console.log(`Added drum pad at column ${n}, row ${r} for track ${t}`)), console.log(`Drum pads for track ${t}: ${i.drumPads.length}`), this._notifyListeners();
  }
}
class LP {
  constructor(t, n, r, i, s) {
    xe(this, "type", "TRACK_VOLUME_CHANGE");
    this.store = t, this.trackId = n, this.oldVolume = r, this.newVolume = i, this.updateTrackVolume = s;
  }
  async execute() {
    this.updateTrackVolume(this.trackId, this.newVolume), console.log(" Execute TrackVolumeChangeAction:", {
      trackId: this.trackId,
      from: this.oldVolume,
      to: this.newVolume
    });
  }
  async undo() {
    this.updateTrackVolume(this.trackId, this.oldVolume), console.log(" Undo TrackVolumeChangeAction:", {
      trackId: this.trackId,
      from: this.newVolume,
      to: this.oldVolume
    });
  }
}
class zP {
  constructor(t, n, r, i, s) {
    xe(this, "type", "TRACK_PAN_CHANGE");
    this.store = t, this.trackId = n, this.oldPan = r, this.newPan = i, this.updateTrackPan = s;
  }
  async execute() {
    this.updateTrackPan(this.trackId, this.newPan), console.log(" Execute TrackPanChangeAction:", {
      trackId: this.trackId,
      from: this.oldPan,
      to: this.newPan
    });
  }
  async undo() {
    this.updateTrackPan(this.trackId, this.oldPan), console.log(" Undo TrackPanChangeAction:", {
      trackId: this.trackId,
      from: this.newPan,
      to: this.oldPan
    });
  }
}
class UP {
  constructor(t, n, r, i, s, l) {
    xe(this, "type", "TRACK_POSITION_CHANGE");
    this.store = t, this.trackId = n, this.oldPosition = r, this.newPosition = i, this.updateTrackPosition = s, this.isPlaying = l;
  }
  async execute() {
    var n, r;
    this.updateTrackPosition(this.trackId, this.newPosition), this.store.getAudioEngine().setTrackPosition(
      this.trackId,
      this.newPosition.x,
      this.newPosition.y
    );
    const t = this.store.getTransport().isPlaying;
    t && (console.log("Playback active during execute - syncing track with transport"), (r = (n = this.store.getTransport()).handleTrackPositionChange) == null || r.call(n, this.trackId, this.newPosition.x)), console.log(" Execute TrackPositionChangeAction:", {
      trackId: this.trackId,
      from: this.oldPosition,
      to: this.newPosition,
      isCurrentlyPlaying: t
    });
  }
  async undo() {
    var n, r;
    this.updateTrackPosition(this.trackId, this.oldPosition), this.store.getAudioEngine().setTrackPosition(
      this.trackId,
      this.oldPosition.x,
      this.oldPosition.y
    );
    const t = this.store.getTransport().isPlaying;
    t && (console.log("Playback active during undo - syncing track with transport"), (r = (n = this.store.getTransport()).handleTrackPositionChange) == null || r.call(n, this.trackId, this.oldPosition.x)), console.log(" Undo TrackPositionChangeAction:", {
      trackId: this.trackId,
      from: this.newPosition,
      to: this.oldPosition,
      isCurrentlyPlaying: t
    });
  }
}
class VP {
  constructor(t, n, r, i, s, l) {
    xe(this, "type", "BPM_CHANGE");
    this.store = t, this.oldBpm = n, this.newBpm = r, this.setBpm = i, this.setTracks = s, this.timeSignature = l;
  }
  updateBPM(t) {
    yl.bpm.value = t, this.setBpm(t), this.setTracks(
      (n) => n.map((r) => r.duration ? {
        ...r,
        _calculatedWidth: cp(r.duration, t, this.timeSignature)
      } : r)
    );
  }
  async execute() {
    this.updateBPM(this.newBpm), console.log(" Execute BPMChangeAction:", { from: this.oldBpm, to: this.newBpm });
  }
  async undo() {
    this.updateBPM(this.oldBpm), console.log(" Undo BPMChangeAction:", { from: this.newBpm, to: this.oldBpm });
  }
}
class GP {
  constructor(t, n, r, i, s, l) {
    xe(this, "type", "TIME_SIGNATURE_CHANGE");
    this.store = t, this.oldTimeSignature = n, this.newTimeSignature = r, this.setTimeSignature = i, this.setTracks = s, this.bpm = l;
  }
  updateTimeSignature(t) {
    const [n, r] = t;
    yl.timeSignature = t, this.setTimeSignature(n, r), this.setTracks(
      (i) => i.map((s) => s.duration ? {
        ...s,
        _calculatedWidth: cp(s.duration, this.bpm, t)
      } : s)
    );
  }
  async execute() {
    this.updateTimeSignature(this.newTimeSignature), console.log(" Execute TimeSignatureChangeAction:", {
      from: this.oldTimeSignature,
      to: this.newTimeSignature
    });
  }
  async undo() {
    this.updateTimeSignature(this.oldTimeSignature), console.log(" Undo TimeSignatureChangeAction:", {
      from: this.newTimeSignature,
      to: this.oldTimeSignature
    });
  }
}
class qP {
  constructor(t, n, r, i) {
    xe(this, "type", "KEY_SIGNATURE_CHANGE");
    this.store = t, this.oldKeySignature = n, this.newKeySignature = r, this.setKeySignature = i;
  }
  async execute() {
    this.setKeySignature(this.newKeySignature), this.store.projectManager && typeof this.store.projectManager.setKey == "function" && this.store.projectManager.setKey(this.newKeySignature), console.log(" Execute KeySignatureChangeAction:", {
      from: this.oldKeySignature,
      to: this.newKeySignature
    });
  }
  async undo() {
    this.setKeySignature(this.oldKeySignature), this.store.projectManager && typeof this.store.projectManager.setKey == "function" && this.store.projectManager.setKey(this.oldKeySignature), console.log(" Undo KeySignatureChangeAction:", {
      from: this.newKeySignature,
      to: this.oldKeySignature
    });
  }
}
class C2 {
  constructor(t, n, r, i) {
    xe(this, "type", "TRACK_ADD");
    this.store = t, this.trackData = n, this.addTrack = r, this.removeTrack = i;
  }
  async execute() {
    this.addTrack(this.trackData), this.trackData.type === "audio" && this.trackData.audioFile && (console.log("Reloading audio file for track during redo:", this.trackData.id), await this.store.loadAudioFile(this.trackData.id, this.trackData.audioFile)), this.store.getAudioEngine().setTrackVolume(this.trackData.id, this.trackData.volume), this.store.getAudioEngine().setTrackPan(this.trackData.id, this.trackData.pan), this.trackData.muted && this.store.getAudioEngine().setTrackMute(this.trackData.id, !0), this.store.getAudioEngine().setTrackPosition(
      this.trackData.id,
      this.trackData.position.x,
      this.trackData.position.y
    );
    const t = this.store.getTransport().isPlaying;
    t && (console.log("Playback is active - syncing newly added track with transport"), setTimeout(() => {
      this.store.getTransport().handleTrackPositionChange(
        this.trackData.id,
        this.trackData.position.x
      );
    }, 10)), console.log(" Execute TrackAddAction:", {
      trackId: this.trackData.id,
      name: this.trackData.name,
      type: this.trackData.type,
      isPlaying: t
    });
  }
  async undo() {
    this.removeTrack(this.trackData.id), console.log(" Undo TrackAddAction:", {
      trackId: this.trackData.id,
      name: this.trackData.name
    });
  }
}
class HP {
  constructor(t, n, r, i) {
    xe(this, "type", "TRACK_DELETE");
    this.store = t, this.trackData = n, this.addTrack = r, this.removeTrack = i;
  }
  async execute() {
    this.removeTrack(this.trackData.id), console.log(" Execute TrackDeleteAction:", {
      trackId: this.trackData.id,
      name: this.trackData.name
    });
  }
  async undo() {
    this.addTrack(this.trackData), this.trackData.type === "audio" && this.trackData.audioFile && await this.store.loadAudioFile(this.trackData.id, this.trackData.audioFile), this.store.getAudioEngine().setTrackPosition(
      this.trackData.id,
      this.trackData.position.x,
      this.trackData.position.y
    ), this.trackData.muted && this.store.getAudioEngine().setTrackMute(this.trackData.id, !0), this.trackData.soloed && this.store.getAudioEngine().setTrackSolo(this.trackData.id, !0), this.store.getAudioEngine().setTrackVolume(this.trackData.id, this.trackData.volume), this.store.getAudioEngine().setTrackPan(this.trackData.id, this.trackData.pan);
    const t = this.store.getTransport().isPlaying;
    t && (console.log("Playback active during undo of delete - syncing restored track with transport"), this.store.getTransport().handleTrackPositionChange(
      this.trackData.id,
      this.trackData.position.x
    )), console.log(" Undo TrackDeleteAction:", {
      trackId: this.trackData.id,
      name: this.trackData.name,
      isPlaying: t
    });
  }
}
const Yc = TA((e, t) => ({
  // Default State
  store: new jP(),
  isInitialized: !1,
  isPlaying: !1,
  currentTime: 0,
  projectTitle: "Untitled Project",
  bpm: 120,
  timeSignature: [4, 4],
  keySignature: "C major",
  // Default key signature is C major
  tracks: [],
  zoomLevel: 1,
  measureCount: 40,
  // Initial number of measures
  canUndo: !1,
  canRedo: !1,
  addMenuAnchor: null,
  // Actions for state updates
  setStore: (n) => e({ store: n }),
  setIsInitialized: (n) => e({ isInitialized: n }),
  setIsPlaying: (n) => e({ isPlaying: n }),
  setCurrentTime: (n) => e({ currentTime: n }),
  setProjectTitle: (n) => {
    e({ projectTitle: n });
    const { store: r } = t();
    r && r.projectManager.getCurrentProject() && r.projectManager.setProjectName(n);
  },
  setBpm: (n) => {
    const r = t().bpm;
    if (r === n) return;
    e({ bpm: n });
    const { store: i, timeSignature: s } = t();
    if (i) {
      i.projectManager.setTempo(n), yl.bpm.value = n;
      const l = new VP(
        i,
        r,
        n,
        (c) => e({ bpm: c }),
        (c) => e((u) => ({ tracks: c(u.tracks) })),
        s
      );
      Ue.executeAction(l).then(() => {
        e({
          canUndo: Ue.canUndo(),
          canRedo: Ue.canRedo()
        });
      });
    }
  },
  setTimeSignature: (n, r) => {
    const i = t().timeSignature, s = [n, r];
    if (i[0] === n && i[1] === r) return;
    e({ timeSignature: s });
    const { store: l, bpm: c } = t();
    if (l) {
      l.projectManager.setTimeSignature(n, r), yl.timeSignature = s;
      const u = new GP(
        l,
        i,
        s,
        (d, h) => e({ timeSignature: [d, h] }),
        (d) => e((h) => ({ tracks: d(h.tracks) })),
        c
      );
      Ue.executeAction(u).then(() => {
        e({
          canUndo: Ue.canUndo(),
          canRedo: Ue.canRedo()
        });
      });
    }
  },
  setKeySignature: (n) => {
    const r = t().keySignature;
    if (r === n) return;
    e({ keySignature: n });
    const { store: i } = t();
    if (i) {
      const s = new qP(
        i,
        r,
        n,
        (l) => e({ keySignature: l })
      );
      Ue.executeAction(s).then(() => {
        e({
          canUndo: Ue.canUndo(),
          canRedo: Ue.canRedo()
        });
      });
    }
  },
  setTracks: (n) => e({ tracks: n }),
  setZoomLevel: (n) => e({ zoomLevel: n }),
  setMeasureCount: (n) => e({ measureCount: n }),
  setCanUndo: (n) => e({ canUndo: n }),
  setCanRedo: (n) => e({ canRedo: n }),
  setAddMenuAnchor: (n) => e({ addMenuAnchor: n }),
  // Core initialization
  initializeAudio: async () => {
    const { store: n, projectTitle: r } = t();
    if (n)
      try {
        if (!n.projectManager.getCurrentProject()) {
          console.log("Creating a new project");
          const i = n.projectManager.createProject(r);
          console.log("Project created:", i);
        }
        await n.initializeAudio(), e({ isInitialized: !0 }), window.storeInstance = n, console.log("Audio engine initialized");
      } catch (i) {
        console.error("Failed to initialize audio:", i), e({ isInitialized: !1 });
      }
  },
  // Track operations with history support
  handleTrackVolumeChange: (n, r) => {
    const { store: i, tracks: s } = t();
    if (!i) return;
    const l = s.find((d) => d.id === n);
    if (!l) {
      console.error(`Track with ID ${n} not found in handleTrackVolumeChange`);
      return;
    }
    const c = l.volume;
    if (c === r) return;
    const u = new LP(
      i,
      n,
      c,
      r,
      // Direct update function that bypasses history
      (d, h) => {
        const { tracks: p } = t();
        e({
          tracks: p.map((v) => v.id === d ? { ...v, volume: h } : v)
        }), i.getAudioEngine().setTrackVolume(d, h);
      }
    );
    Ue.executeAction(u).then(() => {
      e({
        canUndo: Ue.canUndo(),
        canRedo: Ue.canRedo()
      });
    });
  },
  handleTrackPanChange: (n, r) => {
    const { store: i, tracks: s } = t();
    if (!i) return;
    const l = s.find((d) => d.id === n);
    if (!l) {
      console.error(`Track with ID ${n} not found in handleTrackPanChange`);
      return;
    }
    const c = l.pan;
    if (c === r) return;
    const u = new zP(
      i,
      n,
      c,
      r,
      // Direct update function that bypasses history
      (d, h) => {
        const { tracks: p } = t();
        e({
          tracks: p.map((v) => v.id === d ? { ...v, pan: h } : v)
        }), i.getAudioEngine().setTrackPan(d, h), console.log(`History manager updated track ${d} pan to:`, h);
      }
    );
    Ue.executeAction(u).then(() => {
      e({
        canUndo: Ue.canUndo(),
        canRedo: Ue.canRedo()
      });
    });
  },
  handleTrackMuteToggle: (n, r) => {
    const { store: i, tracks: s } = t();
    if (!i) return;
    const l = s.map(
      (c) => c.id === n ? { ...c, muted: r } : c
    );
    e({ tracks: l }), i.getAudioEngine().setTrackMute(n, r);
  },
  handleTrackSoloToggle: (n, r) => {
    const { store: i, tracks: s } = t();
    if (!i) return;
    const l = s.map(
      (u) => u.id === n ? { ...u, soloed: r } : u
    );
    e({ tracks: l }), l.some((u) => u.soloed) ? l.forEach((u) => {
      const d = !u.soloed;
      u.muted !== d && i.getAudioEngine().setTrackMute(u.id, d);
    }) : l.forEach((u) => {
      i.getAudioEngine().setTrackMute(u.id, u.muted);
    });
  },
  handleTrackDelete: async (n) => {
    const { store: r, tracks: i } = t();
    if (r)
      try {
        const s = i.find((u) => u.id === n);
        if (!s) {
          console.error(`Track with ID ${n} not found for deletion`);
          return;
        }
        const l = { ...s }, c = new HP(
          r,
          l,
          // Add track callback
          (u) => {
            console.log("History: Re-adding deleted track:", u.id), e((d) => ({ tracks: [...d.tracks, u] }));
          },
          // Remove track callback
          (u) => {
            console.log("History: Removing track:", u), e((d) => ({ tracks: d.tracks.filter((h) => h.id !== u) })), r.getAudioEngine().removeTrack(u);
          }
        );
        await Ue.executeAction(c), e({
          canUndo: Ue.canUndo(),
          canRedo: Ue.canRedo()
        }), console.log(`Track ${n} deleted successfully (with history support)`);
      } catch (s) {
        console.error(`Failed to delete track ${n}:`, s);
      }
  },
  handleAddTrack: async (n) => {
    const { store: r, isInitialized: i, tracks: s, timeSignature: l, bpm: c } = t();
    if (!r || !i) {
      console.warn("Store not initialized");
      return;
    }
    try {
      let u;
      n === "midi" ? u = `MIDI Track ${s.length + 1}` : n === "drum" ? u = "Drum Machine" : u = `Audio Track ${s.length + 1}`;
      const d = await r.createTrack(u, n), h = await r.getAudioEngine().createTrack(d.id, d.name), g = 4 * l[0] * 60 / c, b = {
        x: 0,
        y: s.length * Ie.trackHeight
        // Use the proper track height from constants
      }, x = {
        ...d,
        ...h,
        position: b,
        duration: g,
        type: n,
        _calculatedWidth: cp(g, c, l)
      };
      r.getAudioEngine().setTrackPosition(
        x.id,
        b.x,
        b.y
      );
      const w = new C2(
        r,
        x,
        // Add track callback
        (T) => {
          console.log("History: Adding track:", T.id), e((S) => ({ tracks: [...S.tracks, T] }));
        },
        // Remove track callback
        (T) => {
          console.log("History: Removing track:", T), e((S) => ({ tracks: S.tracks.filter((C) => C.id !== T) })), r.getAudioEngine().removeTrack(T);
        }
      );
      await Ue.executeAction(w), e({
        canUndo: Ue.canUndo(),
        canRedo: Ue.canRedo()
      }), console.log(`Added new ${n} track (with history support):`, x);
    } catch (u) {
      console.error(`Failed to create ${n} track:`, u);
    }
  },
  handleTrackPositionChange: (n, r, i) => {
    var h, p;
    const { store: s, tracks: l, isPlaying: c } = t();
    if (!s) return;
    const u = l.find((v) => v.id === n);
    if (!u || i && u.position.x === r.x && u.position.y === r.y)
      return;
    const d = l.map(
      (v) => v.id === n ? { ...v, position: r } : v
    );
    if (e({ tracks: d }), s.getAudioEngine().setTrackPosition(
      n,
      r.x,
      r.y
    ), i) {
      const v = { ...u.position }, m = new UP(
        s,
        n,
        v,
        r,
        // Direct update function that bypasses history
        (g, b) => {
          var w, T;
          const { tracks: x } = t();
          e({
            tracks: x.map((S) => S.id === g ? { ...S, position: b } : S)
          }), s.getAudioEngine().setTrackPosition(g, b.x, b.y), c && ((T = (w = s.getTransport()).handleTrackPositionChange) == null || T.call(w, g, b.x)), console.log(`History manager updated track ${g} position to:`, b);
        },
        c
      );
      Ue.executeAction(m).then(() => {
        e({
          canUndo: Ue.canUndo(),
          canRedo: Ue.canRedo()
        });
      }), c && ((p = (h = s.getTransport()).handleTrackPositionChange) == null || p.call(h, n, r.x)), console.log(`Track ${n} repositioned to:`, r);
    }
  },
  uploadAudioFile: async (n) => {
    var c, u;
    const { store: r, tracks: i, bpm: s, timeSignature: l } = t();
    if (!(!r || !t().isInitialized))
      try {
        const d = n.name.split(".")[0], h = await r.createTrack(d, "audio");
        await r.loadAudioFile(h.id, n);
        const p = r.getAudioEngine().getAllTracks().find((b) => b.id === h.id);
        if (!p) throw new Error("Failed to get created audio track");
        const v = ((u = (c = p.player) == null ? void 0 : c.buffer) == null ? void 0 : u.duration) || 0, m = {
          ...h,
          ...p,
          position: {
            x: 0,
            y: i.length * Ie.trackHeight
            // Use the proper track height from constants
          },
          duration: v,
          audioFile: n,
          type: "audio",
          _calculatedWidth: cp(v, s, l)
        };
        r.getAudioEngine().setTrackPosition(
          m.id,
          m.position.x,
          m.position.y
        );
        const g = new C2(
          r,
          m,
          // Add track callback
          (b) => {
            console.log("History: Adding audio file track:", b.id), e((x) => ({ tracks: [...x.tracks, b] })), b.audioFile && r.loadAudioFile(b.id, b.audioFile).catch((x) => {
              console.error("Failed to reload audio file during redo:", x);
            });
          },
          // Remove track callback
          (b) => {
            console.log("History: Removing audio file track:", b), e((x) => ({ tracks: x.tracks.filter((w) => w.id !== b) })), r.getAudioEngine().removeTrack(b);
          }
        );
        await Ue.executeAction(g), e({
          canUndo: Ue.canUndo(),
          canRedo: Ue.canRedo()
        }), console.log("Added audio track from file (with history support):", m);
      } catch (d) {
        console.error("Failed to upload audio file:", d);
      }
  },
  handleTrackNameChange: (n, r) => {
    const { store: i, tracks: s } = t();
    if (!i) return;
    const l = s.map(
      (c) => c.id === n ? { ...c, name: r } : c
    );
    e({ tracks: l }), i.getAudioEngine().setTrackName(n, r);
  },
  // Transport actions
  playPause: async () => {
    const { store: n, isPlaying: r } = t();
    if (n)
      try {
        r ? (console.log(" UI: Triggering pause"), n.getTransport().pause(), e({ isPlaying: !1 })) : (console.log(" UI: Triggering play"), await n.getTransport().play(), e({ isPlaying: !0 }));
      } catch (i) {
        console.error("Playback control failed:", i), e({ isPlaying: !1 });
      }
  },
  stop: () => {
    const { store: n } = t();
    n && (console.log(" UI: Triggering stop"), n.getTransport().stop(), e({
      isPlaying: !1,
      currentTime: 0
    }));
  },
  seekToPosition: (n) => {
    const { store: r } = t();
    r && (r.getTransport().setPosition(n), e({ currentTime: n }));
  },
  // History actions for undo/redo
  undo: async () => {
    Ue.canUndo() ? (console.log(" Performing undo operation"), await Ue.undo(), e({
      canUndo: Ue.canUndo(),
      canRedo: Ue.canRedo()
    })) : console.log(" No actions to undo");
  },
  redo: async () => {
    Ue.canRedo() ? (console.log(" Performing redo operation"), await Ue.redo(), e({
      canUndo: Ue.canUndo(),
      canRedo: Ue.canRedo()
    })) : console.log(" No actions to redo");
  }
})), dx = K.createContext(null), WP = ({ children: e }) => {
  const [t, n] = K.useState(null), [r, i] = K.useState({}), [s, l] = K.useState({}), { store: c } = Yc(), b = {
    activePianoRoll: t,
    openedPianoRolls: r,
    notesByTrack: s,
    openPianoRoll: (x) => {
      console.log("Opening piano roll for track:", x), n(x), i((w) => ({ ...w, [x]: !0 })), s[x] || (console.log("Initializing notes array for track:", x), l((w) => ({ ...w, [x]: [] }))), console.log("Piano roll state after opening:", {
        activePianoRoll: x,
        openedPianoRolls: { ...r, [x]: !0 },
        notesByTrack: s
      });
    },
    closePianoRoll: (x) => {
      i((w) => ({ ...w, [x]: !1 })), t === x && n(null);
    },
    createNote: async (x, w) => {
      if (!c) return;
      const T = s[x] || [], S = { ...w, trackId: x }, C = new yA(
        c,
        (E) => {
          l((O) => {
            const B = { ...O };
            return B[x] = E, B;
          });
        },
        S,
        T
      );
      await Ue.executeAction(C);
    },
    moveNote: async (x, w, T, S) => {
      if (!c) return;
      const C = s[x] || [], E = new vA(
        c,
        (O) => {
          l((B) => {
            const N = { ...B };
            return N[x] = O, N;
          });
        },
        w,
        T,
        S,
        C
      );
      await Ue.executeAction(E);
    },
    resizeNote: async (x, w, T, S, C, E) => {
      if (!c) return;
      const O = s[x] || [], B = new bA(
        c,
        (N) => {
          l((L) => {
            const k = { ...L };
            return k[x] = N, k;
          });
        },
        w,
        T,
        S,
        O,
        C,
        E
      );
      await Ue.executeAction(B);
    },
    playPreview: (x) => {
      var T, S;
      if (!c || !t) return;
      const w = (T = c.getTrackById) == null ? void 0 : T.call(c, t);
      w && ((S = c.getInstrumentManager()) == null || S.playNote(w.instrumentId || "default", x));
    },
    stopPreview: (x) => {
      var T, S;
      if (!c || !t) return;
      const w = (T = c.getTrackById) == null ? void 0 : T.call(c, t);
      w && ((S = c.getInstrumentManager()) == null || S.stopNote(w.instrumentId || "default", x));
    }
  };
  return /* @__PURE__ */ W.jsx(dx.Provider, { value: b, children: e });
}, Sl = () => {
  const e = K.useContext(dx);
  if (!e)
    throw new Error("usePianoRoll must be used within a PianoRollProvider");
  return e;
}, $P = ({
  children: e,
  title: t,
  isOpen: n,
  onClose: r,
  initialPosition: i = { x: 100, y: 100 },
  initialSize: s = { width: 800, height: 500 }
}) => {
  const [l, c] = K.useState(i), [u, d] = K.useState(s), [h, p] = K.useState(!1), [v, m] = K.useState(!1), [g, b] = K.useState({ x: 0, y: 0 }), x = K.useRef(null), w = K.useRef(!1);
  K.useEffect(() => {
    n && !w.current ? (c(i), d(s), w.current = !0) : n || (w.current = !1);
  }, [n, i, s]), K.useEffect(() => {
    const C = (O) => {
      if (h) {
        const B = O.clientX - g.x, N = O.clientY - g.y;
        c({ x: B, y: N });
      } else if (v && x.current) {
        const B = x.current.getBoundingClientRect(), N = Math.max(400, O.clientX - B.left), L = Math.max(300, O.clientY - B.top);
        d({
          width: N,
          height: L
        });
      }
    }, E = () => {
      p(!1), m(!1);
    };
    return (h || v) && (document.addEventListener("mousemove", C), document.addEventListener("mouseup", E)), () => {
      document.removeEventListener("mousemove", C), document.removeEventListener("mouseup", E);
    };
  }, [h, v, g]);
  const T = (C) => {
    C.preventDefault(), !C.target.closest(".close-button") && (p(!0), b({
      x: C.clientX - l.x,
      y: C.clientY - l.y
    }));
  }, S = (C) => {
    C.preventDefault(), C.stopPropagation(), m(!0);
  };
  return n ? /* @__PURE__ */ W.jsx(
    LS,
    {
      open: !0,
      disableAutoFocus: !0,
      disableEscapeKeyDown: !0,
      onClose: r,
      sx: {
        pointerEvents: "none",
        // Make the modal container non-blocking
        "& .MuiBackdrop-root": {
          backgroundColor: "rgba(0, 0, 0, 0.2)",
          pointerEvents: "none"
          // Let clicks through the backdrop
        }
      },
      keepMounted: !0,
      children: /* @__PURE__ */ W.jsxs(
        Zt,
        {
          ref: x,
          sx: {
            position: "absolute",
            left: `${l.x}px`,
            top: `${l.y}px`,
            width: `${u.width}px`,
            height: `${u.height}px`,
            bgcolor: "#222",
            boxShadow: 24,
            borderRadius: 1,
            display: "flex",
            flexDirection: "column",
            outline: "none",
            overflow: "hidden",
            pointerEvents: "auto",
            // Re-enable pointer events for the modal content
            color: "white"
          },
          children: [
            /* @__PURE__ */ W.jsx(
              Zt,
              {
                sx: {
                  height: "32px",
                  bgcolor: "#333",
                  display: "flex",
                  alignItems: "center",
                  pl: 2,
                  pr: 4,
                  cursor: "move",
                  borderTopLeftRadius: "inherit",
                  borderTopRightRadius: "inherit",
                  userSelect: "none"
                },
                onMouseDown: T,
                children: /* @__PURE__ */ W.jsx(Hr, { variant: "subtitle2", sx: { fontWeight: "bold", flex: 1 }, children: t })
              }
            ),
            /* @__PURE__ */ W.jsx(
              Nc,
              {
                onClick: r,
                className: "close-button",
                sx: {
                  position: "absolute",
                  right: 8,
                  top: 4,
                  minWidth: "auto",
                  width: 24,
                  height: 24,
                  p: 0,
                  color: "#999",
                  zIndex: 10,
                  fontSize: "18px",
                  lineHeight: 1,
                  "&:hover": {
                    color: "#fff",
                    bgcolor: "rgba(255, 255, 255, 0.1)"
                  }
                },
                children: ""
              }
            ),
            /* @__PURE__ */ W.jsx(Zt, { sx: {
              flex: 1,
              overflow: "hidden",
              bgcolor: "#181818",
              borderBottomLeftRadius: "inherit",
              borderBottomRightRadius: "inherit"
            }, children: e }),
            /* @__PURE__ */ W.jsx(
              Zt,
              {
                sx: {
                  position: "absolute",
                  bottom: 0,
                  right: 0,
                  width: 20,
                  height: 20,
                  cursor: "se-resize",
                  bgcolor: "transparent",
                  "&:hover": {
                    bgcolor: "rgba(255, 255, 255, 0.1)"
                  },
                  "&::after": {
                    content: '""',
                    position: "absolute",
                    bottom: 4,
                    right: 4,
                    width: 10,
                    height: 10,
                    borderRight: "2px solid #666",
                    borderBottom: "2px solid #666"
                  }
                },
                onMouseDown: S
              }
            )
          ]
        }
      )
    }
  ) : null;
};
var Xf = { exports: {} }, nd = {}, Ng = {}, Pg = {}, w2;
function Fe() {
  return w2 || (w2 = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e._registerNode = e.Konva = e.glob = void 0;
    const t = Math.PI / 180;
    function n() {
      return typeof window < "u" && ({}.toString.call(window) === "[object Window]" || {}.toString.call(window) === "[object global]");
    }
    e.glob = typeof Kg < "u" ? Kg : typeof window < "u" ? window : typeof WorkerGlobalScope < "u" ? self : {}, e.Konva = {
      _global: e.glob,
      version: "9.3.20",
      isBrowser: n(),
      isUnminified: /param/.test((function(i) {
      }).toString()),
      dblClickWindow: 400,
      getAngle(i) {
        return e.Konva.angleDeg ? i * t : i;
      },
      enableTrace: !1,
      pointerEventsEnabled: !0,
      autoDrawEnabled: !0,
      hitOnDragEnabled: !1,
      capturePointerEventsEnabled: !1,
      _mouseListenClick: !1,
      _touchListenClick: !1,
      _pointerListenClick: !1,
      _mouseInDblClickWindow: !1,
      _touchInDblClickWindow: !1,
      _pointerInDblClickWindow: !1,
      _mouseDblClickPointerId: null,
      _touchDblClickPointerId: null,
      _pointerDblClickPointerId: null,
      _fixTextRendering: !1,
      pixelRatio: typeof window < "u" && window.devicePixelRatio || 1,
      dragDistance: 3,
      angleDeg: !0,
      showWarnings: !0,
      dragButtons: [0, 1],
      isDragging() {
        return e.Konva.DD.isDragging;
      },
      isTransforming() {
        var i;
        return (i = e.Konva.Transformer) === null || i === void 0 ? void 0 : i.isTransforming();
      },
      isDragReady() {
        return !!e.Konva.DD.node;
      },
      releaseCanvasOnDestroy: !0,
      document: e.glob.document,
      _injectGlobal(i) {
        e.glob.Konva = i;
      }
    };
    const r = (i) => {
      e.Konva[i.prototype.getClassName()] = i;
    };
    e._registerNode = r, e.Konva._injectGlobal(e.Konva);
  }(Pg)), Pg;
}
var Dg = {}, E2;
function Hn() {
  return E2 || (E2 = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.Util = e.Transform = void 0;
    const t = Fe();
    class n {
      constructor(C = [1, 0, 0, 1, 0, 0]) {
        this.dirty = !1, this.m = C && C.slice() || [1, 0, 0, 1, 0, 0];
      }
      reset() {
        this.m[0] = 1, this.m[1] = 0, this.m[2] = 0, this.m[3] = 1, this.m[4] = 0, this.m[5] = 0;
      }
      copy() {
        return new n(this.m);
      }
      copyInto(C) {
        C.m[0] = this.m[0], C.m[1] = this.m[1], C.m[2] = this.m[2], C.m[3] = this.m[3], C.m[4] = this.m[4], C.m[5] = this.m[5];
      }
      point(C) {
        const E = this.m;
        return {
          x: E[0] * C.x + E[2] * C.y + E[4],
          y: E[1] * C.x + E[3] * C.y + E[5]
        };
      }
      translate(C, E) {
        return this.m[4] += this.m[0] * C + this.m[2] * E, this.m[5] += this.m[1] * C + this.m[3] * E, this;
      }
      scale(C, E) {
        return this.m[0] *= C, this.m[1] *= C, this.m[2] *= E, this.m[3] *= E, this;
      }
      rotate(C) {
        const E = Math.cos(C), O = Math.sin(C), B = this.m[0] * E + this.m[2] * O, N = this.m[1] * E + this.m[3] * O, L = this.m[0] * -O + this.m[2] * E, k = this.m[1] * -O + this.m[3] * E;
        return this.m[0] = B, this.m[1] = N, this.m[2] = L, this.m[3] = k, this;
      }
      getTranslation() {
        return {
          x: this.m[4],
          y: this.m[5]
        };
      }
      skew(C, E) {
        const O = this.m[0] + this.m[2] * E, B = this.m[1] + this.m[3] * E, N = this.m[2] + this.m[0] * C, L = this.m[3] + this.m[1] * C;
        return this.m[0] = O, this.m[1] = B, this.m[2] = N, this.m[3] = L, this;
      }
      multiply(C) {
        const E = this.m[0] * C.m[0] + this.m[2] * C.m[1], O = this.m[1] * C.m[0] + this.m[3] * C.m[1], B = this.m[0] * C.m[2] + this.m[2] * C.m[3], N = this.m[1] * C.m[2] + this.m[3] * C.m[3], L = this.m[0] * C.m[4] + this.m[2] * C.m[5] + this.m[4], k = this.m[1] * C.m[4] + this.m[3] * C.m[5] + this.m[5];
        return this.m[0] = E, this.m[1] = O, this.m[2] = B, this.m[3] = N, this.m[4] = L, this.m[5] = k, this;
      }
      invert() {
        const C = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]), E = this.m[3] * C, O = -this.m[1] * C, B = -this.m[2] * C, N = this.m[0] * C, L = C * (this.m[2] * this.m[5] - this.m[3] * this.m[4]), k = C * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
        return this.m[0] = E, this.m[1] = O, this.m[2] = B, this.m[3] = N, this.m[4] = L, this.m[5] = k, this;
      }
      getMatrix() {
        return this.m;
      }
      decompose() {
        const C = this.m[0], E = this.m[1], O = this.m[2], B = this.m[3], N = this.m[4], L = this.m[5], k = C * B - E * O, F = {
          x: N,
          y: L,
          rotation: 0,
          scaleX: 0,
          scaleY: 0,
          skewX: 0,
          skewY: 0
        };
        if (C != 0 || E != 0) {
          const G = Math.sqrt(C * C + E * E);
          F.rotation = E > 0 ? Math.acos(C / G) : -Math.acos(C / G), F.scaleX = G, F.scaleY = k / G, F.skewX = (C * O + E * B) / k, F.skewY = 0;
        } else if (O != 0 || B != 0) {
          const G = Math.sqrt(O * O + B * B);
          F.rotation = Math.PI / 2 - (B > 0 ? Math.acos(-O / G) : -Math.acos(O / G)), F.scaleX = k / G, F.scaleY = G, F.skewX = 0, F.skewY = (C * O + E * B) / k;
        }
        return F.rotation = e.Util._getRotation(F.rotation), F;
      }
    }
    e.Transform = n;
    const r = "[object Array]", i = "[object Number]", s = "[object String]", l = "[object Boolean]", c = Math.PI / 180, u = 180 / Math.PI, d = "#", h = "", p = "0", v = "Konva warning: ", m = "Konva error: ", g = "rgb(", b = {
      aliceblue: [240, 248, 255],
      antiquewhite: [250, 235, 215],
      aqua: [0, 255, 255],
      aquamarine: [127, 255, 212],
      azure: [240, 255, 255],
      beige: [245, 245, 220],
      bisque: [255, 228, 196],
      black: [0, 0, 0],
      blanchedalmond: [255, 235, 205],
      blue: [0, 0, 255],
      blueviolet: [138, 43, 226],
      brown: [165, 42, 42],
      burlywood: [222, 184, 135],
      cadetblue: [95, 158, 160],
      chartreuse: [127, 255, 0],
      chocolate: [210, 105, 30],
      coral: [255, 127, 80],
      cornflowerblue: [100, 149, 237],
      cornsilk: [255, 248, 220],
      crimson: [220, 20, 60],
      cyan: [0, 255, 255],
      darkblue: [0, 0, 139],
      darkcyan: [0, 139, 139],
      darkgoldenrod: [184, 132, 11],
      darkgray: [169, 169, 169],
      darkgreen: [0, 100, 0],
      darkgrey: [169, 169, 169],
      darkkhaki: [189, 183, 107],
      darkmagenta: [139, 0, 139],
      darkolivegreen: [85, 107, 47],
      darkorange: [255, 140, 0],
      darkorchid: [153, 50, 204],
      darkred: [139, 0, 0],
      darksalmon: [233, 150, 122],
      darkseagreen: [143, 188, 143],
      darkslateblue: [72, 61, 139],
      darkslategray: [47, 79, 79],
      darkslategrey: [47, 79, 79],
      darkturquoise: [0, 206, 209],
      darkviolet: [148, 0, 211],
      deeppink: [255, 20, 147],
      deepskyblue: [0, 191, 255],
      dimgray: [105, 105, 105],
      dimgrey: [105, 105, 105],
      dodgerblue: [30, 144, 255],
      firebrick: [178, 34, 34],
      floralwhite: [255, 255, 240],
      forestgreen: [34, 139, 34],
      fuchsia: [255, 0, 255],
      gainsboro: [220, 220, 220],
      ghostwhite: [248, 248, 255],
      gold: [255, 215, 0],
      goldenrod: [218, 165, 32],
      gray: [128, 128, 128],
      green: [0, 128, 0],
      greenyellow: [173, 255, 47],
      grey: [128, 128, 128],
      honeydew: [240, 255, 240],
      hotpink: [255, 105, 180],
      indianred: [205, 92, 92],
      indigo: [75, 0, 130],
      ivory: [255, 255, 240],
      khaki: [240, 230, 140],
      lavender: [230, 230, 250],
      lavenderblush: [255, 240, 245],
      lawngreen: [124, 252, 0],
      lemonchiffon: [255, 250, 205],
      lightblue: [173, 216, 230],
      lightcoral: [240, 128, 128],
      lightcyan: [224, 255, 255],
      lightgoldenrodyellow: [250, 250, 210],
      lightgray: [211, 211, 211],
      lightgreen: [144, 238, 144],
      lightgrey: [211, 211, 211],
      lightpink: [255, 182, 193],
      lightsalmon: [255, 160, 122],
      lightseagreen: [32, 178, 170],
      lightskyblue: [135, 206, 250],
      lightslategray: [119, 136, 153],
      lightslategrey: [119, 136, 153],
      lightsteelblue: [176, 196, 222],
      lightyellow: [255, 255, 224],
      lime: [0, 255, 0],
      limegreen: [50, 205, 50],
      linen: [250, 240, 230],
      magenta: [255, 0, 255],
      maroon: [128, 0, 0],
      mediumaquamarine: [102, 205, 170],
      mediumblue: [0, 0, 205],
      mediumorchid: [186, 85, 211],
      mediumpurple: [147, 112, 219],
      mediumseagreen: [60, 179, 113],
      mediumslateblue: [123, 104, 238],
      mediumspringgreen: [0, 250, 154],
      mediumturquoise: [72, 209, 204],
      mediumvioletred: [199, 21, 133],
      midnightblue: [25, 25, 112],
      mintcream: [245, 255, 250],
      mistyrose: [255, 228, 225],
      moccasin: [255, 228, 181],
      navajowhite: [255, 222, 173],
      navy: [0, 0, 128],
      oldlace: [253, 245, 230],
      olive: [128, 128, 0],
      olivedrab: [107, 142, 35],
      orange: [255, 165, 0],
      orangered: [255, 69, 0],
      orchid: [218, 112, 214],
      palegoldenrod: [238, 232, 170],
      palegreen: [152, 251, 152],
      paleturquoise: [175, 238, 238],
      palevioletred: [219, 112, 147],
      papayawhip: [255, 239, 213],
      peachpuff: [255, 218, 185],
      peru: [205, 133, 63],
      pink: [255, 192, 203],
      plum: [221, 160, 203],
      powderblue: [176, 224, 230],
      purple: [128, 0, 128],
      rebeccapurple: [102, 51, 153],
      red: [255, 0, 0],
      rosybrown: [188, 143, 143],
      royalblue: [65, 105, 225],
      saddlebrown: [139, 69, 19],
      salmon: [250, 128, 114],
      sandybrown: [244, 164, 96],
      seagreen: [46, 139, 87],
      seashell: [255, 245, 238],
      sienna: [160, 82, 45],
      silver: [192, 192, 192],
      skyblue: [135, 206, 235],
      slateblue: [106, 90, 205],
      slategray: [119, 128, 144],
      slategrey: [119, 128, 144],
      snow: [255, 255, 250],
      springgreen: [0, 255, 127],
      steelblue: [70, 130, 180],
      tan: [210, 180, 140],
      teal: [0, 128, 128],
      thistle: [216, 191, 216],
      transparent: [255, 255, 255, 0],
      tomato: [255, 99, 71],
      turquoise: [64, 224, 208],
      violet: [238, 130, 238],
      wheat: [245, 222, 179],
      white: [255, 255, 255],
      whitesmoke: [245, 245, 245],
      yellow: [255, 255, 0],
      yellowgreen: [154, 205, 5]
    }, x = /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/;
    let w = [];
    const T = typeof requestAnimationFrame < "u" && requestAnimationFrame || function(S) {
      setTimeout(S, 60);
    };
    e.Util = {
      _isElement(S) {
        return !!(S && S.nodeType == 1);
      },
      _isFunction(S) {
        return !!(S && S.constructor && S.call && S.apply);
      },
      _isPlainObject(S) {
        return !!S && S.constructor === Object;
      },
      _isArray(S) {
        return Object.prototype.toString.call(S) === r;
      },
      _isNumber(S) {
        return Object.prototype.toString.call(S) === i && !isNaN(S) && isFinite(S);
      },
      _isString(S) {
        return Object.prototype.toString.call(S) === s;
      },
      _isBoolean(S) {
        return Object.prototype.toString.call(S) === l;
      },
      isObject(S) {
        return S instanceof Object;
      },
      isValidSelector(S) {
        if (typeof S != "string")
          return !1;
        const C = S[0];
        return C === "#" || C === "." || C === C.toUpperCase();
      },
      _sign(S) {
        return S === 0 || S > 0 ? 1 : -1;
      },
      requestAnimFrame(S) {
        w.push(S), w.length === 1 && T(function() {
          const C = w;
          w = [], C.forEach(function(E) {
            E();
          });
        });
      },
      createCanvasElement() {
        const S = document.createElement("canvas");
        try {
          S.style = S.style || {};
        } catch {
        }
        return S;
      },
      createImageElement() {
        return document.createElement("img");
      },
      _isInDocument(S) {
        for (; S = S.parentNode; )
          if (S == document)
            return !0;
        return !1;
      },
      _urlToImage(S, C) {
        const E = e.Util.createImageElement();
        E.onload = function() {
          C(E);
        }, E.src = S;
      },
      _rgbToHex(S, C, E) {
        return ((1 << 24) + (S << 16) + (C << 8) + E).toString(16).slice(1);
      },
      _hexToRgb(S) {
        S = S.replace(d, h);
        const C = parseInt(S, 16);
        return {
          r: C >> 16 & 255,
          g: C >> 8 & 255,
          b: C & 255
        };
      },
      getRandomColor() {
        let S = (Math.random() * 16777215 << 0).toString(16);
        for (; S.length < 6; )
          S = p + S;
        return d + S;
      },
      getRGB(S) {
        let C;
        return S in b ? (C = b[S], {
          r: C[0],
          g: C[1],
          b: C[2]
        }) : S[0] === d ? this._hexToRgb(S.substring(1)) : S.substr(0, 4) === g ? (C = x.exec(S.replace(/ /g, "")), {
          r: parseInt(C[1], 10),
          g: parseInt(C[2], 10),
          b: parseInt(C[3], 10)
        }) : {
          r: 0,
          g: 0,
          b: 0
        };
      },
      colorToRGBA(S) {
        return S = S || "black", e.Util._namedColorToRBA(S) || e.Util._hex3ColorToRGBA(S) || e.Util._hex4ColorToRGBA(S) || e.Util._hex6ColorToRGBA(S) || e.Util._hex8ColorToRGBA(S) || e.Util._rgbColorToRGBA(S) || e.Util._rgbaColorToRGBA(S) || e.Util._hslColorToRGBA(S);
      },
      _namedColorToRBA(S) {
        const C = b[S.toLowerCase()];
        return C ? {
          r: C[0],
          g: C[1],
          b: C[2],
          a: 1
        } : null;
      },
      _rgbColorToRGBA(S) {
        if (S.indexOf("rgb(") === 0) {
          S = S.match(/rgb\(([^)]+)\)/)[1];
          const C = S.split(/ *, */).map(Number);
          return {
            r: C[0],
            g: C[1],
            b: C[2],
            a: 1
          };
        }
      },
      _rgbaColorToRGBA(S) {
        if (S.indexOf("rgba(") === 0) {
          S = S.match(/rgba\(([^)]+)\)/)[1];
          const C = S.split(/ *, */).map((E, O) => E.slice(-1) === "%" ? O === 3 ? parseInt(E) / 100 : parseInt(E) / 100 * 255 : Number(E));
          return {
            r: C[0],
            g: C[1],
            b: C[2],
            a: C[3]
          };
        }
      },
      _hex8ColorToRGBA(S) {
        if (S[0] === "#" && S.length === 9)
          return {
            r: parseInt(S.slice(1, 3), 16),
            g: parseInt(S.slice(3, 5), 16),
            b: parseInt(S.slice(5, 7), 16),
            a: parseInt(S.slice(7, 9), 16) / 255
          };
      },
      _hex6ColorToRGBA(S) {
        if (S[0] === "#" && S.length === 7)
          return {
            r: parseInt(S.slice(1, 3), 16),
            g: parseInt(S.slice(3, 5), 16),
            b: parseInt(S.slice(5, 7), 16),
            a: 1
          };
      },
      _hex4ColorToRGBA(S) {
        if (S[0] === "#" && S.length === 5)
          return {
            r: parseInt(S[1] + S[1], 16),
            g: parseInt(S[2] + S[2], 16),
            b: parseInt(S[3] + S[3], 16),
            a: parseInt(S[4] + S[4], 16) / 255
          };
      },
      _hex3ColorToRGBA(S) {
        if (S[0] === "#" && S.length === 4)
          return {
            r: parseInt(S[1] + S[1], 16),
            g: parseInt(S[2] + S[2], 16),
            b: parseInt(S[3] + S[3], 16),
            a: 1
          };
      },
      _hslColorToRGBA(S) {
        if (/hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.test(S)) {
          const [C, ...E] = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(S), O = Number(E[0]) / 360, B = Number(E[1]) / 100, N = Number(E[2]) / 100;
          let L, k, F;
          if (B === 0)
            return F = N * 255, {
              r: Math.round(F),
              g: Math.round(F),
              b: Math.round(F),
              a: 1
            };
          N < 0.5 ? L = N * (1 + B) : L = N + B - N * B;
          const G = 2 * N - L, M = [0, 0, 0];
          for (let j = 0; j < 3; j++)
            k = O + 1 / 3 * -(j - 1), k < 0 && k++, k > 1 && k--, 6 * k < 1 ? F = G + (L - G) * 6 * k : 2 * k < 1 ? F = L : 3 * k < 2 ? F = G + (L - G) * (2 / 3 - k) * 6 : F = G, M[j] = F * 255;
          return {
            r: Math.round(M[0]),
            g: Math.round(M[1]),
            b: Math.round(M[2]),
            a: 1
          };
        }
      },
      haveIntersection(S, C) {
        return !(C.x > S.x + S.width || C.x + C.width < S.x || C.y > S.y + S.height || C.y + C.height < S.y);
      },
      cloneObject(S) {
        const C = {};
        for (const E in S)
          this._isPlainObject(S[E]) ? C[E] = this.cloneObject(S[E]) : this._isArray(S[E]) ? C[E] = this.cloneArray(S[E]) : C[E] = S[E];
        return C;
      },
      cloneArray(S) {
        return S.slice(0);
      },
      degToRad(S) {
        return S * c;
      },
      radToDeg(S) {
        return S * u;
      },
      _degToRad(S) {
        return e.Util.warn("Util._degToRad is removed. Please use public Util.degToRad instead."), e.Util.degToRad(S);
      },
      _radToDeg(S) {
        return e.Util.warn("Util._radToDeg is removed. Please use public Util.radToDeg instead."), e.Util.radToDeg(S);
      },
      _getRotation(S) {
        return t.Konva.angleDeg ? e.Util.radToDeg(S) : S;
      },
      _capitalize(S) {
        return S.charAt(0).toUpperCase() + S.slice(1);
      },
      throw(S) {
        throw new Error(m + S);
      },
      error(S) {
        console.error(m + S);
      },
      warn(S) {
        t.Konva.showWarnings && console.warn(v + S);
      },
      each(S, C) {
        for (const E in S)
          C(E, S[E]);
      },
      _inRange(S, C, E) {
        return C <= S && S < E;
      },
      _getProjectionToSegment(S, C, E, O, B, N) {
        let L, k, F;
        const G = (S - E) * (S - E) + (C - O) * (C - O);
        if (G == 0)
          L = S, k = C, F = (B - E) * (B - E) + (N - O) * (N - O);
        else {
          const M = ((B - S) * (E - S) + (N - C) * (O - C)) / G;
          M < 0 ? (L = S, k = C, F = (S - B) * (S - B) + (C - N) * (C - N)) : M > 1 ? (L = E, k = O, F = (E - B) * (E - B) + (O - N) * (O - N)) : (L = S + M * (E - S), k = C + M * (O - C), F = (L - B) * (L - B) + (k - N) * (k - N));
        }
        return [L, k, F];
      },
      _getProjectionToLine(S, C, E) {
        const O = e.Util.cloneObject(S);
        let B = Number.MAX_VALUE;
        return C.forEach(function(N, L) {
          if (!E && L === C.length - 1)
            return;
          const k = C[(L + 1) % C.length], F = e.Util._getProjectionToSegment(N.x, N.y, k.x, k.y, S.x, S.y), G = F[0], M = F[1], j = F[2];
          j < B && (O.x = G, O.y = M, B = j);
        }), O;
      },
      _prepareArrayForTween(S, C, E) {
        const O = [], B = [];
        if (S.length > C.length) {
          const L = C;
          C = S, S = L;
        }
        for (let L = 0; L < S.length; L += 2)
          O.push({
            x: S[L],
            y: S[L + 1]
          });
        for (let L = 0; L < C.length; L += 2)
          B.push({
            x: C[L],
            y: C[L + 1]
          });
        const N = [];
        return B.forEach(function(L) {
          const k = e.Util._getProjectionToLine(L, O, E);
          N.push(k.x), N.push(k.y);
        }), N;
      },
      _prepareToStringify(S) {
        let C;
        S.visitedByCircularReferenceRemoval = !0;
        for (const E in S)
          if (S.hasOwnProperty(E) && S[E] && typeof S[E] == "object") {
            if (C = Object.getOwnPropertyDescriptor(S, E), S[E].visitedByCircularReferenceRemoval || e.Util._isElement(S[E]))
              if (C.configurable)
                delete S[E];
              else
                return null;
            else if (e.Util._prepareToStringify(S[E]) === null)
              if (C.configurable)
                delete S[E];
              else
                return null;
          }
        return delete S.visitedByCircularReferenceRemoval, S;
      },
      _assign(S, C) {
        for (const E in C)
          S[E] = C[E];
        return S;
      },
      _getFirstPointerId(S) {
        return S.touches ? S.changedTouches[0].identifier : S.pointerId || 999;
      },
      releaseCanvas(...S) {
        t.Konva.releaseCanvasOnDestroy && S.forEach((C) => {
          C.width = 0, C.height = 0;
        });
      },
      drawRoundedRectPath(S, C, E, O) {
        let B = 0, N = 0, L = 0, k = 0;
        typeof O == "number" ? B = N = L = k = Math.min(O, C / 2, E / 2) : (B = Math.min(O[0] || 0, C / 2, E / 2), N = Math.min(O[1] || 0, C / 2, E / 2), k = Math.min(O[2] || 0, C / 2, E / 2), L = Math.min(O[3] || 0, C / 2, E / 2)), S.moveTo(B, 0), S.lineTo(C - N, 0), S.arc(C - N, N, N, Math.PI * 3 / 2, 0, !1), S.lineTo(C, E - k), S.arc(C - k, E - k, k, 0, Math.PI / 2, !1), S.lineTo(L, E), S.arc(L, E - L, L, Math.PI / 2, Math.PI, !1), S.lineTo(0, B), S.arc(B, B, B, Math.PI, Math.PI * 3 / 2, !1);
      }
    };
  }(Dg)), Dg;
}
var rd = {}, Ig = {}, Jr = {}, A2;
function $e() {
  if (A2) return Jr;
  A2 = 1, Object.defineProperty(Jr, "__esModule", { value: !0 }), Jr.RGBComponent = r, Jr.alphaComponent = i, Jr.getNumberValidator = s, Jr.getNumberOrArrayOfNumbersValidator = l, Jr.getNumberOrAutoValidator = c, Jr.getStringValidator = u, Jr.getStringOrGradientValidator = d, Jr.getFunctionValidator = h, Jr.getNumberArrayValidator = p, Jr.getBooleanValidator = v, Jr.getComponentValidator = m;
  const e = Fe(), t = Hn();
  function n(g) {
    return t.Util._isString(g) ? '"' + g + '"' : Object.prototype.toString.call(g) === "[object Number]" || t.Util._isBoolean(g) ? g : Object.prototype.toString.call(g);
  }
  function r(g) {
    return g > 255 ? 255 : g < 0 ? 0 : Math.round(g);
  }
  function i(g) {
    return g > 1 ? 1 : g < 1e-4 ? 1e-4 : g;
  }
  function s() {
    if (e.Konva.isUnminified)
      return function(g, b) {
        return t.Util._isNumber(g) || t.Util.warn(n(g) + ' is a not valid value for "' + b + '" attribute. The value should be a number.'), g;
      };
  }
  function l(g) {
    if (e.Konva.isUnminified)
      return function(b, x) {
        let w = t.Util._isNumber(b), T = t.Util._isArray(b) && b.length == g;
        return !w && !T && t.Util.warn(n(b) + ' is a not valid value for "' + x + '" attribute. The value should be a number or Array<number>(' + g + ")"), b;
      };
  }
  function c() {
    if (e.Konva.isUnminified)
      return function(g, b) {
        var x = t.Util._isNumber(g), w = g === "auto";
        return x || w || t.Util.warn(n(g) + ' is a not valid value for "' + b + '" attribute. The value should be a number or "auto".'), g;
      };
  }
  function u() {
    if (e.Konva.isUnminified)
      return function(g, b) {
        return t.Util._isString(g) || t.Util.warn(n(g) + ' is a not valid value for "' + b + '" attribute. The value should be a string.'), g;
      };
  }
  function d() {
    if (e.Konva.isUnminified)
      return function(g, b) {
        const x = t.Util._isString(g), w = Object.prototype.toString.call(g) === "[object CanvasGradient]" || g && g.addColorStop;
        return x || w || t.Util.warn(n(g) + ' is a not valid value for "' + b + '" attribute. The value should be a string or a native gradient.'), g;
      };
  }
  function h() {
    if (e.Konva.isUnminified)
      return function(g, b) {
        return t.Util._isFunction(g) || t.Util.warn(n(g) + ' is a not valid value for "' + b + '" attribute. The value should be a function.'), g;
      };
  }
  function p() {
    if (e.Konva.isUnminified)
      return function(g, b) {
        const x = Int8Array ? Object.getPrototypeOf(Int8Array) : null;
        return x && g instanceof x || (t.Util._isArray(g) ? g.forEach(function(w) {
          t.Util._isNumber(w) || t.Util.warn('"' + b + '" attribute has non numeric element ' + w + ". Make sure that all elements are numbers.");
        }) : t.Util.warn(n(g) + ' is a not valid value for "' + b + '" attribute. The value should be a array of numbers.')), g;
      };
  }
  function v() {
    if (e.Konva.isUnminified)
      return function(g, b) {
        var x = g === !0 || g === !1;
        return x || t.Util.warn(n(g) + ' is a not valid value for "' + b + '" attribute. The value should be a boolean.'), g;
      };
  }
  function m(g) {
    if (e.Konva.isUnminified)
      return function(b, x) {
        return b == null || t.Util.isObject(b) || t.Util.warn(n(b) + ' is a not valid value for "' + x + '" attribute. The value should be an object with properties ' + g), b;
      };
  }
  return Jr;
}
var k2;
function We() {
  return k2 || (k2 = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.Factory = void 0;
    const t = Hn(), n = $e(), r = "get", i = "set";
    e.Factory = {
      addGetterSetter(s, l, c, u, d) {
        e.Factory.addGetter(s, l, c), e.Factory.addSetter(s, l, u, d), e.Factory.addOverloadedGetterSetter(s, l);
      },
      addGetter(s, l, c) {
        var u = r + t.Util._capitalize(l);
        s.prototype[u] = s.prototype[u] || function() {
          const d = this.attrs[l];
          return d === void 0 ? c : d;
        };
      },
      addSetter(s, l, c, u) {
        var d = i + t.Util._capitalize(l);
        s.prototype[d] || e.Factory.overWriteSetter(s, l, c, u);
      },
      overWriteSetter(s, l, c, u) {
        var d = i + t.Util._capitalize(l);
        s.prototype[d] = function(h) {
          return c && h !== void 0 && h !== null && (h = c.call(this, h, l)), this._setAttr(l, h), u && u.call(this), this;
        };
      },
      addComponentsGetterSetter(s, l, c, u, d) {
        const h = c.length, p = t.Util._capitalize, v = r + p(l), m = i + p(l);
        s.prototype[v] = function() {
          const b = {};
          for (let x = 0; x < h; x++) {
            const w = c[x];
            b[w] = this.getAttr(l + p(w));
          }
          return b;
        };
        const g = (0, n.getComponentValidator)(c);
        s.prototype[m] = function(b) {
          const x = this.attrs[l];
          u && (b = u.call(this, b, l)), g && g.call(this, b, l);
          for (const w in b)
            b.hasOwnProperty(w) && this._setAttr(l + p(w), b[w]);
          return b || c.forEach((w) => {
            this._setAttr(l + p(w), void 0);
          }), this._fireChangeEvent(l, x, b), d && d.call(this), this;
        }, e.Factory.addOverloadedGetterSetter(s, l);
      },
      addOverloadedGetterSetter(s, l) {
        var c = t.Util._capitalize(l), u = i + c, d = r + c;
        s.prototype[l] = function() {
          return arguments.length ? (this[u](arguments[0]), this) : this[d]();
        };
      },
      addDeprecatedGetterSetter(s, l, c, u) {
        t.Util.error("Adding deprecated " + l);
        const d = r + t.Util._capitalize(l), h = l + " property is deprecated and will be removed soon. Look at Konva change log for more information.";
        s.prototype[d] = function() {
          t.Util.error(h);
          const p = this.attrs[l];
          return p === void 0 ? c : p;
        }, e.Factory.addSetter(s, l, u, function() {
          t.Util.error(h);
        }), e.Factory.addOverloadedGetterSetter(s, l);
      },
      backCompat(s, l) {
        t.Util.each(l, function(c, u) {
          const d = s.prototype[u], h = r + t.Util._capitalize(c), p = i + t.Util._capitalize(c);
          function v() {
            d.apply(this, arguments), t.Util.error('"' + c + '" method is deprecated and will be removed soon. Use ""' + u + '" instead.');
          }
          s.prototype[c] = v, s.prototype[h] = v, s.prototype[p] = v;
        });
      },
      afterSetFilter() {
        this._filterUpToDate = !1;
      }
    };
  }(Ig)), Ig;
}
var co = {}, uo = {}, R2;
function hx() {
  if (R2) return uo;
  R2 = 1, Object.defineProperty(uo, "__esModule", { value: !0 }), uo.HitContext = uo.SceneContext = uo.Context = void 0;
  const e = Hn(), t = Fe();
  function n(w) {
    const T = [], S = w.length, C = e.Util;
    for (let E = 0; E < S; E++) {
      let O = w[E];
      C._isNumber(O) ? O = Math.round(O * 1e3) / 1e3 : C._isString(O) || (O = O + ""), T.push(O);
    }
    return T;
  }
  const r = ",", i = "(", s = ")", l = "([", c = "])", u = ";", d = "()", h = "=", p = [
    "arc",
    "arcTo",
    "beginPath",
    "bezierCurveTo",
    "clearRect",
    "clip",
    "closePath",
    "createLinearGradient",
    "createPattern",
    "createRadialGradient",
    "drawImage",
    "ellipse",
    "fill",
    "fillText",
    "getImageData",
    "createImageData",
    "lineTo",
    "moveTo",
    "putImageData",
    "quadraticCurveTo",
    "rect",
    "roundRect",
    "restore",
    "rotate",
    "save",
    "scale",
    "setLineDash",
    "setTransform",
    "stroke",
    "strokeText",
    "transform",
    "translate"
  ], v = [
    "fillStyle",
    "strokeStyle",
    "shadowColor",
    "shadowBlur",
    "shadowOffsetX",
    "shadowOffsetY",
    "letterSpacing",
    "lineCap",
    "lineDashOffset",
    "lineJoin",
    "lineWidth",
    "miterLimit",
    "direction",
    "font",
    "textAlign",
    "textBaseline",
    "globalAlpha",
    "globalCompositeOperation",
    "imageSmoothingEnabled"
  ], m = 100;
  let g = class {
    constructor(T) {
      this.canvas = T, t.Konva.enableTrace && (this.traceArr = [], this._enableTrace());
    }
    fillShape(T) {
      T.fillEnabled() && this._fill(T);
    }
    _fill(T) {
    }
    strokeShape(T) {
      T.hasStroke() && this._stroke(T);
    }
    _stroke(T) {
    }
    fillStrokeShape(T) {
      T.attrs.fillAfterStrokeEnabled ? (this.strokeShape(T), this.fillShape(T)) : (this.fillShape(T), this.strokeShape(T));
    }
    getTrace(T, S) {
      let C = this.traceArr, E = C.length, O = "", B, N, L, k;
      for (B = 0; B < E; B++)
        N = C[B], L = N.method, L ? (k = N.args, O += L, T ? O += d : e.Util._isArray(k[0]) ? O += l + k.join(r) + c : (S && (k = k.map((F) => typeof F == "number" ? Math.floor(F) : F)), O += i + k.join(r) + s)) : (O += N.property, T || (O += h + N.val)), O += u;
      return O;
    }
    clearTrace() {
      this.traceArr = [];
    }
    _trace(T) {
      let S = this.traceArr, C;
      S.push(T), C = S.length, C >= m && S.shift();
    }
    reset() {
      const T = this.getCanvas().getPixelRatio();
      this.setTransform(1 * T, 0, 0, 1 * T, 0, 0);
    }
    getCanvas() {
      return this.canvas;
    }
    clear(T) {
      const S = this.getCanvas();
      T ? this.clearRect(T.x || 0, T.y || 0, T.width || 0, T.height || 0) : this.clearRect(0, 0, S.getWidth() / S.pixelRatio, S.getHeight() / S.pixelRatio);
    }
    _applyLineCap(T) {
      const S = T.attrs.lineCap;
      S && this.setAttr("lineCap", S);
    }
    _applyOpacity(T) {
      const S = T.getAbsoluteOpacity();
      S !== 1 && this.setAttr("globalAlpha", S);
    }
    _applyLineJoin(T) {
      const S = T.attrs.lineJoin;
      S && this.setAttr("lineJoin", S);
    }
    setAttr(T, S) {
      this._context[T] = S;
    }
    arc(T, S, C, E, O, B) {
      this._context.arc(T, S, C, E, O, B);
    }
    arcTo(T, S, C, E, O) {
      this._context.arcTo(T, S, C, E, O);
    }
    beginPath() {
      this._context.beginPath();
    }
    bezierCurveTo(T, S, C, E, O, B) {
      this._context.bezierCurveTo(T, S, C, E, O, B);
    }
    clearRect(T, S, C, E) {
      this._context.clearRect(T, S, C, E);
    }
    clip(...T) {
      this._context.clip.apply(this._context, T);
    }
    closePath() {
      this._context.closePath();
    }
    createImageData(T, S) {
      const C = arguments;
      if (C.length === 2)
        return this._context.createImageData(T, S);
      if (C.length === 1)
        return this._context.createImageData(T);
    }
    createLinearGradient(T, S, C, E) {
      return this._context.createLinearGradient(T, S, C, E);
    }
    createPattern(T, S) {
      return this._context.createPattern(T, S);
    }
    createRadialGradient(T, S, C, E, O, B) {
      return this._context.createRadialGradient(T, S, C, E, O, B);
    }
    drawImage(T, S, C, E, O, B, N, L, k) {
      const F = arguments, G = this._context;
      F.length === 3 ? G.drawImage(T, S, C) : F.length === 5 ? G.drawImage(T, S, C, E, O) : F.length === 9 && G.drawImage(T, S, C, E, O, B, N, L, k);
    }
    ellipse(T, S, C, E, O, B, N, L) {
      this._context.ellipse(T, S, C, E, O, B, N, L);
    }
    isPointInPath(T, S, C, E) {
      return C ? this._context.isPointInPath(C, T, S, E) : this._context.isPointInPath(T, S, E);
    }
    fill(...T) {
      this._context.fill.apply(this._context, T);
    }
    fillRect(T, S, C, E) {
      this._context.fillRect(T, S, C, E);
    }
    strokeRect(T, S, C, E) {
      this._context.strokeRect(T, S, C, E);
    }
    fillText(T, S, C, E) {
      E ? this._context.fillText(T, S, C, E) : this._context.fillText(T, S, C);
    }
    measureText(T) {
      return this._context.measureText(T);
    }
    getImageData(T, S, C, E) {
      return this._context.getImageData(T, S, C, E);
    }
    lineTo(T, S) {
      this._context.lineTo(T, S);
    }
    moveTo(T, S) {
      this._context.moveTo(T, S);
    }
    rect(T, S, C, E) {
      this._context.rect(T, S, C, E);
    }
    roundRect(T, S, C, E, O) {
      this._context.roundRect(T, S, C, E, O);
    }
    putImageData(T, S, C) {
      this._context.putImageData(T, S, C);
    }
    quadraticCurveTo(T, S, C, E) {
      this._context.quadraticCurveTo(T, S, C, E);
    }
    restore() {
      this._context.restore();
    }
    rotate(T) {
      this._context.rotate(T);
    }
    save() {
      this._context.save();
    }
    scale(T, S) {
      this._context.scale(T, S);
    }
    setLineDash(T) {
      this._context.setLineDash ? this._context.setLineDash(T) : "mozDash" in this._context ? this._context.mozDash = T : "webkitLineDash" in this._context && (this._context.webkitLineDash = T);
    }
    getLineDash() {
      return this._context.getLineDash();
    }
    setTransform(T, S, C, E, O, B) {
      this._context.setTransform(T, S, C, E, O, B);
    }
    stroke(T) {
      T ? this._context.stroke(T) : this._context.stroke();
    }
    strokeText(T, S, C, E) {
      this._context.strokeText(T, S, C, E);
    }
    transform(T, S, C, E, O, B) {
      this._context.transform(T, S, C, E, O, B);
    }
    translate(T, S) {
      this._context.translate(T, S);
    }
    _enableTrace() {
      let T = this, S = p.length, C = this.setAttr, E, O;
      const B = function(N) {
        let L = T[N], k;
        T[N] = function() {
          return O = n(Array.prototype.slice.call(arguments, 0)), k = L.apply(T, arguments), T._trace({
            method: N,
            args: O
          }), k;
        };
      };
      for (E = 0; E < S; E++)
        B(p[E]);
      T.setAttr = function() {
        C.apply(T, arguments);
        const N = arguments[0];
        let L = arguments[1];
        (N === "shadowOffsetX" || N === "shadowOffsetY" || N === "shadowBlur") && (L = L / this.canvas.getPixelRatio()), T._trace({
          property: N,
          val: L
        });
      };
    }
    _applyGlobalCompositeOperation(T) {
      const S = T.attrs.globalCompositeOperation;
      !S || S === "source-over" || this.setAttr("globalCompositeOperation", S);
    }
  };
  uo.Context = g, v.forEach(function(w) {
    Object.defineProperty(g.prototype, w, {
      get() {
        return this._context[w];
      },
      set(T) {
        this._context[w] = T;
      }
    });
  });
  class b extends g {
    constructor(T, { willReadFrequently: S = !1 } = {}) {
      super(T), this._context = T._canvas.getContext("2d", {
        willReadFrequently: S
      });
    }
    _fillColor(T) {
      const S = T.fill();
      this.setAttr("fillStyle", S), T._fillFunc(this);
    }
    _fillPattern(T) {
      this.setAttr("fillStyle", T._getFillPattern()), T._fillFunc(this);
    }
    _fillLinearGradient(T) {
      const S = T._getLinearGradient();
      S && (this.setAttr("fillStyle", S), T._fillFunc(this));
    }
    _fillRadialGradient(T) {
      const S = T._getRadialGradient();
      S && (this.setAttr("fillStyle", S), T._fillFunc(this));
    }
    _fill(T) {
      const S = T.fill(), C = T.getFillPriority();
      if (S && C === "color") {
        this._fillColor(T);
        return;
      }
      const E = T.getFillPatternImage();
      if (E && C === "pattern") {
        this._fillPattern(T);
        return;
      }
      const O = T.getFillLinearGradientColorStops();
      if (O && C === "linear-gradient") {
        this._fillLinearGradient(T);
        return;
      }
      const B = T.getFillRadialGradientColorStops();
      if (B && C === "radial-gradient") {
        this._fillRadialGradient(T);
        return;
      }
      S ? this._fillColor(T) : E ? this._fillPattern(T) : O ? this._fillLinearGradient(T) : B && this._fillRadialGradient(T);
    }
    _strokeLinearGradient(T) {
      const S = T.getStrokeLinearGradientStartPoint(), C = T.getStrokeLinearGradientEndPoint(), E = T.getStrokeLinearGradientColorStops(), O = this.createLinearGradient(S.x, S.y, C.x, C.y);
      if (E) {
        for (let B = 0; B < E.length; B += 2)
          O.addColorStop(E[B], E[B + 1]);
        this.setAttr("strokeStyle", O);
      }
    }
    _stroke(T) {
      const S = T.dash(), C = T.getStrokeScaleEnabled();
      if (T.hasStroke()) {
        if (!C) {
          this.save();
          const O = this.getCanvas().getPixelRatio();
          this.setTransform(O, 0, 0, O, 0, 0);
        }
        this._applyLineCap(T), S && T.dashEnabled() && (this.setLineDash(S), this.setAttr("lineDashOffset", T.dashOffset())), this.setAttr("lineWidth", T.strokeWidth()), T.getShadowForStrokeEnabled() || this.setAttr("shadowColor", "rgba(0,0,0,0)"), T.getStrokeLinearGradientColorStops() ? this._strokeLinearGradient(T) : this.setAttr("strokeStyle", T.stroke()), T._strokeFunc(this), C || this.restore();
      }
    }
    _applyShadow(T) {
      var S, C, E;
      const O = (S = T.getShadowRGBA()) !== null && S !== void 0 ? S : "black", B = (C = T.getShadowBlur()) !== null && C !== void 0 ? C : 5, N = (E = T.getShadowOffset()) !== null && E !== void 0 ? E : {
        x: 0,
        y: 0
      }, L = T.getAbsoluteScale(), k = this.canvas.getPixelRatio(), F = L.x * k, G = L.y * k;
      this.setAttr("shadowColor", O), this.setAttr("shadowBlur", B * Math.min(Math.abs(F), Math.abs(G))), this.setAttr("shadowOffsetX", N.x * F), this.setAttr("shadowOffsetY", N.y * G);
    }
  }
  uo.SceneContext = b;
  class x extends g {
    constructor(T) {
      super(T), this._context = T._canvas.getContext("2d", {
        willReadFrequently: !0
      });
    }
    _fill(T) {
      this.save(), this.setAttr("fillStyle", T.colorKey), T._fillFuncHit(this), this.restore();
    }
    strokeShape(T) {
      T.hasHitStroke() && this._stroke(T);
    }
    _stroke(T) {
      if (T.hasHitStroke()) {
        const S = T.getStrokeScaleEnabled();
        if (!S) {
          this.save();
          const O = this.getCanvas().getPixelRatio();
          this.setTransform(O, 0, 0, O, 0, 0);
        }
        this._applyLineCap(T);
        const C = T.hitStrokeWidth(), E = C === "auto" ? T.strokeWidth() : C;
        this.setAttr("lineWidth", E), this.setAttr("strokeStyle", T.colorKey), T._strokeFuncHit(this), S || this.restore();
      }
    }
  }
  return uo.HitContext = x, uo;
}
var M2;
function fm() {
  if (M2) return co;
  M2 = 1, Object.defineProperty(co, "__esModule", { value: !0 }), co.HitCanvas = co.SceneCanvas = co.Canvas = void 0;
  const e = Hn(), t = hx(), n = Fe();
  let r;
  function i() {
    if (r)
      return r;
    const u = e.Util.createCanvasElement(), d = u.getContext("2d");
    return r = function() {
      const h = n.Konva._global.devicePixelRatio || 1, p = d.webkitBackingStorePixelRatio || d.mozBackingStorePixelRatio || d.msBackingStorePixelRatio || d.oBackingStorePixelRatio || d.backingStorePixelRatio || 1;
      return h / p;
    }(), e.Util.releaseCanvas(u), r;
  }
  let s = class {
    constructor(d) {
      this.pixelRatio = 1, this.width = 0, this.height = 0, this.isCache = !1;
      const p = (d || {}).pixelRatio || n.Konva.pixelRatio || i();
      this.pixelRatio = p, this._canvas = e.Util.createCanvasElement(), this._canvas.style.padding = "0", this._canvas.style.margin = "0", this._canvas.style.border = "0", this._canvas.style.background = "transparent", this._canvas.style.position = "absolute", this._canvas.style.top = "0", this._canvas.style.left = "0";
    }
    getContext() {
      return this.context;
    }
    getPixelRatio() {
      return this.pixelRatio;
    }
    setPixelRatio(d) {
      const h = this.pixelRatio;
      this.pixelRatio = d, this.setSize(this.getWidth() / h, this.getHeight() / h);
    }
    setWidth(d) {
      this.width = this._canvas.width = d * this.pixelRatio, this._canvas.style.width = d + "px";
      const h = this.pixelRatio;
      this.getContext()._context.scale(h, h);
    }
    setHeight(d) {
      this.height = this._canvas.height = d * this.pixelRatio, this._canvas.style.height = d + "px";
      const h = this.pixelRatio;
      this.getContext()._context.scale(h, h);
    }
    getWidth() {
      return this.width;
    }
    getHeight() {
      return this.height;
    }
    setSize(d, h) {
      this.setWidth(d || 0), this.setHeight(h || 0);
    }
    toDataURL(d, h) {
      try {
        return this._canvas.toDataURL(d, h);
      } catch {
        try {
          return this._canvas.toDataURL();
        } catch (v) {
          return e.Util.error("Unable to get data URL. " + v.message + " For more info read https://konvajs.org/docs/posts/Tainted_Canvas.html."), "";
        }
      }
    }
  };
  co.Canvas = s;
  class l extends s {
    constructor(d = { width: 0, height: 0, willReadFrequently: !1 }) {
      super(d), this.context = new t.SceneContext(this, {
        willReadFrequently: d.willReadFrequently
      }), this.setSize(d.width, d.height);
    }
  }
  co.SceneCanvas = l;
  class c extends s {
    constructor(d = { width: 0, height: 0 }) {
      super(d), this.hitCanvas = !0, this.context = new t.HitContext(this), this.setSize(d.width, d.height);
    }
  }
  return co.HitCanvas = c, co;
}
var Bg = {}, O2;
function Zy() {
  return O2 || (O2 = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.DD = void 0;
    const t = Fe(), n = Hn();
    e.DD = {
      get isDragging() {
        let r = !1;
        return e.DD._dragElements.forEach((i) => {
          i.dragStatus === "dragging" && (r = !0);
        }), r;
      },
      justDragged: !1,
      get node() {
        let r;
        return e.DD._dragElements.forEach((i) => {
          r = i.node;
        }), r;
      },
      _dragElements: /* @__PURE__ */ new Map(),
      _drag(r) {
        const i = [];
        e.DD._dragElements.forEach((s, l) => {
          const { node: c } = s, u = c.getStage();
          u.setPointersPositions(r), s.pointerId === void 0 && (s.pointerId = n.Util._getFirstPointerId(r));
          const d = u._changedPointerPositions.find((h) => h.id === s.pointerId);
          if (d) {
            if (s.dragStatus !== "dragging") {
              const h = c.dragDistance();
              if (Math.max(Math.abs(d.x - s.startPointerPos.x), Math.abs(d.y - s.startPointerPos.y)) < h || (c.startDrag({ evt: r }), !c.isDragging()))
                return;
            }
            c._setDragPosition(r, s), i.push(c);
          }
        }), i.forEach((s) => {
          s.fire("dragmove", {
            type: "dragmove",
            target: s,
            evt: r
          }, !0);
        });
      },
      _endDragBefore(r) {
        const i = [];
        e.DD._dragElements.forEach((s) => {
          const { node: l } = s, c = l.getStage();
          if (r && c.setPointersPositions(r), !c._changedPointerPositions.find((h) => h.id === s.pointerId))
            return;
          (s.dragStatus === "dragging" || s.dragStatus === "stopped") && (e.DD.justDragged = !0, t.Konva._mouseListenClick = !1, t.Konva._touchListenClick = !1, t.Konva._pointerListenClick = !1, s.dragStatus = "stopped");
          const d = s.node.getLayer() || s.node instanceof t.Konva.Stage && s.node;
          d && i.indexOf(d) === -1 && i.push(d);
        }), i.forEach((s) => {
          s.draw();
        });
      },
      _endDragAfter(r) {
        e.DD._dragElements.forEach((i, s) => {
          i.dragStatus === "stopped" && i.node.fire("dragend", {
            type: "dragend",
            target: i.node,
            evt: r
          }, !0), i.dragStatus !== "dragging" && e.DD._dragElements.delete(s);
        });
      }
    }, t.Konva.isBrowser && (window.addEventListener("mouseup", e.DD._endDragBefore, !0), window.addEventListener("touchend", e.DD._endDragBefore, !0), window.addEventListener("touchcancel", e.DD._endDragBefore, !0), window.addEventListener("mousemove", e.DD._drag), window.addEventListener("touchmove", e.DD._drag), window.addEventListener("mouseup", e.DD._endDragAfter, !1), window.addEventListener("touchend", e.DD._endDragAfter, !1), window.addEventListener("touchcancel", e.DD._endDragAfter, !1));
  }(Bg)), Bg;
}
var N2;
function Xn() {
  if (N2) return rd;
  N2 = 1, Object.defineProperty(rd, "__esModule", { value: !0 }), rd.Node = void 0;
  const e = Hn(), t = We(), n = fm(), r = Fe(), i = Zy(), s = $e(), l = "absoluteOpacity", c = "allEventListeners", u = "absoluteTransform", d = "absoluteScale", h = "canvas", p = "Change", v = "children", m = "konva", g = "listening", b = "mouseenter", x = "mouseleave", w = "set", T = "Shape", S = " ", C = "stage", E = "transform", O = "Stage", B = "visible", N = [
    "xChange.konva",
    "yChange.konva",
    "scaleXChange.konva",
    "scaleYChange.konva",
    "skewXChange.konva",
    "skewYChange.konva",
    "rotationChange.konva",
    "offsetXChange.konva",
    "offsetYChange.konva",
    "transformsEnabledChange.konva"
  ].join(S);
  let L = 1, k = class R0 {
    constructor(M) {
      this._id = L++, this.eventListeners = {}, this.attrs = {}, this.index = 0, this._allEventListeners = null, this.parent = null, this._cache = /* @__PURE__ */ new Map(), this._attachedDepsListeners = /* @__PURE__ */ new Map(), this._lastPos = null, this._batchingTransformChange = !1, this._needClearTransformCache = !1, this._filterUpToDate = !1, this._isUnderCache = !1, this._dragEventId = null, this._shouldFireChangeEvents = !1, this.setAttrs(M), this._shouldFireChangeEvents = !0;
    }
    hasChildren() {
      return !1;
    }
    _clearCache(M) {
      (M === E || M === u) && this._cache.get(M) ? this._cache.get(M).dirty = !0 : M ? this._cache.delete(M) : this._cache.clear();
    }
    _getCache(M, j) {
      let D = this._cache.get(M);
      return (D === void 0 || (M === E || M === u) && D.dirty === !0) && (D = j.call(this), this._cache.set(M, D)), D;
    }
    _calculate(M, j, D) {
      if (!this._attachedDepsListeners.get(M)) {
        const z = j.map((H) => H + "Change.konva").join(S);
        this.on(z, () => {
          this._clearCache(M);
        }), this._attachedDepsListeners.set(M, !0);
      }
      return this._getCache(M, D);
    }
    _getCanvasCache() {
      return this._cache.get(h);
    }
    _clearSelfAndDescendantCache(M) {
      this._clearCache(M), M === u && this.fire("absoluteTransformChange");
    }
    clearCache() {
      if (this._cache.has(h)) {
        const { scene: M, filter: j, hit: D } = this._cache.get(h);
        e.Util.releaseCanvas(M, j, D), this._cache.delete(h);
      }
      return this._clearSelfAndDescendantCache(), this._requestDraw(), this;
    }
    cache(M) {
      const j = M || {};
      let D = {};
      (j.x === void 0 || j.y === void 0 || j.width === void 0 || j.height === void 0) && (D = this.getClientRect({
        skipTransform: !0,
        relativeTo: this.getParent() || void 0
      }));
      let z = Math.ceil(j.width || D.width), H = Math.ceil(j.height || D.height), X = j.pixelRatio, Y = j.x === void 0 ? Math.floor(D.x) : j.x, V = j.y === void 0 ? Math.floor(D.y) : j.y, Z = j.offset || 0, ct = j.drawBorder || !1, et = j.hitCanvasPixelRatio || 1;
      if (!z || !H) {
        e.Util.error("Can not cache the node. Width or height of the node equals 0. Caching is skipped.");
        return;
      }
      const rt = Math.abs(Math.round(D.x) - Y) > 0.5 ? 1 : 0, st = Math.abs(Math.round(D.y) - V) > 0.5 ? 1 : 0;
      z += Z * 2 + rt, H += Z * 2 + st, Y -= Z, V -= Z;
      const yt = new n.SceneCanvas({
        pixelRatio: X,
        width: z,
        height: H
      }), J = new n.SceneCanvas({
        pixelRatio: X,
        width: 0,
        height: 0,
        willReadFrequently: !0
      }), tt = new n.HitCanvas({
        pixelRatio: et,
        width: z,
        height: H
      }), ot = yt.getContext(), Tt = tt.getContext();
      return tt.isCache = !0, yt.isCache = !0, this._cache.delete(h), this._filterUpToDate = !1, j.imageSmoothingEnabled === !1 && (yt.getContext()._context.imageSmoothingEnabled = !1, J.getContext()._context.imageSmoothingEnabled = !1), ot.save(), Tt.save(), ot.translate(-Y, -V), Tt.translate(-Y, -V), this._isUnderCache = !0, this._clearSelfAndDescendantCache(l), this._clearSelfAndDescendantCache(d), this.drawScene(yt, this), this.drawHit(tt, this), this._isUnderCache = !1, ot.restore(), Tt.restore(), ct && (ot.save(), ot.beginPath(), ot.rect(0, 0, z, H), ot.closePath(), ot.setAttr("strokeStyle", "red"), ot.setAttr("lineWidth", 5), ot.stroke(), ot.restore()), this._cache.set(h, {
        scene: yt,
        filter: J,
        hit: tt,
        x: Y,
        y: V
      }), this._requestDraw(), this;
    }
    isCached() {
      return this._cache.has(h);
    }
    getClientRect(M) {
      throw new Error('abstract "getClientRect" method call');
    }
    _transformedRect(M, j) {
      const D = [
        { x: M.x, y: M.y },
        { x: M.x + M.width, y: M.y },
        { x: M.x + M.width, y: M.y + M.height },
        { x: M.x, y: M.y + M.height }
      ];
      let z = 1 / 0, H = 1 / 0, X = -1 / 0, Y = -1 / 0;
      const V = this.getAbsoluteTransform(j);
      return D.forEach(function(Z) {
        const ct = V.point(Z);
        z === void 0 && (z = X = ct.x, H = Y = ct.y), z = Math.min(z, ct.x), H = Math.min(H, ct.y), X = Math.max(X, ct.x), Y = Math.max(Y, ct.y);
      }), {
        x: z,
        y: H,
        width: X - z,
        height: Y - H
      };
    }
    _drawCachedSceneCanvas(M) {
      M.save(), M._applyOpacity(this), M._applyGlobalCompositeOperation(this);
      const j = this._getCanvasCache();
      M.translate(j.x, j.y);
      const D = this._getCachedSceneCanvas(), z = D.pixelRatio;
      M.drawImage(D._canvas, 0, 0, D.width / z, D.height / z), M.restore();
    }
    _drawCachedHitCanvas(M) {
      const j = this._getCanvasCache(), D = j.hit;
      M.save(), M.translate(j.x, j.y), M.drawImage(D._canvas, 0, 0, D.width / D.pixelRatio, D.height / D.pixelRatio), M.restore();
    }
    _getCachedSceneCanvas() {
      let M = this.filters(), j = this._getCanvasCache(), D = j.scene, z = j.filter, H = z.getContext(), X, Y, V, Z;
      if (M) {
        if (!this._filterUpToDate) {
          const ct = D.pixelRatio;
          z.setSize(D.width / D.pixelRatio, D.height / D.pixelRatio);
          try {
            for (X = M.length, H.clear(), H.drawImage(D._canvas, 0, 0, D.getWidth() / ct, D.getHeight() / ct), Y = H.getImageData(0, 0, z.getWidth(), z.getHeight()), V = 0; V < X; V++) {
              if (Z = M[V], typeof Z != "function") {
                e.Util.error("Filter should be type of function, but got " + typeof Z + " instead. Please check correct filters");
                continue;
              }
              Z.call(this, Y), H.putImageData(Y, 0, 0);
            }
          } catch (et) {
            e.Util.error("Unable to apply filter. " + et.message + " This post my help you https://konvajs.org/docs/posts/Tainted_Canvas.html.");
          }
          this._filterUpToDate = !0;
        }
        return z;
      }
      return D;
    }
    on(M, j) {
      if (this._cache && this._cache.delete(c), arguments.length === 3)
        return this._delegate.apply(this, arguments);
      let D = M.split(S), z = D.length, H, X, Y, V, Z;
      for (H = 0; H < z; H++)
        X = D[H], Y = X.split("."), V = Y[0], Z = Y[1] || "", this.eventListeners[V] || (this.eventListeners[V] = []), this.eventListeners[V].push({
          name: Z,
          handler: j
        });
      return this;
    }
    off(M, j) {
      let D = (M || "").split(S), z = D.length, H, X, Y, V, Z, ct;
      if (this._cache && this._cache.delete(c), !M)
        for (X in this.eventListeners)
          this._off(X);
      for (H = 0; H < z; H++)
        if (Y = D[H], V = Y.split("."), Z = V[0], ct = V[1], Z)
          this.eventListeners[Z] && this._off(Z, ct, j);
        else
          for (X in this.eventListeners)
            this._off(X, ct, j);
      return this;
    }
    dispatchEvent(M) {
      const j = {
        target: this,
        type: M.type,
        evt: M
      };
      return this.fire(M.type, j), this;
    }
    addEventListener(M, j) {
      return this.on(M, function(D) {
        j.call(this, D.evt);
      }), this;
    }
    removeEventListener(M) {
      return this.off(M), this;
    }
    _delegate(M, j, D) {
      const z = this;
      this.on(M, function(H) {
        const X = H.target.findAncestors(j, !0, z);
        for (let Y = 0; Y < X.length; Y++)
          H = e.Util.cloneObject(H), H.currentTarget = X[Y], D.call(X[Y], H);
      });
    }
    remove() {
      return this.isDragging() && this.stopDrag(), i.DD._dragElements.delete(this._id), this._remove(), this;
    }
    _clearCaches() {
      this._clearSelfAndDescendantCache(u), this._clearSelfAndDescendantCache(l), this._clearSelfAndDescendantCache(d), this._clearSelfAndDescendantCache(C), this._clearSelfAndDescendantCache(B), this._clearSelfAndDescendantCache(g);
    }
    _remove() {
      this._clearCaches();
      const M = this.getParent();
      M && M.children && (M.children.splice(this.index, 1), M._setChildrenIndices(), this.parent = null);
    }
    destroy() {
      return this.remove(), this.clearCache(), this;
    }
    getAttr(M) {
      const j = "get" + e.Util._capitalize(M);
      return e.Util._isFunction(this[j]) ? this[j]() : this.attrs[M];
    }
    getAncestors() {
      let M = this.getParent(), j = [];
      for (; M; )
        j.push(M), M = M.getParent();
      return j;
    }
    getAttrs() {
      return this.attrs || {};
    }
    setAttrs(M) {
      return this._batchTransformChanges(() => {
        let j, D;
        if (!M)
          return this;
        for (j in M)
          j !== v && (D = w + e.Util._capitalize(j), e.Util._isFunction(this[D]) ? this[D](M[j]) : this._setAttr(j, M[j]));
      }), this;
    }
    isListening() {
      return this._getCache(g, this._isListening);
    }
    _isListening(M) {
      if (!this.listening())
        return !1;
      const D = this.getParent();
      return D && D !== M && this !== M ? D._isListening(M) : !0;
    }
    isVisible() {
      return this._getCache(B, this._isVisible);
    }
    _isVisible(M) {
      if (!this.visible())
        return !1;
      const D = this.getParent();
      return D && D !== M && this !== M ? D._isVisible(M) : !0;
    }
    shouldDrawHit(M, j = !1) {
      if (M)
        return this._isVisible(M) && this._isListening(M);
      const D = this.getLayer();
      let z = !1;
      i.DD._dragElements.forEach((X) => {
        X.dragStatus === "dragging" && (X.node.nodeType === "Stage" || X.node.getLayer() === D) && (z = !0);
      });
      const H = !j && !r.Konva.hitOnDragEnabled && (z || r.Konva.isTransforming());
      return this.isListening() && this.isVisible() && !H;
    }
    show() {
      return this.visible(!0), this;
    }
    hide() {
      return this.visible(!1), this;
    }
    getZIndex() {
      return this.index || 0;
    }
    getAbsoluteZIndex() {
      let M = this.getDepth(), j = this, D = 0, z, H, X, Y;
      function V(ct) {
        for (z = [], H = ct.length, X = 0; X < H; X++)
          Y = ct[X], D++, Y.nodeType !== T && (z = z.concat(Y.getChildren().slice())), Y._id === j._id && (X = H);
        z.length > 0 && z[0].getDepth() <= M && V(z);
      }
      const Z = this.getStage();
      return j.nodeType !== O && Z && V(Z.getChildren()), D;
    }
    getDepth() {
      let M = 0, j = this.parent;
      for (; j; )
        M++, j = j.parent;
      return M;
    }
    _batchTransformChanges(M) {
      this._batchingTransformChange = !0, M(), this._batchingTransformChange = !1, this._needClearTransformCache && (this._clearCache(E), this._clearSelfAndDescendantCache(u)), this._needClearTransformCache = !1;
    }
    setPosition(M) {
      return this._batchTransformChanges(() => {
        this.x(M.x), this.y(M.y);
      }), this;
    }
    getPosition() {
      return {
        x: this.x(),
        y: this.y()
      };
    }
    getRelativePointerPosition() {
      const M = this.getStage();
      if (!M)
        return null;
      const j = M.getPointerPosition();
      if (!j)
        return null;
      const D = this.getAbsoluteTransform().copy();
      return D.invert(), D.point(j);
    }
    getAbsolutePosition(M) {
      let j = !1, D = this.parent;
      for (; D; ) {
        if (D.isCached()) {
          j = !0;
          break;
        }
        D = D.parent;
      }
      j && !M && (M = !0);
      const z = this.getAbsoluteTransform(M).getMatrix(), H = new e.Transform(), X = this.offset();
      return H.m = z.slice(), H.translate(X.x, X.y), H.getTranslation();
    }
    setAbsolutePosition(M) {
      const { x: j, y: D, ...z } = this._clearTransform();
      this.attrs.x = j, this.attrs.y = D, this._clearCache(E);
      const H = this._getAbsoluteTransform().copy();
      return H.invert(), H.translate(M.x, M.y), M = {
        x: this.attrs.x + H.getTranslation().x,
        y: this.attrs.y + H.getTranslation().y
      }, this._setTransform(z), this.setPosition({ x: M.x, y: M.y }), this._clearCache(E), this._clearSelfAndDescendantCache(u), this;
    }
    _setTransform(M) {
      let j;
      for (j in M)
        this.attrs[j] = M[j];
    }
    _clearTransform() {
      const M = {
        x: this.x(),
        y: this.y(),
        rotation: this.rotation(),
        scaleX: this.scaleX(),
        scaleY: this.scaleY(),
        offsetX: this.offsetX(),
        offsetY: this.offsetY(),
        skewX: this.skewX(),
        skewY: this.skewY()
      };
      return this.attrs.x = 0, this.attrs.y = 0, this.attrs.rotation = 0, this.attrs.scaleX = 1, this.attrs.scaleY = 1, this.attrs.offsetX = 0, this.attrs.offsetY = 0, this.attrs.skewX = 0, this.attrs.skewY = 0, M;
    }
    move(M) {
      let j = M.x, D = M.y, z = this.x(), H = this.y();
      return j !== void 0 && (z += j), D !== void 0 && (H += D), this.setPosition({ x: z, y: H }), this;
    }
    _eachAncestorReverse(M, j) {
      let D = [], z = this.getParent(), H, X;
      if (!(j && j._id === this._id)) {
        for (D.unshift(this); z && (!j || z._id !== j._id); )
          D.unshift(z), z = z.parent;
        for (H = D.length, X = 0; X < H; X++)
          M(D[X]);
      }
    }
    rotate(M) {
      return this.rotation(this.rotation() + M), this;
    }
    moveToTop() {
      if (!this.parent)
        return e.Util.warn("Node has no parent. moveToTop function is ignored."), !1;
      const M = this.index, j = this.parent.getChildren().length;
      return M < j - 1 ? (this.parent.children.splice(M, 1), this.parent.children.push(this), this.parent._setChildrenIndices(), !0) : !1;
    }
    moveUp() {
      if (!this.parent)
        return e.Util.warn("Node has no parent. moveUp function is ignored."), !1;
      const M = this.index, j = this.parent.getChildren().length;
      return M < j - 1 ? (this.parent.children.splice(M, 1), this.parent.children.splice(M + 1, 0, this), this.parent._setChildrenIndices(), !0) : !1;
    }
    moveDown() {
      if (!this.parent)
        return e.Util.warn("Node has no parent. moveDown function is ignored."), !1;
      const M = this.index;
      return M > 0 ? (this.parent.children.splice(M, 1), this.parent.children.splice(M - 1, 0, this), this.parent._setChildrenIndices(), !0) : !1;
    }
    moveToBottom() {
      if (!this.parent)
        return e.Util.warn("Node has no parent. moveToBottom function is ignored."), !1;
      const M = this.index;
      return M > 0 ? (this.parent.children.splice(M, 1), this.parent.children.unshift(this), this.parent._setChildrenIndices(), !0) : !1;
    }
    setZIndex(M) {
      if (!this.parent)
        return e.Util.warn("Node has no parent. zIndex parameter is ignored."), this;
      (M < 0 || M >= this.parent.children.length) && e.Util.warn("Unexpected value " + M + " for zIndex property. zIndex is just index of a node in children of its parent. Expected value is from 0 to " + (this.parent.children.length - 1) + ".");
      const j = this.index;
      return this.parent.children.splice(j, 1), this.parent.children.splice(M, 0, this), this.parent._setChildrenIndices(), this;
    }
    getAbsoluteOpacity() {
      return this._getCache(l, this._getAbsoluteOpacity);
    }
    _getAbsoluteOpacity() {
      let M = this.opacity();
      const j = this.getParent();
      return j && !j._isUnderCache && (M *= j.getAbsoluteOpacity()), M;
    }
    moveTo(M) {
      return this.getParent() !== M && (this._remove(), M.add(this)), this;
    }
    toObject() {
      let M = this.getAttrs(), j, D, z, H, X;
      const Y = {
        attrs: {},
        className: this.getClassName()
      };
      for (j in M)
        D = M[j], X = e.Util.isObject(D) && !e.Util._isPlainObject(D) && !e.Util._isArray(D), !X && (z = typeof this[j] == "function" && this[j], delete M[j], H = z ? z.call(this) : null, M[j] = D, H !== D && (Y.attrs[j] = D));
      return e.Util._prepareToStringify(Y);
    }
    toJSON() {
      return JSON.stringify(this.toObject());
    }
    getParent() {
      return this.parent;
    }
    findAncestors(M, j, D) {
      const z = [];
      j && this._isMatch(M) && z.push(this);
      let H = this.parent;
      for (; H; ) {
        if (H === D)
          return z;
        H._isMatch(M) && z.push(H), H = H.parent;
      }
      return z;
    }
    isAncestorOf(M) {
      return !1;
    }
    findAncestor(M, j, D) {
      return this.findAncestors(M, j, D)[0];
    }
    _isMatch(M) {
      if (!M)
        return !1;
      if (typeof M == "function")
        return M(this);
      let j = M.replace(/ /g, "").split(","), D = j.length, z, H;
      for (z = 0; z < D; z++)
        if (H = j[z], e.Util.isValidSelector(H) || (e.Util.warn('Selector "' + H + '" is invalid. Allowed selectors examples are "#foo", ".bar" or "Group".'), e.Util.warn('If you have a custom shape with such className, please change it to start with upper letter like "Triangle".'), e.Util.warn("Konva is awesome, right?")), H.charAt(0) === "#") {
          if (this.id() === H.slice(1))
            return !0;
        } else if (H.charAt(0) === ".") {
          if (this.hasName(H.slice(1)))
            return !0;
        } else if (this.className === H || this.nodeType === H)
          return !0;
      return !1;
    }
    getLayer() {
      const M = this.getParent();
      return M ? M.getLayer() : null;
    }
    getStage() {
      return this._getCache(C, this._getStage);
    }
    _getStage() {
      const M = this.getParent();
      return M ? M.getStage() : null;
    }
    fire(M, j = {}, D) {
      return j.target = j.target || this, D ? this._fireAndBubble(M, j) : this._fire(M, j), this;
    }
    getAbsoluteTransform(M) {
      return M ? this._getAbsoluteTransform(M) : this._getCache(u, this._getAbsoluteTransform);
    }
    _getAbsoluteTransform(M) {
      let j;
      if (M)
        return j = new e.Transform(), this._eachAncestorReverse(function(D) {
          const z = D.transformsEnabled();
          z === "all" ? j.multiply(D.getTransform()) : z === "position" && j.translate(D.x() - D.offsetX(), D.y() - D.offsetY());
        }, M), j;
      {
        j = this._cache.get(u) || new e.Transform(), this.parent ? this.parent.getAbsoluteTransform().copyInto(j) : j.reset();
        const D = this.transformsEnabled();
        if (D === "all")
          j.multiply(this.getTransform());
        else if (D === "position") {
          const z = this.attrs.x || 0, H = this.attrs.y || 0, X = this.attrs.offsetX || 0, Y = this.attrs.offsetY || 0;
          j.translate(z - X, H - Y);
        }
        return j.dirty = !1, j;
      }
    }
    getAbsoluteScale(M) {
      let j = this;
      for (; j; )
        j._isUnderCache && (M = j), j = j.getParent();
      const z = this.getAbsoluteTransform(M).decompose();
      return {
        x: z.scaleX,
        y: z.scaleY
      };
    }
    getAbsoluteRotation() {
      return this.getAbsoluteTransform().decompose().rotation;
    }
    getTransform() {
      return this._getCache(E, this._getTransform);
    }
    _getTransform() {
      var M, j;
      const D = this._cache.get(E) || new e.Transform();
      D.reset();
      const z = this.x(), H = this.y(), X = r.Konva.getAngle(this.rotation()), Y = (M = this.attrs.scaleX) !== null && M !== void 0 ? M : 1, V = (j = this.attrs.scaleY) !== null && j !== void 0 ? j : 1, Z = this.attrs.skewX || 0, ct = this.attrs.skewY || 0, et = this.attrs.offsetX || 0, rt = this.attrs.offsetY || 0;
      return (z !== 0 || H !== 0) && D.translate(z, H), X !== 0 && D.rotate(X), (Z !== 0 || ct !== 0) && D.skew(Z, ct), (Y !== 1 || V !== 1) && D.scale(Y, V), (et !== 0 || rt !== 0) && D.translate(-1 * et, -1 * rt), D.dirty = !1, D;
    }
    clone(M) {
      let j = e.Util.cloneObject(this.attrs), D, z, H, X, Y;
      for (D in M)
        j[D] = M[D];
      const V = new this.constructor(j);
      for (D in this.eventListeners)
        for (z = this.eventListeners[D], H = z.length, X = 0; X < H; X++)
          Y = z[X], Y.name.indexOf(m) < 0 && (V.eventListeners[D] || (V.eventListeners[D] = []), V.eventListeners[D].push(Y));
      return V;
    }
    _toKonvaCanvas(M) {
      M = M || {};
      const j = this.getClientRect(), D = this.getStage(), z = M.x !== void 0 ? M.x : Math.floor(j.x), H = M.y !== void 0 ? M.y : Math.floor(j.y), X = M.pixelRatio || 1, Y = new n.SceneCanvas({
        width: M.width || Math.ceil(j.width) || (D ? D.width() : 0),
        height: M.height || Math.ceil(j.height) || (D ? D.height() : 0),
        pixelRatio: X
      }), V = Y.getContext(), Z = new n.SceneCanvas({
        width: Y.width / Y.pixelRatio + Math.abs(z),
        height: Y.height / Y.pixelRatio + Math.abs(H),
        pixelRatio: Y.pixelRatio
      });
      return M.imageSmoothingEnabled === !1 && (V._context.imageSmoothingEnabled = !1), V.save(), (z || H) && V.translate(-1 * z, -1 * H), this.drawScene(Y, void 0, Z), V.restore(), Y;
    }
    toCanvas(M) {
      return this._toKonvaCanvas(M)._canvas;
    }
    toDataURL(M) {
      M = M || {};
      const j = M.mimeType || null, D = M.quality || null, z = this._toKonvaCanvas(M).toDataURL(j, D);
      return M.callback && M.callback(z), z;
    }
    toImage(M) {
      return new Promise((j, D) => {
        try {
          const z = M == null ? void 0 : M.callback;
          z && delete M.callback, e.Util._urlToImage(this.toDataURL(M), function(H) {
            j(H), z == null || z(H);
          });
        } catch (z) {
          D(z);
        }
      });
    }
    toBlob(M) {
      return new Promise((j, D) => {
        try {
          const z = M == null ? void 0 : M.callback;
          z && delete M.callback, this.toCanvas(M).toBlob((H) => {
            j(H), z == null || z(H);
          }, M == null ? void 0 : M.mimeType, M == null ? void 0 : M.quality);
        } catch (z) {
          D(z);
        }
      });
    }
    setSize(M) {
      return this.width(M.width), this.height(M.height), this;
    }
    getSize() {
      return {
        width: this.width(),
        height: this.height()
      };
    }
    getClassName() {
      return this.className || this.nodeType;
    }
    getType() {
      return this.nodeType;
    }
    getDragDistance() {
      return this.attrs.dragDistance !== void 0 ? this.attrs.dragDistance : this.parent ? this.parent.getDragDistance() : r.Konva.dragDistance;
    }
    _off(M, j, D) {
      let z = this.eventListeners[M], H, X, Y;
      for (H = 0; H < z.length; H++)
        if (X = z[H].name, Y = z[H].handler, (X !== "konva" || j === "konva") && (!j || X === j) && (!D || D === Y)) {
          if (z.splice(H, 1), z.length === 0) {
            delete this.eventListeners[M];
            break;
          }
          H--;
        }
    }
    _fireChangeEvent(M, j, D) {
      this._fire(M + p, {
        oldVal: j,
        newVal: D
      });
    }
    addName(M) {
      if (!this.hasName(M)) {
        const j = this.name(), D = j ? j + " " + M : M;
        this.name(D);
      }
      return this;
    }
    hasName(M) {
      if (!M)
        return !1;
      const j = this.name();
      return j ? (j || "").split(/\s/g).indexOf(M) !== -1 : !1;
    }
    removeName(M) {
      const j = (this.name() || "").split(/\s/g), D = j.indexOf(M);
      return D !== -1 && (j.splice(D, 1), this.name(j.join(" "))), this;
    }
    setAttr(M, j) {
      const D = this[w + e.Util._capitalize(M)];
      return e.Util._isFunction(D) ? D.call(this, j) : this._setAttr(M, j), this;
    }
    _requestDraw() {
      if (r.Konva.autoDrawEnabled) {
        const M = this.getLayer() || this.getStage();
        M == null || M.batchDraw();
      }
    }
    _setAttr(M, j) {
      const D = this.attrs[M];
      D === j && !e.Util.isObject(j) || (j == null ? delete this.attrs[M] : this.attrs[M] = j, this._shouldFireChangeEvents && this._fireChangeEvent(M, D, j), this._requestDraw());
    }
    _setComponentAttr(M, j, D) {
      let z;
      D !== void 0 && (z = this.attrs[M], z || (this.attrs[M] = this.getAttr(M)), this.attrs[M][j] = D, this._fireChangeEvent(M, z, D));
    }
    _fireAndBubble(M, j, D) {
      if (j && this.nodeType === T && (j.target = this), !((M === b || M === x) && (D && (this === D || this.isAncestorOf && this.isAncestorOf(D)) || this.nodeType === "Stage" && !D))) {
        this._fire(M, j);
        const H = (M === b || M === x) && D && D.isAncestorOf && D.isAncestorOf(this) && !D.isAncestorOf(this.parent);
        (j && !j.cancelBubble || !j) && this.parent && this.parent.isListening() && !H && (D && D.parent ? this._fireAndBubble.call(this.parent, M, j, D) : this._fireAndBubble.call(this.parent, M, j));
      }
    }
    _getProtoListeners(M) {
      var j, D, z;
      const H = (j = this._cache.get(c)) !== null && j !== void 0 ? j : {};
      let X = H == null ? void 0 : H[M];
      if (X === void 0) {
        X = [];
        let Y = Object.getPrototypeOf(this);
        for (; Y; ) {
          const V = (z = (D = Y.eventListeners) === null || D === void 0 ? void 0 : D[M]) !== null && z !== void 0 ? z : [];
          X.push(...V), Y = Object.getPrototypeOf(Y);
        }
        H[M] = X, this._cache.set(c, H);
      }
      return X;
    }
    _fire(M, j) {
      j = j || {}, j.currentTarget = this, j.type = M;
      const D = this._getProtoListeners(M);
      if (D)
        for (var z = 0; z < D.length; z++)
          D[z].handler.call(this, j);
      const H = this.eventListeners[M];
      if (H)
        for (var z = 0; z < H.length; z++)
          H[z].handler.call(this, j);
    }
    draw() {
      return this.drawScene(), this.drawHit(), this;
    }
    _createDragElement(M) {
      const j = M ? M.pointerId : void 0, D = this.getStage(), z = this.getAbsolutePosition();
      if (!D)
        return;
      const H = D._getPointerById(j) || D._changedPointerPositions[0] || z;
      i.DD._dragElements.set(this._id, {
        node: this,
        startPointerPos: H,
        offset: {
          x: H.x - z.x,
          y: H.y - z.y
        },
        dragStatus: "ready",
        pointerId: j
      });
    }
    startDrag(M, j = !0) {
      i.DD._dragElements.has(this._id) || this._createDragElement(M);
      const D = i.DD._dragElements.get(this._id);
      D.dragStatus = "dragging", this.fire("dragstart", {
        type: "dragstart",
        target: this,
        evt: M && M.evt
      }, j);
    }
    _setDragPosition(M, j) {
      const D = this.getStage()._getPointerById(j.pointerId);
      if (!D)
        return;
      let z = {
        x: D.x - j.offset.x,
        y: D.y - j.offset.y
      };
      const H = this.dragBoundFunc();
      if (H !== void 0) {
        const X = H.call(this, z, M);
        X ? z = X : e.Util.warn("dragBoundFunc did not return any value. That is unexpected behavior. You must return new absolute position from dragBoundFunc.");
      }
      (!this._lastPos || this._lastPos.x !== z.x || this._lastPos.y !== z.y) && (this.setAbsolutePosition(z), this._requestDraw()), this._lastPos = z;
    }
    stopDrag(M) {
      const j = i.DD._dragElements.get(this._id);
      j && (j.dragStatus = "stopped"), i.DD._endDragBefore(M), i.DD._endDragAfter(M);
    }
    setDraggable(M) {
      this._setAttr("draggable", M), this._dragChange();
    }
    isDragging() {
      const M = i.DD._dragElements.get(this._id);
      return M ? M.dragStatus === "dragging" : !1;
    }
    _listenDrag() {
      this._dragCleanup(), this.on("mousedown.konva touchstart.konva", function(M) {
        if (!(!(M.evt.button !== void 0) || r.Konva.dragButtons.indexOf(M.evt.button) >= 0) || this.isDragging())
          return;
        let z = !1;
        i.DD._dragElements.forEach((H) => {
          this.isAncestorOf(H.node) && (z = !0);
        }), z || this._createDragElement(M);
      });
    }
    _dragChange() {
      if (this.attrs.draggable)
        this._listenDrag();
      else {
        if (this._dragCleanup(), !this.getStage())
          return;
        const j = i.DD._dragElements.get(this._id), D = j && j.dragStatus === "dragging", z = j && j.dragStatus === "ready";
        D ? this.stopDrag() : z && i.DD._dragElements.delete(this._id);
      }
    }
    _dragCleanup() {
      this.off("mousedown.konva"), this.off("touchstart.konva");
    }
    isClientRectOnScreen(M = { x: 0, y: 0 }) {
      const j = this.getStage();
      if (!j)
        return !1;
      const D = {
        x: -M.x,
        y: -M.y,
        width: j.width() + 2 * M.x,
        height: j.height() + 2 * M.y
      };
      return e.Util.haveIntersection(D, this.getClientRect());
    }
    static create(M, j) {
      return e.Util._isString(M) && (M = JSON.parse(M)), this._createNode(M, j);
    }
    static _createNode(M, j) {
      let D = R0.prototype.getClassName.call(M), z = M.children, H, X, Y;
      j && (M.attrs.container = j), r.Konva[D] || (e.Util.warn('Can not find a node with class name "' + D + '". Fallback to "Shape".'), D = "Shape");
      const V = r.Konva[D];
      if (H = new V(M.attrs), z)
        for (X = z.length, Y = 0; Y < X; Y++)
          H.add(R0._createNode(z[Y]));
      return H;
    }
  };
  rd.Node = k, k.prototype.nodeType = "Node", k.prototype._attrsAffectingSize = [], k.prototype.eventListeners = {}, k.prototype.on.call(k.prototype, N, function() {
    if (this._batchingTransformChange) {
      this._needClearTransformCache = !0;
      return;
    }
    this._clearCache(E), this._clearSelfAndDescendantCache(u);
  }), k.prototype.on.call(k.prototype, "visibleChange.konva", function() {
    this._clearSelfAndDescendantCache(B);
  }), k.prototype.on.call(k.prototype, "listeningChange.konva", function() {
    this._clearSelfAndDescendantCache(g);
  }), k.prototype.on.call(k.prototype, "opacityChange.konva", function() {
    this._clearSelfAndDescendantCache(l);
  });
  const F = t.Factory.addGetterSetter;
  return F(k, "zIndex"), F(k, "absolutePosition"), F(k, "position"), F(k, "x", 0, (0, s.getNumberValidator)()), F(k, "y", 0, (0, s.getNumberValidator)()), F(k, "globalCompositeOperation", "source-over", (0, s.getStringValidator)()), F(k, "opacity", 1, (0, s.getNumberValidator)()), F(k, "name", "", (0, s.getStringValidator)()), F(k, "id", "", (0, s.getStringValidator)()), F(k, "rotation", 0, (0, s.getNumberValidator)()), t.Factory.addComponentsGetterSetter(k, "scale", ["x", "y"]), F(k, "scaleX", 1, (0, s.getNumberValidator)()), F(k, "scaleY", 1, (0, s.getNumberValidator)()), t.Factory.addComponentsGetterSetter(k, "skew", ["x", "y"]), F(k, "skewX", 0, (0, s.getNumberValidator)()), F(k, "skewY", 0, (0, s.getNumberValidator)()), t.Factory.addComponentsGetterSetter(k, "offset", ["x", "y"]), F(k, "offsetX", 0, (0, s.getNumberValidator)()), F(k, "offsetY", 0, (0, s.getNumberValidator)()), F(k, "dragDistance", void 0, (0, s.getNumberValidator)()), F(k, "width", 0, (0, s.getNumberValidator)()), F(k, "height", 0, (0, s.getNumberValidator)()), F(k, "listening", !0, (0, s.getBooleanValidator)()), F(k, "preventDefault", !0, (0, s.getBooleanValidator)()), F(k, "filters", void 0, function(G) {
    return this._filterUpToDate = !1, G;
  }), F(k, "visible", !0, (0, s.getBooleanValidator)()), F(k, "transformsEnabled", "all", (0, s.getStringValidator)()), F(k, "size"), F(k, "dragBoundFunc"), F(k, "draggable", !1, (0, s.getBooleanValidator)()), t.Factory.backCompat(k, {
    rotateDeg: "rotate",
    setRotationDeg: "setRotation",
    getRotationDeg: "getRotation"
  }), rd;
}
var id = {}, P2;
function pm() {
  if (P2) return id;
  P2 = 1, Object.defineProperty(id, "__esModule", { value: !0 }), id.Container = void 0;
  const e = We(), t = Xn(), n = $e();
  let r = class extends t.Node {
    constructor() {
      super(...arguments), this.children = [];
    }
    getChildren(s) {
      if (!s)
        return this.children || [];
      const l = this.children || [], c = [];
      return l.forEach(function(u) {
        s(u) && c.push(u);
      }), c;
    }
    hasChildren() {
      return this.getChildren().length > 0;
    }
    removeChildren() {
      return this.getChildren().forEach((s) => {
        s.parent = null, s.index = 0, s.remove();
      }), this.children = [], this._requestDraw(), this;
    }
    destroyChildren() {
      return this.getChildren().forEach((s) => {
        s.parent = null, s.index = 0, s.destroy();
      }), this.children = [], this._requestDraw(), this;
    }
    add(...s) {
      if (s.length === 0)
        return this;
      if (s.length > 1) {
        for (let c = 0; c < s.length; c++)
          this.add(s[c]);
        return this;
      }
      const l = s[0];
      return l.getParent() ? (l.moveTo(this), this) : (this._validateAdd(l), l.index = this.getChildren().length, l.parent = this, l._clearCaches(), this.getChildren().push(l), this._fire("add", {
        child: l
      }), this._requestDraw(), this);
    }
    destroy() {
      return this.hasChildren() && this.destroyChildren(), super.destroy(), this;
    }
    find(s) {
      return this._generalFind(s, !1);
    }
    findOne(s) {
      const l = this._generalFind(s, !0);
      return l.length > 0 ? l[0] : void 0;
    }
    _generalFind(s, l) {
      const c = [];
      return this._descendants((u) => {
        const d = u._isMatch(s);
        return d && c.push(u), !!(d && l);
      }), c;
    }
    _descendants(s) {
      let l = !1;
      const c = this.getChildren();
      for (const u of c) {
        if (l = s(u), l)
          return !0;
        if (u.hasChildren() && (l = u._descendants(s), l))
          return !0;
      }
      return !1;
    }
    toObject() {
      const s = t.Node.prototype.toObject.call(this);
      return s.children = [], this.getChildren().forEach((l) => {
        s.children.push(l.toObject());
      }), s;
    }
    isAncestorOf(s) {
      let l = s.getParent();
      for (; l; ) {
        if (l._id === this._id)
          return !0;
        l = l.getParent();
      }
      return !1;
    }
    clone(s) {
      const l = t.Node.prototype.clone.call(this, s);
      return this.getChildren().forEach(function(c) {
        l.add(c.clone());
      }), l;
    }
    getAllIntersections(s) {
      const l = [];
      return this.find("Shape").forEach((c) => {
        c.isVisible() && c.intersects(s) && l.push(c);
      }), l;
    }
    _clearSelfAndDescendantCache(s) {
      var l;
      super._clearSelfAndDescendantCache(s), !this.isCached() && ((l = this.children) === null || l === void 0 || l.forEach(function(c) {
        c._clearSelfAndDescendantCache(s);
      }));
    }
    _setChildrenIndices() {
      var s;
      (s = this.children) === null || s === void 0 || s.forEach(function(l, c) {
        l.index = c;
      }), this._requestDraw();
    }
    drawScene(s, l, c) {
      const u = this.getLayer(), d = s || u && u.getCanvas(), h = d && d.getContext(), p = this._getCanvasCache(), v = p && p.scene, m = d && d.isCache;
      if (!this.isVisible() && !m)
        return this;
      if (v) {
        h.save();
        const g = this.getAbsoluteTransform(l).getMatrix();
        h.transform(g[0], g[1], g[2], g[3], g[4], g[5]), this._drawCachedSceneCanvas(h), h.restore();
      } else
        this._drawChildren("drawScene", d, l, c);
      return this;
    }
    drawHit(s, l) {
      if (!this.shouldDrawHit(l))
        return this;
      const c = this.getLayer(), u = s || c && c.hitCanvas, d = u && u.getContext(), h = this._getCanvasCache();
      if (h && h.hit) {
        d.save();
        const v = this.getAbsoluteTransform(l).getMatrix();
        d.transform(v[0], v[1], v[2], v[3], v[4], v[5]), this._drawCachedHitCanvas(d), d.restore();
      } else
        this._drawChildren("drawHit", u, l);
      return this;
    }
    _drawChildren(s, l, c, u) {
      var d;
      const h = l && l.getContext(), p = this.clipWidth(), v = this.clipHeight(), m = this.clipFunc(), g = typeof p == "number" && typeof v == "number" || m, b = c === this;
      if (g) {
        h.save();
        const w = this.getAbsoluteTransform(c);
        let T = w.getMatrix();
        h.transform(T[0], T[1], T[2], T[3], T[4], T[5]), h.beginPath();
        let S;
        if (m)
          S = m.call(this, h, this);
        else {
          const C = this.clipX(), E = this.clipY();
          h.rect(C || 0, E || 0, p, v);
        }
        h.clip.apply(h, S), T = w.copy().invert().getMatrix(), h.transform(T[0], T[1], T[2], T[3], T[4], T[5]);
      }
      const x = !b && this.globalCompositeOperation() !== "source-over" && s === "drawScene";
      x && (h.save(), h._applyGlobalCompositeOperation(this)), (d = this.children) === null || d === void 0 || d.forEach(function(w) {
        w[s](l, c, u);
      }), x && h.restore(), g && h.restore();
    }
    getClientRect(s = {}) {
      var l;
      const c = s.skipTransform, u = s.relativeTo;
      let d, h, p, v, m = {
        x: 1 / 0,
        y: 1 / 0,
        width: 0,
        height: 0
      };
      const g = this;
      (l = this.children) === null || l === void 0 || l.forEach(function(w) {
        if (!w.visible())
          return;
        const T = w.getClientRect({
          relativeTo: g,
          skipShadow: s.skipShadow,
          skipStroke: s.skipStroke
        });
        T.width === 0 && T.height === 0 || (d === void 0 ? (d = T.x, h = T.y, p = T.x + T.width, v = T.y + T.height) : (d = Math.min(d, T.x), h = Math.min(h, T.y), p = Math.max(p, T.x + T.width), v = Math.max(v, T.y + T.height)));
      });
      const b = this.find("Shape");
      let x = !1;
      for (let w = 0; w < b.length; w++)
        if (b[w]._isVisible(this)) {
          x = !0;
          break;
        }
      return x && d !== void 0 ? m = {
        x: d,
        y: h,
        width: p - d,
        height: v - h
      } : m = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      }, c ? m : this._transformedRect(m, u);
    }
  };
  return id.Container = r, e.Factory.addComponentsGetterSetter(r, "clip", [
    "x",
    "y",
    "width",
    "height"
  ]), e.Factory.addGetterSetter(r, "clipX", void 0, (0, n.getNumberValidator)()), e.Factory.addGetterSetter(r, "clipY", void 0, (0, n.getNumberValidator)()), e.Factory.addGetterSetter(r, "clipWidth", void 0, (0, n.getNumberValidator)()), e.Factory.addGetterSetter(r, "clipHeight", void 0, (0, n.getNumberValidator)()), e.Factory.addGetterSetter(r, "clipFunc"), id;
}
var Fg = {}, Yo = {}, D2;
function fx() {
  if (D2) return Yo;
  D2 = 1, Object.defineProperty(Yo, "__esModule", { value: !0 }), Yo.getCapturedShape = r, Yo.createEvent = i, Yo.hasPointerCapture = s, Yo.setPointerCapture = l, Yo.releaseCapture = c;
  const e = Fe(), t = /* @__PURE__ */ new Map(), n = e.Konva._global.PointerEvent !== void 0;
  function r(u) {
    return t.get(u);
  }
  function i(u) {
    return {
      evt: u,
      pointerId: u.pointerId
    };
  }
  function s(u, d) {
    return t.get(u) === d;
  }
  function l(u, d) {
    c(u), d.getStage() && (t.set(u, d), n && d._fire("gotpointercapture", i(new PointerEvent("gotpointercapture"))));
  }
  function c(u, d) {
    const h = t.get(u);
    if (!h)
      return;
    const p = h.getStage();
    p && p.content, t.delete(u), n && h._fire("lostpointercapture", i(new PointerEvent("lostpointercapture")));
  }
  return Yo;
}
var I2;
function KP() {
  return I2 || (I2 = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.Stage = e.stages = void 0;
    const t = Hn(), n = We(), r = pm(), i = Fe(), s = fm(), l = Zy(), c = Fe(), u = fx(), d = "Stage", h = "string", p = "px", v = "mouseout", m = "mouseleave", g = "mouseover", b = "mouseenter", x = "mousemove", w = "mousedown", T = "mouseup", S = "pointermove", C = "pointerdown", E = "pointerup", O = "pointercancel", B = "lostpointercapture", N = "pointerout", L = "pointerleave", k = "pointerover", F = "pointerenter", G = "contextmenu", M = "touchstart", j = "touchend", D = "touchmove", z = "touchcancel", H = "wheel", X = 5, Y = [
      [b, "_pointerenter"],
      [w, "_pointerdown"],
      [x, "_pointermove"],
      [T, "_pointerup"],
      [m, "_pointerleave"],
      [M, "_pointerdown"],
      [D, "_pointermove"],
      [j, "_pointerup"],
      [z, "_pointercancel"],
      [g, "_pointerover"],
      [H, "_wheel"],
      [G, "_contextmenu"],
      [C, "_pointerdown"],
      [S, "_pointermove"],
      [E, "_pointerup"],
      [O, "_pointercancel"],
      [B, "_lostpointercapture"]
    ], V = {
      mouse: {
        [N]: v,
        [L]: m,
        [k]: g,
        [F]: b,
        [S]: x,
        [C]: w,
        [E]: T,
        [O]: "mousecancel",
        pointerclick: "click",
        pointerdblclick: "dblclick"
      },
      touch: {
        [N]: "touchout",
        [L]: "touchleave",
        [k]: "touchover",
        [F]: "touchenter",
        [S]: D,
        [C]: M,
        [E]: j,
        [O]: z,
        pointerclick: "tap",
        pointerdblclick: "dbltap"
      },
      pointer: {
        [N]: N,
        [L]: L,
        [k]: k,
        [F]: F,
        [S]: S,
        [C]: C,
        [E]: E,
        [O]: O,
        pointerclick: "pointerclick",
        pointerdblclick: "pointerdblclick"
      }
    }, Z = (yt) => yt.indexOf("pointer") >= 0 ? "pointer" : yt.indexOf("touch") >= 0 ? "touch" : "mouse", ct = (yt) => {
      const J = Z(yt);
      if (J === "pointer")
        return i.Konva.pointerEventsEnabled && V.pointer;
      if (J === "touch")
        return V.touch;
      if (J === "mouse")
        return V.mouse;
    };
    function et(yt = {}) {
      return (yt.clipFunc || yt.clipWidth || yt.clipHeight) && t.Util.warn("Stage does not support clipping. Please use clip for Layers or Groups."), yt;
    }
    const rt = "Pointer position is missing and not registered by the stage. Looks like it is outside of the stage container. You can set it manually from event: stage.setPointersPositions(event);";
    e.stages = [];
    class st extends r.Container {
      constructor(J) {
        super(et(J)), this._pointerPositions = [], this._changedPointerPositions = [], this._buildDOM(), this._bindContentEvents(), e.stages.push(this), this.on("widthChange.konva heightChange.konva", this._resizeDOM), this.on("visibleChange.konva", this._checkVisibility), this.on("clipWidthChange.konva clipHeightChange.konva clipFuncChange.konva", () => {
          et(this.attrs);
        }), this._checkVisibility();
      }
      _validateAdd(J) {
        const tt = J.getType() === "Layer", ot = J.getType() === "FastLayer";
        tt || ot || t.Util.throw("You may only add layers to the stage.");
      }
      _checkVisibility() {
        if (!this.content)
          return;
        const J = this.visible() ? "" : "none";
        this.content.style.display = J;
      }
      setContainer(J) {
        if (typeof J === h) {
          if (J.charAt(0) === ".") {
            const ot = J.slice(1);
            J = document.getElementsByClassName(ot)[0];
          } else {
            var tt;
            J.charAt(0) !== "#" ? tt = J : tt = J.slice(1), J = document.getElementById(tt);
          }
          if (!J)
            throw "Can not find container in document with id " + tt;
        }
        return this._setAttr("container", J), this.content && (this.content.parentElement && this.content.parentElement.removeChild(this.content), J.appendChild(this.content)), this;
      }
      shouldDrawHit() {
        return !0;
      }
      clear() {
        const J = this.children, tt = J.length;
        for (let ot = 0; ot < tt; ot++)
          J[ot].clear();
        return this;
      }
      clone(J) {
        return J || (J = {}), J.container = typeof document < "u" && document.createElement("div"), r.Container.prototype.clone.call(this, J);
      }
      destroy() {
        super.destroy();
        const J = this.content;
        J && t.Util._isInDocument(J) && this.container().removeChild(J);
        const tt = e.stages.indexOf(this);
        return tt > -1 && e.stages.splice(tt, 1), t.Util.releaseCanvas(this.bufferCanvas._canvas, this.bufferHitCanvas._canvas), this;
      }
      getPointerPosition() {
        const J = this._pointerPositions[0] || this._changedPointerPositions[0];
        return J ? {
          x: J.x,
          y: J.y
        } : (t.Util.warn(rt), null);
      }
      _getPointerById(J) {
        return this._pointerPositions.find((tt) => tt.id === J);
      }
      getPointersPositions() {
        return this._pointerPositions;
      }
      getStage() {
        return this;
      }
      getContent() {
        return this.content;
      }
      _toKonvaCanvas(J) {
        J = J || {}, J.x = J.x || 0, J.y = J.y || 0, J.width = J.width || this.width(), J.height = J.height || this.height();
        const tt = new s.SceneCanvas({
          width: J.width,
          height: J.height,
          pixelRatio: J.pixelRatio || 1
        }), ot = tt.getContext()._context, Tt = this.children;
        return (J.x || J.y) && ot.translate(-1 * J.x, -1 * J.y), Tt.forEach(function(Ct) {
          if (!Ct.isVisible())
            return;
          const bt = Ct._toKonvaCanvas(J);
          ot.drawImage(bt._canvas, J.x, J.y, bt.getWidth() / bt.getPixelRatio(), bt.getHeight() / bt.getPixelRatio());
        }), tt;
      }
      getIntersection(J) {
        if (!J)
          return null;
        const tt = this.children, ot = tt.length, Tt = ot - 1;
        for (let Ct = Tt; Ct >= 0; Ct--) {
          const bt = tt[Ct].getIntersection(J);
          if (bt)
            return bt;
        }
        return null;
      }
      _resizeDOM() {
        const J = this.width(), tt = this.height();
        this.content && (this.content.style.width = J + p, this.content.style.height = tt + p), this.bufferCanvas.setSize(J, tt), this.bufferHitCanvas.setSize(J, tt), this.children.forEach((ot) => {
          ot.setSize({ width: J, height: tt }), ot.draw();
        });
      }
      add(J, ...tt) {
        if (arguments.length > 1) {
          for (let Tt = 0; Tt < arguments.length; Tt++)
            this.add(arguments[Tt]);
          return this;
        }
        super.add(J);
        const ot = this.children.length;
        return ot > X && t.Util.warn("The stage has " + ot + " layers. Recommended maximum number of layers is 3-5. Adding more layers into the stage may drop the performance. Rethink your tree structure, you can use Konva.Group."), J.setSize({ width: this.width(), height: this.height() }), J.draw(), i.Konva.isBrowser && this.content.appendChild(J.canvas._canvas), this;
      }
      getParent() {
        return null;
      }
      getLayer() {
        return null;
      }
      hasPointerCapture(J) {
        return u.hasPointerCapture(J, this);
      }
      setPointerCapture(J) {
        u.setPointerCapture(J, this);
      }
      releaseCapture(J) {
        u.releaseCapture(J, this);
      }
      getLayers() {
        return this.children;
      }
      _bindContentEvents() {
        i.Konva.isBrowser && Y.forEach(([J, tt]) => {
          this.content.addEventListener(J, (ot) => {
            this[tt](ot);
          }, { passive: !1 });
        });
      }
      _pointerenter(J) {
        this.setPointersPositions(J);
        const tt = ct(J.type);
        tt && this._fire(tt.pointerenter, {
          evt: J,
          target: this,
          currentTarget: this
        });
      }
      _pointerover(J) {
        this.setPointersPositions(J);
        const tt = ct(J.type);
        tt && this._fire(tt.pointerover, {
          evt: J,
          target: this,
          currentTarget: this
        });
      }
      _getTargetShape(J) {
        let tt = this[J + "targetShape"];
        return tt && !tt.getStage() && (tt = null), tt;
      }
      _pointerleave(J) {
        const tt = ct(J.type), ot = Z(J.type);
        if (!tt)
          return;
        this.setPointersPositions(J);
        const Tt = this._getTargetShape(ot), Ct = !(i.Konva.isDragging() || i.Konva.isTransforming()) || i.Konva.hitOnDragEnabled;
        Tt && Ct ? (Tt._fireAndBubble(tt.pointerout, { evt: J }), Tt._fireAndBubble(tt.pointerleave, { evt: J }), this._fire(tt.pointerleave, {
          evt: J,
          target: this,
          currentTarget: this
        }), this[ot + "targetShape"] = null) : Ct && (this._fire(tt.pointerleave, {
          evt: J,
          target: this,
          currentTarget: this
        }), this._fire(tt.pointerout, {
          evt: J,
          target: this,
          currentTarget: this
        })), this.pointerPos = null, this._pointerPositions = [];
      }
      _pointerdown(J) {
        const tt = ct(J.type), ot = Z(J.type);
        if (!tt)
          return;
        this.setPointersPositions(J);
        let Tt = !1;
        this._changedPointerPositions.forEach((Ct) => {
          const bt = this.getIntersection(Ct);
          if (l.DD.justDragged = !1, i.Konva["_" + ot + "ListenClick"] = !0, !bt || !bt.isListening()) {
            this[ot + "ClickStartShape"] = void 0;
            return;
          }
          i.Konva.capturePointerEventsEnabled && bt.setPointerCapture(Ct.id), this[ot + "ClickStartShape"] = bt, bt._fireAndBubble(tt.pointerdown, {
            evt: J,
            pointerId: Ct.id
          }), Tt = !0;
          const Ht = J.type.indexOf("touch") >= 0;
          bt.preventDefault() && J.cancelable && Ht && J.preventDefault();
        }), Tt || this._fire(tt.pointerdown, {
          evt: J,
          target: this,
          currentTarget: this,
          pointerId: this._pointerPositions[0].id
        });
      }
      _pointermove(J) {
        const tt = ct(J.type), ot = Z(J.type);
        if (!tt || (i.Konva.isDragging() && l.DD.node.preventDefault() && J.cancelable && J.preventDefault(), this.setPointersPositions(J), !(!(i.Konva.isDragging() || i.Konva.isTransforming()) || i.Konva.hitOnDragEnabled)))
          return;
        const Ct = {};
        let bt = !1;
        const Ht = this._getTargetShape(ot);
        this._changedPointerPositions.forEach(($t) => {
          const wt = u.getCapturedShape($t.id) || this.getIntersection($t), Wt = $t.id, Ut = { evt: J, pointerId: Wt }, ne = Ht !== wt;
          if (ne && Ht && (Ht._fireAndBubble(tt.pointerout, { ...Ut }, wt), Ht._fireAndBubble(tt.pointerleave, { ...Ut }, wt)), wt) {
            if (Ct[wt._id])
              return;
            Ct[wt._id] = !0;
          }
          wt && wt.isListening() ? (bt = !0, ne && (wt._fireAndBubble(tt.pointerover, { ...Ut }, Ht), wt._fireAndBubble(tt.pointerenter, { ...Ut }, Ht), this[ot + "targetShape"] = wt), wt._fireAndBubble(tt.pointermove, { ...Ut })) : Ht && (this._fire(tt.pointerover, {
            evt: J,
            target: this,
            currentTarget: this,
            pointerId: Wt
          }), this[ot + "targetShape"] = null);
        }), bt || this._fire(tt.pointermove, {
          evt: J,
          target: this,
          currentTarget: this,
          pointerId: this._changedPointerPositions[0].id
        });
      }
      _pointerup(J) {
        const tt = ct(J.type), ot = Z(J.type);
        if (!tt)
          return;
        this.setPointersPositions(J);
        const Tt = this[ot + "ClickStartShape"], Ct = this[ot + "ClickEndShape"], bt = {};
        let Ht = !1;
        this._changedPointerPositions.forEach(($t) => {
          const wt = u.getCapturedShape($t.id) || this.getIntersection($t);
          if (wt) {
            if (wt.releaseCapture($t.id), bt[wt._id])
              return;
            bt[wt._id] = !0;
          }
          const Wt = $t.id, Ut = { evt: J, pointerId: Wt };
          let ne = !1;
          i.Konva["_" + ot + "InDblClickWindow"] ? (ne = !0, clearTimeout(this[ot + "DblTimeout"])) : l.DD.justDragged || (i.Konva["_" + ot + "InDblClickWindow"] = !0, clearTimeout(this[ot + "DblTimeout"])), this[ot + "DblTimeout"] = setTimeout(function() {
            i.Konva["_" + ot + "InDblClickWindow"] = !1;
          }, i.Konva.dblClickWindow), wt && wt.isListening() ? (Ht = !0, this[ot + "ClickEndShape"] = wt, wt._fireAndBubble(tt.pointerup, { ...Ut }), i.Konva["_" + ot + "ListenClick"] && Tt && Tt === wt && (wt._fireAndBubble(tt.pointerclick, { ...Ut }), ne && Ct && Ct === wt && wt._fireAndBubble(tt.pointerdblclick, { ...Ut }))) : (this[ot + "ClickEndShape"] = null, i.Konva["_" + ot + "ListenClick"] && this._fire(tt.pointerclick, {
            evt: J,
            target: this,
            currentTarget: this,
            pointerId: Wt
          }), ne && this._fire(tt.pointerdblclick, {
            evt: J,
            target: this,
            currentTarget: this,
            pointerId: Wt
          }));
        }), Ht || this._fire(tt.pointerup, {
          evt: J,
          target: this,
          currentTarget: this,
          pointerId: this._changedPointerPositions[0].id
        }), i.Konva["_" + ot + "ListenClick"] = !1, J.cancelable && ot !== "touch" && ot !== "pointer" && J.preventDefault();
      }
      _contextmenu(J) {
        this.setPointersPositions(J);
        const tt = this.getIntersection(this.getPointerPosition());
        tt && tt.isListening() ? tt._fireAndBubble(G, { evt: J }) : this._fire(G, {
          evt: J,
          target: this,
          currentTarget: this
        });
      }
      _wheel(J) {
        this.setPointersPositions(J);
        const tt = this.getIntersection(this.getPointerPosition());
        tt && tt.isListening() ? tt._fireAndBubble(H, { evt: J }) : this._fire(H, {
          evt: J,
          target: this,
          currentTarget: this
        });
      }
      _pointercancel(J) {
        this.setPointersPositions(J);
        const tt = u.getCapturedShape(J.pointerId) || this.getIntersection(this.getPointerPosition());
        tt && tt._fireAndBubble(E, u.createEvent(J)), u.releaseCapture(J.pointerId);
      }
      _lostpointercapture(J) {
        u.releaseCapture(J.pointerId);
      }
      setPointersPositions(J) {
        const tt = this._getContentPosition();
        let ot = null, Tt = null;
        J = J || window.event, J.touches !== void 0 ? (this._pointerPositions = [], this._changedPointerPositions = [], Array.prototype.forEach.call(J.touches, (Ct) => {
          this._pointerPositions.push({
            id: Ct.identifier,
            x: (Ct.clientX - tt.left) / tt.scaleX,
            y: (Ct.clientY - tt.top) / tt.scaleY
          });
        }), Array.prototype.forEach.call(J.changedTouches || J.touches, (Ct) => {
          this._changedPointerPositions.push({
            id: Ct.identifier,
            x: (Ct.clientX - tt.left) / tt.scaleX,
            y: (Ct.clientY - tt.top) / tt.scaleY
          });
        })) : (ot = (J.clientX - tt.left) / tt.scaleX, Tt = (J.clientY - tt.top) / tt.scaleY, this.pointerPos = {
          x: ot,
          y: Tt
        }, this._pointerPositions = [{ x: ot, y: Tt, id: t.Util._getFirstPointerId(J) }], this._changedPointerPositions = [
          { x: ot, y: Tt, id: t.Util._getFirstPointerId(J) }
        ]);
      }
      _setPointerPosition(J) {
        t.Util.warn('Method _setPointerPosition is deprecated. Use "stage.setPointersPositions(event)" instead.'), this.setPointersPositions(J);
      }
      _getContentPosition() {
        if (!this.content || !this.content.getBoundingClientRect)
          return {
            top: 0,
            left: 0,
            scaleX: 1,
            scaleY: 1
          };
        const J = this.content.getBoundingClientRect();
        return {
          top: J.top,
          left: J.left,
          scaleX: J.width / this.content.clientWidth || 1,
          scaleY: J.height / this.content.clientHeight || 1
        };
      }
      _buildDOM() {
        if (this.bufferCanvas = new s.SceneCanvas({
          width: this.width(),
          height: this.height()
        }), this.bufferHitCanvas = new s.HitCanvas({
          pixelRatio: 1,
          width: this.width(),
          height: this.height()
        }), !i.Konva.isBrowser)
          return;
        const J = this.container();
        if (!J)
          throw "Stage has no container. A container is required.";
        J.innerHTML = "", this.content = document.createElement("div"), this.content.style.position = "relative", this.content.style.userSelect = "none", this.content.className = "konvajs-content", this.content.setAttribute("role", "presentation"), J.appendChild(this.content), this._resizeDOM();
      }
      cache() {
        return t.Util.warn("Cache function is not allowed for stage. You may use cache only for layers, groups and shapes."), this;
      }
      clearCache() {
        return this;
      }
      batchDraw() {
        return this.getChildren().forEach(function(J) {
          J.batchDraw();
        }), this;
      }
    }
    e.Stage = st, st.prototype.nodeType = d, (0, c._registerNode)(st), n.Factory.addGetterSetter(st, "container"), i.Konva.isBrowser && document.addEventListener("visibilitychange", () => {
      e.stages.forEach((yt) => {
        yt.batchDraw();
      });
    });
  }(Fg)), Fg;
}
var sd = {}, jg = {}, B2;
function _r() {
  return B2 || (B2 = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.Shape = e.shapes = void 0;
    const t = Fe(), n = Hn(), r = We(), i = Xn(), s = $e(), l = Fe(), c = fx(), u = "hasShadow", d = "shadowRGBA", h = "patternImage", p = "linearGradient", v = "radialGradient";
    let m;
    function g() {
      return m || (m = n.Util.createCanvasElement().getContext("2d"), m);
    }
    e.shapes = {};
    function b(L) {
      const k = this.attrs.fillRule;
      k ? L.fill(k) : L.fill();
    }
    function x(L) {
      L.stroke();
    }
    function w(L) {
      const k = this.attrs.fillRule;
      k ? L.fill(k) : L.fill();
    }
    function T(L) {
      L.stroke();
    }
    function S() {
      this._clearCache(u);
    }
    function C() {
      this._clearCache(d);
    }
    function E() {
      this._clearCache(h);
    }
    function O() {
      this._clearCache(p);
    }
    function B() {
      this._clearCache(v);
    }
    class N extends i.Node {
      constructor(k) {
        super(k);
        let F;
        for (; F = n.Util.getRandomColor(), !(F && !(F in e.shapes)); )
          ;
        this.colorKey = F, e.shapes[F] = this;
      }
      getContext() {
        return n.Util.warn("shape.getContext() method is deprecated. Please do not use it."), this.getLayer().getContext();
      }
      getCanvas() {
        return n.Util.warn("shape.getCanvas() method is deprecated. Please do not use it."), this.getLayer().getCanvas();
      }
      getSceneFunc() {
        return this.attrs.sceneFunc || this._sceneFunc;
      }
      getHitFunc() {
        return this.attrs.hitFunc || this._hitFunc;
      }
      hasShadow() {
        return this._getCache(u, this._hasShadow);
      }
      _hasShadow() {
        return this.shadowEnabled() && this.shadowOpacity() !== 0 && !!(this.shadowColor() || this.shadowBlur() || this.shadowOffsetX() || this.shadowOffsetY());
      }
      _getFillPattern() {
        return this._getCache(h, this.__getFillPattern);
      }
      __getFillPattern() {
        if (this.fillPatternImage()) {
          const F = g().createPattern(this.fillPatternImage(), this.fillPatternRepeat() || "repeat");
          if (F && F.setTransform) {
            const G = new n.Transform();
            G.translate(this.fillPatternX(), this.fillPatternY()), G.rotate(t.Konva.getAngle(this.fillPatternRotation())), G.scale(this.fillPatternScaleX(), this.fillPatternScaleY()), G.translate(-1 * this.fillPatternOffsetX(), -1 * this.fillPatternOffsetY());
            const M = G.getMatrix(), j = typeof DOMMatrix > "u" ? {
              a: M[0],
              b: M[1],
              c: M[2],
              d: M[3],
              e: M[4],
              f: M[5]
            } : new DOMMatrix(M);
            F.setTransform(j);
          }
          return F;
        }
      }
      _getLinearGradient() {
        return this._getCache(p, this.__getLinearGradient);
      }
      __getLinearGradient() {
        const k = this.fillLinearGradientColorStops();
        if (k) {
          const F = g(), G = this.fillLinearGradientStartPoint(), M = this.fillLinearGradientEndPoint(), j = F.createLinearGradient(G.x, G.y, M.x, M.y);
          for (let D = 0; D < k.length; D += 2)
            j.addColorStop(k[D], k[D + 1]);
          return j;
        }
      }
      _getRadialGradient() {
        return this._getCache(v, this.__getRadialGradient);
      }
      __getRadialGradient() {
        const k = this.fillRadialGradientColorStops();
        if (k) {
          const F = g(), G = this.fillRadialGradientStartPoint(), M = this.fillRadialGradientEndPoint(), j = F.createRadialGradient(G.x, G.y, this.fillRadialGradientStartRadius(), M.x, M.y, this.fillRadialGradientEndRadius());
          for (let D = 0; D < k.length; D += 2)
            j.addColorStop(k[D], k[D + 1]);
          return j;
        }
      }
      getShadowRGBA() {
        return this._getCache(d, this._getShadowRGBA);
      }
      _getShadowRGBA() {
        if (!this.hasShadow())
          return;
        const k = n.Util.colorToRGBA(this.shadowColor());
        if (k)
          return "rgba(" + k.r + "," + k.g + "," + k.b + "," + k.a * (this.shadowOpacity() || 1) + ")";
      }
      hasFill() {
        return this._calculate("hasFill", [
          "fillEnabled",
          "fill",
          "fillPatternImage",
          "fillLinearGradientColorStops",
          "fillRadialGradientColorStops"
        ], () => this.fillEnabled() && !!(this.fill() || this.fillPatternImage() || this.fillLinearGradientColorStops() || this.fillRadialGradientColorStops()));
      }
      hasStroke() {
        return this._calculate("hasStroke", [
          "strokeEnabled",
          "strokeWidth",
          "stroke",
          "strokeLinearGradientColorStops"
        ], () => this.strokeEnabled() && this.strokeWidth() && !!(this.stroke() || this.strokeLinearGradientColorStops()));
      }
      hasHitStroke() {
        const k = this.hitStrokeWidth();
        return k === "auto" ? this.hasStroke() : this.strokeEnabled() && !!k;
      }
      intersects(k) {
        const F = this.getStage();
        if (!F)
          return !1;
        const G = F.bufferHitCanvas;
        return G.getContext().clear(), this.drawHit(G, void 0, !0), G.context.getImageData(Math.round(k.x), Math.round(k.y), 1, 1).data[3] > 0;
      }
      destroy() {
        return i.Node.prototype.destroy.call(this), delete e.shapes[this.colorKey], delete this.colorKey, this;
      }
      _useBufferCanvas(k) {
        var F;
        if (!((F = this.attrs.perfectDrawEnabled) !== null && F !== void 0 ? F : !0))
          return !1;
        const M = k || this.hasFill(), j = this.hasStroke(), D = this.getAbsoluteOpacity() !== 1;
        if (M && j && D)
          return !0;
        const z = this.hasShadow(), H = this.shadowForStrokeEnabled();
        return !!(M && j && z && H);
      }
      setStrokeHitEnabled(k) {
        n.Util.warn("strokeHitEnabled property is deprecated. Please use hitStrokeWidth instead."), k ? this.hitStrokeWidth("auto") : this.hitStrokeWidth(0);
      }
      getStrokeHitEnabled() {
        return this.hitStrokeWidth() !== 0;
      }
      getSelfRect() {
        const k = this.size();
        return {
          x: this._centroid ? -k.width / 2 : 0,
          y: this._centroid ? -k.height / 2 : 0,
          width: k.width,
          height: k.height
        };
      }
      getClientRect(k = {}) {
        let F = !1, G = this.getParent();
        for (; G; ) {
          if (G.isCached()) {
            F = !0;
            break;
          }
          G = G.getParent();
        }
        const M = k.skipTransform, j = k.relativeTo || F && this.getStage() || void 0, D = this.getSelfRect(), H = !k.skipStroke && this.hasStroke() && this.strokeWidth() || 0, X = D.width + H, Y = D.height + H, V = !k.skipShadow && this.hasShadow(), Z = V ? this.shadowOffsetX() : 0, ct = V ? this.shadowOffsetY() : 0, et = X + Math.abs(Z), rt = Y + Math.abs(ct), st = V && this.shadowBlur() || 0, yt = et + st * 2, J = rt + st * 2, tt = {
          width: yt,
          height: J,
          x: -(H / 2 + st) + Math.min(Z, 0) + D.x,
          y: -(H / 2 + st) + Math.min(ct, 0) + D.y
        };
        return M ? tt : this._transformedRect(tt, j);
      }
      drawScene(k, F, G) {
        const M = this.getLayer();
        let j = k || M.getCanvas(), D = j.getContext(), z = this._getCanvasCache(), H = this.getSceneFunc(), X = this.hasShadow(), Y, V;
        const Z = j.isCache, ct = F === this;
        if (!this.isVisible() && !ct)
          return this;
        if (z) {
          D.save();
          const rt = this.getAbsoluteTransform(F).getMatrix();
          return D.transform(rt[0], rt[1], rt[2], rt[3], rt[4], rt[5]), this._drawCachedSceneCanvas(D), D.restore(), this;
        }
        if (!H)
          return this;
        if (D.save(), this._useBufferCanvas() && !Z) {
          Y = this.getStage();
          const rt = G || Y.bufferCanvas;
          V = rt.getContext(), V.clear(), V.save(), V._applyLineJoin(this);
          var et = this.getAbsoluteTransform(F).getMatrix();
          V.transform(et[0], et[1], et[2], et[3], et[4], et[5]), H.call(this, V, this), V.restore();
          const st = rt.pixelRatio;
          X && D._applyShadow(this), D._applyOpacity(this), D._applyGlobalCompositeOperation(this), D.drawImage(rt._canvas, 0, 0, rt.width / st, rt.height / st);
        } else {
          if (D._applyLineJoin(this), !ct) {
            var et = this.getAbsoluteTransform(F).getMatrix();
            D.transform(et[0], et[1], et[2], et[3], et[4], et[5]), D._applyOpacity(this), D._applyGlobalCompositeOperation(this);
          }
          X && D._applyShadow(this), H.call(this, D, this);
        }
        return D.restore(), this;
      }
      drawHit(k, F, G = !1) {
        if (!this.shouldDrawHit(F, G))
          return this;
        const M = this.getLayer(), j = k || M.hitCanvas, D = j && j.getContext(), z = this.hitFunc() || this.sceneFunc(), H = this._getCanvasCache(), X = H && H.hit;
        if (this.colorKey || n.Util.warn("Looks like your canvas has a destroyed shape in it. Do not reuse shape after you destroyed it. If you want to reuse shape you should call remove() instead of destroy()"), X) {
          D.save();
          const V = this.getAbsoluteTransform(F).getMatrix();
          return D.transform(V[0], V[1], V[2], V[3], V[4], V[5]), this._drawCachedHitCanvas(D), D.restore(), this;
        }
        if (!z)
          return this;
        if (D.save(), D._applyLineJoin(this), !(this === F)) {
          const V = this.getAbsoluteTransform(F).getMatrix();
          D.transform(V[0], V[1], V[2], V[3], V[4], V[5]);
        }
        return z.call(this, D, this), D.restore(), this;
      }
      drawHitFromCache(k = 0) {
        const F = this._getCanvasCache(), G = this._getCachedSceneCanvas(), M = F.hit, j = M.getContext(), D = M.getWidth(), z = M.getHeight();
        j.clear(), j.drawImage(G._canvas, 0, 0, D, z);
        try {
          const H = j.getImageData(0, 0, D, z), X = H.data, Y = X.length, V = n.Util._hexToRgb(this.colorKey);
          for (let Z = 0; Z < Y; Z += 4)
            X[Z + 3] > k ? (X[Z] = V.r, X[Z + 1] = V.g, X[Z + 2] = V.b, X[Z + 3] = 255) : X[Z + 3] = 0;
          j.putImageData(H, 0, 0);
        } catch (H) {
          n.Util.error("Unable to draw hit graph from cached scene canvas. " + H.message);
        }
        return this;
      }
      hasPointerCapture(k) {
        return c.hasPointerCapture(k, this);
      }
      setPointerCapture(k) {
        c.setPointerCapture(k, this);
      }
      releaseCapture(k) {
        c.releaseCapture(k, this);
      }
    }
    e.Shape = N, N.prototype._fillFunc = b, N.prototype._strokeFunc = x, N.prototype._fillFuncHit = w, N.prototype._strokeFuncHit = T, N.prototype._centroid = !1, N.prototype.nodeType = "Shape", (0, l._registerNode)(N), N.prototype.eventListeners = {}, N.prototype.on.call(N.prototype, "shadowColorChange.konva shadowBlurChange.konva shadowOffsetChange.konva shadowOpacityChange.konva shadowEnabledChange.konva", S), N.prototype.on.call(N.prototype, "shadowColorChange.konva shadowOpacityChange.konva shadowEnabledChange.konva", C), N.prototype.on.call(N.prototype, "fillPriorityChange.konva fillPatternImageChange.konva fillPatternRepeatChange.konva fillPatternScaleXChange.konva fillPatternScaleYChange.konva fillPatternOffsetXChange.konva fillPatternOffsetYChange.konva fillPatternXChange.konva fillPatternYChange.konva fillPatternRotationChange.konva", E), N.prototype.on.call(N.prototype, "fillPriorityChange.konva fillLinearGradientColorStopsChange.konva fillLinearGradientStartPointXChange.konva fillLinearGradientStartPointYChange.konva fillLinearGradientEndPointXChange.konva fillLinearGradientEndPointYChange.konva", O), N.prototype.on.call(N.prototype, "fillPriorityChange.konva fillRadialGradientColorStopsChange.konva fillRadialGradientStartPointXChange.konva fillRadialGradientStartPointYChange.konva fillRadialGradientEndPointXChange.konva fillRadialGradientEndPointYChange.konva fillRadialGradientStartRadiusChange.konva fillRadialGradientEndRadiusChange.konva", B), r.Factory.addGetterSetter(N, "stroke", void 0, (0, s.getStringOrGradientValidator)()), r.Factory.addGetterSetter(N, "strokeWidth", 2, (0, s.getNumberValidator)()), r.Factory.addGetterSetter(N, "fillAfterStrokeEnabled", !1), r.Factory.addGetterSetter(N, "hitStrokeWidth", "auto", (0, s.getNumberOrAutoValidator)()), r.Factory.addGetterSetter(N, "strokeHitEnabled", !0, (0, s.getBooleanValidator)()), r.Factory.addGetterSetter(N, "perfectDrawEnabled", !0, (0, s.getBooleanValidator)()), r.Factory.addGetterSetter(N, "shadowForStrokeEnabled", !0, (0, s.getBooleanValidator)()), r.Factory.addGetterSetter(N, "lineJoin"), r.Factory.addGetterSetter(N, "lineCap"), r.Factory.addGetterSetter(N, "sceneFunc"), r.Factory.addGetterSetter(N, "hitFunc"), r.Factory.addGetterSetter(N, "dash"), r.Factory.addGetterSetter(N, "dashOffset", 0, (0, s.getNumberValidator)()), r.Factory.addGetterSetter(N, "shadowColor", void 0, (0, s.getStringValidator)()), r.Factory.addGetterSetter(N, "shadowBlur", 0, (0, s.getNumberValidator)()), r.Factory.addGetterSetter(N, "shadowOpacity", 1, (0, s.getNumberValidator)()), r.Factory.addComponentsGetterSetter(N, "shadowOffset", ["x", "y"]), r.Factory.addGetterSetter(N, "shadowOffsetX", 0, (0, s.getNumberValidator)()), r.Factory.addGetterSetter(N, "shadowOffsetY", 0, (0, s.getNumberValidator)()), r.Factory.addGetterSetter(N, "fillPatternImage"), r.Factory.addGetterSetter(N, "fill", void 0, (0, s.getStringOrGradientValidator)()), r.Factory.addGetterSetter(N, "fillPatternX", 0, (0, s.getNumberValidator)()), r.Factory.addGetterSetter(N, "fillPatternY", 0, (0, s.getNumberValidator)()), r.Factory.addGetterSetter(N, "fillLinearGradientColorStops"), r.Factory.addGetterSetter(N, "strokeLinearGradientColorStops"), r.Factory.addGetterSetter(N, "fillRadialGradientStartRadius", 0), r.Factory.addGetterSetter(N, "fillRadialGradientEndRadius", 0), r.Factory.addGetterSetter(N, "fillRadialGradientColorStops"), r.Factory.addGetterSetter(N, "fillPatternRepeat", "repeat"), r.Factory.addGetterSetter(N, "fillEnabled", !0), r.Factory.addGetterSetter(N, "strokeEnabled", !0), r.Factory.addGetterSetter(N, "shadowEnabled", !0), r.Factory.addGetterSetter(N, "dashEnabled", !0), r.Factory.addGetterSetter(N, "strokeScaleEnabled", !0), r.Factory.addGetterSetter(N, "fillPriority", "color"), r.Factory.addComponentsGetterSetter(N, "fillPatternOffset", ["x", "y"]), r.Factory.addGetterSetter(N, "fillPatternOffsetX", 0, (0, s.getNumberValidator)()), r.Factory.addGetterSetter(N, "fillPatternOffsetY", 0, (0, s.getNumberValidator)()), r.Factory.addComponentsGetterSetter(N, "fillPatternScale", ["x", "y"]), r.Factory.addGetterSetter(N, "fillPatternScaleX", 1, (0, s.getNumberValidator)()), r.Factory.addGetterSetter(N, "fillPatternScaleY", 1, (0, s.getNumberValidator)()), r.Factory.addComponentsGetterSetter(N, "fillLinearGradientStartPoint", [
      "x",
      "y"
    ]), r.Factory.addComponentsGetterSetter(N, "strokeLinearGradientStartPoint", [
      "x",
      "y"
    ]), r.Factory.addGetterSetter(N, "fillLinearGradientStartPointX", 0), r.Factory.addGetterSetter(N, "strokeLinearGradientStartPointX", 0), r.Factory.addGetterSetter(N, "fillLinearGradientStartPointY", 0), r.Factory.addGetterSetter(N, "strokeLinearGradientStartPointY", 0), r.Factory.addComponentsGetterSetter(N, "fillLinearGradientEndPoint", [
      "x",
      "y"
    ]), r.Factory.addComponentsGetterSetter(N, "strokeLinearGradientEndPoint", [
      "x",
      "y"
    ]), r.Factory.addGetterSetter(N, "fillLinearGradientEndPointX", 0), r.Factory.addGetterSetter(N, "strokeLinearGradientEndPointX", 0), r.Factory.addGetterSetter(N, "fillLinearGradientEndPointY", 0), r.Factory.addGetterSetter(N, "strokeLinearGradientEndPointY", 0), r.Factory.addComponentsGetterSetter(N, "fillRadialGradientStartPoint", [
      "x",
      "y"
    ]), r.Factory.addGetterSetter(N, "fillRadialGradientStartPointX", 0), r.Factory.addGetterSetter(N, "fillRadialGradientStartPointY", 0), r.Factory.addComponentsGetterSetter(N, "fillRadialGradientEndPoint", [
      "x",
      "y"
    ]), r.Factory.addGetterSetter(N, "fillRadialGradientEndPointX", 0), r.Factory.addGetterSetter(N, "fillRadialGradientEndPointY", 0), r.Factory.addGetterSetter(N, "fillPatternRotation", 0), r.Factory.addGetterSetter(N, "fillRule", void 0, (0, s.getStringValidator)()), r.Factory.backCompat(N, {
      dashArray: "dash",
      getDashArray: "getDash",
      setDashArray: "getDash",
      drawFunc: "sceneFunc",
      getDrawFunc: "getSceneFunc",
      setDrawFunc: "setSceneFunc",
      drawHitFunc: "hitFunc",
      getDrawHitFunc: "getHitFunc",
      setDrawHitFunc: "setHitFunc"
    });
  }(jg)), jg;
}
var F2;
function px() {
  if (F2) return sd;
  F2 = 1, Object.defineProperty(sd, "__esModule", { value: !0 }), sd.Layer = void 0;
  const e = Hn(), t = pm(), n = Xn(), r = We(), i = fm(), s = $e(), l = _r(), c = Fe(), u = "#", d = "beforeDraw", h = "draw", p = [
    { x: 0, y: 0 },
    { x: -1, y: -1 },
    { x: 1, y: -1 },
    { x: 1, y: 1 },
    { x: -1, y: 1 }
  ], v = p.length;
  class m extends t.Container {
    constructor(b) {
      super(b), this.canvas = new i.SceneCanvas(), this.hitCanvas = new i.HitCanvas({
        pixelRatio: 1
      }), this._waitingForDraw = !1, this.on("visibleChange.konva", this._checkVisibility), this._checkVisibility(), this.on("imageSmoothingEnabledChange.konva", this._setSmoothEnabled), this._setSmoothEnabled();
    }
    createPNGStream() {
      return this.canvas._canvas.createPNGStream();
    }
    getCanvas() {
      return this.canvas;
    }
    getNativeCanvasElement() {
      return this.canvas._canvas;
    }
    getHitCanvas() {
      return this.hitCanvas;
    }
    getContext() {
      return this.getCanvas().getContext();
    }
    clear(b) {
      return this.getContext().clear(b), this.getHitCanvas().getContext().clear(b), this;
    }
    setZIndex(b) {
      super.setZIndex(b);
      const x = this.getStage();
      return x && x.content && (x.content.removeChild(this.getNativeCanvasElement()), b < x.children.length - 1 ? x.content.insertBefore(this.getNativeCanvasElement(), x.children[b + 1].getCanvas()._canvas) : x.content.appendChild(this.getNativeCanvasElement())), this;
    }
    moveToTop() {
      n.Node.prototype.moveToTop.call(this);
      const b = this.getStage();
      return b && b.content && (b.content.removeChild(this.getNativeCanvasElement()), b.content.appendChild(this.getNativeCanvasElement())), !0;
    }
    moveUp() {
      if (!n.Node.prototype.moveUp.call(this))
        return !1;
      const x = this.getStage();
      return !x || !x.content ? !1 : (x.content.removeChild(this.getNativeCanvasElement()), this.index < x.children.length - 1 ? x.content.insertBefore(this.getNativeCanvasElement(), x.children[this.index + 1].getCanvas()._canvas) : x.content.appendChild(this.getNativeCanvasElement()), !0);
    }
    moveDown() {
      if (n.Node.prototype.moveDown.call(this)) {
        const b = this.getStage();
        if (b) {
          const x = b.children;
          b.content && (b.content.removeChild(this.getNativeCanvasElement()), b.content.insertBefore(this.getNativeCanvasElement(), x[this.index + 1].getCanvas()._canvas));
        }
        return !0;
      }
      return !1;
    }
    moveToBottom() {
      if (n.Node.prototype.moveToBottom.call(this)) {
        const b = this.getStage();
        if (b) {
          const x = b.children;
          b.content && (b.content.removeChild(this.getNativeCanvasElement()), b.content.insertBefore(this.getNativeCanvasElement(), x[1].getCanvas()._canvas));
        }
        return !0;
      }
      return !1;
    }
    getLayer() {
      return this;
    }
    remove() {
      const b = this.getNativeCanvasElement();
      return n.Node.prototype.remove.call(this), b && b.parentNode && e.Util._isInDocument(b) && b.parentNode.removeChild(b), this;
    }
    getStage() {
      return this.parent;
    }
    setSize({ width: b, height: x }) {
      return this.canvas.setSize(b, x), this.hitCanvas.setSize(b, x), this._setSmoothEnabled(), this;
    }
    _validateAdd(b) {
      const x = b.getType();
      x !== "Group" && x !== "Shape" && e.Util.throw("You may only add groups and shapes to a layer.");
    }
    _toKonvaCanvas(b) {
      return b = b || {}, b.width = b.width || this.getWidth(), b.height = b.height || this.getHeight(), b.x = b.x !== void 0 ? b.x : this.x(), b.y = b.y !== void 0 ? b.y : this.y(), n.Node.prototype._toKonvaCanvas.call(this, b);
    }
    _checkVisibility() {
      this.visible() ? this.canvas._canvas.style.display = "block" : this.canvas._canvas.style.display = "none";
    }
    _setSmoothEnabled() {
      this.getContext()._context.imageSmoothingEnabled = this.imageSmoothingEnabled();
    }
    getWidth() {
      if (this.parent)
        return this.parent.width();
    }
    setWidth() {
      e.Util.warn('Can not change width of layer. Use "stage.width(value)" function instead.');
    }
    getHeight() {
      if (this.parent)
        return this.parent.height();
    }
    setHeight() {
      e.Util.warn('Can not change height of layer. Use "stage.height(value)" function instead.');
    }
    batchDraw() {
      return this._waitingForDraw || (this._waitingForDraw = !0, e.Util.requestAnimFrame(() => {
        this.draw(), this._waitingForDraw = !1;
      })), this;
    }
    getIntersection(b) {
      if (!this.isListening() || !this.isVisible())
        return null;
      let x = 1, w = !1;
      for (; ; ) {
        for (let T = 0; T < v; T++) {
          const S = p[T], C = this._getIntersection({
            x: b.x + S.x * x,
            y: b.y + S.y * x
          }), E = C.shape;
          if (E)
            return E;
          if (w = !!C.antialiased, !C.antialiased)
            break;
        }
        if (w)
          x += 1;
        else
          return null;
      }
    }
    _getIntersection(b) {
      const x = this.hitCanvas.pixelRatio, w = this.hitCanvas.context.getImageData(Math.round(b.x * x), Math.round(b.y * x), 1, 1).data, T = w[3];
      if (T === 255) {
        const S = e.Util._rgbToHex(w[0], w[1], w[2]), C = l.shapes[u + S];
        return C ? {
          shape: C
        } : {
          antialiased: !0
        };
      } else if (T > 0)
        return {
          antialiased: !0
        };
      return {};
    }
    drawScene(b, x) {
      const w = this.getLayer(), T = b || w && w.getCanvas();
      return this._fire(d, {
        node: this
      }), this.clearBeforeDraw() && T.getContext().clear(), t.Container.prototype.drawScene.call(this, T, x), this._fire(h, {
        node: this
      }), this;
    }
    drawHit(b, x) {
      const w = this.getLayer(), T = b || w && w.hitCanvas;
      return w && w.clearBeforeDraw() && w.getHitCanvas().getContext().clear(), t.Container.prototype.drawHit.call(this, T, x), this;
    }
    enableHitGraph() {
      return this.hitGraphEnabled(!0), this;
    }
    disableHitGraph() {
      return this.hitGraphEnabled(!1), this;
    }
    setHitGraphEnabled(b) {
      e.Util.warn("hitGraphEnabled method is deprecated. Please use layer.listening() instead."), this.listening(b);
    }
    getHitGraphEnabled(b) {
      return e.Util.warn("hitGraphEnabled method is deprecated. Please use layer.listening() instead."), this.listening();
    }
    toggleHitCanvas() {
      if (!this.parent || !this.parent.content)
        return;
      const b = this.parent;
      !!this.hitCanvas._canvas.parentNode ? b.content.removeChild(this.hitCanvas._canvas) : b.content.appendChild(this.hitCanvas._canvas);
    }
    destroy() {
      return e.Util.releaseCanvas(this.getNativeCanvasElement(), this.getHitCanvas()._canvas), super.destroy();
    }
  }
  return sd.Layer = m, m.prototype.nodeType = "Layer", (0, c._registerNode)(m), r.Factory.addGetterSetter(m, "imageSmoothingEnabled", !0), r.Factory.addGetterSetter(m, "clearBeforeDraw", !0), r.Factory.addGetterSetter(m, "hitGraphEnabled", !0, (0, s.getBooleanValidator)()), sd;
}
var od = {}, j2;
function YP() {
  if (j2) return od;
  j2 = 1, Object.defineProperty(od, "__esModule", { value: !0 }), od.FastLayer = void 0;
  const e = Hn(), t = px(), n = Fe();
  let r = class extends t.Layer {
    constructor(s) {
      super(s), this.listening(!1), e.Util.warn('Konva.Fast layer is deprecated. Please use "new Konva.Layer({ listening: false })" instead.');
    }
  };
  return od.FastLayer = r, r.prototype.nodeType = "FastLayer", (0, n._registerNode)(r), od;
}
var ad = {}, L2;
function Jy() {
  if (L2) return ad;
  L2 = 1, Object.defineProperty(ad, "__esModule", { value: !0 }), ad.Group = void 0;
  const e = Hn(), t = pm(), n = Fe();
  class r extends t.Container {
    _validateAdd(s) {
      const l = s.getType();
      l !== "Group" && l !== "Shape" && e.Util.throw("You may only add groups and shapes to groups.");
    }
  }
  return ad.Group = r, r.prototype.nodeType = "Group", (0, n._registerNode)(r), ad;
}
var ld = {}, z2;
function t1() {
  if (z2) return ld;
  z2 = 1, Object.defineProperty(ld, "__esModule", { value: !0 }), ld.Animation = void 0;
  const e = Fe(), t = Hn(), n = function() {
    return e.glob.performance && e.glob.performance.now ? function() {
      return e.glob.performance.now();
    } : function() {
      return (/* @__PURE__ */ new Date()).getTime();
    };
  }();
  let r = class wc {
    constructor(s, l) {
      this.id = wc.animIdCounter++, this.frame = {
        time: 0,
        timeDiff: 0,
        lastTime: n(),
        frameRate: 0
      }, this.func = s, this.setLayers(l);
    }
    setLayers(s) {
      let l = [];
      return s && (l = Array.isArray(s) ? s : [s]), this.layers = l, this;
    }
    getLayers() {
      return this.layers;
    }
    addLayer(s) {
      const l = this.layers, c = l.length;
      for (let u = 0; u < c; u++)
        if (l[u]._id === s._id)
          return !1;
      return this.layers.push(s), !0;
    }
    isRunning() {
      const l = wc.animations, c = l.length;
      for (let u = 0; u < c; u++)
        if (l[u].id === this.id)
          return !0;
      return !1;
    }
    start() {
      return this.stop(), this.frame.timeDiff = 0, this.frame.lastTime = n(), wc._addAnimation(this), this;
    }
    stop() {
      return wc._removeAnimation(this), this;
    }
    _updateFrameObject(s) {
      this.frame.timeDiff = s - this.frame.lastTime, this.frame.lastTime = s, this.frame.time += this.frame.timeDiff, this.frame.frameRate = 1e3 / this.frame.timeDiff;
    }
    static _addAnimation(s) {
      this.animations.push(s), this._handleAnimation();
    }
    static _removeAnimation(s) {
      const l = s.id, c = this.animations, u = c.length;
      for (let d = 0; d < u; d++)
        if (c[d].id === l) {
          this.animations.splice(d, 1);
          break;
        }
    }
    static _runFrames() {
      const s = {}, l = this.animations;
      for (let c = 0; c < l.length; c++) {
        const u = l[c], d = u.layers, h = u.func;
        u._updateFrameObject(n());
        const p = d.length;
        let v;
        if (h ? v = h.call(u, u.frame) !== !1 : v = !0, !!v)
          for (let m = 0; m < p; m++) {
            const g = d[m];
            g._id !== void 0 && (s[g._id] = g);
          }
      }
      for (const c in s)
        s.hasOwnProperty(c) && s[c].batchDraw();
    }
    static _animationLoop() {
      const s = wc;
      s.animations.length ? (s._runFrames(), t.Util.requestAnimFrame(s._animationLoop)) : s.animRunning = !1;
    }
    static _handleAnimation() {
      this.animRunning || (this.animRunning = !0, t.Util.requestAnimFrame(this._animationLoop));
    }
  };
  return ld.Animation = r, r.animations = [], r.animIdCounter = 0, r.animRunning = !1, ld;
}
var Lg = {}, U2;
function XP() {
  return U2 || (U2 = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.Easings = e.Tween = void 0;
    const t = Hn(), n = t1(), r = Xn(), i = Fe(), s = {
      node: 1,
      duration: 1,
      easing: 1,
      onFinish: 1,
      yoyo: 1
    }, l = 1, c = 2, u = 3, d = ["fill", "stroke", "shadowColor"];
    let h = 0;
    class p {
      constructor(g, b, x, w, T, S, C) {
        this.prop = g, this.propFunc = b, this.begin = w, this._pos = w, this.duration = S, this._change = 0, this.prevPos = 0, this.yoyo = C, this._time = 0, this._position = 0, this._startTime = 0, this._finish = 0, this.func = x, this._change = T - this.begin, this.pause();
      }
      fire(g) {
        const b = this[g];
        b && b();
      }
      setTime(g) {
        g > this.duration ? this.yoyo ? (this._time = this.duration, this.reverse()) : this.finish() : g < 0 ? this.yoyo ? (this._time = 0, this.play()) : this.reset() : (this._time = g, this.update());
      }
      getTime() {
        return this._time;
      }
      setPosition(g) {
        this.prevPos = this._pos, this.propFunc(g), this._pos = g;
      }
      getPosition(g) {
        return g === void 0 && (g = this._time), this.func(g, this.begin, this._change, this.duration);
      }
      play() {
        this.state = c, this._startTime = this.getTimer() - this._time, this.onEnterFrame(), this.fire("onPlay");
      }
      reverse() {
        this.state = u, this._time = this.duration - this._time, this._startTime = this.getTimer() - this._time, this.onEnterFrame(), this.fire("onReverse");
      }
      seek(g) {
        this.pause(), this._time = g, this.update(), this.fire("onSeek");
      }
      reset() {
        this.pause(), this._time = 0, this.update(), this.fire("onReset");
      }
      finish() {
        this.pause(), this._time = this.duration, this.update(), this.fire("onFinish");
      }
      update() {
        this.setPosition(this.getPosition(this._time)), this.fire("onUpdate");
      }
      onEnterFrame() {
        const g = this.getTimer() - this._startTime;
        this.state === c ? this.setTime(g) : this.state === u && this.setTime(this.duration - g);
      }
      pause() {
        this.state = l, this.fire("onPause");
      }
      getTimer() {
        return (/* @__PURE__ */ new Date()).getTime();
      }
    }
    class v {
      constructor(g) {
        const b = this, x = g.node, w = x._id, T = g.easing || e.Easings.Linear, S = !!g.yoyo;
        let C, E;
        typeof g.duration > "u" ? C = 0.3 : g.duration === 0 ? C = 1e-3 : C = g.duration, this.node = x, this._id = h++;
        const O = x.getLayer() || (x instanceof i.Konva.Stage ? x.getLayers() : null);
        O || t.Util.error("Tween constructor have `node` that is not in a layer. Please add node into layer first."), this.anim = new n.Animation(function() {
          b.tween.onEnterFrame();
        }, O), this.tween = new p(E, function(B) {
          b._tweenFunc(B);
        }, T, 0, 1, C * 1e3, S), this._addListeners(), v.attrs[w] || (v.attrs[w] = {}), v.attrs[w][this._id] || (v.attrs[w][this._id] = {}), v.tweens[w] || (v.tweens[w] = {});
        for (E in g)
          s[E] === void 0 && this._addAttr(E, g[E]);
        this.reset(), this.onFinish = g.onFinish, this.onReset = g.onReset, this.onUpdate = g.onUpdate;
      }
      _addAttr(g, b) {
        const x = this.node, w = x._id;
        let T, S, C, E, O;
        const B = v.tweens[w][g];
        B && delete v.attrs[w][B][g];
        let N = x.getAttr(g);
        if (t.Util._isArray(b))
          if (T = [], S = Math.max(b.length, N.length), g === "points" && b.length !== N.length && (b.length > N.length ? (E = N, N = t.Util._prepareArrayForTween(N, b, x.closed())) : (C = b, b = t.Util._prepareArrayForTween(b, N, x.closed()))), g.indexOf("fill") === 0)
            for (let L = 0; L < S; L++)
              if (L % 2 === 0)
                T.push(b[L] - N[L]);
              else {
                const k = t.Util.colorToRGBA(N[L]);
                O = t.Util.colorToRGBA(b[L]), N[L] = k, T.push({
                  r: O.r - k.r,
                  g: O.g - k.g,
                  b: O.b - k.b,
                  a: O.a - k.a
                });
              }
          else
            for (let L = 0; L < S; L++)
              T.push(b[L] - N[L]);
        else d.indexOf(g) !== -1 ? (N = t.Util.colorToRGBA(N), O = t.Util.colorToRGBA(b), T = {
          r: O.r - N.r,
          g: O.g - N.g,
          b: O.b - N.b,
          a: O.a - N.a
        }) : T = b - N;
        v.attrs[w][this._id][g] = {
          start: N,
          diff: T,
          end: b,
          trueEnd: C,
          trueStart: E
        }, v.tweens[w][g] = this._id;
      }
      _tweenFunc(g) {
        const b = this.node, x = v.attrs[b._id][this._id];
        let w, T, S, C, E, O, B, N;
        for (w in x) {
          if (T = x[w], S = T.start, C = T.diff, N = T.end, t.Util._isArray(S))
            if (E = [], B = Math.max(S.length, N.length), w.indexOf("fill") === 0)
              for (O = 0; O < B; O++)
                O % 2 === 0 ? E.push((S[O] || 0) + C[O] * g) : E.push("rgba(" + Math.round(S[O].r + C[O].r * g) + "," + Math.round(S[O].g + C[O].g * g) + "," + Math.round(S[O].b + C[O].b * g) + "," + (S[O].a + C[O].a * g) + ")");
            else
              for (O = 0; O < B; O++)
                E.push((S[O] || 0) + C[O] * g);
          else d.indexOf(w) !== -1 ? E = "rgba(" + Math.round(S.r + C.r * g) + "," + Math.round(S.g + C.g * g) + "," + Math.round(S.b + C.b * g) + "," + (S.a + C.a * g) + ")" : E = S + C * g;
          b.setAttr(w, E);
        }
      }
      _addListeners() {
        this.tween.onPlay = () => {
          this.anim.start();
        }, this.tween.onReverse = () => {
          this.anim.start();
        }, this.tween.onPause = () => {
          this.anim.stop();
        }, this.tween.onFinish = () => {
          const g = this.node, b = v.attrs[g._id][this._id];
          b.points && b.points.trueEnd && g.setAttr("points", b.points.trueEnd), this.onFinish && this.onFinish.call(this);
        }, this.tween.onReset = () => {
          const g = this.node, b = v.attrs[g._id][this._id];
          b.points && b.points.trueStart && g.points(b.points.trueStart), this.onReset && this.onReset();
        }, this.tween.onUpdate = () => {
          this.onUpdate && this.onUpdate.call(this);
        };
      }
      play() {
        return this.tween.play(), this;
      }
      reverse() {
        return this.tween.reverse(), this;
      }
      reset() {
        return this.tween.reset(), this;
      }
      seek(g) {
        return this.tween.seek(g * 1e3), this;
      }
      pause() {
        return this.tween.pause(), this;
      }
      finish() {
        return this.tween.finish(), this;
      }
      destroy() {
        const g = this.node._id, b = this._id, x = v.tweens[g];
        this.pause();
        for (const w in x)
          delete v.tweens[g][w];
        delete v.attrs[g][b];
      }
    }
    e.Tween = v, v.attrs = {}, v.tweens = {}, r.Node.prototype.to = function(m) {
      const g = m.onFinish;
      m.node = this, m.onFinish = function() {
        this.destroy(), g && g();
      }, new v(m).play();
    }, e.Easings = {
      BackEaseIn(m, g, b, x) {
        return b * (m /= x) * m * ((1.70158 + 1) * m - 1.70158) + g;
      },
      BackEaseOut(m, g, b, x) {
        return b * ((m = m / x - 1) * m * ((1.70158 + 1) * m + 1.70158) + 1) + g;
      },
      BackEaseInOut(m, g, b, x) {
        let w = 1.70158;
        return (m /= x / 2) < 1 ? b / 2 * (m * m * (((w *= 1.525) + 1) * m - w)) + g : b / 2 * ((m -= 2) * m * (((w *= 1.525) + 1) * m + w) + 2) + g;
      },
      ElasticEaseIn(m, g, b, x, w, T) {
        let S = 0;
        return m === 0 ? g : (m /= x) === 1 ? g + b : (T || (T = x * 0.3), !w || w < Math.abs(b) ? (w = b, S = T / 4) : S = T / (2 * Math.PI) * Math.asin(b / w), -(w * Math.pow(2, 10 * (m -= 1)) * Math.sin((m * x - S) * (2 * Math.PI) / T)) + g);
      },
      ElasticEaseOut(m, g, b, x, w, T) {
        let S = 0;
        return m === 0 ? g : (m /= x) === 1 ? g + b : (T || (T = x * 0.3), !w || w < Math.abs(b) ? (w = b, S = T / 4) : S = T / (2 * Math.PI) * Math.asin(b / w), w * Math.pow(2, -10 * m) * Math.sin((m * x - S) * (2 * Math.PI) / T) + b + g);
      },
      ElasticEaseInOut(m, g, b, x, w, T) {
        let S = 0;
        return m === 0 ? g : (m /= x / 2) === 2 ? g + b : (T || (T = x * (0.3 * 1.5)), !w || w < Math.abs(b) ? (w = b, S = T / 4) : S = T / (2 * Math.PI) * Math.asin(b / w), m < 1 ? -0.5 * (w * Math.pow(2, 10 * (m -= 1)) * Math.sin((m * x - S) * (2 * Math.PI) / T)) + g : w * Math.pow(2, -10 * (m -= 1)) * Math.sin((m * x - S) * (2 * Math.PI) / T) * 0.5 + b + g);
      },
      BounceEaseOut(m, g, b, x) {
        return (m /= x) < 1 / 2.75 ? b * (7.5625 * m * m) + g : m < 2 / 2.75 ? b * (7.5625 * (m -= 1.5 / 2.75) * m + 0.75) + g : m < 2.5 / 2.75 ? b * (7.5625 * (m -= 2.25 / 2.75) * m + 0.9375) + g : b * (7.5625 * (m -= 2.625 / 2.75) * m + 0.984375) + g;
      },
      BounceEaseIn(m, g, b, x) {
        return b - e.Easings.BounceEaseOut(x - m, 0, b, x) + g;
      },
      BounceEaseInOut(m, g, b, x) {
        return m < x / 2 ? e.Easings.BounceEaseIn(m * 2, 0, b, x) * 0.5 + g : e.Easings.BounceEaseOut(m * 2 - x, 0, b, x) * 0.5 + b * 0.5 + g;
      },
      EaseIn(m, g, b, x) {
        return b * (m /= x) * m + g;
      },
      EaseOut(m, g, b, x) {
        return -b * (m /= x) * (m - 2) + g;
      },
      EaseInOut(m, g, b, x) {
        return (m /= x / 2) < 1 ? b / 2 * m * m + g : -b / 2 * (--m * (m - 2) - 1) + g;
      },
      StrongEaseIn(m, g, b, x) {
        return b * (m /= x) * m * m * m * m + g;
      },
      StrongEaseOut(m, g, b, x) {
        return b * ((m = m / x - 1) * m * m * m * m + 1) + g;
      },
      StrongEaseInOut(m, g, b, x) {
        return (m /= x / 2) < 1 ? b / 2 * m * m * m * m * m + g : b / 2 * ((m -= 2) * m * m * m * m + 2) + g;
      },
      Linear(m, g, b, x) {
        return b * m / x + g;
      }
    };
  }(Lg)), Lg;
}
var V2;
function M0() {
  return V2 || (V2 = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.Konva = void 0;
    const t = Fe(), n = Hn(), r = Xn(), i = pm(), s = KP(), l = px(), c = YP(), u = Jy(), d = Zy(), h = _r(), p = t1(), v = XP(), m = hx(), g = fm();
    e.Konva = n.Util._assign(t.Konva, {
      Util: n.Util,
      Transform: n.Transform,
      Node: r.Node,
      Container: i.Container,
      Stage: s.Stage,
      stages: s.stages,
      Layer: l.Layer,
      FastLayer: c.FastLayer,
      Group: u.Group,
      DD: d.DD,
      Shape: h.Shape,
      shapes: h.shapes,
      Animation: p.Animation,
      Tween: v.Tween,
      Easings: v.Easings,
      Context: m.Context,
      Canvas: g.Canvas
    }), e.default = e.Konva;
  }(Ng)), Ng;
}
var cd = {}, G2;
function QP() {
  if (G2) return cd;
  G2 = 1, Object.defineProperty(cd, "__esModule", { value: !0 }), cd.Arc = void 0;
  const e = We(), t = _r(), n = Fe(), r = $e(), i = Fe();
  let s = class extends t.Shape {
    _sceneFunc(c) {
      const u = n.Konva.getAngle(this.angle()), d = this.clockwise();
      c.beginPath(), c.arc(0, 0, this.outerRadius(), 0, u, d), c.arc(0, 0, this.innerRadius(), u, 0, !d), c.closePath(), c.fillStrokeShape(this);
    }
    getWidth() {
      return this.outerRadius() * 2;
    }
    getHeight() {
      return this.outerRadius() * 2;
    }
    setWidth(c) {
      this.outerRadius(c / 2);
    }
    setHeight(c) {
      this.outerRadius(c / 2);
    }
    getSelfRect() {
      const c = this.innerRadius(), u = this.outerRadius(), d = this.clockwise(), h = n.Konva.getAngle(d ? 360 - this.angle() : this.angle()), p = Math.cos(Math.min(h, Math.PI)), v = 1, m = Math.sin(Math.min(Math.max(Math.PI, h), 3 * Math.PI / 2)), g = Math.sin(Math.min(h, Math.PI / 2)), b = p * (p > 0 ? c : u), x = v * u, w = m * (m > 0 ? c : u), T = g * (g > 0 ? u : c);
      return {
        x: b,
        y: d ? -1 * T : w,
        width: x - b,
        height: T - w
      };
    }
  };
  return cd.Arc = s, s.prototype._centroid = !0, s.prototype.className = "Arc", s.prototype._attrsAffectingSize = [
    "innerRadius",
    "outerRadius",
    "angle",
    "clockwise"
  ], (0, i._registerNode)(s), e.Factory.addGetterSetter(s, "innerRadius", 0, (0, r.getNumberValidator)()), e.Factory.addGetterSetter(s, "outerRadius", 0, (0, r.getNumberValidator)()), e.Factory.addGetterSetter(s, "angle", 0, (0, r.getNumberValidator)()), e.Factory.addGetterSetter(s, "clockwise", !1, (0, r.getBooleanValidator)()), cd;
}
var ud = {}, dd = {}, q2;
function mx() {
  if (q2) return dd;
  q2 = 1, Object.defineProperty(dd, "__esModule", { value: !0 }), dd.Line = void 0;
  const e = We(), t = Fe(), n = _r(), r = $e();
  function i(c, u, d, h, p, v, m) {
    const g = Math.sqrt(Math.pow(d - c, 2) + Math.pow(h - u, 2)), b = Math.sqrt(Math.pow(p - d, 2) + Math.pow(v - h, 2)), x = m * g / (g + b), w = m * b / (g + b), T = d - x * (p - c), S = h - x * (v - u), C = d + w * (p - c), E = h + w * (v - u);
    return [T, S, C, E];
  }
  function s(c, u) {
    const d = c.length, h = [];
    for (let p = 2; p < d - 2; p += 2) {
      const v = i(c[p - 2], c[p - 1], c[p], c[p + 1], c[p + 2], c[p + 3], u);
      isNaN(v[0]) || (h.push(v[0]), h.push(v[1]), h.push(c[p]), h.push(c[p + 1]), h.push(v[2]), h.push(v[3]));
    }
    return h;
  }
  class l extends n.Shape {
    constructor(u) {
      super(u), this.on("pointsChange.konva tensionChange.konva closedChange.konva bezierChange.konva", function() {
        this._clearCache("tensionPoints");
      });
    }
    _sceneFunc(u) {
      let d = this.points(), h = d.length, p = this.tension(), v = this.closed(), m = this.bezier(), g, b, x;
      if (h) {
        if (u.beginPath(), u.moveTo(d[0], d[1]), p !== 0 && h > 4) {
          for (g = this.getTensionPoints(), b = g.length, x = v ? 0 : 4, v || u.quadraticCurveTo(g[0], g[1], g[2], g[3]); x < b - 2; )
            u.bezierCurveTo(g[x++], g[x++], g[x++], g[x++], g[x++], g[x++]);
          v || u.quadraticCurveTo(g[b - 2], g[b - 1], d[h - 2], d[h - 1]);
        } else if (m)
          for (x = 2; x < h; )
            u.bezierCurveTo(d[x++], d[x++], d[x++], d[x++], d[x++], d[x++]);
        else
          for (x = 2; x < h; x += 2)
            u.lineTo(d[x], d[x + 1]);
        v ? (u.closePath(), u.fillStrokeShape(this)) : u.strokeShape(this);
      }
    }
    getTensionPoints() {
      return this._getCache("tensionPoints", this._getTensionPoints);
    }
    _getTensionPoints() {
      return this.closed() ? this._getTensionPointsClosed() : s(this.points(), this.tension());
    }
    _getTensionPointsClosed() {
      const u = this.points(), d = u.length, h = this.tension(), p = i(u[d - 2], u[d - 1], u[0], u[1], u[2], u[3], h), v = i(u[d - 4], u[d - 3], u[d - 2], u[d - 1], u[0], u[1], h), m = s(u, h);
      return [p[2], p[3]].concat(m).concat([
        v[0],
        v[1],
        u[d - 2],
        u[d - 1],
        v[2],
        v[3],
        p[0],
        p[1],
        u[0],
        u[1]
      ]);
    }
    getWidth() {
      return this.getSelfRect().width;
    }
    getHeight() {
      return this.getSelfRect().height;
    }
    getSelfRect() {
      let u = this.points();
      if (u.length < 4)
        return {
          x: u[0] || 0,
          y: u[1] || 0,
          width: 0,
          height: 0
        };
      this.tension() !== 0 ? u = [
        u[0],
        u[1],
        ...this._getTensionPoints(),
        u[u.length - 2],
        u[u.length - 1]
      ] : u = this.points();
      let d = u[0], h = u[0], p = u[1], v = u[1], m, g;
      for (let b = 0; b < u.length / 2; b++)
        m = u[b * 2], g = u[b * 2 + 1], d = Math.min(d, m), h = Math.max(h, m), p = Math.min(p, g), v = Math.max(v, g);
      return {
        x: d,
        y: p,
        width: h - d,
        height: v - p
      };
    }
  }
  return dd.Line = l, l.prototype.className = "Line", l.prototype._attrsAffectingSize = ["points", "bezier", "tension"], (0, t._registerNode)(l), e.Factory.addGetterSetter(l, "closed", !1), e.Factory.addGetterSetter(l, "bezier", !1), e.Factory.addGetterSetter(l, "tension", 0, (0, r.getNumberValidator)()), e.Factory.addGetterSetter(l, "points", [], (0, r.getNumberArrayValidator)()), dd;
}
var hd = {}, zg = {}, H2;
function ZP() {
  return H2 || (H2 = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.t2length = e.getQuadraticArcLength = e.getCubicArcLength = e.binomialCoefficients = e.cValues = e.tValues = void 0, e.tValues = [
      [],
      [],
      [
        -0.5773502691896257,
        0.5773502691896257
      ],
      [
        0,
        -0.7745966692414834,
        0.7745966692414834
      ],
      [
        -0.33998104358485626,
        0.33998104358485626,
        -0.8611363115940526,
        0.8611363115940526
      ],
      [
        0,
        -0.5384693101056831,
        0.5384693101056831,
        -0.906179845938664,
        0.906179845938664
      ],
      [
        0.6612093864662645,
        -0.6612093864662645,
        -0.2386191860831969,
        0.2386191860831969,
        -0.932469514203152,
        0.932469514203152
      ],
      [
        0,
        0.4058451513773972,
        -0.4058451513773972,
        -0.7415311855993945,
        0.7415311855993945,
        -0.9491079123427585,
        0.9491079123427585
      ],
      [
        -0.1834346424956498,
        0.1834346424956498,
        -0.525532409916329,
        0.525532409916329,
        -0.7966664774136267,
        0.7966664774136267,
        -0.9602898564975363,
        0.9602898564975363
      ],
      [
        0,
        -0.8360311073266358,
        0.8360311073266358,
        -0.9681602395076261,
        0.9681602395076261,
        -0.3242534234038089,
        0.3242534234038089,
        -0.6133714327005904,
        0.6133714327005904
      ],
      [
        -0.14887433898163122,
        0.14887433898163122,
        -0.4333953941292472,
        0.4333953941292472,
        -0.6794095682990244,
        0.6794095682990244,
        -0.8650633666889845,
        0.8650633666889845,
        -0.9739065285171717,
        0.9739065285171717
      ],
      [
        0,
        -0.26954315595234496,
        0.26954315595234496,
        -0.5190961292068118,
        0.5190961292068118,
        -0.7301520055740494,
        0.7301520055740494,
        -0.8870625997680953,
        0.8870625997680953,
        -0.978228658146057,
        0.978228658146057
      ],
      [
        -0.1252334085114689,
        0.1252334085114689,
        -0.3678314989981802,
        0.3678314989981802,
        -0.5873179542866175,
        0.5873179542866175,
        -0.7699026741943047,
        0.7699026741943047,
        -0.9041172563704749,
        0.9041172563704749,
        -0.9815606342467192,
        0.9815606342467192
      ],
      [
        0,
        -0.2304583159551348,
        0.2304583159551348,
        -0.44849275103644687,
        0.44849275103644687,
        -0.6423493394403402,
        0.6423493394403402,
        -0.8015780907333099,
        0.8015780907333099,
        -0.9175983992229779,
        0.9175983992229779,
        -0.9841830547185881,
        0.9841830547185881
      ],
      [
        -0.10805494870734367,
        0.10805494870734367,
        -0.31911236892788974,
        0.31911236892788974,
        -0.5152486363581541,
        0.5152486363581541,
        -0.6872929048116855,
        0.6872929048116855,
        -0.827201315069765,
        0.827201315069765,
        -0.9284348836635735,
        0.9284348836635735,
        -0.9862838086968123,
        0.9862838086968123
      ],
      [
        0,
        -0.20119409399743451,
        0.20119409399743451,
        -0.3941513470775634,
        0.3941513470775634,
        -0.5709721726085388,
        0.5709721726085388,
        -0.7244177313601701,
        0.7244177313601701,
        -0.8482065834104272,
        0.8482065834104272,
        -0.937273392400706,
        0.937273392400706,
        -0.9879925180204854,
        0.9879925180204854
      ],
      [
        -0.09501250983763744,
        0.09501250983763744,
        -0.2816035507792589,
        0.2816035507792589,
        -0.45801677765722737,
        0.45801677765722737,
        -0.6178762444026438,
        0.6178762444026438,
        -0.755404408355003,
        0.755404408355003,
        -0.8656312023878318,
        0.8656312023878318,
        -0.9445750230732326,
        0.9445750230732326,
        -0.9894009349916499,
        0.9894009349916499
      ],
      [
        0,
        -0.17848418149584785,
        0.17848418149584785,
        -0.3512317634538763,
        0.3512317634538763,
        -0.5126905370864769,
        0.5126905370864769,
        -0.6576711592166907,
        0.6576711592166907,
        -0.7815140038968014,
        0.7815140038968014,
        -0.8802391537269859,
        0.8802391537269859,
        -0.9506755217687678,
        0.9506755217687678,
        -0.9905754753144174,
        0.9905754753144174
      ],
      [
        -0.0847750130417353,
        0.0847750130417353,
        -0.2518862256915055,
        0.2518862256915055,
        -0.41175116146284263,
        0.41175116146284263,
        -0.5597708310739475,
        0.5597708310739475,
        -0.6916870430603532,
        0.6916870430603532,
        -0.8037049589725231,
        0.8037049589725231,
        -0.8926024664975557,
        0.8926024664975557,
        -0.9558239495713977,
        0.9558239495713977,
        -0.9915651684209309,
        0.9915651684209309
      ],
      [
        0,
        -0.16035864564022537,
        0.16035864564022537,
        -0.31656409996362983,
        0.31656409996362983,
        -0.46457074137596094,
        0.46457074137596094,
        -0.600545304661681,
        0.600545304661681,
        -0.7209661773352294,
        0.7209661773352294,
        -0.8227146565371428,
        0.8227146565371428,
        -0.9031559036148179,
        0.9031559036148179,
        -0.96020815213483,
        0.96020815213483,
        -0.9924068438435844,
        0.9924068438435844
      ],
      [
        -0.07652652113349734,
        0.07652652113349734,
        -0.22778585114164507,
        0.22778585114164507,
        -0.37370608871541955,
        0.37370608871541955,
        -0.5108670019508271,
        0.5108670019508271,
        -0.636053680726515,
        0.636053680726515,
        -0.7463319064601508,
        0.7463319064601508,
        -0.8391169718222188,
        0.8391169718222188,
        -0.912234428251326,
        0.912234428251326,
        -0.9639719272779138,
        0.9639719272779138,
        -0.9931285991850949,
        0.9931285991850949
      ],
      [
        0,
        -0.1455618541608951,
        0.1455618541608951,
        -0.2880213168024011,
        0.2880213168024011,
        -0.4243421202074388,
        0.4243421202074388,
        -0.5516188358872198,
        0.5516188358872198,
        -0.6671388041974123,
        0.6671388041974123,
        -0.7684399634756779,
        0.7684399634756779,
        -0.8533633645833173,
        0.8533633645833173,
        -0.9200993341504008,
        0.9200993341504008,
        -0.9672268385663063,
        0.9672268385663063,
        -0.9937521706203895,
        0.9937521706203895
      ],
      [
        -0.06973927331972223,
        0.06973927331972223,
        -0.20786042668822127,
        0.20786042668822127,
        -0.34193582089208424,
        0.34193582089208424,
        -0.469355837986757,
        0.469355837986757,
        -0.5876404035069116,
        0.5876404035069116,
        -0.6944872631866827,
        0.6944872631866827,
        -0.7878168059792081,
        0.7878168059792081,
        -0.8658125777203002,
        0.8658125777203002,
        -0.926956772187174,
        0.926956772187174,
        -0.9700604978354287,
        0.9700604978354287,
        -0.9942945854823992,
        0.9942945854823992
      ],
      [
        0,
        -0.1332568242984661,
        0.1332568242984661,
        -0.26413568097034495,
        0.26413568097034495,
        -0.3903010380302908,
        0.3903010380302908,
        -0.5095014778460075,
        0.5095014778460075,
        -0.6196098757636461,
        0.6196098757636461,
        -0.7186613631319502,
        0.7186613631319502,
        -0.8048884016188399,
        0.8048884016188399,
        -0.8767523582704416,
        0.8767523582704416,
        -0.9329710868260161,
        0.9329710868260161,
        -0.9725424712181152,
        0.9725424712181152,
        -0.9947693349975522,
        0.9947693349975522
      ],
      [
        -0.06405689286260563,
        0.06405689286260563,
        -0.1911188674736163,
        0.1911188674736163,
        -0.3150426796961634,
        0.3150426796961634,
        -0.4337935076260451,
        0.4337935076260451,
        -0.5454214713888396,
        0.5454214713888396,
        -0.6480936519369755,
        0.6480936519369755,
        -0.7401241915785544,
        0.7401241915785544,
        -0.820001985973903,
        0.820001985973903,
        -0.8864155270044011,
        0.8864155270044011,
        -0.9382745520027328,
        0.9382745520027328,
        -0.9747285559713095,
        0.9747285559713095,
        -0.9951872199970213,
        0.9951872199970213
      ]
    ], e.cValues = [
      [],
      [],
      [1, 1],
      [
        0.8888888888888888,
        0.5555555555555556,
        0.5555555555555556
      ],
      [
        0.6521451548625461,
        0.6521451548625461,
        0.34785484513745385,
        0.34785484513745385
      ],
      [
        0.5688888888888889,
        0.47862867049936647,
        0.47862867049936647,
        0.23692688505618908,
        0.23692688505618908
      ],
      [
        0.3607615730481386,
        0.3607615730481386,
        0.46791393457269104,
        0.46791393457269104,
        0.17132449237917036,
        0.17132449237917036
      ],
      [
        0.4179591836734694,
        0.3818300505051189,
        0.3818300505051189,
        0.27970539148927664,
        0.27970539148927664,
        0.1294849661688697,
        0.1294849661688697
      ],
      [
        0.362683783378362,
        0.362683783378362,
        0.31370664587788727,
        0.31370664587788727,
        0.22238103445337448,
        0.22238103445337448,
        0.10122853629037626,
        0.10122853629037626
      ],
      [
        0.3302393550012598,
        0.1806481606948574,
        0.1806481606948574,
        0.08127438836157441,
        0.08127438836157441,
        0.31234707704000286,
        0.31234707704000286,
        0.26061069640293544,
        0.26061069640293544
      ],
      [
        0.29552422471475287,
        0.29552422471475287,
        0.26926671930999635,
        0.26926671930999635,
        0.21908636251598204,
        0.21908636251598204,
        0.1494513491505806,
        0.1494513491505806,
        0.06667134430868814,
        0.06667134430868814
      ],
      [
        0.2729250867779006,
        0.26280454451024665,
        0.26280454451024665,
        0.23319376459199048,
        0.23319376459199048,
        0.18629021092773426,
        0.18629021092773426,
        0.1255803694649046,
        0.1255803694649046,
        0.05566856711617366,
        0.05566856711617366
      ],
      [
        0.24914704581340277,
        0.24914704581340277,
        0.2334925365383548,
        0.2334925365383548,
        0.20316742672306592,
        0.20316742672306592,
        0.16007832854334622,
        0.16007832854334622,
        0.10693932599531843,
        0.10693932599531843,
        0.04717533638651183,
        0.04717533638651183
      ],
      [
        0.2325515532308739,
        0.22628318026289723,
        0.22628318026289723,
        0.2078160475368885,
        0.2078160475368885,
        0.17814598076194574,
        0.17814598076194574,
        0.13887351021978725,
        0.13887351021978725,
        0.09212149983772845,
        0.09212149983772845,
        0.04048400476531588,
        0.04048400476531588
      ],
      [
        0.2152638534631578,
        0.2152638534631578,
        0.2051984637212956,
        0.2051984637212956,
        0.18553839747793782,
        0.18553839747793782,
        0.15720316715819355,
        0.15720316715819355,
        0.12151857068790319,
        0.12151857068790319,
        0.08015808715976021,
        0.08015808715976021,
        0.03511946033175186,
        0.03511946033175186
      ],
      [
        0.2025782419255613,
        0.19843148532711158,
        0.19843148532711158,
        0.1861610000155622,
        0.1861610000155622,
        0.16626920581699392,
        0.16626920581699392,
        0.13957067792615432,
        0.13957067792615432,
        0.10715922046717194,
        0.10715922046717194,
        0.07036604748810812,
        0.07036604748810812,
        0.03075324199611727,
        0.03075324199611727
      ],
      [
        0.1894506104550685,
        0.1894506104550685,
        0.18260341504492358,
        0.18260341504492358,
        0.16915651939500254,
        0.16915651939500254,
        0.14959598881657674,
        0.14959598881657674,
        0.12462897125553388,
        0.12462897125553388,
        0.09515851168249279,
        0.09515851168249279,
        0.062253523938647894,
        0.062253523938647894,
        0.027152459411754096,
        0.027152459411754096
      ],
      [
        0.17944647035620653,
        0.17656270536699264,
        0.17656270536699264,
        0.16800410215645004,
        0.16800410215645004,
        0.15404576107681028,
        0.15404576107681028,
        0.13513636846852548,
        0.13513636846852548,
        0.11188384719340397,
        0.11188384719340397,
        0.08503614831717918,
        0.08503614831717918,
        0.0554595293739872,
        0.0554595293739872,
        0.02414830286854793,
        0.02414830286854793
      ],
      [
        0.1691423829631436,
        0.1691423829631436,
        0.16427648374583273,
        0.16427648374583273,
        0.15468467512626524,
        0.15468467512626524,
        0.14064291467065065,
        0.14064291467065065,
        0.12255520671147846,
        0.12255520671147846,
        0.10094204410628717,
        0.10094204410628717,
        0.07642573025488905,
        0.07642573025488905,
        0.0497145488949698,
        0.0497145488949698,
        0.02161601352648331,
        0.02161601352648331
      ],
      [
        0.1610544498487837,
        0.15896884339395434,
        0.15896884339395434,
        0.15276604206585967,
        0.15276604206585967,
        0.1426067021736066,
        0.1426067021736066,
        0.12875396253933621,
        0.12875396253933621,
        0.11156664554733399,
        0.11156664554733399,
        0.09149002162245,
        0.09149002162245,
        0.06904454273764123,
        0.06904454273764123,
        0.0448142267656996,
        0.0448142267656996,
        0.019461788229726478,
        0.019461788229726478
      ],
      [
        0.15275338713072584,
        0.15275338713072584,
        0.14917298647260374,
        0.14917298647260374,
        0.14209610931838204,
        0.14209610931838204,
        0.13168863844917664,
        0.13168863844917664,
        0.11819453196151841,
        0.11819453196151841,
        0.10193011981724044,
        0.10193011981724044,
        0.08327674157670475,
        0.08327674157670475,
        0.06267204833410907,
        0.06267204833410907,
        0.04060142980038694,
        0.04060142980038694,
        0.017614007139152118,
        0.017614007139152118
      ],
      [
        0.14608113364969041,
        0.14452440398997005,
        0.14452440398997005,
        0.13988739479107315,
        0.13988739479107315,
        0.13226893863333747,
        0.13226893863333747,
        0.12183141605372853,
        0.12183141605372853,
        0.10879729916714838,
        0.10879729916714838,
        0.09344442345603386,
        0.09344442345603386,
        0.0761001136283793,
        0.0761001136283793,
        0.057134425426857205,
        0.057134425426857205,
        0.036953789770852494,
        0.036953789770852494,
        0.016017228257774335,
        0.016017228257774335
      ],
      [
        0.13925187285563198,
        0.13925187285563198,
        0.13654149834601517,
        0.13654149834601517,
        0.13117350478706238,
        0.13117350478706238,
        0.12325237681051242,
        0.12325237681051242,
        0.11293229608053922,
        0.11293229608053922,
        0.10041414444288096,
        0.10041414444288096,
        0.08594160621706773,
        0.08594160621706773,
        0.06979646842452049,
        0.06979646842452049,
        0.052293335152683286,
        0.052293335152683286,
        0.03377490158481415,
        0.03377490158481415,
        0.0146279952982722,
        0.0146279952982722
      ],
      [
        0.13365457218610619,
        0.1324620394046966,
        0.1324620394046966,
        0.12890572218808216,
        0.12890572218808216,
        0.12304908430672953,
        0.12304908430672953,
        0.11499664022241136,
        0.11499664022241136,
        0.10489209146454141,
        0.10489209146454141,
        0.09291576606003515,
        0.09291576606003515,
        0.07928141177671895,
        0.07928141177671895,
        0.06423242140852585,
        0.06423242140852585,
        0.04803767173108467,
        0.04803767173108467,
        0.030988005856979445,
        0.030988005856979445,
        0.013411859487141771,
        0.013411859487141771
      ],
      [
        0.12793819534675216,
        0.12793819534675216,
        0.1258374563468283,
        0.1258374563468283,
        0.12167047292780339,
        0.12167047292780339,
        0.1155056680537256,
        0.1155056680537256,
        0.10744427011596563,
        0.10744427011596563,
        0.09761865210411388,
        0.09761865210411388,
        0.08619016153195327,
        0.08619016153195327,
        0.0733464814110803,
        0.0733464814110803,
        0.05929858491543678,
        0.05929858491543678,
        0.04427743881741981,
        0.04427743881741981,
        0.028531388628933663,
        0.028531388628933663,
        0.0123412297999872,
        0.0123412297999872
      ]
    ], e.binomialCoefficients = [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1]];
    const t = (l, c, u) => {
      let d, h;
      const v = u / 2;
      d = 0;
      for (let m = 0; m < 20; m++)
        h = v * e.tValues[20][m] + v, d += e.cValues[20][m] * r(l, c, h);
      return v * d;
    };
    e.getCubicArcLength = t;
    const n = (l, c, u) => {
      u === void 0 && (u = 1);
      const d = l[0] - 2 * l[1] + l[2], h = c[0] - 2 * c[1] + c[2], p = 2 * l[1] - 2 * l[0], v = 2 * c[1] - 2 * c[0], m = 4 * (d * d + h * h), g = 4 * (d * p + h * v), b = p * p + v * v;
      if (m === 0)
        return u * Math.sqrt(Math.pow(l[2] - l[0], 2) + Math.pow(c[2] - c[0], 2));
      const x = g / (2 * m), w = b / m, T = u + x, S = w - x * x, C = T * T + S > 0 ? Math.sqrt(T * T + S) : 0, E = x * x + S > 0 ? Math.sqrt(x * x + S) : 0, O = x + Math.sqrt(x * x + S) !== 0 ? S * Math.log(Math.abs((T + C) / (x + E))) : 0;
      return Math.sqrt(m) / 2 * (T * C - x * E + O);
    };
    e.getQuadraticArcLength = n;
    function r(l, c, u) {
      const d = i(1, u, l), h = i(1, u, c), p = d * d + h * h;
      return Math.sqrt(p);
    }
    const i = (l, c, u) => {
      const d = u.length - 1;
      let h, p;
      if (d === 0)
        return 0;
      if (l === 0) {
        p = 0;
        for (let v = 0; v <= d; v++)
          p += e.binomialCoefficients[d][v] * Math.pow(1 - c, d - v) * Math.pow(c, v) * u[v];
        return p;
      } else {
        h = new Array(d);
        for (let v = 0; v < d; v++)
          h[v] = d * (u[v + 1] - u[v]);
        return i(l - 1, c, h);
      }
    }, s = (l, c, u) => {
      let d = 1, h = l / c, p = (l - u(h)) / c, v = 0;
      for (; d > 1e-3; ) {
        const m = u(h + p), g = Math.abs(l - m) / c;
        if (g < d)
          d = g, h += p;
        else {
          const b = u(h - p), x = Math.abs(l - b) / c;
          x < d ? (d = x, h -= p) : p /= 2;
        }
        if (v++, v > 500)
          break;
      }
      return h;
    };
    e.t2length = s;
  }(zg)), zg;
}
var W2;
function e1() {
  if (W2) return hd;
  W2 = 1, Object.defineProperty(hd, "__esModule", { value: !0 }), hd.Path = void 0;
  const e = We(), t = _r(), n = Fe(), r = ZP();
  let i = class ti extends t.Shape {
    constructor(l) {
      super(l), this.dataArray = [], this.pathLength = 0, this._readDataAttribute(), this.on("dataChange.konva", function() {
        this._readDataAttribute();
      });
    }
    _readDataAttribute() {
      this.dataArray = ti.parsePathData(this.data()), this.pathLength = ti.getPathLength(this.dataArray);
    }
    _sceneFunc(l) {
      const c = this.dataArray;
      l.beginPath();
      let u = !1;
      for (let C = 0; C < c.length; C++) {
        const E = c[C].command, O = c[C].points;
        switch (E) {
          case "L":
            l.lineTo(O[0], O[1]);
            break;
          case "M":
            l.moveTo(O[0], O[1]);
            break;
          case "C":
            l.bezierCurveTo(O[0], O[1], O[2], O[3], O[4], O[5]);
            break;
          case "Q":
            l.quadraticCurveTo(O[0], O[1], O[2], O[3]);
            break;
          case "A":
            var d = O[0], h = O[1], p = O[2], v = O[3], m = O[4], g = O[5], b = O[6], x = O[7], w = p > v ? p : v, T = p > v ? 1 : p / v, S = p > v ? v / p : 1;
            l.translate(d, h), l.rotate(b), l.scale(T, S), l.arc(0, 0, w, m, m + g, 1 - x), l.scale(1 / T, 1 / S), l.rotate(-b), l.translate(-d, -h);
            break;
          case "z":
            u = !0, l.closePath();
            break;
        }
      }
      !u && !this.hasFill() ? l.strokeShape(this) : l.fillStrokeShape(this);
    }
    getSelfRect() {
      let l = [];
      this.dataArray.forEach(function(m) {
        if (m.command === "A") {
          const g = m.points[4], b = m.points[5], x = m.points[4] + b;
          let w = Math.PI / 180;
          if (Math.abs(g - x) < w && (w = Math.abs(g - x)), b < 0)
            for (let T = g - w; T > x; T -= w) {
              const S = ti.getPointOnEllipticalArc(m.points[0], m.points[1], m.points[2], m.points[3], T, 0);
              l.push(S.x, S.y);
            }
          else
            for (let T = g + w; T < x; T += w) {
              const S = ti.getPointOnEllipticalArc(m.points[0], m.points[1], m.points[2], m.points[3], T, 0);
              l.push(S.x, S.y);
            }
        } else if (m.command === "C")
          for (let g = 0; g <= 1; g += 0.01) {
            const b = ti.getPointOnCubicBezier(g, m.start.x, m.start.y, m.points[0], m.points[1], m.points[2], m.points[3], m.points[4], m.points[5]);
            l.push(b.x, b.y);
          }
        else
          l = l.concat(m.points);
      });
      let c = l[0], u = l[0], d = l[1], h = l[1], p, v;
      for (let m = 0; m < l.length / 2; m++)
        p = l[m * 2], v = l[m * 2 + 1], isNaN(p) || (c = Math.min(c, p), u = Math.max(u, p)), isNaN(v) || (d = Math.min(d, v), h = Math.max(h, v));
      return {
        x: c,
        y: d,
        width: u - c,
        height: h - d
      };
    }
    getLength() {
      return this.pathLength;
    }
    getPointAtLength(l) {
      return ti.getPointAtLengthOfDataArray(l, this.dataArray);
    }
    static getLineLength(l, c, u, d) {
      return Math.sqrt((u - l) * (u - l) + (d - c) * (d - c));
    }
    static getPathLength(l) {
      let c = 0;
      for (let u = 0; u < l.length; ++u)
        c += l[u].pathLength;
      return c;
    }
    static getPointAtLengthOfDataArray(l, c) {
      let u, d = 0, h = c.length;
      if (!h)
        return null;
      for (; d < h && l > c[d].pathLength; )
        l -= c[d].pathLength, ++d;
      if (d === h)
        return u = c[d - 1].points.slice(-2), {
          x: u[0],
          y: u[1]
        };
      if (l < 0.01)
        return u = c[d].points.slice(0, 2), {
          x: u[0],
          y: u[1]
        };
      const p = c[d], v = p.points;
      switch (p.command) {
        case "L":
          return ti.getPointOnLine(l, p.start.x, p.start.y, v[0], v[1]);
        case "C":
          return ti.getPointOnCubicBezier((0, r.t2length)(l, ti.getPathLength(c), (C) => (0, r.getCubicArcLength)([p.start.x, v[0], v[2], v[4]], [p.start.y, v[1], v[3], v[5]], C)), p.start.x, p.start.y, v[0], v[1], v[2], v[3], v[4], v[5]);
        case "Q":
          return ti.getPointOnQuadraticBezier((0, r.t2length)(l, ti.getPathLength(c), (C) => (0, r.getQuadraticArcLength)([p.start.x, v[0], v[2]], [p.start.y, v[1], v[3]], C)), p.start.x, p.start.y, v[0], v[1], v[2], v[3]);
        case "A":
          var m = v[0], g = v[1], b = v[2], x = v[3], w = v[4], T = v[5], S = v[6];
          return w += T * l / p.pathLength, ti.getPointOnEllipticalArc(m, g, b, x, w, S);
      }
      return null;
    }
    static getPointOnLine(l, c, u, d, h, p, v) {
      p = p ?? c, v = v ?? u;
      const m = this.getLineLength(c, u, d, h);
      if (m < 1e-10)
        return { x: c, y: u };
      if (d === c)
        return { x: p, y: v + (h > u ? l : -l) };
      const g = (h - u) / (d - c), b = Math.sqrt(l * l / (1 + g * g)) * (d < c ? -1 : 1), x = g * b;
      if (Math.abs(v - u - g * (p - c)) < 1e-10)
        return { x: p + b, y: v + x };
      const w = ((p - c) * (d - c) + (v - u) * (h - u)) / (m * m), T = c + w * (d - c), S = u + w * (h - u), C = this.getLineLength(p, v, T, S), E = Math.sqrt(l * l - C * C), O = Math.sqrt(E * E / (1 + g * g)) * (d < c ? -1 : 1), B = g * O;
      return { x: T + O, y: S + B };
    }
    static getPointOnCubicBezier(l, c, u, d, h, p, v, m, g) {
      function b(E) {
        return E * E * E;
      }
      function x(E) {
        return 3 * E * E * (1 - E);
      }
      function w(E) {
        return 3 * E * (1 - E) * (1 - E);
      }
      function T(E) {
        return (1 - E) * (1 - E) * (1 - E);
      }
      const S = m * b(l) + p * x(l) + d * w(l) + c * T(l), C = g * b(l) + v * x(l) + h * w(l) + u * T(l);
      return {
        x: S,
        y: C
      };
    }
    static getPointOnQuadraticBezier(l, c, u, d, h, p, v) {
      function m(T) {
        return T * T;
      }
      function g(T) {
        return 2 * T * (1 - T);
      }
      function b(T) {
        return (1 - T) * (1 - T);
      }
      const x = p * m(l) + d * g(l) + c * b(l), w = v * m(l) + h * g(l) + u * b(l);
      return {
        x,
        y: w
      };
    }
    static getPointOnEllipticalArc(l, c, u, d, h, p) {
      const v = Math.cos(p), m = Math.sin(p), g = {
        x: u * Math.cos(h),
        y: d * Math.sin(h)
      };
      return {
        x: l + (g.x * v - g.y * m),
        y: c + (g.x * m + g.y * v)
      };
    }
    static parsePathData(l) {
      if (!l)
        return [];
      let c = l;
      const u = [
        "m",
        "M",
        "l",
        "L",
        "v",
        "V",
        "h",
        "H",
        "z",
        "Z",
        "c",
        "C",
        "q",
        "Q",
        "t",
        "T",
        "s",
        "S",
        "a",
        "A"
      ];
      c = c.replace(new RegExp(" ", "g"), ",");
      for (var d = 0; d < u.length; d++)
        c = c.replace(new RegExp(u[d], "g"), "|" + u[d]);
      const h = c.split("|"), p = [], v = [];
      let m = 0, g = 0;
      const b = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:e[-+]?\d+)?)/gi;
      let x;
      for (d = 1; d < h.length; d++) {
        let M = h[d], j = M.charAt(0);
        for (M = M.slice(1), v.length = 0; x = b.exec(M); )
          v.push(x[0]);
        const D = [];
        for (let z = 0, H = v.length; z < H; z++) {
          if (v[z] === "00") {
            D.push(0, 0);
            continue;
          }
          const X = parseFloat(v[z]);
          isNaN(X) ? D.push(0) : D.push(X);
        }
        for (; D.length > 0 && !isNaN(D[0]); ) {
          let z = "", H = [];
          const X = m, Y = g;
          var w, T, S, C, E, O, B, N, L, k;
          switch (j) {
            case "l":
              m += D.shift(), g += D.shift(), z = "L", H.push(m, g);
              break;
            case "L":
              m = D.shift(), g = D.shift(), H.push(m, g);
              break;
            case "m":
              var F = D.shift(), G = D.shift();
              if (m += F, g += G, z = "M", p.length > 2 && p[p.length - 1].command === "z") {
                for (let V = p.length - 2; V >= 0; V--)
                  if (p[V].command === "M") {
                    m = p[V].points[0] + F, g = p[V].points[1] + G;
                    break;
                  }
              }
              H.push(m, g), j = "l";
              break;
            case "M":
              m = D.shift(), g = D.shift(), z = "M", H.push(m, g), j = "L";
              break;
            case "h":
              m += D.shift(), z = "L", H.push(m, g);
              break;
            case "H":
              m = D.shift(), z = "L", H.push(m, g);
              break;
            case "v":
              g += D.shift(), z = "L", H.push(m, g);
              break;
            case "V":
              g = D.shift(), z = "L", H.push(m, g);
              break;
            case "C":
              H.push(D.shift(), D.shift(), D.shift(), D.shift()), m = D.shift(), g = D.shift(), H.push(m, g);
              break;
            case "c":
              H.push(m + D.shift(), g + D.shift(), m + D.shift(), g + D.shift()), m += D.shift(), g += D.shift(), z = "C", H.push(m, g);
              break;
            case "S":
              T = m, S = g, w = p[p.length - 1], w.command === "C" && (T = m + (m - w.points[2]), S = g + (g - w.points[3])), H.push(T, S, D.shift(), D.shift()), m = D.shift(), g = D.shift(), z = "C", H.push(m, g);
              break;
            case "s":
              T = m, S = g, w = p[p.length - 1], w.command === "C" && (T = m + (m - w.points[2]), S = g + (g - w.points[3])), H.push(T, S, m + D.shift(), g + D.shift()), m += D.shift(), g += D.shift(), z = "C", H.push(m, g);
              break;
            case "Q":
              H.push(D.shift(), D.shift()), m = D.shift(), g = D.shift(), H.push(m, g);
              break;
            case "q":
              H.push(m + D.shift(), g + D.shift()), m += D.shift(), g += D.shift(), z = "Q", H.push(m, g);
              break;
            case "T":
              T = m, S = g, w = p[p.length - 1], w.command === "Q" && (T = m + (m - w.points[0]), S = g + (g - w.points[1])), m = D.shift(), g = D.shift(), z = "Q", H.push(T, S, m, g);
              break;
            case "t":
              T = m, S = g, w = p[p.length - 1], w.command === "Q" && (T = m + (m - w.points[0]), S = g + (g - w.points[1])), m += D.shift(), g += D.shift(), z = "Q", H.push(T, S, m, g);
              break;
            case "A":
              C = D.shift(), E = D.shift(), O = D.shift(), B = D.shift(), N = D.shift(), L = m, k = g, m = D.shift(), g = D.shift(), z = "A", H = this.convertEndpointToCenterParameterization(L, k, m, g, B, N, C, E, O);
              break;
            case "a":
              C = D.shift(), E = D.shift(), O = D.shift(), B = D.shift(), N = D.shift(), L = m, k = g, m += D.shift(), g += D.shift(), z = "A", H = this.convertEndpointToCenterParameterization(L, k, m, g, B, N, C, E, O);
              break;
          }
          p.push({
            command: z || j,
            points: H,
            start: {
              x: X,
              y: Y
            },
            pathLength: this.calcLength(X, Y, z || j, H)
          });
        }
        (j === "z" || j === "Z") && p.push({
          command: "z",
          points: [],
          start: void 0,
          pathLength: 0
        });
      }
      return p;
    }
    static calcLength(l, c, u, d) {
      let h, p, v, m;
      const g = ti;
      switch (u) {
        case "L":
          return g.getLineLength(l, c, d[0], d[1]);
        case "C":
          return (0, r.getCubicArcLength)([l, d[0], d[2], d[4]], [c, d[1], d[3], d[5]], 1);
        case "Q":
          return (0, r.getQuadraticArcLength)([l, d[0], d[2]], [c, d[1], d[3]], 1);
        case "A":
          h = 0;
          var b = d[4], x = d[5], w = d[4] + x, T = Math.PI / 180;
          if (Math.abs(b - w) < T && (T = Math.abs(b - w)), p = g.getPointOnEllipticalArc(d[0], d[1], d[2], d[3], b, 0), x < 0)
            for (m = b - T; m > w; m -= T)
              v = g.getPointOnEllipticalArc(d[0], d[1], d[2], d[3], m, 0), h += g.getLineLength(p.x, p.y, v.x, v.y), p = v;
          else
            for (m = b + T; m < w; m += T)
              v = g.getPointOnEllipticalArc(d[0], d[1], d[2], d[3], m, 0), h += g.getLineLength(p.x, p.y, v.x, v.y), p = v;
          return v = g.getPointOnEllipticalArc(d[0], d[1], d[2], d[3], w, 0), h += g.getLineLength(p.x, p.y, v.x, v.y), h;
      }
      return 0;
    }
    static convertEndpointToCenterParameterization(l, c, u, d, h, p, v, m, g) {
      const b = g * (Math.PI / 180), x = Math.cos(b) * (l - u) / 2 + Math.sin(b) * (c - d) / 2, w = -1 * Math.sin(b) * (l - u) / 2 + Math.cos(b) * (c - d) / 2, T = x * x / (v * v) + w * w / (m * m);
      T > 1 && (v *= Math.sqrt(T), m *= Math.sqrt(T));
      let S = Math.sqrt((v * v * (m * m) - v * v * (w * w) - m * m * (x * x)) / (v * v * (w * w) + m * m * (x * x)));
      h === p && (S *= -1), isNaN(S) && (S = 0);
      const C = S * v * w / m, E = S * -m * x / v, O = (l + u) / 2 + Math.cos(b) * C - Math.sin(b) * E, B = (c + d) / 2 + Math.sin(b) * C + Math.cos(b) * E, N = function(D) {
        return Math.sqrt(D[0] * D[0] + D[1] * D[1]);
      }, L = function(D, z) {
        return (D[0] * z[0] + D[1] * z[1]) / (N(D) * N(z));
      }, k = function(D, z) {
        return (D[0] * z[1] < D[1] * z[0] ? -1 : 1) * Math.acos(L(D, z));
      }, F = k([1, 0], [(x - C) / v, (w - E) / m]), G = [(x - C) / v, (w - E) / m], M = [(-1 * x - C) / v, (-1 * w - E) / m];
      let j = k(G, M);
      return L(G, M) <= -1 && (j = Math.PI), L(G, M) >= 1 && (j = 0), p === 0 && j > 0 && (j = j - 2 * Math.PI), p === 1 && j < 0 && (j = j + 2 * Math.PI), [O, B, v, m, F, j, b, p];
    }
  };
  return hd.Path = i, i.prototype.className = "Path", i.prototype._attrsAffectingSize = ["data"], (0, n._registerNode)(i), e.Factory.addGetterSetter(i, "data"), hd;
}
var $2;
function JP() {
  if ($2) return ud;
  $2 = 1, Object.defineProperty(ud, "__esModule", { value: !0 }), ud.Arrow = void 0;
  const e = We(), t = mx(), n = $e(), r = Fe(), i = e1();
  let s = class extends t.Line {
    _sceneFunc(c) {
      super._sceneFunc(c);
      const u = Math.PI * 2, d = this.points();
      let h = d;
      const p = this.tension() !== 0 && d.length > 4;
      p && (h = this.getTensionPoints());
      const v = this.pointerLength(), m = d.length;
      let g, b;
      if (p) {
        const T = [
          h[h.length - 4],
          h[h.length - 3],
          h[h.length - 2],
          h[h.length - 1],
          d[m - 2],
          d[m - 1]
        ], S = i.Path.calcLength(h[h.length - 4], h[h.length - 3], "C", T), C = i.Path.getPointOnQuadraticBezier(Math.min(1, 1 - v / S), T[0], T[1], T[2], T[3], T[4], T[5]);
        g = d[m - 2] - C.x, b = d[m - 1] - C.y;
      } else
        g = d[m - 2] - d[m - 4], b = d[m - 1] - d[m - 3];
      const x = (Math.atan2(b, g) + u) % u, w = this.pointerWidth();
      this.pointerAtEnding() && (c.save(), c.beginPath(), c.translate(d[m - 2], d[m - 1]), c.rotate(x), c.moveTo(0, 0), c.lineTo(-v, w / 2), c.lineTo(-v, -w / 2), c.closePath(), c.restore(), this.__fillStroke(c)), this.pointerAtBeginning() && (c.save(), c.beginPath(), c.translate(d[0], d[1]), p ? (g = (h[0] + h[2]) / 2 - d[0], b = (h[1] + h[3]) / 2 - d[1]) : (g = d[2] - d[0], b = d[3] - d[1]), c.rotate((Math.atan2(-b, -g) + u) % u), c.moveTo(0, 0), c.lineTo(-v, w / 2), c.lineTo(-v, -w / 2), c.closePath(), c.restore(), this.__fillStroke(c));
    }
    __fillStroke(c) {
      const u = this.dashEnabled();
      u && (this.attrs.dashEnabled = !1, c.setLineDash([])), c.fillStrokeShape(this), u && (this.attrs.dashEnabled = !0);
    }
    getSelfRect() {
      const c = super.getSelfRect(), u = this.pointerWidth() / 2;
      return {
        x: c.x,
        y: c.y - u,
        width: c.width,
        height: c.height + u * 2
      };
    }
  };
  return ud.Arrow = s, s.prototype.className = "Arrow", (0, r._registerNode)(s), e.Factory.addGetterSetter(s, "pointerLength", 10, (0, n.getNumberValidator)()), e.Factory.addGetterSetter(s, "pointerWidth", 10, (0, n.getNumberValidator)()), e.Factory.addGetterSetter(s, "pointerAtBeginning", !1), e.Factory.addGetterSetter(s, "pointerAtEnding", !0), ud;
}
var fd = {}, K2;
function tD() {
  if (K2) return fd;
  K2 = 1, Object.defineProperty(fd, "__esModule", { value: !0 }), fd.Circle = void 0;
  const e = We(), t = _r(), n = $e(), r = Fe();
  let i = class extends t.Shape {
    _sceneFunc(l) {
      l.beginPath(), l.arc(0, 0, this.attrs.radius || 0, 0, Math.PI * 2, !1), l.closePath(), l.fillStrokeShape(this);
    }
    getWidth() {
      return this.radius() * 2;
    }
    getHeight() {
      return this.radius() * 2;
    }
    setWidth(l) {
      this.radius() !== l / 2 && this.radius(l / 2);
    }
    setHeight(l) {
      this.radius() !== l / 2 && this.radius(l / 2);
    }
  };
  return fd.Circle = i, i.prototype._centroid = !0, i.prototype.className = "Circle", i.prototype._attrsAffectingSize = ["radius"], (0, r._registerNode)(i), e.Factory.addGetterSetter(i, "radius", 0, (0, n.getNumberValidator)()), fd;
}
var pd = {}, Y2;
function eD() {
  if (Y2) return pd;
  Y2 = 1, Object.defineProperty(pd, "__esModule", { value: !0 }), pd.Ellipse = void 0;
  const e = We(), t = _r(), n = $e(), r = Fe();
  let i = class extends t.Shape {
    _sceneFunc(l) {
      const c = this.radiusX(), u = this.radiusY();
      l.beginPath(), l.save(), c !== u && l.scale(1, u / c), l.arc(0, 0, c, 0, Math.PI * 2, !1), l.restore(), l.closePath(), l.fillStrokeShape(this);
    }
    getWidth() {
      return this.radiusX() * 2;
    }
    getHeight() {
      return this.radiusY() * 2;
    }
    setWidth(l) {
      this.radiusX(l / 2);
    }
    setHeight(l) {
      this.radiusY(l / 2);
    }
  };
  return pd.Ellipse = i, i.prototype.className = "Ellipse", i.prototype._centroid = !0, i.prototype._attrsAffectingSize = ["radiusX", "radiusY"], (0, r._registerNode)(i), e.Factory.addComponentsGetterSetter(i, "radius", ["x", "y"]), e.Factory.addGetterSetter(i, "radiusX", 0, (0, n.getNumberValidator)()), e.Factory.addGetterSetter(i, "radiusY", 0, (0, n.getNumberValidator)()), pd;
}
var md = {}, X2;
function nD() {
  if (X2) return md;
  X2 = 1, Object.defineProperty(md, "__esModule", { value: !0 }), md.Image = void 0;
  const e = Hn(), t = We(), n = _r(), r = Fe(), i = $e();
  let s = class gx extends n.Shape {
    constructor(c) {
      super(c), this._loadListener = () => {
        this._requestDraw();
      }, this.on("imageChange.konva", (u) => {
        this._removeImageLoad(u.oldVal), this._setImageLoad();
      }), this._setImageLoad();
    }
    _setImageLoad() {
      const c = this.image();
      c && c.complete || c && c.readyState === 4 || c && c.addEventListener && c.addEventListener("load", this._loadListener);
    }
    _removeImageLoad(c) {
      c && c.removeEventListener && c.removeEventListener("load", this._loadListener);
    }
    destroy() {
      return this._removeImageLoad(this.image()), super.destroy(), this;
    }
    _useBufferCanvas() {
      const c = !!this.cornerRadius(), u = this.hasShadow();
      return c && u ? !0 : super._useBufferCanvas(!0);
    }
    _sceneFunc(c) {
      const u = this.getWidth(), d = this.getHeight(), h = this.cornerRadius(), p = this.attrs.image;
      let v;
      if (p) {
        const m = this.attrs.cropWidth, g = this.attrs.cropHeight;
        m && g ? v = [
          p,
          this.cropX(),
          this.cropY(),
          m,
          g,
          0,
          0,
          u,
          d
        ] : v = [p, 0, 0, u, d];
      }
      (this.hasFill() || this.hasStroke() || h) && (c.beginPath(), h ? e.Util.drawRoundedRectPath(c, u, d, h) : c.rect(0, 0, u, d), c.closePath(), c.fillStrokeShape(this)), p && (h && c.clip(), c.drawImage.apply(c, v));
    }
    _hitFunc(c) {
      const u = this.width(), d = this.height(), h = this.cornerRadius();
      c.beginPath(), h ? e.Util.drawRoundedRectPath(c, u, d, h) : c.rect(0, 0, u, d), c.closePath(), c.fillStrokeShape(this);
    }
    getWidth() {
      var c, u;
      return (c = this.attrs.width) !== null && c !== void 0 ? c : (u = this.image()) === null || u === void 0 ? void 0 : u.width;
    }
    getHeight() {
      var c, u;
      return (c = this.attrs.height) !== null && c !== void 0 ? c : (u = this.image()) === null || u === void 0 ? void 0 : u.height;
    }
    static fromURL(c, u, d = null) {
      const h = e.Util.createImageElement();
      h.onload = function() {
        const p = new gx({
          image: h
        });
        u(p);
      }, h.onerror = d, h.crossOrigin = "Anonymous", h.src = c;
    }
  };
  return md.Image = s, s.prototype.className = "Image", (0, r._registerNode)(s), t.Factory.addGetterSetter(s, "cornerRadius", 0, (0, i.getNumberOrArrayOfNumbersValidator)(4)), t.Factory.addGetterSetter(s, "image"), t.Factory.addComponentsGetterSetter(s, "crop", ["x", "y", "width", "height"]), t.Factory.addGetterSetter(s, "cropX", 0, (0, i.getNumberValidator)()), t.Factory.addGetterSetter(s, "cropY", 0, (0, i.getNumberValidator)()), t.Factory.addGetterSetter(s, "cropWidth", 0, (0, i.getNumberValidator)()), t.Factory.addGetterSetter(s, "cropHeight", 0, (0, i.getNumberValidator)()), md;
}
var tl = {}, Q2;
function rD() {
  if (Q2) return tl;
  Q2 = 1, Object.defineProperty(tl, "__esModule", { value: !0 }), tl.Tag = tl.Label = void 0;
  const e = We(), t = _r(), n = Jy(), r = $e(), i = Fe(), s = [
    "fontFamily",
    "fontSize",
    "fontStyle",
    "padding",
    "lineHeight",
    "text",
    "width",
    "height",
    "pointerDirection",
    "pointerWidth",
    "pointerHeight"
  ], l = "Change.konva", c = "none", u = "up", d = "right", h = "down", p = "left", v = s.length;
  let m = class extends n.Group {
    constructor(x) {
      super(x), this.on("add.konva", function(w) {
        this._addListeners(w.child), this._sync();
      });
    }
    getText() {
      return this.find("Text")[0];
    }
    getTag() {
      return this.find("Tag")[0];
    }
    _addListeners(x) {
      let w = this, T;
      const S = function() {
        w._sync();
      };
      for (T = 0; T < v; T++)
        x.on(s[T] + l, S);
    }
    getWidth() {
      return this.getText().width();
    }
    getHeight() {
      return this.getText().height();
    }
    _sync() {
      let x = this.getText(), w = this.getTag(), T, S, C, E, O, B, N;
      if (x && w) {
        switch (T = x.width(), S = x.height(), C = w.pointerDirection(), E = w.pointerWidth(), N = w.pointerHeight(), O = 0, B = 0, C) {
          case u:
            O = T / 2, B = -1 * N;
            break;
          case d:
            O = T + E, B = S / 2;
            break;
          case h:
            O = T / 2, B = S + N;
            break;
          case p:
            O = -1 * E, B = S / 2;
            break;
        }
        w.setAttrs({
          x: -1 * O,
          y: -1 * B,
          width: T,
          height: S
        }), x.setAttrs({
          x: -1 * O,
          y: -1 * B
        });
      }
    }
  };
  tl.Label = m, m.prototype.className = "Label", (0, i._registerNode)(m);
  class g extends t.Shape {
    _sceneFunc(x) {
      const w = this.width(), T = this.height(), S = this.pointerDirection(), C = this.pointerWidth(), E = this.pointerHeight(), O = this.cornerRadius();
      let B = 0, N = 0, L = 0, k = 0;
      typeof O == "number" ? B = N = L = k = Math.min(O, w / 2, T / 2) : (B = Math.min(O[0] || 0, w / 2, T / 2), N = Math.min(O[1] || 0, w / 2, T / 2), k = Math.min(O[2] || 0, w / 2, T / 2), L = Math.min(O[3] || 0, w / 2, T / 2)), x.beginPath(), x.moveTo(B, 0), S === u && (x.lineTo((w - C) / 2, 0), x.lineTo(w / 2, -1 * E), x.lineTo((w + C) / 2, 0)), x.lineTo(w - N, 0), x.arc(w - N, N, N, Math.PI * 3 / 2, 0, !1), S === d && (x.lineTo(w, (T - E) / 2), x.lineTo(w + C, T / 2), x.lineTo(w, (T + E) / 2)), x.lineTo(w, T - k), x.arc(w - k, T - k, k, 0, Math.PI / 2, !1), S === h && (x.lineTo((w + C) / 2, T), x.lineTo(w / 2, T + E), x.lineTo((w - C) / 2, T)), x.lineTo(L, T), x.arc(L, T - L, L, Math.PI / 2, Math.PI, !1), S === p && (x.lineTo(0, (T + E) / 2), x.lineTo(-1 * C, T / 2), x.lineTo(0, (T - E) / 2)), x.lineTo(0, B), x.arc(B, B, B, Math.PI, Math.PI * 3 / 2, !1), x.closePath(), x.fillStrokeShape(this);
    }
    getSelfRect() {
      let x = 0, w = 0, T = this.pointerWidth(), S = this.pointerHeight(), C = this.pointerDirection(), E = this.width(), O = this.height();
      return C === u ? (w -= S, O += S) : C === h ? O += S : C === p ? (x -= T * 1.5, E += T) : C === d && (E += T * 1.5), {
        x,
        y: w,
        width: E,
        height: O
      };
    }
  }
  return tl.Tag = g, g.prototype.className = "Tag", (0, i._registerNode)(g), e.Factory.addGetterSetter(g, "pointerDirection", c), e.Factory.addGetterSetter(g, "pointerWidth", 0, (0, r.getNumberValidator)()), e.Factory.addGetterSetter(g, "pointerHeight", 0, (0, r.getNumberValidator)()), e.Factory.addGetterSetter(g, "cornerRadius", 0, (0, r.getNumberOrArrayOfNumbersValidator)(4)), tl;
}
var gd = {}, Z2;
function yx() {
  if (Z2) return gd;
  Z2 = 1, Object.defineProperty(gd, "__esModule", { value: !0 }), gd.Rect = void 0;
  const e = We(), t = _r(), n = Fe(), r = Hn(), i = $e();
  class s extends t.Shape {
    _sceneFunc(c) {
      const u = this.cornerRadius(), d = this.width(), h = this.height();
      c.beginPath(), u ? r.Util.drawRoundedRectPath(c, d, h, u) : c.rect(0, 0, d, h), c.closePath(), c.fillStrokeShape(this);
    }
  }
  return gd.Rect = s, s.prototype.className = "Rect", (0, n._registerNode)(s), e.Factory.addGetterSetter(s, "cornerRadius", 0, (0, i.getNumberOrArrayOfNumbersValidator)(4)), gd;
}
var yd = {}, J2;
function iD() {
  if (J2) return yd;
  J2 = 1, Object.defineProperty(yd, "__esModule", { value: !0 }), yd.RegularPolygon = void 0;
  const e = We(), t = _r(), n = $e(), r = Fe();
  let i = class extends t.Shape {
    _sceneFunc(l) {
      const c = this._getPoints();
      l.beginPath(), l.moveTo(c[0].x, c[0].y);
      for (let u = 1; u < c.length; u++)
        l.lineTo(c[u].x, c[u].y);
      l.closePath(), l.fillStrokeShape(this);
    }
    _getPoints() {
      const l = this.attrs.sides, c = this.attrs.radius || 0, u = [];
      for (let d = 0; d < l; d++)
        u.push({
          x: c * Math.sin(d * 2 * Math.PI / l),
          y: -1 * c * Math.cos(d * 2 * Math.PI / l)
        });
      return u;
    }
    getSelfRect() {
      const l = this._getPoints();
      let c = l[0].x, u = l[0].y, d = l[0].x, h = l[0].y;
      return l.forEach((p) => {
        c = Math.min(c, p.x), u = Math.max(u, p.x), d = Math.min(d, p.y), h = Math.max(h, p.y);
      }), {
        x: c,
        y: d,
        width: u - c,
        height: h - d
      };
    }
    getWidth() {
      return this.radius() * 2;
    }
    getHeight() {
      return this.radius() * 2;
    }
    setWidth(l) {
      this.radius(l / 2);
    }
    setHeight(l) {
      this.radius(l / 2);
    }
  };
  return yd.RegularPolygon = i, i.prototype.className = "RegularPolygon", i.prototype._centroid = !0, i.prototype._attrsAffectingSize = ["radius"], (0, r._registerNode)(i), e.Factory.addGetterSetter(i, "radius", 0, (0, n.getNumberValidator)()), e.Factory.addGetterSetter(i, "sides", 0, (0, n.getNumberValidator)()), yd;
}
var vd = {}, t_;
function sD() {
  if (t_) return vd;
  t_ = 1, Object.defineProperty(vd, "__esModule", { value: !0 }), vd.Ring = void 0;
  const e = We(), t = _r(), n = $e(), r = Fe(), i = Math.PI * 2;
  let s = class extends t.Shape {
    _sceneFunc(c) {
      c.beginPath(), c.arc(0, 0, this.innerRadius(), 0, i, !1), c.moveTo(this.outerRadius(), 0), c.arc(0, 0, this.outerRadius(), i, 0, !0), c.closePath(), c.fillStrokeShape(this);
    }
    getWidth() {
      return this.outerRadius() * 2;
    }
    getHeight() {
      return this.outerRadius() * 2;
    }
    setWidth(c) {
      this.outerRadius(c / 2);
    }
    setHeight(c) {
      this.outerRadius(c / 2);
    }
  };
  return vd.Ring = s, s.prototype.className = "Ring", s.prototype._centroid = !0, s.prototype._attrsAffectingSize = ["innerRadius", "outerRadius"], (0, r._registerNode)(s), e.Factory.addGetterSetter(s, "innerRadius", 0, (0, n.getNumberValidator)()), e.Factory.addGetterSetter(s, "outerRadius", 0, (0, n.getNumberValidator)()), vd;
}
var bd = {}, e_;
function oD() {
  if (e_) return bd;
  e_ = 1, Object.defineProperty(bd, "__esModule", { value: !0 }), bd.Sprite = void 0;
  const e = We(), t = _r(), n = t1(), r = $e(), i = Fe();
  let s = class extends t.Shape {
    constructor(c) {
      super(c), this._updated = !0, this.anim = new n.Animation(() => {
        const u = this._updated;
        return this._updated = !1, u;
      }), this.on("animationChange.konva", function() {
        this.frameIndex(0);
      }), this.on("frameIndexChange.konva", function() {
        this._updated = !0;
      }), this.on("frameRateChange.konva", function() {
        this.anim.isRunning() && (clearInterval(this.interval), this._setInterval());
      });
    }
    _sceneFunc(c) {
      const u = this.animation(), d = this.frameIndex(), h = d * 4, p = this.animations()[u], v = this.frameOffsets(), m = p[h + 0], g = p[h + 1], b = p[h + 2], x = p[h + 3], w = this.image();
      if ((this.hasFill() || this.hasStroke()) && (c.beginPath(), c.rect(0, 0, b, x), c.closePath(), c.fillStrokeShape(this)), w)
        if (v) {
          const T = v[u], S = d * 2;
          c.drawImage(w, m, g, b, x, T[S + 0], T[S + 1], b, x);
        } else
          c.drawImage(w, m, g, b, x, 0, 0, b, x);
    }
    _hitFunc(c) {
      const u = this.animation(), d = this.frameIndex(), h = d * 4, p = this.animations()[u], v = this.frameOffsets(), m = p[h + 2], g = p[h + 3];
      if (c.beginPath(), v) {
        const b = v[u], x = d * 2;
        c.rect(b[x + 0], b[x + 1], m, g);
      } else
        c.rect(0, 0, m, g);
      c.closePath(), c.fillShape(this);
    }
    _useBufferCanvas() {
      return super._useBufferCanvas(!0);
    }
    _setInterval() {
      const c = this;
      this.interval = setInterval(function() {
        c._updateIndex();
      }, 1e3 / this.frameRate());
    }
    start() {
      if (this.isRunning())
        return;
      const c = this.getLayer();
      this.anim.setLayers(c), this._setInterval(), this.anim.start();
    }
    stop() {
      this.anim.stop(), clearInterval(this.interval);
    }
    isRunning() {
      return this.anim.isRunning();
    }
    _updateIndex() {
      const c = this.frameIndex(), u = this.animation(), d = this.animations(), h = d[u], p = h.length / 4;
      c < p - 1 ? this.frameIndex(c + 1) : this.frameIndex(0);
    }
  };
  return bd.Sprite = s, s.prototype.className = "Sprite", (0, i._registerNode)(s), e.Factory.addGetterSetter(s, "animation"), e.Factory.addGetterSetter(s, "animations"), e.Factory.addGetterSetter(s, "frameOffsets"), e.Factory.addGetterSetter(s, "image"), e.Factory.addGetterSetter(s, "frameIndex", 0, (0, r.getNumberValidator)()), e.Factory.addGetterSetter(s, "frameRate", 17, (0, r.getNumberValidator)()), e.Factory.backCompat(s, {
    index: "frameIndex",
    getIndex: "getFrameIndex",
    setIndex: "setFrameIndex"
  }), bd;
}
var _d = {}, n_;
function aD() {
  if (n_) return _d;
  n_ = 1, Object.defineProperty(_d, "__esModule", { value: !0 }), _d.Star = void 0;
  const e = We(), t = _r(), n = $e(), r = Fe();
  let i = class extends t.Shape {
    _sceneFunc(l) {
      const c = this.innerRadius(), u = this.outerRadius(), d = this.numPoints();
      l.beginPath(), l.moveTo(0, 0 - u);
      for (let h = 1; h < d * 2; h++) {
        const p = h % 2 === 0 ? u : c, v = p * Math.sin(h * Math.PI / d), m = -1 * p * Math.cos(h * Math.PI / d);
        l.lineTo(v, m);
      }
      l.closePath(), l.fillStrokeShape(this);
    }
    getWidth() {
      return this.outerRadius() * 2;
    }
    getHeight() {
      return this.outerRadius() * 2;
    }
    setWidth(l) {
      this.outerRadius(l / 2);
    }
    setHeight(l) {
      this.outerRadius(l / 2);
    }
  };
  return _d.Star = i, i.prototype.className = "Star", i.prototype._centroid = !0, i.prototype._attrsAffectingSize = ["innerRadius", "outerRadius"], (0, r._registerNode)(i), e.Factory.addGetterSetter(i, "numPoints", 5, (0, n.getNumberValidator)()), e.Factory.addGetterSetter(i, "innerRadius", 0, (0, n.getNumberValidator)()), e.Factory.addGetterSetter(i, "outerRadius", 0, (0, n.getNumberValidator)()), _d;
}
var Sc = {}, r_;
function vx() {
  if (r_) return Sc;
  r_ = 1, Object.defineProperty(Sc, "__esModule", { value: !0 }), Sc.Text = void 0, Sc.stringToArray = l;
  const e = Hn(), t = We(), n = _r(), r = Fe(), i = $e(), s = Fe();
  function l(ct) {
    return [...ct].reduce((et, rt, st, yt) => {
      if (new RegExp("\\p{Emoji}", "u").test(rt)) {
        const J = yt[st + 1];
        J && new RegExp("\\p{Emoji_Modifier}|\\u200D", "u").test(J) ? (et.push(rt + J), yt[st + 1] = "") : et.push(rt);
      } else new RegExp("\\p{Regional_Indicator}{2}", "u").test(rt + (yt[st + 1] || "")) ? et.push(rt + yt[st + 1]) : st > 0 && new RegExp("\\p{Mn}|\\p{Me}|\\p{Mc}", "u").test(rt) ? et[et.length - 1] += rt : rt && et.push(rt);
      return et;
    }, []);
  }
  const c = "auto", u = "center", d = "inherit", h = "justify", p = "Change.konva", v = "2d", m = "-", g = "left", b = "text", x = "Text", w = "top", T = "bottom", S = "middle", C = "normal", E = "px ", O = " ", B = "right", N = "rtl", L = "word", k = "char", F = "none", G = "", M = [
    "direction",
    "fontFamily",
    "fontSize",
    "fontStyle",
    "fontVariant",
    "padding",
    "align",
    "verticalAlign",
    "lineHeight",
    "text",
    "width",
    "height",
    "wrap",
    "ellipsis",
    "letterSpacing"
  ], j = M.length;
  function D(ct) {
    return ct.split(",").map((et) => {
      et = et.trim();
      const rt = et.indexOf(" ") >= 0, st = et.indexOf('"') >= 0 || et.indexOf("'") >= 0;
      return rt && !st && (et = `"${et}"`), et;
    }).join(", ");
  }
  let z;
  function H() {
    return z || (z = e.Util.createCanvasElement().getContext(v), z);
  }
  function X(ct) {
    ct.fillText(this._partialText, this._partialTextX, this._partialTextY);
  }
  function Y(ct) {
    ct.setAttr("miterLimit", 2), ct.strokeText(this._partialText, this._partialTextX, this._partialTextY);
  }
  function V(ct) {
    return ct = ct || {}, !ct.fillLinearGradientColorStops && !ct.fillRadialGradientColorStops && !ct.fillPatternImage && (ct.fill = ct.fill || "black"), ct;
  }
  class Z extends n.Shape {
    constructor(et) {
      super(V(et)), this._partialTextX = 0, this._partialTextY = 0;
      for (let rt = 0; rt < j; rt++)
        this.on(M[rt] + p, this._setTextData);
      this._setTextData();
    }
    _sceneFunc(et) {
      const rt = this.textArr, st = rt.length;
      if (!this.text())
        return;
      let yt = this.padding(), J = this.fontSize(), tt = this.lineHeight() * J, ot = this.verticalAlign(), Tt = this.direction(), Ct = 0, bt = this.align(), Ht = this.getWidth(), $t = this.letterSpacing(), wt = this.fill(), Wt = this.textDecoration(), Ut = Wt.indexOf("underline") !== -1, ne = Wt.indexOf("line-through") !== -1, ce;
      Tt = Tt === d ? et.direction : Tt;
      let re = tt / 2, le = S;
      if (r.Konva._fixTextRendering) {
        const Ft = this.measureSize("M");
        le = "alphabetic", re = (Ft.fontBoundingBoxAscent - Ft.fontBoundingBoxDescent) / 2 + tt / 2;
      }
      var Lt = 0, ye = 0;
      for (Tt === N && et.setAttr("direction", Tt), et.setAttr("font", this._getContextFont()), et.setAttr("textBaseline", le), et.setAttr("textAlign", g), ot === S ? Ct = (this.getHeight() - st * tt - yt * 2) / 2 : ot === T && (Ct = this.getHeight() - st * tt - yt * 2), et.translate(yt, Ct + yt), ce = 0; ce < st; ce++) {
        var Lt = 0, ye = 0, be = rt[ce], Nt = be.text, Bt = be.width, Rt = be.lastInParagraph, Dt, jt;
        if (et.save(), bt === B ? Lt += Ht - Bt - yt * 2 : bt === u && (Lt += (Ht - Bt - yt * 2) / 2), Ut) {
          et.save(), et.beginPath();
          const Yt = r.Konva._fixTextRendering ? Math.round(J / 4) : Math.round(J / 2), ee = Lt, fe = re + ye + Yt;
          et.moveTo(ee, fe), Dt = Nt.split(" ").length - 1, jt = bt === h && !Rt ? Ht - yt * 2 : Bt, et.lineTo(ee + Math.round(jt), fe), et.lineWidth = J / 15;
          const ie = this._getLinearGradient();
          et.strokeStyle = ie || wt, et.stroke(), et.restore();
        }
        if (ne) {
          et.save(), et.beginPath();
          const Yt = r.Konva._fixTextRendering ? -Math.round(J / 4) : 0;
          et.moveTo(Lt, re + ye + Yt), Dt = Nt.split(" ").length - 1, jt = bt === h && !Rt ? Ht - yt * 2 : Bt, et.lineTo(Lt + Math.round(jt), re + ye + Yt), et.lineWidth = J / 15;
          const ee = this._getLinearGradient();
          et.strokeStyle = ee || wt, et.stroke(), et.restore();
        }
        if (Tt !== N && ($t !== 0 || bt === h)) {
          Dt = Nt.split(" ").length - 1;
          const Yt = l(Nt);
          for (let ee = 0; ee < Yt.length; ee++) {
            const fe = Yt[ee];
            fe === " " && !Rt && bt === h && (Lt += (Ht - yt * 2 - Bt) / Dt), this._partialTextX = Lt, this._partialTextY = re + ye, this._partialText = fe, et.fillStrokeShape(this), Lt += this.measureSize(fe).width + $t;
          }
        } else
          $t !== 0 && et.setAttr("letterSpacing", `${$t}px`), this._partialTextX = Lt, this._partialTextY = re + ye, this._partialText = Nt, et.fillStrokeShape(this);
        et.restore(), st > 1 && (re += tt);
      }
    }
    _hitFunc(et) {
      const rt = this.getWidth(), st = this.getHeight();
      et.beginPath(), et.rect(0, 0, rt, st), et.closePath(), et.fillStrokeShape(this);
    }
    setText(et) {
      const rt = e.Util._isString(et) ? et : et == null ? "" : et + "";
      return this._setAttr(b, rt), this;
    }
    getWidth() {
      return this.attrs.width === c || this.attrs.width === void 0 ? this.getTextWidth() + this.padding() * 2 : this.attrs.width;
    }
    getHeight() {
      return this.attrs.height === c || this.attrs.height === void 0 ? this.fontSize() * this.textArr.length * this.lineHeight() + this.padding() * 2 : this.attrs.height;
    }
    getTextWidth() {
      return this.textWidth;
    }
    getTextHeight() {
      return e.Util.warn("text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height."), this.textHeight;
    }
    measureSize(et) {
      var rt, st, yt, J, tt, ot, Tt, Ct, bt, Ht, $t;
      let wt = H(), Wt = this.fontSize(), Ut;
      wt.save(), wt.font = this._getContextFont(), Ut = wt.measureText(et), wt.restore();
      const ne = Wt / 100;
      return {
        actualBoundingBoxAscent: (rt = Ut.actualBoundingBoxAscent) !== null && rt !== void 0 ? rt : 71.58203125 * ne,
        actualBoundingBoxDescent: (st = Ut.actualBoundingBoxDescent) !== null && st !== void 0 ? st : 0,
        actualBoundingBoxLeft: (yt = Ut.actualBoundingBoxLeft) !== null && yt !== void 0 ? yt : -7.421875 * ne,
        actualBoundingBoxRight: (J = Ut.actualBoundingBoxRight) !== null && J !== void 0 ? J : 75.732421875 * ne,
        alphabeticBaseline: (tt = Ut.alphabeticBaseline) !== null && tt !== void 0 ? tt : 0,
        emHeightAscent: (ot = Ut.emHeightAscent) !== null && ot !== void 0 ? ot : 100 * ne,
        emHeightDescent: (Tt = Ut.emHeightDescent) !== null && Tt !== void 0 ? Tt : -20 * ne,
        fontBoundingBoxAscent: (Ct = Ut.fontBoundingBoxAscent) !== null && Ct !== void 0 ? Ct : 91 * ne,
        fontBoundingBoxDescent: (bt = Ut.fontBoundingBoxDescent) !== null && bt !== void 0 ? bt : 21 * ne,
        hangingBaseline: (Ht = Ut.hangingBaseline) !== null && Ht !== void 0 ? Ht : 72.80000305175781 * ne,
        ideographicBaseline: ($t = Ut.ideographicBaseline) !== null && $t !== void 0 ? $t : -21 * ne,
        width: Ut.width,
        height: Wt
      };
    }
    _getContextFont() {
      return this.fontStyle() + O + this.fontVariant() + O + (this.fontSize() + E) + D(this.fontFamily());
    }
    _addTextLine(et) {
      this.align() === h && (et = et.trim());
      const st = this._getTextWidth(et);
      return this.textArr.push({
        text: et,
        width: st,
        lastInParagraph: !1
      });
    }
    _getTextWidth(et) {
      const rt = this.letterSpacing(), st = et.length;
      return H().measureText(et).width + rt * st;
    }
    _setTextData() {
      let et = this.text().split(`
`), rt = +this.fontSize(), st = 0, yt = this.lineHeight() * rt, J = this.attrs.width, tt = this.attrs.height, ot = J !== c && J !== void 0, Tt = tt !== c && tt !== void 0, Ct = this.padding(), bt = J - Ct * 2, Ht = tt - Ct * 2, $t = 0, wt = this.wrap(), Wt = wt !== F, Ut = wt !== k && Wt, ne = this.ellipsis();
      this.textArr = [], H().font = this._getContextFont();
      const ce = ne ? this._getTextWidth(G) : 0;
      for (let re = 0, le = et.length; re < le; ++re) {
        let Lt = et[re], ye = this._getTextWidth(Lt);
        if (ot && ye > bt)
          for (; Lt.length > 0; ) {
            let be = 0, Nt = l(Lt).length, Bt = "", Rt = 0;
            for (; be < Nt; ) {
              const Dt = be + Nt >>> 1, jt = l(Lt), Ft = jt.slice(0, Dt + 1).join(""), Vt = this._getTextWidth(Ft);
              (ne && Tt && $t + yt > Ht ? Vt + ce : Vt) <= bt ? (be = Dt + 1, Bt = Ft, Rt = Vt) : Nt = Dt;
            }
            if (Bt) {
              if (Ut) {
                const Ft = l(Lt), Vt = l(Bt), Yt = Ft[Vt.length], ee = Yt === O || Yt === m;
                let fe;
                if (ee && Rt <= bt)
                  fe = Vt.length;
                else {
                  const ie = Vt.lastIndexOf(O), zt = Vt.lastIndexOf(m);
                  fe = Math.max(ie, zt) + 1;
                }
                fe > 0 && (be = fe, Bt = Ft.slice(0, be).join(""), Rt = this._getTextWidth(Bt));
              }
              if (Bt = Bt.trimRight(), this._addTextLine(Bt), st = Math.max(st, Rt), $t += yt, this._shouldHandleEllipsis($t)) {
                this._tryToAddEllipsisToLastLine();
                break;
              }
              if (Lt = l(Lt).slice(be).join("").trimLeft(), Lt.length > 0 && (ye = this._getTextWidth(Lt), ye <= bt)) {
                this._addTextLine(Lt), $t += yt, st = Math.max(st, ye);
                break;
              }
            } else
              break;
          }
        else
          this._addTextLine(Lt), $t += yt, st = Math.max(st, ye), this._shouldHandleEllipsis($t) && re < le - 1 && this._tryToAddEllipsisToLastLine();
        if (this.textArr[this.textArr.length - 1] && (this.textArr[this.textArr.length - 1].lastInParagraph = !0), Tt && $t + yt > Ht)
          break;
      }
      this.textHeight = rt, this.textWidth = st;
    }
    _shouldHandleEllipsis(et) {
      const rt = +this.fontSize(), st = this.lineHeight() * rt, yt = this.attrs.height, J = yt !== c && yt !== void 0, tt = this.padding(), ot = yt - tt * 2;
      return !(this.wrap() !== F) || J && et + st > ot;
    }
    _tryToAddEllipsisToLastLine() {
      const et = this.attrs.width, rt = et !== c && et !== void 0, st = this.padding(), yt = et - st * 2, J = this.ellipsis(), tt = this.textArr[this.textArr.length - 1];
      !tt || !J || (rt && (this._getTextWidth(tt.text + G) < yt || (tt.text = tt.text.slice(0, tt.text.length - 3))), this.textArr.splice(this.textArr.length - 1, 1), this._addTextLine(tt.text + G));
    }
    getStrokeScaleEnabled() {
      return !0;
    }
    _useBufferCanvas() {
      const et = this.textDecoration().indexOf("underline") !== -1 || this.textDecoration().indexOf("line-through") !== -1, rt = this.hasShadow();
      return et && rt ? !0 : super._useBufferCanvas();
    }
  }
  return Sc.Text = Z, Z.prototype._fillFunc = X, Z.prototype._strokeFunc = Y, Z.prototype.className = x, Z.prototype._attrsAffectingSize = [
    "text",
    "fontSize",
    "padding",
    "wrap",
    "lineHeight",
    "letterSpacing"
  ], (0, s._registerNode)(Z), t.Factory.overWriteSetter(Z, "width", (0, i.getNumberOrAutoValidator)()), t.Factory.overWriteSetter(Z, "height", (0, i.getNumberOrAutoValidator)()), t.Factory.addGetterSetter(Z, "direction", d), t.Factory.addGetterSetter(Z, "fontFamily", "Arial"), t.Factory.addGetterSetter(Z, "fontSize", 12, (0, i.getNumberValidator)()), t.Factory.addGetterSetter(Z, "fontStyle", C), t.Factory.addGetterSetter(Z, "fontVariant", C), t.Factory.addGetterSetter(Z, "padding", 0, (0, i.getNumberValidator)()), t.Factory.addGetterSetter(Z, "align", g), t.Factory.addGetterSetter(Z, "verticalAlign", w), t.Factory.addGetterSetter(Z, "lineHeight", 1, (0, i.getNumberValidator)()), t.Factory.addGetterSetter(Z, "wrap", L), t.Factory.addGetterSetter(Z, "ellipsis", !1, (0, i.getBooleanValidator)()), t.Factory.addGetterSetter(Z, "letterSpacing", 0, (0, i.getNumberValidator)()), t.Factory.addGetterSetter(Z, "text", "", (0, i.getStringValidator)()), t.Factory.addGetterSetter(Z, "textDecoration", ""), Sc;
}
var Sd = {}, i_;
function lD() {
  if (i_) return Sd;
  i_ = 1, Object.defineProperty(Sd, "__esModule", { value: !0 }), Sd.TextPath = void 0;
  const e = Hn(), t = We(), n = _r(), r = e1(), i = vx(), s = $e(), l = Fe(), c = "", u = "normal";
  function d(v) {
    v.fillText(this.partialText, 0, 0);
  }
  function h(v) {
    v.strokeText(this.partialText, 0, 0);
  }
  let p = class extends n.Shape {
    constructor(m) {
      super(m), this.dummyCanvas = e.Util.createCanvasElement(), this.dataArray = [], this._readDataAttribute(), this.on("dataChange.konva", function() {
        this._readDataAttribute(), this._setTextData();
      }), this.on("textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva fontSizeChange.konva fontFamilyChange.konva", this._setTextData), this._setTextData();
    }
    _getTextPathLength() {
      return r.Path.getPathLength(this.dataArray);
    }
    _getPointAtLength(m) {
      if (!this.attrs.data)
        return null;
      const g = this.pathLength;
      return m - 1 > g ? null : r.Path.getPointAtLengthOfDataArray(m, this.dataArray);
    }
    _readDataAttribute() {
      this.dataArray = r.Path.parsePathData(this.attrs.data), this.pathLength = this._getTextPathLength();
    }
    _sceneFunc(m) {
      m.setAttr("font", this._getContextFont()), m.setAttr("textBaseline", this.textBaseline()), m.setAttr("textAlign", "left"), m.save();
      const g = this.textDecoration(), b = this.fill(), x = this.fontSize(), w = this.glyphInfo;
      g === "underline" && m.beginPath();
      for (let T = 0; T < w.length; T++) {
        m.save();
        const S = w[T].p0;
        m.translate(S.x, S.y), m.rotate(w[T].rotation), this.partialText = w[T].text, m.fillStrokeShape(this), g === "underline" && (T === 0 && m.moveTo(0, x / 2 + 1), m.lineTo(x, x / 2 + 1)), m.restore();
      }
      g === "underline" && (m.strokeStyle = b, m.lineWidth = x / 20, m.stroke()), m.restore();
    }
    _hitFunc(m) {
      m.beginPath();
      const g = this.glyphInfo;
      if (g.length >= 1) {
        const b = g[0].p0;
        m.moveTo(b.x, b.y);
      }
      for (let b = 0; b < g.length; b++) {
        const x = g[b].p1;
        m.lineTo(x.x, x.y);
      }
      m.setAttr("lineWidth", this.fontSize()), m.setAttr("strokeStyle", this.colorKey), m.stroke();
    }
    getTextWidth() {
      return this.textWidth;
    }
    getTextHeight() {
      return e.Util.warn("text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height."), this.textHeight;
    }
    setText(m) {
      return i.Text.prototype.setText.call(this, m);
    }
    _getContextFont() {
      return i.Text.prototype._getContextFont.call(this);
    }
    _getTextSize(m) {
      const b = this.dummyCanvas.getContext("2d");
      b.save(), b.font = this._getContextFont();
      const x = b.measureText(m);
      return b.restore(), {
        width: x.width,
        height: parseInt(`${this.fontSize()}`, 10)
      };
    }
    _setTextData() {
      const { width: m, height: g } = this._getTextSize(this.attrs.text);
      if (this.textWidth = m, this.textHeight = g, this.glyphInfo = [], !this.attrs.data)
        return null;
      const b = this.letterSpacing(), x = this.align(), w = this.kerningFunc(), T = Math.max(this.textWidth + ((this.attrs.text || "").length - 1) * b, 0);
      let S = 0;
      x === "center" && (S = Math.max(0, this.pathLength / 2 - T / 2)), x === "right" && (S = Math.max(0, this.pathLength - T));
      const C = (0, i.stringToArray)(this.text());
      let E = S;
      for (let O = 0; O < C.length; O++) {
        const B = this._getPointAtLength(E);
        if (!B)
          return;
        let N = this._getTextSize(C[O]).width + b;
        if (C[O] === " " && x === "justify") {
          const j = this.text().split(" ").length - 1;
          N += (this.pathLength - T) / j;
        }
        const L = this._getPointAtLength(E + N);
        if (!L)
          return;
        const k = r.Path.getLineLength(B.x, B.y, L.x, L.y);
        let F = 0;
        if (w)
          try {
            F = w(C[O - 1], C[O]) * this.fontSize();
          } catch {
            F = 0;
          }
        B.x += F, L.x += F, this.textWidth += F;
        const G = r.Path.getPointOnLine(F + k / 2, B.x, B.y, L.x, L.y), M = Math.atan2(L.y - B.y, L.x - B.x);
        this.glyphInfo.push({
          transposeX: G.x,
          transposeY: G.y,
          text: C[O],
          rotation: M,
          p0: B,
          p1: L
        }), E += N;
      }
    }
    getSelfRect() {
      if (!this.glyphInfo.length)
        return {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        };
      const m = [];
      this.glyphInfo.forEach(function(E) {
        m.push(E.p0.x), m.push(E.p0.y), m.push(E.p1.x), m.push(E.p1.y);
      });
      let g = m[0] || 0, b = m[0] || 0, x = m[1] || 0, w = m[1] || 0, T, S;
      for (let E = 0; E < m.length / 2; E++)
        T = m[E * 2], S = m[E * 2 + 1], g = Math.min(g, T), b = Math.max(b, T), x = Math.min(x, S), w = Math.max(w, S);
      const C = this.fontSize();
      return {
        x: g - C / 2,
        y: x - C / 2,
        width: b - g + C,
        height: w - x + C
      };
    }
    destroy() {
      return e.Util.releaseCanvas(this.dummyCanvas), super.destroy();
    }
  };
  return Sd.TextPath = p, p.prototype._fillFunc = d, p.prototype._strokeFunc = h, p.prototype._fillFuncHit = d, p.prototype._strokeFuncHit = h, p.prototype.className = "TextPath", p.prototype._attrsAffectingSize = ["text", "fontSize", "data"], (0, l._registerNode)(p), t.Factory.addGetterSetter(p, "data"), t.Factory.addGetterSetter(p, "fontFamily", "Arial"), t.Factory.addGetterSetter(p, "fontSize", 12, (0, s.getNumberValidator)()), t.Factory.addGetterSetter(p, "fontStyle", u), t.Factory.addGetterSetter(p, "align", "left"), t.Factory.addGetterSetter(p, "letterSpacing", 0, (0, s.getNumberValidator)()), t.Factory.addGetterSetter(p, "textBaseline", "middle"), t.Factory.addGetterSetter(p, "fontVariant", u), t.Factory.addGetterSetter(p, "text", c), t.Factory.addGetterSetter(p, "textDecoration", ""), t.Factory.addGetterSetter(p, "kerningFunc", void 0), Sd;
}
var xd = {}, s_;
function cD() {
  if (s_) return xd;
  s_ = 1, Object.defineProperty(xd, "__esModule", { value: !0 }), xd.Transformer = void 0;
  const e = Hn(), t = We(), n = Xn(), r = _r(), i = yx(), s = Jy(), l = Fe(), c = $e(), u = Fe(), d = "tr-konva", h = [
    "resizeEnabledChange",
    "rotateAnchorOffsetChange",
    "rotateEnabledChange",
    "enabledAnchorsChange",
    "anchorSizeChange",
    "borderEnabledChange",
    "borderStrokeChange",
    "borderStrokeWidthChange",
    "borderDashChange",
    "anchorStrokeChange",
    "anchorStrokeWidthChange",
    "anchorFillChange",
    "anchorCornerRadiusChange",
    "ignoreStrokeChange",
    "anchorStyleFuncChange"
  ].map((N) => N + `.${d}`).join(" "), p = "nodesRect", v = [
    "widthChange",
    "heightChange",
    "scaleXChange",
    "scaleYChange",
    "skewXChange",
    "skewYChange",
    "rotationChange",
    "offsetXChange",
    "offsetYChange",
    "transformsEnabledChange",
    "strokeWidthChange"
  ], m = {
    "top-left": -45,
    "top-center": 0,
    "top-right": 45,
    "middle-right": -90,
    "middle-left": 90,
    "bottom-left": -135,
    "bottom-center": 180,
    "bottom-right": 135
  }, g = "ontouchstart" in l.Konva._global;
  function b(N, L, k) {
    if (N === "rotater")
      return k;
    L += e.Util.degToRad(m[N] || 0);
    const F = (e.Util.radToDeg(L) % 360 + 360) % 360;
    return e.Util._inRange(F, 315 + 22.5, 360) || e.Util._inRange(F, 0, 22.5) ? "ns-resize" : e.Util._inRange(F, 45 - 22.5, 45 + 22.5) ? "nesw-resize" : e.Util._inRange(F, 90 - 22.5, 90 + 22.5) ? "ew-resize" : e.Util._inRange(F, 135 - 22.5, 135 + 22.5) ? "nwse-resize" : e.Util._inRange(F, 180 - 22.5, 180 + 22.5) ? "ns-resize" : e.Util._inRange(F, 225 - 22.5, 225 + 22.5) ? "nesw-resize" : e.Util._inRange(F, 270 - 22.5, 270 + 22.5) ? "ew-resize" : e.Util._inRange(F, 315 - 22.5, 315 + 22.5) ? "nwse-resize" : (e.Util.error("Transformer has unknown angle for cursor detection: " + F), "pointer");
  }
  const x = [
    "top-left",
    "top-center",
    "top-right",
    "middle-right",
    "middle-left",
    "bottom-left",
    "bottom-center",
    "bottom-right"
  ];
  function w(N) {
    return {
      x: N.x + N.width / 2 * Math.cos(N.rotation) + N.height / 2 * Math.sin(-N.rotation),
      y: N.y + N.height / 2 * Math.cos(N.rotation) + N.width / 2 * Math.sin(N.rotation)
    };
  }
  function T(N, L, k) {
    const F = k.x + (N.x - k.x) * Math.cos(L) - (N.y - k.y) * Math.sin(L), G = k.y + (N.x - k.x) * Math.sin(L) + (N.y - k.y) * Math.cos(L);
    return {
      ...N,
      rotation: N.rotation + L,
      x: F,
      y: G
    };
  }
  function S(N, L) {
    const k = w(N);
    return T(N, L, k);
  }
  function C(N, L, k) {
    let F = L;
    for (let G = 0; G < N.length; G++) {
      const M = l.Konva.getAngle(N[G]), j = Math.abs(M - L) % (Math.PI * 2);
      Math.min(j, Math.PI * 2 - j) < k && (F = M);
    }
    return F;
  }
  let E = 0, O = class extends s.Group {
    constructor(L) {
      super(L), this._movingAnchorName = null, this._transforming = !1, this._createElements(), this._handleMouseMove = this._handleMouseMove.bind(this), this._handleMouseUp = this._handleMouseUp.bind(this), this.update = this.update.bind(this), this.on(h, this.update), this.getNode() && this.update();
    }
    attachTo(L) {
      return this.setNode(L), this;
    }
    setNode(L) {
      return e.Util.warn("tr.setNode(shape), tr.node(shape) and tr.attachTo(shape) methods are deprecated. Please use tr.nodes(nodesArray) instead."), this.setNodes([L]);
    }
    getNode() {
      return this._nodes && this._nodes[0];
    }
    _getEventNamespace() {
      return d + this._id;
    }
    setNodes(L = []) {
      this._nodes && this._nodes.length && this.detach();
      const k = L.filter((G) => G.isAncestorOf(this) ? (e.Util.error("Konva.Transformer cannot be an a child of the node you are trying to attach"), !1) : !0);
      return this._nodes = L = k, L.length === 1 && this.useSingleNodeRotation() ? this.rotation(L[0].getAbsoluteRotation()) : this.rotation(0), this._nodes.forEach((G) => {
        const M = () => {
          this.nodes().length === 1 && this.useSingleNodeRotation() && this.rotation(this.nodes()[0].getAbsoluteRotation()), this._resetTransformCache(), !this._transforming && !this.isDragging() && this.update();
        };
        if (G._attrsAffectingSize.length) {
          const j = G._attrsAffectingSize.map((D) => D + "Change." + this._getEventNamespace()).join(" ");
          G.on(j, M);
        }
        G.on(v.map((j) => j + `.${this._getEventNamespace()}`).join(" "), M), G.on(`absoluteTransformChange.${this._getEventNamespace()}`, M), this._proxyDrag(G);
      }), this._resetTransformCache(), !!this.findOne(".top-left") && this.update(), this;
    }
    _proxyDrag(L) {
      let k;
      L.on(`dragstart.${this._getEventNamespace()}`, (F) => {
        k = L.getAbsolutePosition(), !this.isDragging() && L !== this.findOne(".back") && this.startDrag(F, !1);
      }), L.on(`dragmove.${this._getEventNamespace()}`, (F) => {
        if (!k)
          return;
        const G = L.getAbsolutePosition(), M = G.x - k.x, j = G.y - k.y;
        this.nodes().forEach((D) => {
          if (D === L || D.isDragging())
            return;
          const z = D.getAbsolutePosition();
          D.setAbsolutePosition({
            x: z.x + M,
            y: z.y + j
          }), D.startDrag(F);
        }), k = null;
      });
    }
    getNodes() {
      return this._nodes || [];
    }
    getActiveAnchor() {
      return this._movingAnchorName;
    }
    detach() {
      this._nodes && this._nodes.forEach((L) => {
        L.off("." + this._getEventNamespace());
      }), this._nodes = [], this._resetTransformCache();
    }
    _resetTransformCache() {
      this._clearCache(p), this._clearCache("transform"), this._clearSelfAndDescendantCache("absoluteTransform");
    }
    _getNodeRect() {
      return this._getCache(p, this.__getNodeRect);
    }
    __getNodeShape(L, k = this.rotation(), F) {
      const G = L.getClientRect({
        skipTransform: !0,
        skipShadow: !0,
        skipStroke: this.ignoreStroke()
      }), M = L.getAbsoluteScale(F), j = L.getAbsolutePosition(F), D = G.x * M.x - L.offsetX() * M.x, z = G.y * M.y - L.offsetY() * M.y, H = (l.Konva.getAngle(L.getAbsoluteRotation()) + Math.PI * 2) % (Math.PI * 2), X = {
        x: j.x + D * Math.cos(H) + z * Math.sin(-H),
        y: j.y + z * Math.cos(H) + D * Math.sin(H),
        width: G.width * M.x,
        height: G.height * M.y,
        rotation: H
      };
      return T(X, -l.Konva.getAngle(k), {
        x: 0,
        y: 0
      });
    }
    __getNodeRect() {
      if (!this.getNode())
        return {
          x: -1e8,
          y: -1e8,
          width: 0,
          height: 0,
          rotation: 0
        };
      const k = [];
      this.nodes().map((H) => {
        const X = H.getClientRect({
          skipTransform: !0,
          skipShadow: !0,
          skipStroke: this.ignoreStroke()
        }), Y = [
          { x: X.x, y: X.y },
          { x: X.x + X.width, y: X.y },
          { x: X.x + X.width, y: X.y + X.height },
          { x: X.x, y: X.y + X.height }
        ], V = H.getAbsoluteTransform();
        Y.forEach(function(Z) {
          const ct = V.point(Z);
          k.push(ct);
        });
      });
      const F = new e.Transform();
      F.rotate(-l.Konva.getAngle(this.rotation()));
      let G = 1 / 0, M = 1 / 0, j = -1 / 0, D = -1 / 0;
      k.forEach(function(H) {
        const X = F.point(H);
        G === void 0 && (G = j = X.x, M = D = X.y), G = Math.min(G, X.x), M = Math.min(M, X.y), j = Math.max(j, X.x), D = Math.max(D, X.y);
      }), F.invert();
      const z = F.point({ x: G, y: M });
      return {
        x: z.x,
        y: z.y,
        width: j - G,
        height: D - M,
        rotation: l.Konva.getAngle(this.rotation())
      };
    }
    getX() {
      return this._getNodeRect().x;
    }
    getY() {
      return this._getNodeRect().y;
    }
    getWidth() {
      return this._getNodeRect().width;
    }
    getHeight() {
      return this._getNodeRect().height;
    }
    _createElements() {
      this._createBack(), x.forEach((L) => {
        this._createAnchor(L);
      }), this._createAnchor("rotater");
    }
    _createAnchor(L) {
      const k = new i.Rect({
        stroke: "rgb(0, 161, 255)",
        fill: "white",
        strokeWidth: 1,
        name: L + " _anchor",
        dragDistance: 0,
        draggable: !0,
        hitStrokeWidth: g ? 10 : "auto"
      }), F = this;
      k.on("mousedown touchstart", function(G) {
        F._handleMouseDown(G);
      }), k.on("dragstart", (G) => {
        k.stopDrag(), G.cancelBubble = !0;
      }), k.on("dragend", (G) => {
        G.cancelBubble = !0;
      }), k.on("mouseenter", () => {
        const G = l.Konva.getAngle(this.rotation()), M = this.rotateAnchorCursor(), j = b(L, G, M);
        k.getStage().content && (k.getStage().content.style.cursor = j), this._cursorChange = !0;
      }), k.on("mouseout", () => {
        k.getStage().content && (k.getStage().content.style.cursor = ""), this._cursorChange = !1;
      }), this.add(k);
    }
    _createBack() {
      const L = new r.Shape({
        name: "back",
        width: 0,
        height: 0,
        draggable: !0,
        sceneFunc(k, F) {
          const G = F.getParent(), M = G.padding();
          k.beginPath(), k.rect(-M, -M, F.width() + M * 2, F.height() + M * 2), k.moveTo(F.width() / 2, -M), G.rotateEnabled() && G.rotateLineVisible() && k.lineTo(F.width() / 2, -G.rotateAnchorOffset() * e.Util._sign(F.height()) - M), k.fillStrokeShape(F);
        },
        hitFunc: (k, F) => {
          if (!this.shouldOverdrawWholeArea())
            return;
          const G = this.padding();
          k.beginPath(), k.rect(-G, -G, F.width() + G * 2, F.height() + G * 2), k.fillStrokeShape(F);
        }
      });
      this.add(L), this._proxyDrag(L), L.on("dragstart", (k) => {
        k.cancelBubble = !0;
      }), L.on("dragmove", (k) => {
        k.cancelBubble = !0;
      }), L.on("dragend", (k) => {
        k.cancelBubble = !0;
      }), this.on("dragmove", (k) => {
        this.update();
      });
    }
    _handleMouseDown(L) {
      if (this._transforming)
        return;
      this._movingAnchorName = L.target.name().split(" ")[0];
      const k = this._getNodeRect(), F = k.width, G = k.height, M = Math.sqrt(Math.pow(F, 2) + Math.pow(G, 2));
      this.sin = Math.abs(G / M), this.cos = Math.abs(F / M), typeof window < "u" && (window.addEventListener("mousemove", this._handleMouseMove), window.addEventListener("touchmove", this._handleMouseMove), window.addEventListener("mouseup", this._handleMouseUp, !0), window.addEventListener("touchend", this._handleMouseUp, !0)), this._transforming = !0;
      const j = L.target.getAbsolutePosition(), D = L.target.getStage().getPointerPosition();
      this._anchorDragOffset = {
        x: D.x - j.x,
        y: D.y - j.y
      }, E++, this._fire("transformstart", { evt: L.evt, target: this.getNode() }), this._nodes.forEach((z) => {
        z._fire("transformstart", { evt: L.evt, target: z });
      });
    }
    _handleMouseMove(L) {
      let k, F, G;
      const M = this.findOne("." + this._movingAnchorName), j = M.getStage();
      j.setPointersPositions(L);
      const D = j.getPointerPosition();
      let z = {
        x: D.x - this._anchorDragOffset.x,
        y: D.y - this._anchorDragOffset.y
      };
      const H = M.getAbsolutePosition();
      this.anchorDragBoundFunc() && (z = this.anchorDragBoundFunc()(H, z, L)), M.setAbsolutePosition(z);
      const X = M.getAbsolutePosition();
      if (H.x === X.x && H.y === X.y)
        return;
      if (this._movingAnchorName === "rotater") {
        const ot = this._getNodeRect();
        k = M.x() - ot.width / 2, F = -M.y() + ot.height / 2;
        let Tt = Math.atan2(-F, k) + Math.PI / 2;
        ot.height < 0 && (Tt -= Math.PI);
        const bt = l.Konva.getAngle(this.rotation()) + Tt, Ht = l.Konva.getAngle(this.rotationSnapTolerance()), wt = C(this.rotationSnaps(), bt, Ht) - ot.rotation, Wt = S(ot, wt);
        this._fitNodesInto(Wt, L);
        return;
      }
      const Y = this.shiftBehavior();
      let V;
      Y === "inverted" ? V = this.keepRatio() && !L.shiftKey : Y === "none" ? V = this.keepRatio() : V = this.keepRatio() || L.shiftKey;
      var st = this.centeredScaling() || L.altKey;
      if (this._movingAnchorName === "top-left") {
        if (V) {
          var Z = st ? {
            x: this.width() / 2,
            y: this.height() / 2
          } : {
            x: this.findOne(".bottom-right").x(),
            y: this.findOne(".bottom-right").y()
          };
          G = Math.sqrt(Math.pow(Z.x - M.x(), 2) + Math.pow(Z.y - M.y(), 2));
          var ct = this.findOne(".top-left").x() > Z.x ? -1 : 1, et = this.findOne(".top-left").y() > Z.y ? -1 : 1;
          k = G * this.cos * ct, F = G * this.sin * et, this.findOne(".top-left").x(Z.x - k), this.findOne(".top-left").y(Z.y - F);
        }
      } else if (this._movingAnchorName === "top-center")
        this.findOne(".top-left").y(M.y());
      else if (this._movingAnchorName === "top-right") {
        if (V) {
          var Z = st ? {
            x: this.width() / 2,
            y: this.height() / 2
          } : {
            x: this.findOne(".bottom-left").x(),
            y: this.findOne(".bottom-left").y()
          };
          G = Math.sqrt(Math.pow(M.x() - Z.x, 2) + Math.pow(Z.y - M.y(), 2));
          var ct = this.findOne(".top-right").x() < Z.x ? -1 : 1, et = this.findOne(".top-right").y() > Z.y ? -1 : 1;
          k = G * this.cos * ct, F = G * this.sin * et, this.findOne(".top-right").x(Z.x + k), this.findOne(".top-right").y(Z.y - F);
        }
        var rt = M.position();
        this.findOne(".top-left").y(rt.y), this.findOne(".bottom-right").x(rt.x);
      } else if (this._movingAnchorName === "middle-left")
        this.findOne(".top-left").x(M.x());
      else if (this._movingAnchorName === "middle-right")
        this.findOne(".bottom-right").x(M.x());
      else if (this._movingAnchorName === "bottom-left") {
        if (V) {
          var Z = st ? {
            x: this.width() / 2,
            y: this.height() / 2
          } : {
            x: this.findOne(".top-right").x(),
            y: this.findOne(".top-right").y()
          };
          G = Math.sqrt(Math.pow(Z.x - M.x(), 2) + Math.pow(M.y() - Z.y, 2));
          var ct = Z.x < M.x() ? -1 : 1, et = M.y() < Z.y ? -1 : 1;
          k = G * this.cos * ct, F = G * this.sin * et, M.x(Z.x - k), M.y(Z.y + F);
        }
        rt = M.position(), this.findOne(".top-left").x(rt.x), this.findOne(".bottom-right").y(rt.y);
      } else if (this._movingAnchorName === "bottom-center")
        this.findOne(".bottom-right").y(M.y());
      else if (this._movingAnchorName === "bottom-right") {
        if (V) {
          var Z = st ? {
            x: this.width() / 2,
            y: this.height() / 2
          } : {
            x: this.findOne(".top-left").x(),
            y: this.findOne(".top-left").y()
          };
          G = Math.sqrt(Math.pow(M.x() - Z.x, 2) + Math.pow(M.y() - Z.y, 2));
          var ct = this.findOne(".bottom-right").x() < Z.x ? -1 : 1, et = this.findOne(".bottom-right").y() < Z.y ? -1 : 1;
          k = G * this.cos * ct, F = G * this.sin * et, this.findOne(".bottom-right").x(Z.x + k), this.findOne(".bottom-right").y(Z.y + F);
        }
      } else
        console.error(new Error("Wrong position argument of selection resizer: " + this._movingAnchorName));
      var st = this.centeredScaling() || L.altKey;
      if (st) {
        const ot = this.findOne(".top-left"), Tt = this.findOne(".bottom-right"), Ct = ot.x(), bt = ot.y(), Ht = this.getWidth() - Tt.x(), $t = this.getHeight() - Tt.y();
        Tt.move({
          x: -Ct,
          y: -bt
        }), ot.move({
          x: Ht,
          y: $t
        });
      }
      const yt = this.findOne(".top-left").getAbsolutePosition();
      k = yt.x, F = yt.y;
      const J = this.findOne(".bottom-right").x() - this.findOne(".top-left").x(), tt = this.findOne(".bottom-right").y() - this.findOne(".top-left").y();
      this._fitNodesInto({
        x: k,
        y: F,
        width: J,
        height: tt,
        rotation: l.Konva.getAngle(this.rotation())
      }, L);
    }
    _handleMouseUp(L) {
      this._removeEvents(L);
    }
    getAbsoluteTransform() {
      return this.getTransform();
    }
    _removeEvents(L) {
      var k;
      if (this._transforming) {
        this._transforming = !1, typeof window < "u" && (window.removeEventListener("mousemove", this._handleMouseMove), window.removeEventListener("touchmove", this._handleMouseMove), window.removeEventListener("mouseup", this._handleMouseUp, !0), window.removeEventListener("touchend", this._handleMouseUp, !0));
        const F = this.getNode();
        E--, this._fire("transformend", { evt: L, target: F }), (k = this.getLayer()) === null || k === void 0 || k.batchDraw(), F && this._nodes.forEach((G) => {
          var M;
          G._fire("transformend", { evt: L, target: G }), (M = G.getLayer()) === null || M === void 0 || M.batchDraw();
        }), this._movingAnchorName = null;
      }
    }
    _fitNodesInto(L, k) {
      const F = this._getNodeRect(), G = 1;
      if (e.Util._inRange(L.width, -this.padding() * 2 - G, G)) {
        this.update();
        return;
      }
      if (e.Util._inRange(L.height, -this.padding() * 2 - G, G)) {
        this.update();
        return;
      }
      const M = new e.Transform();
      if (M.rotate(l.Konva.getAngle(this.rotation())), this._movingAnchorName && L.width < 0 && this._movingAnchorName.indexOf("left") >= 0) {
        const V = M.point({
          x: -this.padding() * 2,
          y: 0
        });
        L.x += V.x, L.y += V.y, L.width += this.padding() * 2, this._movingAnchorName = this._movingAnchorName.replace("left", "right"), this._anchorDragOffset.x -= V.x, this._anchorDragOffset.y -= V.y;
      } else if (this._movingAnchorName && L.width < 0 && this._movingAnchorName.indexOf("right") >= 0) {
        const V = M.point({
          x: this.padding() * 2,
          y: 0
        });
        this._movingAnchorName = this._movingAnchorName.replace("right", "left"), this._anchorDragOffset.x -= V.x, this._anchorDragOffset.y -= V.y, L.width += this.padding() * 2;
      }
      if (this._movingAnchorName && L.height < 0 && this._movingAnchorName.indexOf("top") >= 0) {
        const V = M.point({
          x: 0,
          y: -this.padding() * 2
        });
        L.x += V.x, L.y += V.y, this._movingAnchorName = this._movingAnchorName.replace("top", "bottom"), this._anchorDragOffset.x -= V.x, this._anchorDragOffset.y -= V.y, L.height += this.padding() * 2;
      } else if (this._movingAnchorName && L.height < 0 && this._movingAnchorName.indexOf("bottom") >= 0) {
        const V = M.point({
          x: 0,
          y: this.padding() * 2
        });
        this._movingAnchorName = this._movingAnchorName.replace("bottom", "top"), this._anchorDragOffset.x -= V.x, this._anchorDragOffset.y -= V.y, L.height += this.padding() * 2;
      }
      if (this.boundBoxFunc()) {
        const V = this.boundBoxFunc()(F, L);
        V ? L = V : e.Util.warn("boundBoxFunc returned falsy. You should return new bound rect from it!");
      }
      const j = 1e7, D = new e.Transform();
      D.translate(F.x, F.y), D.rotate(F.rotation), D.scale(F.width / j, F.height / j);
      const z = new e.Transform(), H = L.width / j, X = L.height / j;
      this.flipEnabled() === !1 ? (z.translate(L.x, L.y), z.rotate(L.rotation), z.translate(L.width < 0 ? L.width : 0, L.height < 0 ? L.height : 0), z.scale(Math.abs(H), Math.abs(X))) : (z.translate(L.x, L.y), z.rotate(L.rotation), z.scale(H, X));
      const Y = z.multiply(D.invert());
      this._nodes.forEach((V) => {
        var Z;
        const ct = V.getParent().getAbsoluteTransform(), et = V.getTransform().copy();
        et.translate(V.offsetX(), V.offsetY());
        const rt = new e.Transform();
        rt.multiply(ct.copy().invert()).multiply(Y).multiply(ct).multiply(et);
        const st = rt.decompose();
        V.setAttrs(st), (Z = V.getLayer()) === null || Z === void 0 || Z.batchDraw();
      }), this.rotation(e.Util._getRotation(L.rotation)), this._nodes.forEach((V) => {
        this._fire("transform", { evt: k, target: V }), V._fire("transform", { evt: k, target: V });
      }), this._resetTransformCache(), this.update(), this.getLayer().batchDraw();
    }
    forceUpdate() {
      this._resetTransformCache(), this.update();
    }
    _batchChangeChild(L, k) {
      this.findOne(L).setAttrs(k);
    }
    update() {
      var L;
      const k = this._getNodeRect();
      this.rotation(e.Util._getRotation(k.rotation));
      const F = k.width, G = k.height, M = this.enabledAnchors(), j = this.resizeEnabled(), D = this.padding(), z = this.anchorSize(), H = this.find("._anchor");
      H.forEach((Y) => {
        Y.setAttrs({
          width: z,
          height: z,
          offsetX: z / 2,
          offsetY: z / 2,
          stroke: this.anchorStroke(),
          strokeWidth: this.anchorStrokeWidth(),
          fill: this.anchorFill(),
          cornerRadius: this.anchorCornerRadius()
        });
      }), this._batchChangeChild(".top-left", {
        x: 0,
        y: 0,
        offsetX: z / 2 + D,
        offsetY: z / 2 + D,
        visible: j && M.indexOf("top-left") >= 0
      }), this._batchChangeChild(".top-center", {
        x: F / 2,
        y: 0,
        offsetY: z / 2 + D,
        visible: j && M.indexOf("top-center") >= 0
      }), this._batchChangeChild(".top-right", {
        x: F,
        y: 0,
        offsetX: z / 2 - D,
        offsetY: z / 2 + D,
        visible: j && M.indexOf("top-right") >= 0
      }), this._batchChangeChild(".middle-left", {
        x: 0,
        y: G / 2,
        offsetX: z / 2 + D,
        visible: j && M.indexOf("middle-left") >= 0
      }), this._batchChangeChild(".middle-right", {
        x: F,
        y: G / 2,
        offsetX: z / 2 - D,
        visible: j && M.indexOf("middle-right") >= 0
      }), this._batchChangeChild(".bottom-left", {
        x: 0,
        y: G,
        offsetX: z / 2 + D,
        offsetY: z / 2 - D,
        visible: j && M.indexOf("bottom-left") >= 0
      }), this._batchChangeChild(".bottom-center", {
        x: F / 2,
        y: G,
        offsetY: z / 2 - D,
        visible: j && M.indexOf("bottom-center") >= 0
      }), this._batchChangeChild(".bottom-right", {
        x: F,
        y: G,
        offsetX: z / 2 - D,
        offsetY: z / 2 - D,
        visible: j && M.indexOf("bottom-right") >= 0
      }), this._batchChangeChild(".rotater", {
        x: F / 2,
        y: -this.rotateAnchorOffset() * e.Util._sign(G) - D,
        visible: this.rotateEnabled()
      }), this._batchChangeChild(".back", {
        width: F,
        height: G,
        visible: this.borderEnabled(),
        stroke: this.borderStroke(),
        strokeWidth: this.borderStrokeWidth(),
        dash: this.borderDash(),
        x: 0,
        y: 0
      });
      const X = this.anchorStyleFunc();
      X && H.forEach((Y) => {
        X(Y);
      }), (L = this.getLayer()) === null || L === void 0 || L.batchDraw();
    }
    isTransforming() {
      return this._transforming;
    }
    stopTransform() {
      if (this._transforming) {
        this._removeEvents();
        const L = this.findOne("." + this._movingAnchorName);
        L && L.stopDrag();
      }
    }
    destroy() {
      return this.getStage() && this._cursorChange && this.getStage().content && (this.getStage().content.style.cursor = ""), s.Group.prototype.destroy.call(this), this.detach(), this._removeEvents(), this;
    }
    toObject() {
      return n.Node.prototype.toObject.call(this);
    }
    clone(L) {
      return n.Node.prototype.clone.call(this, L);
    }
    getClientRect() {
      return this.nodes().length > 0 ? super.getClientRect() : { x: 0, y: 0, width: 0, height: 0 };
    }
  };
  xd.Transformer = O, O.isTransforming = () => E > 0;
  function B(N) {
    return N instanceof Array || e.Util.warn("enabledAnchors value should be an array"), N instanceof Array && N.forEach(function(L) {
      x.indexOf(L) === -1 && e.Util.warn("Unknown anchor name: " + L + ". Available names are: " + x.join(", "));
    }), N || [];
  }
  return O.prototype.className = "Transformer", (0, u._registerNode)(O), t.Factory.addGetterSetter(O, "enabledAnchors", x, B), t.Factory.addGetterSetter(O, "flipEnabled", !0, (0, c.getBooleanValidator)()), t.Factory.addGetterSetter(O, "resizeEnabled", !0), t.Factory.addGetterSetter(O, "anchorSize", 10, (0, c.getNumberValidator)()), t.Factory.addGetterSetter(O, "rotateEnabled", !0), t.Factory.addGetterSetter(O, "rotateLineVisible", !0), t.Factory.addGetterSetter(O, "rotationSnaps", []), t.Factory.addGetterSetter(O, "rotateAnchorOffset", 50, (0, c.getNumberValidator)()), t.Factory.addGetterSetter(O, "rotateAnchorCursor", "crosshair"), t.Factory.addGetterSetter(O, "rotationSnapTolerance", 5, (0, c.getNumberValidator)()), t.Factory.addGetterSetter(O, "borderEnabled", !0), t.Factory.addGetterSetter(O, "anchorStroke", "rgb(0, 161, 255)"), t.Factory.addGetterSetter(O, "anchorStrokeWidth", 1, (0, c.getNumberValidator)()), t.Factory.addGetterSetter(O, "anchorFill", "white"), t.Factory.addGetterSetter(O, "anchorCornerRadius", 0, (0, c.getNumberValidator)()), t.Factory.addGetterSetter(O, "borderStroke", "rgb(0, 161, 255)"), t.Factory.addGetterSetter(O, "borderStrokeWidth", 1, (0, c.getNumberValidator)()), t.Factory.addGetterSetter(O, "borderDash"), t.Factory.addGetterSetter(O, "keepRatio", !0), t.Factory.addGetterSetter(O, "shiftBehavior", "default"), t.Factory.addGetterSetter(O, "centeredScaling", !1), t.Factory.addGetterSetter(O, "ignoreStroke", !1), t.Factory.addGetterSetter(O, "padding", 0, (0, c.getNumberValidator)()), t.Factory.addGetterSetter(O, "nodes"), t.Factory.addGetterSetter(O, "node"), t.Factory.addGetterSetter(O, "boundBoxFunc"), t.Factory.addGetterSetter(O, "anchorDragBoundFunc"), t.Factory.addGetterSetter(O, "anchorStyleFunc"), t.Factory.addGetterSetter(O, "shouldOverdrawWholeArea", !1), t.Factory.addGetterSetter(O, "useSingleNodeRotation", !0), t.Factory.backCompat(O, {
    lineEnabled: "borderEnabled",
    rotateHandlerOffset: "rotateAnchorOffset",
    enabledHandlers: "enabledAnchors"
  }), xd;
}
var Td = {}, o_;
function uD() {
  if (o_) return Td;
  o_ = 1, Object.defineProperty(Td, "__esModule", { value: !0 }), Td.Wedge = void 0;
  const e = We(), t = _r(), n = Fe(), r = $e(), i = Fe();
  let s = class extends t.Shape {
    _sceneFunc(c) {
      c.beginPath(), c.arc(0, 0, this.radius(), 0, n.Konva.getAngle(this.angle()), this.clockwise()), c.lineTo(0, 0), c.closePath(), c.fillStrokeShape(this);
    }
    getWidth() {
      return this.radius() * 2;
    }
    getHeight() {
      return this.radius() * 2;
    }
    setWidth(c) {
      this.radius(c / 2);
    }
    setHeight(c) {
      this.radius(c / 2);
    }
  };
  return Td.Wedge = s, s.prototype.className = "Wedge", s.prototype._centroid = !0, s.prototype._attrsAffectingSize = ["radius"], (0, i._registerNode)(s), e.Factory.addGetterSetter(s, "radius", 0, (0, r.getNumberValidator)()), e.Factory.addGetterSetter(s, "angle", 0, (0, r.getNumberValidator)()), e.Factory.addGetterSetter(s, "clockwise", !1), e.Factory.backCompat(s, {
    angleDeg: "angle",
    getAngleDeg: "getAngle",
    setAngleDeg: "setAngle"
  }), Td;
}
var Cd = {}, a_;
function dD() {
  if (a_) return Cd;
  a_ = 1, Object.defineProperty(Cd, "__esModule", { value: !0 }), Cd.Blur = void 0;
  const e = We(), t = Xn(), n = $e();
  function r() {
    this.r = 0, this.g = 0, this.b = 0, this.a = 0, this.next = null;
  }
  const i = [
    512,
    512,
    456,
    512,
    328,
    456,
    335,
    512,
    405,
    328,
    271,
    456,
    388,
    335,
    292,
    512,
    454,
    405,
    364,
    328,
    298,
    271,
    496,
    456,
    420,
    388,
    360,
    335,
    312,
    292,
    273,
    512,
    482,
    454,
    428,
    405,
    383,
    364,
    345,
    328,
    312,
    298,
    284,
    271,
    259,
    496,
    475,
    456,
    437,
    420,
    404,
    388,
    374,
    360,
    347,
    335,
    323,
    312,
    302,
    292,
    282,
    273,
    265,
    512,
    497,
    482,
    468,
    454,
    441,
    428,
    417,
    405,
    394,
    383,
    373,
    364,
    354,
    345,
    337,
    328,
    320,
    312,
    305,
    298,
    291,
    284,
    278,
    271,
    265,
    259,
    507,
    496,
    485,
    475,
    465,
    456,
    446,
    437,
    428,
    420,
    412,
    404,
    396,
    388,
    381,
    374,
    367,
    360,
    354,
    347,
    341,
    335,
    329,
    323,
    318,
    312,
    307,
    302,
    297,
    292,
    287,
    282,
    278,
    273,
    269,
    265,
    261,
    512,
    505,
    497,
    489,
    482,
    475,
    468,
    461,
    454,
    447,
    441,
    435,
    428,
    422,
    417,
    411,
    405,
    399,
    394,
    389,
    383,
    378,
    373,
    368,
    364,
    359,
    354,
    350,
    345,
    341,
    337,
    332,
    328,
    324,
    320,
    316,
    312,
    309,
    305,
    301,
    298,
    294,
    291,
    287,
    284,
    281,
    278,
    274,
    271,
    268,
    265,
    262,
    259,
    257,
    507,
    501,
    496,
    491,
    485,
    480,
    475,
    470,
    465,
    460,
    456,
    451,
    446,
    442,
    437,
    433,
    428,
    424,
    420,
    416,
    412,
    408,
    404,
    400,
    396,
    392,
    388,
    385,
    381,
    377,
    374,
    370,
    367,
    363,
    360,
    357,
    354,
    350,
    347,
    344,
    341,
    338,
    335,
    332,
    329,
    326,
    323,
    320,
    318,
    315,
    312,
    310,
    307,
    304,
    302,
    299,
    297,
    294,
    292,
    289,
    287,
    285,
    282,
    280,
    278,
    275,
    273,
    271,
    269,
    267,
    265,
    263,
    261,
    259
  ], s = [
    9,
    11,
    12,
    13,
    13,
    14,
    14,
    15,
    15,
    15,
    15,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24
  ];
  function l(u, d) {
    const h = u.data, p = u.width, v = u.height;
    let m, g, b, x, w, T, S, C, E, O, B, N, L, k, F, G, M, j, D, z, H, X, Y, V;
    const Z = d + d + 1, ct = p - 1, et = v - 1, rt = d + 1, st = rt * (rt + 1) / 2, yt = new r(), J = i[d], tt = s[d];
    let ot = null, Tt = yt, Ct = null, bt = null;
    for (b = 1; b < Z; b++)
      Tt = Tt.next = new r(), b === rt && (ot = Tt);
    for (Tt.next = yt, S = T = 0, g = 0; g < v; g++) {
      for (G = M = j = D = C = E = O = B = 0, N = rt * (z = h[T]), L = rt * (H = h[T + 1]), k = rt * (X = h[T + 2]), F = rt * (Y = h[T + 3]), C += st * z, E += st * H, O += st * X, B += st * Y, Tt = yt, b = 0; b < rt; b++)
        Tt.r = z, Tt.g = H, Tt.b = X, Tt.a = Y, Tt = Tt.next;
      for (b = 1; b < rt; b++)
        x = T + ((ct < b ? ct : b) << 2), C += (Tt.r = z = h[x]) * (V = rt - b), E += (Tt.g = H = h[x + 1]) * V, O += (Tt.b = X = h[x + 2]) * V, B += (Tt.a = Y = h[x + 3]) * V, G += z, M += H, j += X, D += Y, Tt = Tt.next;
      for (Ct = yt, bt = ot, m = 0; m < p; m++)
        h[T + 3] = Y = B * J >> tt, Y !== 0 ? (Y = 255 / Y, h[T] = (C * J >> tt) * Y, h[T + 1] = (E * J >> tt) * Y, h[T + 2] = (O * J >> tt) * Y) : h[T] = h[T + 1] = h[T + 2] = 0, C -= N, E -= L, O -= k, B -= F, N -= Ct.r, L -= Ct.g, k -= Ct.b, F -= Ct.a, x = S + ((x = m + d + 1) < ct ? x : ct) << 2, G += Ct.r = h[x], M += Ct.g = h[x + 1], j += Ct.b = h[x + 2], D += Ct.a = h[x + 3], C += G, E += M, O += j, B += D, Ct = Ct.next, N += z = bt.r, L += H = bt.g, k += X = bt.b, F += Y = bt.a, G -= z, M -= H, j -= X, D -= Y, bt = bt.next, T += 4;
      S += p;
    }
    for (m = 0; m < p; m++) {
      for (M = j = D = G = E = O = B = C = 0, T = m << 2, N = rt * (z = h[T]), L = rt * (H = h[T + 1]), k = rt * (X = h[T + 2]), F = rt * (Y = h[T + 3]), C += st * z, E += st * H, O += st * X, B += st * Y, Tt = yt, b = 0; b < rt; b++)
        Tt.r = z, Tt.g = H, Tt.b = X, Tt.a = Y, Tt = Tt.next;
      for (w = p, b = 1; b <= d; b++)
        T = w + m << 2, C += (Tt.r = z = h[T]) * (V = rt - b), E += (Tt.g = H = h[T + 1]) * V, O += (Tt.b = X = h[T + 2]) * V, B += (Tt.a = Y = h[T + 3]) * V, G += z, M += H, j += X, D += Y, Tt = Tt.next, b < et && (w += p);
      for (T = m, Ct = yt, bt = ot, g = 0; g < v; g++)
        x = T << 2, h[x + 3] = Y = B * J >> tt, Y > 0 ? (Y = 255 / Y, h[x] = (C * J >> tt) * Y, h[x + 1] = (E * J >> tt) * Y, h[x + 2] = (O * J >> tt) * Y) : h[x] = h[x + 1] = h[x + 2] = 0, C -= N, E -= L, O -= k, B -= F, N -= Ct.r, L -= Ct.g, k -= Ct.b, F -= Ct.a, x = m + ((x = g + rt) < et ? x : et) * p << 2, C += G += Ct.r = h[x], E += M += Ct.g = h[x + 1], O += j += Ct.b = h[x + 2], B += D += Ct.a = h[x + 3], Ct = Ct.next, N += z = bt.r, L += H = bt.g, k += X = bt.b, F += Y = bt.a, G -= z, M -= H, j -= X, D -= Y, bt = bt.next, T += p;
    }
  }
  const c = function(d) {
    const h = Math.round(this.blurRadius());
    h > 0 && l(d, h);
  };
  return Cd.Blur = c, e.Factory.addGetterSetter(t.Node, "blurRadius", 0, (0, n.getNumberValidator)(), e.Factory.afterSetFilter), Cd;
}
var wd = {}, l_;
function hD() {
  if (l_) return wd;
  l_ = 1, Object.defineProperty(wd, "__esModule", { value: !0 }), wd.Brighten = void 0;
  const e = We(), t = Xn(), n = $e(), r = function(i) {
    const s = this.brightness() * 255, l = i.data, c = l.length;
    for (let u = 0; u < c; u += 4)
      l[u] += s, l[u + 1] += s, l[u + 2] += s;
  };
  return wd.Brighten = r, e.Factory.addGetterSetter(t.Node, "brightness", 0, (0, n.getNumberValidator)(), e.Factory.afterSetFilter), wd;
}
var Ed = {}, c_;
function fD() {
  if (c_) return Ed;
  c_ = 1, Object.defineProperty(Ed, "__esModule", { value: !0 }), Ed.Contrast = void 0;
  const e = We(), t = Xn(), n = $e(), r = function(i) {
    const s = Math.pow((this.contrast() + 100) / 100, 2), l = i.data, c = l.length;
    let u = 150, d = 150, h = 150;
    for (let p = 0; p < c; p += 4)
      u = l[p], d = l[p + 1], h = l[p + 2], u /= 255, u -= 0.5, u *= s, u += 0.5, u *= 255, d /= 255, d -= 0.5, d *= s, d += 0.5, d *= 255, h /= 255, h -= 0.5, h *= s, h += 0.5, h *= 255, u = u < 0 ? 0 : u > 255 ? 255 : u, d = d < 0 ? 0 : d > 255 ? 255 : d, h = h < 0 ? 0 : h > 255 ? 255 : h, l[p] = u, l[p + 1] = d, l[p + 2] = h;
  };
  return Ed.Contrast = r, e.Factory.addGetterSetter(t.Node, "contrast", 0, (0, n.getNumberValidator)(), e.Factory.afterSetFilter), Ed;
}
var Ad = {}, u_;
function pD() {
  if (u_) return Ad;
  u_ = 1, Object.defineProperty(Ad, "__esModule", { value: !0 }), Ad.Emboss = void 0;
  const e = We(), t = Xn(), n = Hn(), r = $e(), i = function(s) {
    const l = this.embossStrength() * 10, c = this.embossWhiteLevel() * 255, u = this.embossDirection(), d = this.embossBlend(), h = s.data, p = s.width, v = s.height, m = p * 4;
    let g = 0, b = 0, x = v;
    switch (u) {
      case "top-left":
        g = -1, b = -1;
        break;
      case "top":
        g = -1, b = 0;
        break;
      case "top-right":
        g = -1, b = 1;
        break;
      case "right":
        g = 0, b = 1;
        break;
      case "bottom-right":
        g = 1, b = 1;
        break;
      case "bottom":
        g = 1, b = 0;
        break;
      case "bottom-left":
        g = 1, b = -1;
        break;
      case "left":
        g = 0, b = -1;
        break;
      default:
        n.Util.error("Unknown emboss direction: " + u);
    }
    do {
      const w = (x - 1) * m;
      let T = g;
      x + T < 1 && (T = 0), x + T > v && (T = 0);
      const S = (x - 1 + T) * p * 4;
      let C = p;
      do {
        const E = w + (C - 1) * 4;
        let O = b;
        C + O < 1 && (O = 0), C + O > p && (O = 0);
        const B = S + (C - 1 + O) * 4, N = h[E] - h[B], L = h[E + 1] - h[B + 1], k = h[E + 2] - h[B + 2];
        let F = N;
        const G = F > 0 ? F : -F, M = L > 0 ? L : -L, j = k > 0 ? k : -k;
        if (M > G && (F = L), j > G && (F = k), F *= l, d) {
          const D = h[E] + F, z = h[E + 1] + F, H = h[E + 2] + F;
          h[E] = D > 255 ? 255 : D < 0 ? 0 : D, h[E + 1] = z > 255 ? 255 : z < 0 ? 0 : z, h[E + 2] = H > 255 ? 255 : H < 0 ? 0 : H;
        } else {
          let D = c - F;
          D < 0 ? D = 0 : D > 255 && (D = 255), h[E] = h[E + 1] = h[E + 2] = D;
        }
      } while (--C);
    } while (--x);
  };
  return Ad.Emboss = i, e.Factory.addGetterSetter(t.Node, "embossStrength", 0.5, (0, r.getNumberValidator)(), e.Factory.afterSetFilter), e.Factory.addGetterSetter(t.Node, "embossWhiteLevel", 0.5, (0, r.getNumberValidator)(), e.Factory.afterSetFilter), e.Factory.addGetterSetter(t.Node, "embossDirection", "top-left", void 0, e.Factory.afterSetFilter), e.Factory.addGetterSetter(t.Node, "embossBlend", !1, void 0, e.Factory.afterSetFilter), Ad;
}
var kd = {}, d_;
function mD() {
  if (d_) return kd;
  d_ = 1, Object.defineProperty(kd, "__esModule", { value: !0 }), kd.Enhance = void 0;
  const e = We(), t = Xn(), n = $e();
  function r(s, l, c, u, d) {
    const h = c - l, p = d - u;
    if (h === 0)
      return u + p / 2;
    if (p === 0)
      return u;
    let v = (s - l) / h;
    return v = p * v + u, v;
  }
  const i = function(s) {
    const l = s.data, c = l.length;
    let u = l[0], d = u, h, p = l[1], v = p, m, g = l[2], b = g, x;
    const w = this.enhance();
    if (w === 0)
      return;
    for (let F = 0; F < c; F += 4)
      h = l[F + 0], h < u ? u = h : h > d && (d = h), m = l[F + 1], m < p ? p = m : m > v && (v = m), x = l[F + 2], x < g ? g = x : x > b && (b = x);
    d === u && (d = 255, u = 0), v === p && (v = 255, p = 0), b === g && (b = 255, g = 0);
    let T, S, C, E, O, B, N, L, k;
    w > 0 ? (S = d + w * (255 - d), C = u - w * (u - 0), O = v + w * (255 - v), B = p - w * (p - 0), L = b + w * (255 - b), k = g - w * (g - 0)) : (T = (d + u) * 0.5, S = d + w * (d - T), C = u + w * (u - T), E = (v + p) * 0.5, O = v + w * (v - E), B = p + w * (p - E), N = (b + g) * 0.5, L = b + w * (b - N), k = g + w * (g - N));
    for (let F = 0; F < c; F += 4)
      l[F + 0] = r(l[F + 0], u, d, C, S), l[F + 1] = r(l[F + 1], p, v, B, O), l[F + 2] = r(l[F + 2], g, b, k, L);
  };
  return kd.Enhance = i, e.Factory.addGetterSetter(t.Node, "enhance", 0, (0, n.getNumberValidator)(), e.Factory.afterSetFilter), kd;
}
var Rd = {}, h_;
function gD() {
  if (h_) return Rd;
  h_ = 1, Object.defineProperty(Rd, "__esModule", { value: !0 }), Rd.Grayscale = void 0;
  const e = function(t) {
    const n = t.data, r = n.length;
    for (let i = 0; i < r; i += 4) {
      const s = 0.34 * n[i] + 0.5 * n[i + 1] + 0.16 * n[i + 2];
      n[i] = s, n[i + 1] = s, n[i + 2] = s;
    }
  };
  return Rd.Grayscale = e, Rd;
}
var Md = {}, f_;
function yD() {
  if (f_) return Md;
  f_ = 1, Object.defineProperty(Md, "__esModule", { value: !0 }), Md.HSL = void 0;
  const e = We(), t = Xn(), n = $e();
  e.Factory.addGetterSetter(t.Node, "hue", 0, (0, n.getNumberValidator)(), e.Factory.afterSetFilter), e.Factory.addGetterSetter(t.Node, "saturation", 0, (0, n.getNumberValidator)(), e.Factory.afterSetFilter), e.Factory.addGetterSetter(t.Node, "luminance", 0, (0, n.getNumberValidator)(), e.Factory.afterSetFilter);
  const r = function(i) {
    const s = i.data, l = s.length, c = 1, u = Math.pow(2, this.saturation()), d = Math.abs(this.hue() + 360) % 360, h = this.luminance() * 127, p = c * u * Math.cos(d * Math.PI / 180), v = c * u * Math.sin(d * Math.PI / 180), m = 0.299 * c + 0.701 * p + 0.167 * v, g = 0.587 * c - 0.587 * p + 0.33 * v, b = 0.114 * c - 0.114 * p - 0.497 * v, x = 0.299 * c - 0.299 * p - 0.328 * v, w = 0.587 * c + 0.413 * p + 0.035 * v, T = 0.114 * c - 0.114 * p + 0.293 * v, S = 0.299 * c - 0.3 * p + 1.25 * v, C = 0.587 * c - 0.586 * p - 1.05 * v, E = 0.114 * c + 0.886 * p - 0.2 * v;
    let O, B, N, L;
    for (let k = 0; k < l; k += 4)
      O = s[k + 0], B = s[k + 1], N = s[k + 2], L = s[k + 3], s[k + 0] = m * O + g * B + b * N + h, s[k + 1] = x * O + w * B + T * N + h, s[k + 2] = S * O + C * B + E * N + h, s[k + 3] = L;
  };
  return Md.HSL = r, Md;
}
var Od = {}, p_;
function vD() {
  if (p_) return Od;
  p_ = 1, Object.defineProperty(Od, "__esModule", { value: !0 }), Od.HSV = void 0;
  const e = We(), t = Xn(), n = $e(), r = function(i) {
    const s = i.data, l = s.length, c = Math.pow(2, this.value()), u = Math.pow(2, this.saturation()), d = Math.abs(this.hue() + 360) % 360, h = c * u * Math.cos(d * Math.PI / 180), p = c * u * Math.sin(d * Math.PI / 180), v = 0.299 * c + 0.701 * h + 0.167 * p, m = 0.587 * c - 0.587 * h + 0.33 * p, g = 0.114 * c - 0.114 * h - 0.497 * p, b = 0.299 * c - 0.299 * h - 0.328 * p, x = 0.587 * c + 0.413 * h + 0.035 * p, w = 0.114 * c - 0.114 * h + 0.293 * p, T = 0.299 * c - 0.3 * h + 1.25 * p, S = 0.587 * c - 0.586 * h - 1.05 * p, C = 0.114 * c + 0.886 * h - 0.2 * p;
    let E, O, B, N;
    for (let L = 0; L < l; L += 4)
      E = s[L + 0], O = s[L + 1], B = s[L + 2], N = s[L + 3], s[L + 0] = v * E + m * O + g * B, s[L + 1] = b * E + x * O + w * B, s[L + 2] = T * E + S * O + C * B, s[L + 3] = N;
  };
  return Od.HSV = r, e.Factory.addGetterSetter(t.Node, "hue", 0, (0, n.getNumberValidator)(), e.Factory.afterSetFilter), e.Factory.addGetterSetter(t.Node, "saturation", 0, (0, n.getNumberValidator)(), e.Factory.afterSetFilter), e.Factory.addGetterSetter(t.Node, "value", 0, (0, n.getNumberValidator)(), e.Factory.afterSetFilter), Od;
}
var Nd = {}, m_;
function bD() {
  if (m_) return Nd;
  m_ = 1, Object.defineProperty(Nd, "__esModule", { value: !0 }), Nd.Invert = void 0;
  const e = function(t) {
    const n = t.data, r = n.length;
    for (let i = 0; i < r; i += 4)
      n[i] = 255 - n[i], n[i + 1] = 255 - n[i + 1], n[i + 2] = 255 - n[i + 2];
  };
  return Nd.Invert = e, Nd;
}
var Pd = {}, g_;
function _D() {
  if (g_) return Pd;
  g_ = 1, Object.defineProperty(Pd, "__esModule", { value: !0 }), Pd.Kaleidoscope = void 0;
  const e = We(), t = Xn(), n = Hn(), r = $e(), i = function(c, u, d) {
    const h = c.data, p = u.data, v = c.width, m = c.height, g = d.polarCenterX || v / 2, b = d.polarCenterY || m / 2;
    let x = Math.sqrt(g * g + b * b), w = v - g, T = m - b;
    const S = Math.sqrt(w * w + T * T);
    x = S > x ? S : x;
    const C = m, E = v, O = 360 / E * Math.PI / 180;
    for (let B = 0; B < E; B += 1) {
      const N = Math.sin(B * O), L = Math.cos(B * O);
      for (let k = 0; k < C; k += 1) {
        w = Math.floor(g + x * k / C * L), T = Math.floor(b + x * k / C * N);
        let F = (T * v + w) * 4;
        const G = h[F + 0], M = h[F + 1], j = h[F + 2], D = h[F + 3];
        F = (B + k * v) * 4, p[F + 0] = G, p[F + 1] = M, p[F + 2] = j, p[F + 3] = D;
      }
    }
  }, s = function(c, u, d) {
    const h = c.data, p = u.data, v = c.width, m = c.height, g = d.polarCenterX || v / 2, b = d.polarCenterY || m / 2;
    let x = Math.sqrt(g * g + b * b), w = v - g, T = m - b;
    const S = Math.sqrt(w * w + T * T);
    x = S > x ? S : x;
    const C = m, E = v, O = 0;
    let B, N;
    for (w = 0; w < v; w += 1)
      for (T = 0; T < m; T += 1) {
        const L = w - g, k = T - b, F = Math.sqrt(L * L + k * k) * C / x;
        let G = (Math.atan2(k, L) * 180 / Math.PI + 360 + O) % 360;
        G = G * E / 360, B = Math.floor(G), N = Math.floor(F);
        let M = (N * v + B) * 4;
        const j = h[M + 0], D = h[M + 1], z = h[M + 2], H = h[M + 3];
        M = (T * v + w) * 4, p[M + 0] = j, p[M + 1] = D, p[M + 2] = z, p[M + 3] = H;
      }
  }, l = function(c) {
    const u = c.width, d = c.height;
    let h, p, v, m, g, b, x, w, T, S, C = Math.round(this.kaleidoscopePower());
    const E = Math.round(this.kaleidoscopeAngle()), O = Math.floor(u * (E % 360) / 360);
    if (C < 1)
      return;
    const B = n.Util.createCanvasElement();
    B.width = u, B.height = d;
    const N = B.getContext("2d").getImageData(0, 0, u, d);
    n.Util.releaseCanvas(B), i(c, N, {
      polarCenterX: u / 2,
      polarCenterY: d / 2
    });
    let L = u / Math.pow(2, C);
    for (; L <= 8; )
      L = L * 2, C -= 1;
    L = Math.ceil(L);
    let k = L, F = 0, G = k, M = 1;
    for (O + L > u && (F = k, G = 0, M = -1), p = 0; p < d; p += 1)
      for (h = F; h !== G; h += M)
        v = Math.round(h + O) % u, T = (u * p + v) * 4, g = N.data[T + 0], b = N.data[T + 1], x = N.data[T + 2], w = N.data[T + 3], S = (u * p + h) * 4, N.data[S + 0] = g, N.data[S + 1] = b, N.data[S + 2] = x, N.data[S + 3] = w;
    for (p = 0; p < d; p += 1)
      for (k = Math.floor(L), m = 0; m < C; m += 1) {
        for (h = 0; h < k + 1; h += 1)
          T = (u * p + h) * 4, g = N.data[T + 0], b = N.data[T + 1], x = N.data[T + 2], w = N.data[T + 3], S = (u * p + k * 2 - h - 1) * 4, N.data[S + 0] = g, N.data[S + 1] = b, N.data[S + 2] = x, N.data[S + 3] = w;
        k *= 2;
      }
    s(N, c, {});
  };
  return Pd.Kaleidoscope = l, e.Factory.addGetterSetter(t.Node, "kaleidoscopePower", 2, (0, r.getNumberValidator)(), e.Factory.afterSetFilter), e.Factory.addGetterSetter(t.Node, "kaleidoscopeAngle", 0, (0, r.getNumberValidator)(), e.Factory.afterSetFilter), Pd;
}
var Dd = {}, y_;
function SD() {
  if (y_) return Dd;
  y_ = 1, Object.defineProperty(Dd, "__esModule", { value: !0 }), Dd.Mask = void 0;
  const e = We(), t = Xn(), n = $e();
  function r(v, m, g) {
    let b = (g * v.width + m) * 4;
    const x = [];
    return x.push(v.data[b++], v.data[b++], v.data[b++], v.data[b++]), x;
  }
  function i(v, m) {
    return Math.sqrt(Math.pow(v[0] - m[0], 2) + Math.pow(v[1] - m[1], 2) + Math.pow(v[2] - m[2], 2));
  }
  function s(v) {
    const m = [0, 0, 0];
    for (let g = 0; g < v.length; g++)
      m[0] += v[g][0], m[1] += v[g][1], m[2] += v[g][2];
    return m[0] /= v.length, m[1] /= v.length, m[2] /= v.length, m;
  }
  function l(v, m) {
    const g = r(v, 0, 0), b = r(v, v.width - 1, 0), x = r(v, 0, v.height - 1), w = r(v, v.width - 1, v.height - 1), T = m || 10;
    if (i(g, b) < T && i(b, w) < T && i(w, x) < T && i(x, g) < T) {
      const S = s([b, g, w, x]), C = [];
      for (let E = 0; E < v.width * v.height; E++) {
        const O = i(S, [
          v.data[E * 4],
          v.data[E * 4 + 1],
          v.data[E * 4 + 2]
        ]);
        C[E] = O < T ? 0 : 255;
      }
      return C;
    }
  }
  function c(v, m) {
    for (let g = 0; g < v.width * v.height; g++)
      v.data[4 * g + 3] = m[g];
  }
  function u(v, m, g) {
    const b = [1, 1, 1, 1, 0, 1, 1, 1, 1], x = Math.round(Math.sqrt(b.length)), w = Math.floor(x / 2), T = [];
    for (let S = 0; S < g; S++)
      for (let C = 0; C < m; C++) {
        const E = S * m + C;
        let O = 0;
        for (let B = 0; B < x; B++)
          for (let N = 0; N < x; N++) {
            const L = S + B - w, k = C + N - w;
            if (L >= 0 && L < g && k >= 0 && k < m) {
              const F = L * m + k, G = b[B * x + N];
              O += v[F] * G;
            }
          }
        T[E] = O === 255 * 8 ? 255 : 0;
      }
    return T;
  }
  function d(v, m, g) {
    const b = [1, 1, 1, 1, 1, 1, 1, 1, 1], x = Math.round(Math.sqrt(b.length)), w = Math.floor(x / 2), T = [];
    for (let S = 0; S < g; S++)
      for (let C = 0; C < m; C++) {
        const E = S * m + C;
        let O = 0;
        for (let B = 0; B < x; B++)
          for (let N = 0; N < x; N++) {
            const L = S + B - w, k = C + N - w;
            if (L >= 0 && L < g && k >= 0 && k < m) {
              const F = L * m + k, G = b[B * x + N];
              O += v[F] * G;
            }
          }
        T[E] = O >= 255 * 4 ? 255 : 0;
      }
    return T;
  }
  function h(v, m, g) {
    const b = [0.1111111111111111, 0.1111111111111111, 0.1111111111111111, 0.1111111111111111, 0.1111111111111111, 0.1111111111111111, 0.1111111111111111, 0.1111111111111111, 0.1111111111111111], x = Math.round(Math.sqrt(b.length)), w = Math.floor(x / 2), T = [];
    for (let S = 0; S < g; S++)
      for (let C = 0; C < m; C++) {
        const E = S * m + C;
        let O = 0;
        for (let B = 0; B < x; B++)
          for (let N = 0; N < x; N++) {
            const L = S + B - w, k = C + N - w;
            if (L >= 0 && L < g && k >= 0 && k < m) {
              const F = L * m + k, G = b[B * x + N];
              O += v[F] * G;
            }
          }
        T[E] = O;
      }
    return T;
  }
  const p = function(v) {
    const m = this.threshold();
    let g = l(v, m);
    return g && (g = u(g, v.width, v.height), g = d(g, v.width, v.height), g = h(g, v.width, v.height), c(v, g)), v;
  };
  return Dd.Mask = p, e.Factory.addGetterSetter(t.Node, "threshold", 0, (0, n.getNumberValidator)(), e.Factory.afterSetFilter), Dd;
}
var Id = {}, v_;
function xD() {
  if (v_) return Id;
  v_ = 1, Object.defineProperty(Id, "__esModule", { value: !0 }), Id.Noise = void 0;
  const e = We(), t = Xn(), n = $e(), r = function(i) {
    const s = this.noise() * 255, l = i.data, c = l.length, u = s / 2;
    for (let d = 0; d < c; d += 4)
      l[d + 0] += u - 2 * u * Math.random(), l[d + 1] += u - 2 * u * Math.random(), l[d + 2] += u - 2 * u * Math.random();
  };
  return Id.Noise = r, e.Factory.addGetterSetter(t.Node, "noise", 0.2, (0, n.getNumberValidator)(), e.Factory.afterSetFilter), Id;
}
var Bd = {}, b_;
function TD() {
  if (b_) return Bd;
  b_ = 1, Object.defineProperty(Bd, "__esModule", { value: !0 }), Bd.Pixelate = void 0;
  const e = We(), t = Hn(), n = Xn(), r = $e(), i = function(s) {
    let l = Math.ceil(this.pixelSize()), c = s.width, u = s.height, d, h, p, v, m, g, b, x = Math.ceil(c / l), w = Math.ceil(u / l), T, S, C, E, O, B, N, L = s.data;
    if (l <= 0) {
      t.Util.error("pixelSize value can not be <= 0");
      return;
    }
    for (O = 0; O < x; O += 1)
      for (B = 0; B < w; B += 1) {
        for (v = 0, m = 0, g = 0, b = 0, T = O * l, S = T + l, C = B * l, E = C + l, N = 0, d = T; d < S; d += 1)
          if (!(d >= c))
            for (h = C; h < E; h += 1)
              h >= u || (p = (c * h + d) * 4, v += L[p + 0], m += L[p + 1], g += L[p + 2], b += L[p + 3], N += 1);
        for (v = v / N, m = m / N, g = g / N, b = b / N, d = T; d < S; d += 1)
          if (!(d >= c))
            for (h = C; h < E; h += 1)
              h >= u || (p = (c * h + d) * 4, L[p + 0] = v, L[p + 1] = m, L[p + 2] = g, L[p + 3] = b);
      }
  };
  return Bd.Pixelate = i, e.Factory.addGetterSetter(n.Node, "pixelSize", 8, (0, r.getNumberValidator)(), e.Factory.afterSetFilter), Bd;
}
var Fd = {}, __;
function CD() {
  if (__) return Fd;
  __ = 1, Object.defineProperty(Fd, "__esModule", { value: !0 }), Fd.Posterize = void 0;
  const e = We(), t = Xn(), n = $e(), r = function(i) {
    const s = Math.round(this.levels() * 254) + 1, l = i.data, c = l.length, u = 255 / s;
    for (let d = 0; d < c; d += 1)
      l[d] = Math.floor(l[d] / u) * u;
  };
  return Fd.Posterize = r, e.Factory.addGetterSetter(t.Node, "levels", 0.5, (0, n.getNumberValidator)(), e.Factory.afterSetFilter), Fd;
}
var jd = {}, S_;
function wD() {
  if (S_) return jd;
  S_ = 1, Object.defineProperty(jd, "__esModule", { value: !0 }), jd.RGB = void 0;
  const e = We(), t = Xn(), n = $e(), r = function(i) {
    const s = i.data, l = s.length, c = this.red(), u = this.green(), d = this.blue();
    for (let h = 0; h < l; h += 4) {
      const p = (0.34 * s[h] + 0.5 * s[h + 1] + 0.16 * s[h + 2]) / 255;
      s[h] = p * c, s[h + 1] = p * u, s[h + 2] = p * d, s[h + 3] = s[h + 3];
    }
  };
  return jd.RGB = r, e.Factory.addGetterSetter(t.Node, "red", 0, function(i) {
    return this._filterUpToDate = !1, i > 255 ? 255 : i < 0 ? 0 : Math.round(i);
  }), e.Factory.addGetterSetter(t.Node, "green", 0, function(i) {
    return this._filterUpToDate = !1, i > 255 ? 255 : i < 0 ? 0 : Math.round(i);
  }), e.Factory.addGetterSetter(t.Node, "blue", 0, n.RGBComponent, e.Factory.afterSetFilter), jd;
}
var Ld = {}, x_;
function ED() {
  if (x_) return Ld;
  x_ = 1, Object.defineProperty(Ld, "__esModule", { value: !0 }), Ld.RGBA = void 0;
  const e = We(), t = Xn(), n = $e(), r = function(i) {
    const s = i.data, l = s.length, c = this.red(), u = this.green(), d = this.blue(), h = this.alpha();
    for (let p = 0; p < l; p += 4) {
      const v = 1 - h;
      s[p] = c * h + s[p] * v, s[p + 1] = u * h + s[p + 1] * v, s[p + 2] = d * h + s[p + 2] * v;
    }
  };
  return Ld.RGBA = r, e.Factory.addGetterSetter(t.Node, "red", 0, function(i) {
    return this._filterUpToDate = !1, i > 255 ? 255 : i < 0 ? 0 : Math.round(i);
  }), e.Factory.addGetterSetter(t.Node, "green", 0, function(i) {
    return this._filterUpToDate = !1, i > 255 ? 255 : i < 0 ? 0 : Math.round(i);
  }), e.Factory.addGetterSetter(t.Node, "blue", 0, n.RGBComponent, e.Factory.afterSetFilter), e.Factory.addGetterSetter(t.Node, "alpha", 1, function(i) {
    return this._filterUpToDate = !1, i > 1 ? 1 : i < 0 ? 0 : i;
  }), Ld;
}
var zd = {}, T_;
function AD() {
  if (T_) return zd;
  T_ = 1, Object.defineProperty(zd, "__esModule", { value: !0 }), zd.Sepia = void 0;
  const e = function(t) {
    const n = t.data, r = n.length;
    for (let i = 0; i < r; i += 4) {
      const s = n[i + 0], l = n[i + 1], c = n[i + 2];
      n[i + 0] = Math.min(255, s * 0.393 + l * 0.769 + c * 0.189), n[i + 1] = Math.min(255, s * 0.349 + l * 0.686 + c * 0.168), n[i + 2] = Math.min(255, s * 0.272 + l * 0.534 + c * 0.131);
    }
  };
  return zd.Sepia = e, zd;
}
var Ud = {}, C_;
function kD() {
  if (C_) return Ud;
  C_ = 1, Object.defineProperty(Ud, "__esModule", { value: !0 }), Ud.Solarize = void 0;
  const e = function(t) {
    const n = t.data, r = t.width, i = t.height, s = r * 4;
    let l = i;
    do {
      const c = (l - 1) * s;
      let u = r;
      do {
        const d = c + (u - 1) * 4;
        let h = n[d], p = n[d + 1], v = n[d + 2];
        h > 127 && (h = 255 - h), p > 127 && (p = 255 - p), v > 127 && (v = 255 - v), n[d] = h, n[d + 1] = p, n[d + 2] = v;
      } while (--u);
    } while (--l);
  };
  return Ud.Solarize = e, Ud;
}
var Vd = {}, w_;
function RD() {
  if (w_) return Vd;
  w_ = 1, Object.defineProperty(Vd, "__esModule", { value: !0 }), Vd.Threshold = void 0;
  const e = We(), t = Xn(), n = $e(), r = function(i) {
    const s = this.threshold() * 255, l = i.data, c = l.length;
    for (let u = 0; u < c; u += 1)
      l[u] = l[u] < s ? 0 : 255;
  };
  return Vd.Threshold = r, e.Factory.addGetterSetter(t.Node, "threshold", 0.5, (0, n.getNumberValidator)(), e.Factory.afterSetFilter), Vd;
}
var E_;
function MD() {
  if (E_) return nd;
  E_ = 1, Object.defineProperty(nd, "__esModule", { value: !0 }), nd.Konva = void 0;
  const e = M0(), t = QP(), n = JP(), r = tD(), i = eD(), s = nD(), l = rD(), c = mx(), u = e1(), d = yx(), h = iD(), p = sD(), v = oD(), m = aD(), g = vx(), b = lD(), x = cD(), w = uD(), T = dD(), S = hD(), C = fD(), E = pD(), O = mD(), B = gD(), N = yD(), L = vD(), k = bD(), F = _D(), G = SD(), M = xD(), j = TD(), D = CD(), z = wD(), H = ED(), X = AD(), Y = kD(), V = RD();
  return nd.Konva = e.Konva.Util._assign(e.Konva, {
    Arc: t.Arc,
    Arrow: n.Arrow,
    Circle: r.Circle,
    Ellipse: i.Ellipse,
    Image: s.Image,
    Label: l.Label,
    Tag: l.Tag,
    Line: c.Line,
    Path: u.Path,
    Rect: d.Rect,
    RegularPolygon: h.RegularPolygon,
    Ring: p.Ring,
    Sprite: v.Sprite,
    Star: m.Star,
    Text: g.Text,
    TextPath: b.TextPath,
    Transformer: x.Transformer,
    Wedge: w.Wedge,
    Filters: {
      Blur: T.Blur,
      Brighten: S.Brighten,
      Contrast: C.Contrast,
      Emboss: E.Emboss,
      Enhance: O.Enhance,
      Grayscale: B.Grayscale,
      HSL: N.HSL,
      HSV: L.HSV,
      Invert: k.Invert,
      Kaleidoscope: F.Kaleidoscope,
      Mask: G.Mask,
      Noise: M.Noise,
      Pixelate: j.Pixelate,
      Posterize: D.Posterize,
      RGB: z.RGB,
      RGBA: H.RGBA,
      Sepia: X.Sepia,
      Solarize: Y.Solarize,
      Threshold: V.Threshold
    }
  }), nd;
}
var OD = Xf.exports, A_;
function ND() {
  if (A_) return Xf.exports;
  A_ = 1, Object.defineProperty(OD, "__esModule", { value: !0 });
  const e = MD();
  return Xf.exports = e.Konva, Xf.exports;
}
ND();
var Lf = { exports: {} }, k_;
function PD() {
  return k_ || (k_ = 1, function(e, t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.Konva = void 0;
    var n = M0();
    Object.defineProperty(t, "Konva", { enumerable: !0, get: function() {
      return n.Konva;
    } });
    const r = M0();
    e.exports = r.Konva;
  }(Lf, Lf.exports)), Lf.exports;
}
var DD = PD();
const wp = /* @__PURE__ */ hh(DD);
var Ug = { exports: {} }, Vg = { exports: {} }, Gg = { exports: {} }, qg = {};
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var R_;
function ID() {
  return R_ || (R_ = 1, function(e) {
    function t(z, H) {
      var X = z.length;
      z.push(H);
      t: for (; 0 < X; ) {
        var Y = X - 1 >>> 1, V = z[Y];
        if (0 < i(V, H))
          z[Y] = H, z[X] = V, X = Y;
        else break t;
      }
    }
    function n(z) {
      return z.length === 0 ? null : z[0];
    }
    function r(z) {
      if (z.length === 0) return null;
      var H = z[0], X = z.pop();
      if (X !== H) {
        z[0] = X;
        t: for (var Y = 0, V = z.length, Z = V >>> 1; Y < Z; ) {
          var ct = 2 * (Y + 1) - 1, et = z[ct], rt = ct + 1, st = z[rt];
          if (0 > i(et, X))
            rt < V && 0 > i(st, et) ? (z[Y] = st, z[rt] = X, Y = rt) : (z[Y] = et, z[ct] = X, Y = ct);
          else if (rt < V && 0 > i(st, X))
            z[Y] = st, z[rt] = X, Y = rt;
          else break t;
        }
      }
      return H;
    }
    function i(z, H) {
      var X = z.sortIndex - H.sortIndex;
      return X !== 0 ? X : z.id - H.id;
    }
    if (e.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
      var s = performance;
      e.unstable_now = function() {
        return s.now();
      };
    } else {
      var l = Date, c = l.now();
      e.unstable_now = function() {
        return l.now() - c;
      };
    }
    var u = [], d = [], h = 1, p = null, v = 3, m = !1, g = !1, b = !1, x = typeof setTimeout == "function" ? setTimeout : null, w = typeof clearTimeout == "function" ? clearTimeout : null, T = typeof setImmediate < "u" ? setImmediate : null;
    function S(z) {
      for (var H = n(d); H !== null; ) {
        if (H.callback === null) r(d);
        else if (H.startTime <= z)
          r(d), H.sortIndex = H.expirationTime, t(u, H);
        else break;
        H = n(d);
      }
    }
    function C(z) {
      if (b = !1, S(z), !g)
        if (n(u) !== null)
          g = !0, j();
        else {
          var H = n(d);
          H !== null && D(C, H.startTime - z);
        }
    }
    var E = !1, O = -1, B = 5, N = -1;
    function L() {
      return !(e.unstable_now() - N < B);
    }
    function k() {
      if (E) {
        var z = e.unstable_now();
        N = z;
        var H = !0;
        try {
          t: {
            g = !1, b && (b = !1, w(O), O = -1), m = !0;
            var X = v;
            try {
              e: {
                for (S(z), p = n(u); p !== null && !(p.expirationTime > z && L()); ) {
                  var Y = p.callback;
                  if (typeof Y == "function") {
                    p.callback = null, v = p.priorityLevel;
                    var V = Y(
                      p.expirationTime <= z
                    );
                    if (z = e.unstable_now(), typeof V == "function") {
                      p.callback = V, S(z), H = !0;
                      break e;
                    }
                    p === n(u) && r(u), S(z);
                  } else r(u);
                  p = n(u);
                }
                if (p !== null) H = !0;
                else {
                  var Z = n(d);
                  Z !== null && D(
                    C,
                    Z.startTime - z
                  ), H = !1;
                }
              }
              break t;
            } finally {
              p = null, v = X, m = !1;
            }
            H = void 0;
          }
        } finally {
          H ? F() : E = !1;
        }
      }
    }
    var F;
    if (typeof T == "function")
      F = function() {
        T(k);
      };
    else if (typeof MessageChannel < "u") {
      var G = new MessageChannel(), M = G.port2;
      G.port1.onmessage = k, F = function() {
        M.postMessage(null);
      };
    } else
      F = function() {
        x(k, 0);
      };
    function j() {
      E || (E = !0, F());
    }
    function D(z, H) {
      O = x(function() {
        z(e.unstable_now());
      }, H);
    }
    e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function(z) {
      z.callback = null;
    }, e.unstable_continueExecution = function() {
      g || m || (g = !0, j());
    }, e.unstable_forceFrameRate = function(z) {
      0 > z || 125 < z ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      ) : B = 0 < z ? Math.floor(1e3 / z) : 5;
    }, e.unstable_getCurrentPriorityLevel = function() {
      return v;
    }, e.unstable_getFirstCallbackNode = function() {
      return n(u);
    }, e.unstable_next = function(z) {
      switch (v) {
        case 1:
        case 2:
        case 3:
          var H = 3;
          break;
        default:
          H = v;
      }
      var X = v;
      v = H;
      try {
        return z();
      } finally {
        v = X;
      }
    }, e.unstable_pauseExecution = function() {
    }, e.unstable_requestPaint = function() {
    }, e.unstable_runWithPriority = function(z, H) {
      switch (z) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          z = 3;
      }
      var X = v;
      v = z;
      try {
        return H();
      } finally {
        v = X;
      }
    }, e.unstable_scheduleCallback = function(z, H, X) {
      var Y = e.unstable_now();
      switch (typeof X == "object" && X !== null ? (X = X.delay, X = typeof X == "number" && 0 < X ? Y + X : Y) : X = Y, z) {
        case 1:
          var V = -1;
          break;
        case 2:
          V = 250;
          break;
        case 5:
          V = 1073741823;
          break;
        case 4:
          V = 1e4;
          break;
        default:
          V = 5e3;
      }
      return V = X + V, z = {
        id: h++,
        callback: H,
        priorityLevel: z,
        startTime: X,
        expirationTime: V,
        sortIndex: -1
      }, X > Y ? (z.sortIndex = X, t(d, z), n(u) === null && z === n(d) && (b ? (w(O), O = -1) : b = !0, D(C, X - Y))) : (z.sortIndex = V, t(u, z), g || m || (g = !0, j())), z;
    }, e.unstable_shouldYield = L, e.unstable_wrapCallback = function(z) {
      var H = v;
      return function() {
        var X = v;
        v = H;
        try {
          return z.apply(this, arguments);
        } finally {
          v = X;
        }
      };
    };
  }(qg)), qg;
}
var M_;
function bx() {
  return M_ || (M_ = 1, Gg.exports = ID()), Gg.exports;
}
/**
 * @license React
 * react-reconciler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var O_;
function BD() {
  return O_ || (O_ = 1, function(e) {
    e.exports = function(t) {
      function n(o, a, f, _) {
        return new Bx(o, a, f, _);
      }
      function r() {
      }
      function i(o) {
        var a = "https://react.dev/errors/" + o;
        if (1 < arguments.length) {
          a += "?args[]=" + encodeURIComponent(arguments[1]);
          for (var f = 2; f < arguments.length; f++)
            a += "&args[]=" + encodeURIComponent(arguments[f]);
        }
        return "Minified React error #" + o + "; visit " + a + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      function s(o) {
        return o === null || typeof o != "object" ? null : (o = M1 && o[M1] || o["@@iterator"], typeof o == "function" ? o : null);
      }
      function l(o) {
        if (o == null) return null;
        if (typeof o == "function")
          return o.$$typeof === Vx ? null : o.displayName || o.name || null;
        if (typeof o == "string") return o;
        switch (o) {
          case Yl:
            return "Fragment";
          case Kl:
            return "Portal";
          case Rm:
            return "Profiler";
          case A1:
            return "StrictMode";
          case Om:
            return "Suspense";
          case Nm:
            return "SuspenseList";
        }
        if (typeof o == "object")
          switch (o.$$typeof) {
            case Fo:
              return (o.displayName || "Context") + ".Provider";
            case k1:
              return (o._context.displayName || "Context") + ".Consumer";
            case Mm:
              var a = o.render;
              return o = o.displayName, o || (o = a.displayName || a.name || "", o = o !== "" ? "ForwardRef(" + o + ")" : "ForwardRef"), o;
            case Pm:
              return a = o.displayName || null, a !== null ? a : l(o.type) || "Memo";
            case jo:
              a = o._payload, o = o._init;
              try {
                return l(o(a));
              } catch {
              }
          }
        return null;
      }
      function c(o) {
        if (Dm === void 0)
          try {
            throw Error();
          } catch (f) {
            var a = f.stack.trim().match(/\n( *(at )?)/);
            Dm = a && a[1] || "", O1 = -1 < f.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < f.stack.indexOf("@") ? "@unknown:0:0" : "";
          }
        return `
` + Dm + o + O1;
      }
      function u(o, a) {
        if (!o || Im) return "";
        Im = !0;
        var f = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
          var _ = {
            DetermineComponentFrameRoot: function() {
              try {
                if (a) {
                  var ae = function() {
                    throw Error();
                  };
                  if (Object.defineProperty(ae.prototype, "props", {
                    set: function() {
                      throw Error();
                    }
                  }), typeof Reflect == "object" && Reflect.construct) {
                    try {
                      Reflect.construct(ae, []);
                    } catch (Oe) {
                      var de = Oe;
                    }
                    Reflect.construct(o, [], ae);
                  } else {
                    try {
                      ae.call();
                    } catch (Oe) {
                      de = Oe;
                    }
                    o.call(ae.prototype);
                  }
                } else {
                  try {
                    throw Error();
                  } catch (Oe) {
                    de = Oe;
                  }
                  (ae = o()) && typeof ae.catch == "function" && ae.catch(function() {
                  });
                }
              } catch (Oe) {
                if (Oe && de && typeof Oe.stack == "string")
                  return [Oe.stack, de.stack];
              }
              return [null, null];
            }
          };
          _.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
          var R = Object.getOwnPropertyDescriptor(
            _.DetermineComponentFrameRoot,
            "name"
          );
          R && R.configurable && Object.defineProperty(
            _.DetermineComponentFrameRoot,
            "name",
            { value: "DetermineComponentFrameRoot" }
          );
          var I = _.DetermineComponentFrameRoot(), Q = I[0], lt = I[1];
          if (Q && lt) {
            var St = Q.split(`
`), It = lt.split(`
`);
            for (R = _ = 0; _ < St.length && !St[_].includes("DetermineComponentFrameRoot"); )
              _++;
            for (; R < It.length && !It[R].includes(
              "DetermineComponentFrameRoot"
            ); )
              R++;
            if (_ === St.length || R === It.length)
              for (_ = St.length - 1, R = It.length - 1; 1 <= _ && 0 <= R && St[_] !== It[R]; )
                R--;
            for (; 1 <= _ && 0 <= R; _--, R--)
              if (St[_] !== It[R]) {
                if (_ !== 1 || R !== 1)
                  do
                    if (_--, R--, 0 > R || St[_] !== It[R]) {
                      var te = `
` + St[_].replace(" at new ", " at ");
                      return o.displayName && te.includes("<anonymous>") && (te = te.replace("<anonymous>", o.displayName)), te;
                    }
                  while (1 <= _ && 0 <= R);
                break;
              }
          }
        } finally {
          Im = !1, Error.prepareStackTrace = f;
        }
        return (f = o ? o.displayName || o.name : "") ? c(f) : "";
      }
      function d(o) {
        switch (o.tag) {
          case 26:
          case 27:
          case 5:
            return c(o.type);
          case 16:
            return c("Lazy");
          case 13:
            return c("Suspense");
          case 19:
            return c("SuspenseList");
          case 0:
          case 15:
            return o = u(o.type, !1), o;
          case 11:
            return o = u(o.type.render, !1), o;
          case 1:
            return o = u(o.type, !0), o;
          default:
            return "";
        }
      }
      function h(o) {
        try {
          var a = "";
          do
            a += d(o), o = o.return;
          while (o);
          return a;
        } catch (f) {
          return `
Error generating stack: ` + f.message + `
` + f.stack;
        }
      }
      function p(o) {
        var a = o, f = o;
        if (o.alternate) for (; a.return; ) a = a.return;
        else {
          o = a;
          do
            a = o, (a.flags & 4098) !== 0 && (f = a.return), o = a.return;
          while (o);
        }
        return a.tag === 3 ? f : null;
      }
      function v(o) {
        if (p(o) !== o)
          throw Error(i(188));
      }
      function m(o) {
        var a = o.alternate;
        if (!a) {
          if (a = p(o), a === null) throw Error(i(188));
          return a !== o ? null : o;
        }
        for (var f = o, _ = a; ; ) {
          var R = f.return;
          if (R === null) break;
          var I = R.alternate;
          if (I === null) {
            if (_ = R.return, _ !== null) {
              f = _;
              continue;
            }
            break;
          }
          if (R.child === I.child) {
            for (I = R.child; I; ) {
              if (I === f) return v(R), o;
              if (I === _) return v(R), a;
              I = I.sibling;
            }
            throw Error(i(188));
          }
          if (f.return !== _.return) f = R, _ = I;
          else {
            for (var Q = !1, lt = R.child; lt; ) {
              if (lt === f) {
                Q = !0, f = R, _ = I;
                break;
              }
              if (lt === _) {
                Q = !0, _ = R, f = I;
                break;
              }
              lt = lt.sibling;
            }
            if (!Q) {
              for (lt = I.child; lt; ) {
                if (lt === f) {
                  Q = !0, f = I, _ = R;
                  break;
                }
                if (lt === _) {
                  Q = !0, _ = I, f = R;
                  break;
                }
                lt = lt.sibling;
              }
              if (!Q) throw Error(i(189));
            }
          }
          if (f.alternate !== _) throw Error(i(190));
        }
        if (f.tag !== 3) throw Error(i(188));
        return f.stateNode.current === f ? o : a;
      }
      function g(o) {
        var a = o.tag;
        if (a === 5 || a === 26 || a === 27 || a === 6) return o;
        for (o = o.child; o !== null; ) {
          if (a = g(o), a !== null) return a;
          o = o.sibling;
        }
        return null;
      }
      function b(o) {
        var a = o.tag;
        if (a === 5 || a === 26 || a === 27 || a === 6) return o;
        for (o = o.child; o !== null; ) {
          if (o.tag !== 4 && (a = b(o), a !== null))
            return a;
          o = o.sibling;
        }
        return null;
      }
      function x(o) {
        return { current: o };
      }
      function w(o) {
        0 > Ql || (o.current = Um[Ql], Um[Ql] = null, Ql--);
      }
      function T(o, a) {
        Ql++, Um[Ql] = o.current, o.current = a;
      }
      function S(o) {
        return o >>>= 0, o === 0 ? 32 : 31 - (rT(o) / iT | 0) | 0;
      }
      function C(o) {
        var a = o & 42;
        if (a !== 0) return a;
        switch (o & -o) {
          case 1:
            return 1;
          case 2:
            return 2;
          case 4:
            return 4;
          case 8:
            return 8;
          case 16:
            return 16;
          case 32:
            return 32;
          case 64:
            return 64;
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return o & 4194176;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            return o & 62914560;
          case 67108864:
            return 67108864;
          case 134217728:
            return 134217728;
          case 268435456:
            return 268435456;
          case 536870912:
            return 536870912;
          case 1073741824:
            return 0;
          default:
            return o;
        }
      }
      function E(o, a) {
        var f = o.pendingLanes;
        if (f === 0) return 0;
        var _ = 0, R = o.suspendedLanes, I = o.pingedLanes, Q = o.warmLanes;
        o = o.finishedLanes !== 0;
        var lt = f & 134217727;
        return lt !== 0 ? (f = lt & ~R, f !== 0 ? _ = C(f) : (I &= lt, I !== 0 ? _ = C(I) : o || (Q = lt & ~Q, Q !== 0 && (_ = C(Q))))) : (lt = f & ~R, lt !== 0 ? _ = C(lt) : I !== 0 ? _ = C(I) : o || (Q = f & ~Q, Q !== 0 && (_ = C(Q)))), _ === 0 ? 0 : a !== 0 && a !== _ && (a & R) === 0 && (R = _ & -_, Q = a & -a, R >= Q || R === 32 && (Q & 4194176) !== 0) ? a : _;
      }
      function O(o, a) {
        return (o.pendingLanes & ~(o.suspendedLanes & ~o.pingedLanes) & a) === 0;
      }
      function B(o, a) {
        switch (o) {
          case 1:
          case 2:
          case 4:
          case 8:
            return a + 250;
          case 16:
          case 32:
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return a + 5e3;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            return -1;
          case 67108864:
          case 134217728:
          case 268435456:
          case 536870912:
          case 1073741824:
            return -1;
          default:
            return -1;
        }
      }
      function N() {
        var o = Zh;
        return Zh <<= 1, (Zh & 4194176) === 0 && (Zh = 128), o;
      }
      function L() {
        var o = Jh;
        return Jh <<= 1, (Jh & 62914560) === 0 && (Jh = 4194304), o;
      }
      function k(o) {
        for (var a = [], f = 0; 31 > f; f++) a.push(o);
        return a;
      }
      function F(o, a) {
        o.pendingLanes |= a, a !== 268435456 && (o.suspendedLanes = 0, o.pingedLanes = 0, o.warmLanes = 0);
      }
      function G(o, a, f, _, R, I) {
        var Q = o.pendingLanes;
        o.pendingLanes = f, o.suspendedLanes = 0, o.pingedLanes = 0, o.warmLanes = 0, o.expiredLanes &= f, o.entangledLanes &= f, o.errorRecoveryDisabledLanes &= f, o.shellSuspendCounter = 0;
        var lt = o.entanglements, St = o.expirationTimes, It = o.hiddenUpdates;
        for (f = Q & ~f; 0 < f; ) {
          var te = 31 - gi(f), ae = 1 << te;
          lt[te] = 0, St[te] = -1;
          var de = It[te];
          if (de !== null)
            for (It[te] = null, te = 0; te < de.length; te++) {
              var Oe = de[te];
              Oe !== null && (Oe.lane &= -536870913);
            }
          f &= ~ae;
        }
        _ !== 0 && M(o, _, 0), I !== 0 && R === 0 && o.tag !== 0 && (o.suspendedLanes |= I & ~(Q & ~a));
      }
      function M(o, a, f) {
        o.pendingLanes |= a, o.suspendedLanes &= ~a;
        var _ = 31 - gi(a);
        o.entangledLanes |= a, o.entanglements[_] = o.entanglements[_] | 1073741824 | f & 4194218;
      }
      function j(o, a) {
        var f = o.entangledLanes |= a;
        for (o = o.entanglements; f; ) {
          var _ = 31 - gi(f), R = 1 << _;
          R & a | o[_] & a && (o[_] |= a), f &= ~R;
        }
      }
      function D(o) {
        return o &= -o, 2 < o ? 8 < o ? (o & 134217727) !== 0 ? 32 : 268435456 : 8 : 2;
      }
      function z(o) {
        if (yi && typeof yi.onCommitFiberRoot == "function")
          try {
            yi.onCommitFiberRoot(
              Ru,
              o,
              void 0,
              (o.current.flags & 128) === 128
            );
          } catch {
          }
      }
      function H(o) {
        if (typeof cT == "function" && uT(o), yi && typeof yi.setStrictMode == "function")
          try {
            yi.setStrictMode(Ru, o);
          } catch {
          }
      }
      function X(o, a) {
        return o === a && (o !== 0 || 1 / o === 1 / a) || o !== o && a !== a;
      }
      function Y(o, a) {
        if (typeof o == "object" && o !== null) {
          var f = rv.get(o);
          return f !== void 0 ? f : (a = {
            value: o,
            source: a,
            stack: h(a)
          }, rv.set(o, a), a);
        }
        return {
          value: o,
          source: a,
          stack: h(a)
        };
      }
      function V(o, a) {
        Jl[tc++] = nf, Jl[tc++] = ef, ef = o, nf = a;
      }
      function Z(o, a, f) {
        Pi[Di++] = to, Pi[Di++] = eo, Pi[Di++] = La, La = o;
        var _ = to;
        o = eo;
        var R = 32 - gi(_) - 1;
        _ &= ~(1 << R), f += 1;
        var I = 32 - gi(a) + R;
        if (30 < I) {
          var Q = R - R % 5;
          I = (_ & (1 << Q) - 1).toString(32), _ >>= Q, R -= Q, to = 1 << 32 - gi(a) + R | f << R | _, eo = I + o;
        } else
          to = 1 << I | f << R | _, eo = o;
      }
      function ct(o) {
        o.return !== null && (V(o, 1), Z(o, 1, 0));
      }
      function et(o) {
        for (; o === ef; )
          ef = Jl[--tc], Jl[tc] = null, nf = Jl[--tc], Jl[tc] = null;
        for (; o === La; )
          La = Pi[--Di], Pi[Di] = null, eo = Pi[--Di], Pi[Di] = null, to = Pi[--Di], Pi[Di] = null;
      }
      function rt(o, a) {
        T(zo, a), T(Mu, o), T(Tr, null), o = Hx(a), w(Tr), T(Tr, o);
      }
      function st() {
        w(Tr), w(Mu), w(zo);
      }
      function yt(o) {
        o.memoizedState !== null && T(rf, o);
        var a = Tr.current, f = Wx(a, o.type);
        a !== f && (T(Mu, o), T(Tr, f));
      }
      function J(o) {
        Mu.current === o && (w(Tr), w(Mu)), rf.current === o && (w(rf), Js ? ja._currentValue = Xl : ja._currentValue2 = Xl);
      }
      function tt(o) {
        var a = Error(i(418, ""));
        throw Ht(Y(a, o)), qm;
      }
      function ot(o, a) {
        if (!Oi) throw Error(i(175));
        L4(
          o.stateNode,
          o.type,
          o.memoizedProps,
          a,
          o
        ) || tt(o);
      }
      function Tt(o) {
        for (qr = o.return; qr; )
          switch (qr.tag) {
            case 3:
            case 27:
              bs = !0;
              return;
            case 5:
            case 13:
              bs = !1;
              return;
            default:
              qr = qr.return;
          }
      }
      function Ct(o) {
        if (!Oi || o !== qr) return !1;
        if (!Je) return Tt(o), Je = !0, !1;
        var a = !1;
        if (Pr ? o.tag !== 3 && o.tag !== 27 && (o.tag !== 5 || W1(o.type) && !Qh(o.type, o.memoizedProps)) && (a = !0) : o.tag !== 3 && (o.tag !== 5 || W1(o.type) && !Qh(o.type, o.memoizedProps)) && (a = !0), a && Dr && tt(o), Tt(o), o.tag === 13) {
          if (!Oi) throw Error(i(316));
          if (o = o.memoizedState, o = o !== null ? o.dehydrated : null, !o) throw Error(i(317));
          Dr = V4(o);
        } else
          Dr = qr ? q1(o.stateNode) : null;
        return !0;
      }
      function bt() {
        Oi && (Dr = qr = null, Je = !1);
      }
      function Ht(o) {
        is === null ? is = [o] : is.push(o);
      }
      function $t() {
        for (var o = ec, a = Hm = ec = 0; a < o; ) {
          var f = Ii[a];
          Ii[a++] = null;
          var _ = Ii[a];
          Ii[a++] = null;
          var R = Ii[a];
          Ii[a++] = null;
          var I = Ii[a];
          if (Ii[a++] = null, _ !== null && R !== null) {
            var Q = _.pending;
            Q === null ? R.next = R : (R.next = Q.next, Q.next = R), _.pending = R;
          }
          I !== 0 && ne(f, R, I);
        }
      }
      function wt(o, a, f, _) {
        Ii[ec++] = o, Ii[ec++] = a, Ii[ec++] = f, Ii[ec++] = _, Hm |= _, o.lanes |= _, o = o.alternate, o !== null && (o.lanes |= _);
      }
      function Wt(o, a, f, _) {
        return wt(o, a, f, _), ce(o);
      }
      function Ut(o, a) {
        return wt(o, null, null, a), ce(o);
      }
      function ne(o, a, f) {
        o.lanes |= f;
        var _ = o.alternate;
        _ !== null && (_.lanes |= f);
        for (var R = !1, I = o.return; I !== null; )
          I.childLanes |= f, _ = I.alternate, _ !== null && (_.childLanes |= f), I.tag === 22 && (o = I.stateNode, o === null || o._visibility & 1 || (R = !0)), o = I, I = I.return;
        R && a !== null && o.tag === 3 && (I = o.stateNode, R = 31 - gi(f), I = I.hiddenUpdates, o = I[R], o === null ? I[R] = [a] : o.push(a), a.lane = f | 536870912);
      }
      function ce(o) {
        if (50 < Lu)
          throw Lu = 0, ag = null, Error(i(185));
        for (var a = o.return; a !== null; )
          o = a, a = o.return;
        return o.tag === 3 ? o.stateNode : null;
      }
      function re(o) {
        o !== nc && o.next === null && (nc === null ? sf = nc = o : nc = nc.next = o), of = !0, Wm || (Wm = !0, Bt(Lt));
      }
      function le(o, a) {
        if (!$m && of) {
          $m = !0;
          do
            for (var f = !1, _ = sf; _ !== null; ) {
              if (o !== 0) {
                var R = _.pendingLanes;
                if (R === 0) var I = 0;
                else {
                  var Q = _.suspendedLanes, lt = _.pingedLanes;
                  I = (1 << 31 - gi(42 | o) + 1) - 1, I &= R & ~(Q & ~lt), I = I & 201326677 ? I & 201326677 | 1 : I ? I | 2 : 0;
                }
                I !== 0 && (f = !0, Nt(_, I));
              } else
                I = Ye, I = E(
                  _,
                  _ === bn ? I : 0
                ), (I & 3) === 0 || O(_, I) || (f = !0, Nt(_, I));
              _ = _.next;
            }
          while (f);
          $m = !1;
        }
      }
      function Lt() {
        of = Wm = !1;
        var o = 0;
        rc !== 0 && (t4() && (o = rc), rc = 0);
        for (var a = rs(), f = null, _ = sf; _ !== null; ) {
          var R = _.next, I = ye(_, a);
          I === 0 ? (_.next = null, f === null ? sf = R : f.next = R, R === null && (nc = f)) : (f = _, (o !== 0 || (I & 3) !== 0) && (of = !0)), _ = R;
        }
        le(o);
      }
      function ye(o, a) {
        for (var f = o.suspendedLanes, _ = o.pingedLanes, R = o.expirationTimes, I = o.pendingLanes & -62914561; 0 < I; ) {
          var Q = 31 - gi(I), lt = 1 << Q, St = R[Q];
          St === -1 ? ((lt & f) === 0 || (lt & _) !== 0) && (R[Q] = B(lt, a)) : St <= a && (o.expiredLanes |= lt), I &= ~lt;
        }
        if (a = bn, f = Ye, f = E(
          o,
          o === a ? f : 0
        ), _ = o.callbackNode, f === 0 || o === a && _n === 2 || o.cancelPendingCommit !== null)
          return _ !== null && _ !== null && Vm(_), o.callbackNode = null, o.callbackPriority = 0;
        if ((f & 3) === 0 || O(o, f)) {
          if (a = f & -f, a === o.callbackPriority) return a;
          switch (_ !== null && Vm(_), D(f)) {
            case 2:
            case 8:
              f = aT;
              break;
            case 32:
              f = Gm;
              break;
            case 268435456:
              f = lT;
              break;
            default:
              f = Gm;
          }
          return _ = be.bind(null, o), f = tf(f, _), o.callbackPriority = a, o.callbackNode = f, a;
        }
        return _ !== null && _ !== null && Vm(_), o.callbackPriority = 2, o.callbackNode = null, 2;
      }
      function be(o, a) {
        var f = o.callbackNode;
        if (Ia() && o.callbackNode !== f)
          return null;
        var _ = Ye;
        return _ = E(
          o,
          o === bn ? _ : 0
        ), _ === 0 ? null : (o1(o, _, a), ye(o, rs()), o.callbackNode != null && o.callbackNode === f ? be.bind(null, o) : null);
      }
      function Nt(o, a) {
        if (Ia()) return null;
        o1(o, a, !0);
      }
      function Bt(o) {
        o4 ? a4(function() {
          (fn & 6) !== 0 ? tf(nv, o) : o();
        }) : tf(nv, o);
      }
      function Rt() {
        return rc === 0 && (rc = N()), rc;
      }
      function Dt(o, a) {
        if (Ou === null) {
          var f = Ou = [];
          Km = 0, ic = Rt(), sc = {
            status: "pending",
            value: void 0,
            then: function(_) {
              f.push(_);
            }
          };
        }
        return Km++, a.then(jt, jt), a;
      }
      function jt() {
        if (--Km === 0 && Ou !== null) {
          sc !== null && (sc.status = "fulfilled");
          var o = Ou;
          Ou = null, ic = 0, sc = null;
          for (var a = 0; a < o.length; a++) (0, o[a])();
        }
      }
      function Ft(o, a) {
        var f = [], _ = {
          status: "pending",
          value: null,
          reason: null,
          then: function(R) {
            f.push(R);
          }
        };
        return o.then(
          function() {
            _.status = "fulfilled", _.value = a;
            for (var R = 0; R < f.length; R++) (0, f[R])(a);
          },
          function(R) {
            for (_.status = "rejected", _.reason = R, R = 0; R < f.length; R++)
              (0, f[R])(void 0);
          }
        ), _;
      }
      function Vt(o) {
        o.updateQueue = {
          baseState: o.memoizedState,
          firstBaseUpdate: null,
          lastBaseUpdate: null,
          shared: { pending: null, lanes: 0, hiddenCallbacks: null },
          callbacks: null
        };
      }
      function Yt(o, a) {
        o = o.updateQueue, a.updateQueue === o && (a.updateQueue = {
          baseState: o.baseState,
          firstBaseUpdate: o.firstBaseUpdate,
          lastBaseUpdate: o.lastBaseUpdate,
          shared: o.shared,
          callbacks: null
        });
      }
      function ee(o) {
        return { lane: o, tag: 0, payload: null, callback: null, next: null };
      }
      function fe(o, a, f) {
        var _ = o.updateQueue;
        if (_ === null) return null;
        if (_ = _.shared, (fn & 2) !== 0) {
          var R = _.pending;
          return R === null ? a.next = a : (a.next = R.next, R.next = a), _.pending = a, a = ce(o), ne(o, null, f), a;
        }
        return wt(o, _, a, f), ce(o);
      }
      function ie(o, a, f) {
        if (a = a.updateQueue, a !== null && (a = a.shared, (f & 4194176) !== 0)) {
          var _ = a.lanes;
          _ &= o.pendingLanes, f |= _, a.lanes = f, j(o, f);
        }
      }
      function zt(o, a) {
        var f = o.updateQueue, _ = o.alternate;
        if (_ !== null && (_ = _.updateQueue, f === _)) {
          var R = null, I = null;
          if (f = f.firstBaseUpdate, f !== null) {
            do {
              var Q = {
                lane: f.lane,
                tag: f.tag,
                payload: f.payload,
                callback: null,
                next: null
              };
              I === null ? R = I = Q : I = I.next = Q, f = f.next;
            } while (f !== null);
            I === null ? R = I = a : I = I.next = a;
          } else R = I = a;
          f = {
            baseState: _.baseState,
            firstBaseUpdate: R,
            lastBaseUpdate: I,
            shared: _.shared,
            callbacks: _.callbacks
          }, o.updateQueue = f;
          return;
        }
        o = f.lastBaseUpdate, o === null ? f.firstBaseUpdate = a : o.next = a, f.lastBaseUpdate = a;
      }
      function Pe() {
        if (Ym) {
          var o = sc;
          if (o !== null) throw o;
        }
      }
      function je(o, a, f, _) {
        Ym = !1;
        var R = o.updateQueue;
        Uo = !1;
        var I = R.firstBaseUpdate, Q = R.lastBaseUpdate, lt = R.shared.pending;
        if (lt !== null) {
          R.shared.pending = null;
          var St = lt, It = St.next;
          St.next = null, Q === null ? I = It : Q.next = It, Q = St;
          var te = o.alternate;
          te !== null && (te = te.updateQueue, lt = te.lastBaseUpdate, lt !== Q && (lt === null ? te.firstBaseUpdate = It : lt.next = It, te.lastBaseUpdate = St));
        }
        if (I !== null) {
          var ae = R.baseState;
          Q = 0, te = It = St = null, lt = I;
          do {
            var de = lt.lane & -536870913, Oe = de !== lt.lane;
            if (Oe ? (Ye & de) === de : (_ & de) === de) {
              de !== 0 && de === ic && (Ym = !0), te !== null && (te = te.next = {
                lane: 0,
                tag: lt.tag,
                payload: lt.payload,
                callback: null,
                next: null
              });
              t: {
                var ji = o, zu = lt;
                de = a;
                var Ka = f;
                switch (zu.tag) {
                  case 1:
                    if (ji = zu.payload, typeof ji == "function") {
                      ae = ji.call(
                        Ka,
                        ae,
                        de
                      );
                      break t;
                    }
                    ae = ji;
                    break t;
                  case 3:
                    ji.flags = ji.flags & -65537 | 128;
                  case 0:
                    if (ji = zu.payload, de = typeof ji == "function" ? ji.call(Ka, ae, de) : ji, de == null) break t;
                    ae = km({}, ae, de);
                    break t;
                  case 2:
                    Uo = !0;
                }
              }
              de = lt.callback, de !== null && (o.flags |= 64, Oe && (o.flags |= 8192), Oe = R.callbacks, Oe === null ? R.callbacks = [de] : Oe.push(de));
            } else
              Oe = {
                lane: de,
                tag: lt.tag,
                payload: lt.payload,
                callback: lt.callback,
                next: null
              }, te === null ? (It = te = Oe, St = ae) : te = te.next = Oe, Q |= de;
            if (lt = lt.next, lt === null) {
              if (lt = R.shared.pending, lt === null)
                break;
              Oe = lt, lt = Oe.next, Oe.next = null, R.lastBaseUpdate = Oe, R.shared.pending = null;
            }
          } while (!0);
          te === null && (St = ae), R.baseState = St, R.firstBaseUpdate = It, R.lastBaseUpdate = te, I === null && (R.shared.lanes = 0), qo |= Q, o.lanes = Q, o.memoizedState = ae;
        }
      }
      function cr(o, a) {
        if (typeof o != "function")
          throw Error(i(191, o));
        o.call(a);
      }
      function se(o, a) {
        var f = o.callbacks;
        if (f !== null)
          for (o.callbacks = null, o = 0; o < f.length; o++)
            cr(f[o], a);
      }
      function Sr(o, a) {
        if (vi(o, a)) return !0;
        if (typeof o != "object" || o === null || typeof a != "object" || a === null)
          return !1;
        var f = Object.keys(o), _ = Object.keys(a);
        if (f.length !== _.length) return !1;
        for (_ = 0; _ < f.length; _++) {
          var R = f[_];
          if (!dT.call(a, R) || !vi(o[R], a[R]))
            return !1;
        }
        return !0;
      }
      function on(o) {
        return o = o.status, o === "fulfilled" || o === "rejected";
      }
      function Le() {
      }
      function ai(o, a, f) {
        switch (f = o[f], f === void 0 ? o.push(a) : f !== a && (a.then(Le, Le), a = f), a.status) {
          case "fulfilled":
            return a.value;
          case "rejected":
            throw o = a.reason, o === Nu ? Error(i(483)) : o;
          default:
            if (typeof a.status == "string") a.then(Le, Le);
            else {
              if (o = bn, o !== null && 100 < o.shellSuspendCounter)
                throw Error(i(482));
              o = a, o.status = "pending", o.then(
                function(_) {
                  if (a.status === "pending") {
                    var R = a;
                    R.status = "fulfilled", R.value = _;
                  }
                },
                function(_) {
                  if (a.status === "pending") {
                    var R = a;
                    R.status = "rejected", R.reason = _;
                  }
                }
              );
            }
            switch (a.status) {
              case "fulfilled":
                return a.value;
              case "rejected":
                throw o = a.reason, o === Nu ? Error(i(483)) : o;
            }
            throw oc = a, Nu;
        }
      }
      function kr() {
        if (oc === null) throw Error(i(459));
        var o = oc;
        return oc = null, o;
      }
      function ur(o) {
        var a = Pu;
        return Pu += 1, ac === null && (ac = []), ai(ac, o, a);
      }
      function _e(o, a) {
        a = a.props.ref, o.ref = a !== void 0 ? a : null;
      }
      function Nn(o, a) {
        throw a.$$typeof === Lx ? Error(i(525)) : (o = Object.prototype.toString.call(a), Error(
          i(
            31,
            o === "[object Object]" ? "object with keys {" + Object.keys(a).join(", ") + "}" : o
          )
        ));
      }
      function Ri(o) {
        var a = o._init;
        return a(o._payload);
      }
      function xl(o) {
        function a(At, vt) {
          if (o) {
            var Mt = At.deletions;
            Mt === null ? (At.deletions = [vt], At.flags |= 16) : Mt.push(vt);
          }
        }
        function f(At, vt) {
          if (!o) return null;
          for (; vt !== null; )
            a(At, vt), vt = vt.sibling;
          return null;
        }
        function _(At) {
          for (var vt = /* @__PURE__ */ new Map(); At !== null; )
            At.key !== null ? vt.set(At.key, At) : vt.set(At.index, At), At = At.sibling;
          return vt;
        }
        function R(At, vt) {
          return At = Bo(At, vt), At.index = 0, At.sibling = null, At;
        }
        function I(At, vt, Mt) {
          return At.index = Mt, o ? (Mt = At.alternate, Mt !== null ? (Mt = Mt.index, Mt < vt ? (At.flags |= 33554434, vt) : Mt) : (At.flags |= 33554434, vt)) : (At.flags |= 1048576, vt);
        }
        function Q(At) {
          return o && At.alternate === null && (At.flags |= 33554434), At;
        }
        function lt(At, vt, Mt, Kt) {
          return vt === null || vt.tag !== 6 ? (vt = wm(Mt, At.mode, Kt), vt.return = At, vt) : (vt = R(vt, Mt), vt.return = At, vt);
        }
        function St(At, vt, Mt, Kt) {
          var me = Mt.type;
          return me === Yl ? te(
            At,
            vt,
            Mt.props.children,
            Kt,
            Mt.key
          ) : vt !== null && (vt.elementType === me || typeof me == "object" && me !== null && me.$$typeof === jo && Ri(me) === vt.type) ? (vt = R(vt, Mt.props), _e(vt, Mt), vt.return = At, vt) : (vt = Kh(
            Mt.type,
            Mt.key,
            Mt.props,
            null,
            At.mode,
            Kt
          ), _e(vt, Mt), vt.return = At, vt);
        }
        function It(At, vt, Mt, Kt) {
          return vt === null || vt.tag !== 4 || vt.stateNode.containerInfo !== Mt.containerInfo || vt.stateNode.implementation !== Mt.implementation ? (vt = Em(Mt, At.mode, Kt), vt.return = At, vt) : (vt = R(vt, Mt.children || []), vt.return = At, vt);
        }
        function te(At, vt, Mt, Kt, me) {
          return vt === null || vt.tag !== 7 ? (vt = Ba(
            Mt,
            At.mode,
            Kt,
            me
          ), vt.return = At, vt) : (vt = R(vt, Mt), vt.return = At, vt);
        }
        function ae(At, vt, Mt) {
          if (typeof vt == "string" && vt !== "" || typeof vt == "number" || typeof vt == "bigint")
            return vt = wm(
              "" + vt,
              At.mode,
              Mt
            ), vt.return = At, vt;
          if (typeof vt == "object" && vt !== null) {
            switch (vt.$$typeof) {
              case Yh:
                return Mt = Kh(
                  vt.type,
                  vt.key,
                  vt.props,
                  null,
                  At.mode,
                  Mt
                ), _e(Mt, vt), Mt.return = At, Mt;
              case Kl:
                return vt = Em(
                  vt,
                  At.mode,
                  Mt
                ), vt.return = At, vt;
              case jo:
                var Kt = vt._init;
                return vt = Kt(vt._payload), ae(At, vt, Mt);
            }
            if (Xh(vt) || s(vt))
              return vt = Ba(
                vt,
                At.mode,
                Mt,
                null
              ), vt.return = At, vt;
            if (typeof vt.then == "function")
              return ae(At, ur(vt), Mt);
            if (vt.$$typeof === Fo)
              return ae(
                At,
                Na(At, vt),
                Mt
              );
            Nn(At, vt);
          }
          return null;
        }
        function de(At, vt, Mt, Kt) {
          var me = vt !== null ? vt.key : null;
          if (typeof Mt == "string" && Mt !== "" || typeof Mt == "number" || typeof Mt == "bigint")
            return me !== null ? null : lt(At, vt, "" + Mt, Kt);
          if (typeof Mt == "object" && Mt !== null) {
            switch (Mt.$$typeof) {
              case Yh:
                return Mt.key === me ? St(At, vt, Mt, Kt) : null;
              case Kl:
                return Mt.key === me ? It(At, vt, Mt, Kt) : null;
              case jo:
                return me = Mt._init, Mt = me(Mt._payload), de(At, vt, Mt, Kt);
            }
            if (Xh(Mt) || s(Mt))
              return me !== null ? null : te(At, vt, Mt, Kt, null);
            if (typeof Mt.then == "function")
              return de(
                At,
                vt,
                ur(Mt),
                Kt
              );
            if (Mt.$$typeof === Fo)
              return de(
                At,
                vt,
                Na(At, Mt),
                Kt
              );
            Nn(At, Mt);
          }
          return null;
        }
        function Oe(At, vt, Mt, Kt, me) {
          if (typeof Kt == "string" && Kt !== "" || typeof Kt == "number" || typeof Kt == "bigint")
            return At = At.get(Mt) || null, lt(vt, At, "" + Kt, me);
          if (typeof Kt == "object" && Kt !== null) {
            switch (Kt.$$typeof) {
              case Yh:
                return At = At.get(
                  Kt.key === null ? Mt : Kt.key
                ) || null, St(vt, At, Kt, me);
              case Kl:
                return At = At.get(
                  Kt.key === null ? Mt : Kt.key
                ) || null, It(vt, At, Kt, me);
              case jo:
                var wn = Kt._init;
                return Kt = wn(Kt._payload), Oe(
                  At,
                  vt,
                  Mt,
                  Kt,
                  me
                );
            }
            if (Xh(Kt) || s(Kt))
              return At = At.get(Mt) || null, te(vt, At, Kt, me, null);
            if (typeof Kt.then == "function")
              return Oe(
                At,
                vt,
                Mt,
                ur(Kt),
                me
              );
            if (Kt.$$typeof === Fo)
              return Oe(
                At,
                vt,
                Mt,
                Na(vt, Kt),
                me
              );
            Nn(vt, Kt);
          }
          return null;
        }
        function ji(At, vt, Mt, Kt) {
          for (var me = null, wn = null, Se = vt, tn = vt = 0, yr = null; Se !== null && tn < Mt.length; tn++) {
            Se.index > tn ? (yr = Se, Se = null) : yr = Se.sibling;
            var en = de(
              At,
              Se,
              Mt[tn],
              Kt
            );
            if (en === null) {
              Se === null && (Se = yr);
              break;
            }
            o && Se && en.alternate === null && a(At, Se), vt = I(en, vt, tn), wn === null ? me = en : wn.sibling = en, wn = en, Se = yr;
          }
          if (tn === Mt.length)
            return f(At, Se), Je && V(At, tn), me;
          if (Se === null) {
            for (; tn < Mt.length; tn++)
              Se = ae(At, Mt[tn], Kt), Se !== null && (vt = I(
                Se,
                vt,
                tn
              ), wn === null ? me = Se : wn.sibling = Se, wn = Se);
            return Je && V(At, tn), me;
          }
          for (Se = _(Se); tn < Mt.length; tn++)
            yr = Oe(
              Se,
              At,
              tn,
              Mt[tn],
              Kt
            ), yr !== null && (o && yr.alternate !== null && Se.delete(
              yr.key === null ? tn : yr.key
            ), vt = I(
              yr,
              vt,
              tn
            ), wn === null ? me = yr : wn.sibling = yr, wn = yr);
          return o && Se.forEach(function(Wo) {
            return a(At, Wo);
          }), Je && V(At, tn), me;
        }
        function zu(At, vt, Mt, Kt) {
          if (Mt == null) throw Error(i(151));
          for (var me = null, wn = null, Se = vt, tn = vt = 0, yr = null, en = Mt.next(); Se !== null && !en.done; tn++, en = Mt.next()) {
            Se.index > tn ? (yr = Se, Se = null) : yr = Se.sibling;
            var Wo = de(At, Se, en.value, Kt);
            if (Wo === null) {
              Se === null && (Se = yr);
              break;
            }
            o && Se && Wo.alternate === null && a(At, Se), vt = I(Wo, vt, tn), wn === null ? me = Wo : wn.sibling = Wo, wn = Wo, Se = yr;
          }
          if (en.done)
            return f(At, Se), Je && V(At, tn), me;
          if (Se === null) {
            for (; !en.done; tn++, en = Mt.next())
              en = ae(At, en.value, Kt), en !== null && (vt = I(
                en,
                vt,
                tn
              ), wn === null ? me = en : wn.sibling = en, wn = en);
            return Je && V(At, tn), me;
          }
          for (Se = _(Se); !en.done; tn++, en = Mt.next())
            en = Oe(
              Se,
              At,
              tn,
              en.value,
              Kt
            ), en !== null && (o && en.alternate !== null && Se.delete(en.key === null ? tn : en.key), vt = I(en, vt, tn), wn === null ? me = en : wn.sibling = en, wn = en);
          return o && Se.forEach(function(vT) {
            return a(At, vT);
          }), Je && V(At, tn), me;
        }
        function Ka(At, vt, Mt, Kt) {
          if (typeof Mt == "object" && Mt !== null && Mt.type === Yl && Mt.key === null && (Mt = Mt.props.children), typeof Mt == "object" && Mt !== null) {
            switch (Mt.$$typeof) {
              case Yh:
                t: {
                  for (var me = Mt.key; vt !== null; ) {
                    if (vt.key === me) {
                      if (me = Mt.type, me === Yl) {
                        if (vt.tag === 7) {
                          f(
                            At,
                            vt.sibling
                          ), Kt = R(
                            vt,
                            Mt.props.children
                          ), Kt.return = At, At = Kt;
                          break t;
                        }
                      } else if (vt.elementType === me || typeof me == "object" && me !== null && me.$$typeof === jo && Ri(me) === vt.type) {
                        f(
                          At,
                          vt.sibling
                        ), Kt = R(vt, Mt.props), _e(Kt, Mt), Kt.return = At, At = Kt;
                        break t;
                      }
                      f(At, vt);
                      break;
                    } else a(At, vt);
                    vt = vt.sibling;
                  }
                  Mt.type === Yl ? (Kt = Ba(
                    Mt.props.children,
                    At.mode,
                    Kt,
                    Mt.key
                  ), Kt.return = At, At = Kt) : (Kt = Kh(
                    Mt.type,
                    Mt.key,
                    Mt.props,
                    null,
                    At.mode,
                    Kt
                  ), _e(Kt, Mt), Kt.return = At, At = Kt);
                }
                return Q(At);
              case Kl:
                t: {
                  for (me = Mt.key; vt !== null; ) {
                    if (vt.key === me)
                      if (vt.tag === 4 && vt.stateNode.containerInfo === Mt.containerInfo && vt.stateNode.implementation === Mt.implementation) {
                        f(
                          At,
                          vt.sibling
                        ), Kt = R(
                          vt,
                          Mt.children || []
                        ), Kt.return = At, At = Kt;
                        break t;
                      } else {
                        f(At, vt);
                        break;
                      }
                    else a(At, vt);
                    vt = vt.sibling;
                  }
                  Kt = Em(Mt, At.mode, Kt), Kt.return = At, At = Kt;
                }
                return Q(At);
              case jo:
                return me = Mt._init, Mt = me(Mt._payload), Ka(
                  At,
                  vt,
                  Mt,
                  Kt
                );
            }
            if (Xh(Mt))
              return ji(
                At,
                vt,
                Mt,
                Kt
              );
            if (s(Mt)) {
              if (me = s(Mt), typeof me != "function")
                throw Error(i(150));
              return Mt = me.call(Mt), zu(
                At,
                vt,
                Mt,
                Kt
              );
            }
            if (typeof Mt.then == "function")
              return Ka(
                At,
                vt,
                ur(Mt),
                Kt
              );
            if (Mt.$$typeof === Fo)
              return Ka(
                At,
                vt,
                Na(At, Mt),
                Kt
              );
            Nn(At, Mt);
          }
          return typeof Mt == "string" && Mt !== "" || typeof Mt == "number" || typeof Mt == "bigint" ? (Mt = "" + Mt, vt !== null && vt.tag === 6 ? (f(At, vt.sibling), Kt = R(vt, Mt), Kt.return = At, At = Kt) : (f(At, vt), Kt = wm(Mt, At.mode, Kt), Kt.return = At, At = Kt), Q(At)) : f(At, vt);
        }
        return function(At, vt, Mt, Kt) {
          try {
            Pu = 0;
            var me = Ka(
              At,
              vt,
              Mt,
              Kt
            );
            return ac = null, me;
          } catch (Se) {
            if (Se === Nu) throw Se;
            var wn = n(29, Se, null, At.mode);
            return wn.lanes = Kt, wn.return = At, wn;
          } finally {
          }
        };
      }
      function ua(o, a) {
        o = so, T(lf, o), T(lc, a), so = o | a.baseLanes;
      }
      function dn() {
        T(lf, so), T(lc, lc.current);
      }
      function Dn() {
        so = lf.current, w(lc), w(lf);
      }
      function fs(o) {
        var a = o.alternate;
        T(sr, sr.current & 1), T(Bi, o), _s === null && (a === null || lc.current !== null || a.memoizedState !== null) && (_s = o);
      }
      function da(o) {
        if (o.tag === 22) {
          if (T(sr, sr.current), T(Bi, o), _s === null) {
            var a = o.alternate;
            a !== null && a.memoizedState !== null && (_s = o);
          }
        } else li();
      }
      function li() {
        T(sr, sr.current), T(Bi, Bi.current);
      }
      function Xr(o) {
        w(Bi), _s === o && (_s = null), w(sr);
      }
      function Tl(o) {
        for (var a = o; a !== null; ) {
          if (a.tag === 13) {
            var f = a.memoizedState;
            if (f !== null && (f = f.dehydrated, f === null || jm(f) || Lm(f)))
              return a;
          } else if (a.tag === 19 && a.memoizedProps.revealOrder !== void 0) {
            if ((a.flags & 128) !== 0) return a;
          } else if (a.child !== null) {
            a.child.return = a, a = a.child;
            continue;
          }
          if (a === o) break;
          for (; a.sibling === null; ) {
            if (a.return === null || a.return === o) return null;
            a = a.return;
          }
          a.sibling.return = a.return, a = a.sibling;
        }
        return null;
      }
      function an() {
        throw Error(i(321));
      }
      function ps(o, a) {
        if (a === null) return !1;
        for (var f = 0; f < a.length && f < o.length; f++)
          if (!vi(o[f], a[f])) return !1;
        return !0;
      }
      function Mi(o, a, f, _, R, I) {
        return Vo = I, De = a, a.memoizedState = null, a.updateQueue = null, a.lanes = 0, Ee.H = o === null || o.memoizedState === null ? Va : Go, Ua = !1, I = f(_, R), Ua = !1, cc && (I = Bh(
          a,
          f,
          _,
          R
        )), ha(o), I;
      }
      function ha(o) {
        Ee.H = Ss;
        var a = hn !== null && hn.next !== null;
        if (Vo = 0, Qn = hn = De = null, cf = !1, Du = 0, uc = null, a) throw Error(i(300));
        o === null || mr || (o = o.dependencies, o !== null && Po(o) && (mr = !0));
      }
      function Bh(o, a, f, _) {
        De = o;
        var R = 0;
        do {
          if (cc && (uc = null), Du = 0, cc = !1, 25 <= R) throw Error(i(301));
          if (R += 1, Qn = hn = null, o.updateQueue != null) {
            var I = o.updateQueue;
            I.lastEffect = null, I.events = null, I.stores = null, I.memoCache != null && (I.memoCache.index = 0);
          }
          Ee.H = Ga, I = a(f, _);
        } while (cc);
        return I;
      }
      function ms() {
        var o = Ee.H, a = o.useState()[0];
        return a = typeof a.then == "function" ? ci(a) : a, o = o.useState()[0], (hn !== null ? hn.memoizedState : null) !== o && (De.flags |= 1024), a;
      }
      function Cl() {
        var o = uf !== 0;
        return uf = 0, o;
      }
      function Ki(o, a, f) {
        a.updateQueue = o.updateQueue, a.flags &= -2053, o.lanes &= ~f;
      }
      function wl(o) {
        if (cf) {
          for (o = o.memoizedState; o !== null; ) {
            var a = o.queue;
            a !== null && (a.pending = null), o = o.next;
          }
          cf = !1;
        }
        Vo = 0, Qn = hn = De = null, cc = !1, Du = uf = 0, uc = null;
      }
      function dr() {
        var o = {
          memoizedState: null,
          baseState: null,
          baseQueue: null,
          queue: null,
          next: null
        };
        return Qn === null ? De.memoizedState = Qn = o : Qn = Qn.next = o, Qn;
      }
      function Me() {
        if (hn === null) {
          var o = De.alternate;
          o = o !== null ? o.memoizedState : null;
        } else o = hn.next;
        var a = Qn === null ? De.memoizedState : Qn.next;
        if (a !== null)
          Qn = a, hn = o;
        else {
          if (o === null)
            throw De.alternate === null ? Error(i(467)) : Error(i(310));
          hn = o, o = {
            memoizedState: hn.memoizedState,
            baseState: hn.baseState,
            baseQueue: hn.baseQueue,
            queue: hn.queue,
            next: null
          }, Qn === null ? De.memoizedState = Qn = o : Qn = Qn.next = o;
        }
        return Qn;
      }
      function ci(o) {
        var a = Du;
        return Du += 1, uc === null && (uc = []), o = ai(uc, o, a), a = De, (Qn === null ? a.memoizedState : Qn.next) === null && (a = a.alternate, Ee.H = a === null || a.memoizedState === null ? Va : Go), o;
      }
      function Qr(o) {
        if (o !== null && typeof o == "object") {
          if (typeof o.then == "function") return ci(o);
          if (o.$$typeof === Fo) return hr(o);
        }
        throw Error(i(438, String(o)));
      }
      function El(o) {
        var a = null, f = De.updateQueue;
        if (f !== null && (a = f.memoCache), a == null) {
          var _ = De.alternate;
          _ !== null && (_ = _.updateQueue, _ !== null && (_ = _.memoCache, _ != null && (a = {
            data: _.data.map(function(R) {
              return R.slice();
            }),
            index: 0
          })));
        }
        if (a == null && (a = { data: [], index: 0 }), f === null && (f = Qm(), De.updateQueue = f), f.memoCache = a, f = a.data[a.index], f === void 0)
          for (f = a.data[a.index] = Array(o), _ = 0; _ < o; _++)
            f[_] = Ux;
        return a.index++, f;
      }
      function Rr(o, a) {
        return typeof a == "function" ? a(o) : a;
      }
      function Us(o) {
        var a = Me();
        return fa(a, hn, o);
      }
      function fa(o, a, f) {
        var _ = o.queue;
        if (_ === null) throw Error(i(311));
        _.lastRenderedReducer = f;
        var R = o.baseQueue, I = _.pending;
        if (I !== null) {
          if (R !== null) {
            var Q = R.next;
            R.next = I.next, I.next = Q;
          }
          a.baseQueue = R = I, _.pending = null;
        }
        if (I = o.baseState, R === null) o.memoizedState = I;
        else {
          a = R.next;
          var lt = Q = null, St = null, It = a, te = !1;
          do {
            var ae = It.lane & -536870913;
            if (ae !== It.lane ? (Ye & ae) === ae : (Vo & ae) === ae) {
              var de = It.revertLane;
              if (de === 0)
                St !== null && (St = St.next = {
                  lane: 0,
                  revertLane: 0,
                  action: It.action,
                  hasEagerState: It.hasEagerState,
                  eagerState: It.eagerState,
                  next: null
                }), ae === ic && (te = !0);
              else if ((Vo & de) === de) {
                It = It.next, de === ic && (te = !0);
                continue;
              } else
                ae = {
                  lane: 0,
                  revertLane: It.revertLane,
                  action: It.action,
                  hasEagerState: It.hasEagerState,
                  eagerState: It.eagerState,
                  next: null
                }, St === null ? (lt = St = ae, Q = I) : St = St.next = ae, De.lanes |= de, qo |= de;
              ae = It.action, Ua && f(I, ae), I = It.hasEagerState ? It.eagerState : f(I, ae);
            } else
              de = {
                lane: ae,
                revertLane: It.revertLane,
                action: It.action,
                hasEagerState: It.hasEagerState,
                eagerState: It.eagerState,
                next: null
              }, St === null ? (lt = St = de, Q = I) : St = St.next = de, De.lanes |= ae, qo |= ae;
            It = It.next;
          } while (It !== null && It !== a);
          if (St === null ? Q = I : St.next = lt, !vi(I, o.memoizedState) && (mr = !0, te && (f = sc, f !== null)))
            throw f;
          o.memoizedState = I, o.baseState = Q, o.baseQueue = St, _.lastRenderedState = I;
        }
        return R === null && (_.lanes = 0), [o.memoizedState, _.dispatch];
      }
      function pa(o) {
        var a = Me(), f = a.queue;
        if (f === null) throw Error(i(311));
        f.lastRenderedReducer = o;
        var _ = f.dispatch, R = f.pending, I = a.memoizedState;
        if (R !== null) {
          f.pending = null;
          var Q = R = R.next;
          do
            I = o(I, Q.action), Q = Q.next;
          while (Q !== R);
          vi(I, a.memoizedState) || (mr = !0), a.memoizedState = I, a.baseQueue === null && (a.baseState = I), f.lastRenderedState = I;
        }
        return [I, _];
      }
      function gs(o, a, f) {
        var _ = De, R = Me(), I = Je;
        if (I) {
          if (f === void 0)
            throw Error(i(407));
          f = f();
        } else f = a();
        var Q = !vi(
          (hn || R).memoizedState,
          f
        );
        if (Q && (R.memoizedState = f, mr = !0), R = R.queue, xr(lu.bind(null, _, R, o), [
          o
        ]), R.getSnapshot !== a || Q || Qn !== null && Qn.memoizedState.tag & 1) {
          if (_.flags |= 2048, Eo(
            9,
            ma.bind(
              null,
              _,
              R,
              f,
              a
            ),
            { destroy: void 0 },
            null
          ), bn === null) throw Error(i(349));
          I || (Vo & 60) !== 0 || au(_, a, f);
        }
        return f;
      }
      function au(o, a, f) {
        o.flags |= 16384, o = { getSnapshot: a, value: f }, a = De.updateQueue, a === null ? (a = Qm(), De.updateQueue = a, a.stores = [o]) : (f = a.stores, f === null ? a.stores = [o] : f.push(o));
      }
      function ma(o, a, f, _) {
        a.value = f, a.getSnapshot = _, ze(a) && cu(o);
      }
      function lu(o, a, f) {
        return f(function() {
          ze(a) && cu(o);
        });
      }
      function ze(o) {
        var a = o.getSnapshot;
        o = o.value;
        try {
          var f = a();
          return !vi(o, f);
        } catch {
          return !0;
        }
      }
      function cu(o) {
        var a = Ut(o, 2);
        a !== null && Gr(a, o, 2);
      }
      function Al(o) {
        var a = dr();
        if (typeof o == "function") {
          var f = o;
          if (o = f(), Ua) {
            H(!0);
            try {
              f();
            } finally {
              H(!1);
            }
          }
        }
        return a.memoizedState = a.baseState = o, a.queue = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: Rr,
          lastRenderedState: o
        }, a;
      }
      function uu(o, a, f, _) {
        return o.baseState = f, fa(
          o,
          hn,
          typeof _ == "function" ? _ : Rr
        );
      }
      function gn(o, a, f, _, R) {
        if (Dl(o)) throw Error(i(485));
        if (o = a.action, o !== null) {
          var I = {
            payload: R,
            action: o,
            next: null,
            isTransition: !0,
            status: "pending",
            value: null,
            reason: null,
            listeners: [],
            then: function(Q) {
              I.listeners.push(Q);
            }
          };
          Ee.T !== null ? f(!0) : I.isTransition = !1, _(I), f = a.pending, f === null ? (I.next = a.pending = I, Co(a, I)) : (I.next = f.next, a.pending = f.next = I);
        }
      }
      function Co(o, a) {
        var f = a.action, _ = a.payload, R = o.state;
        if (a.isTransition) {
          var I = Ee.T, Q = {};
          Ee.T = Q;
          try {
            var lt = f(R, _), St = Ee.S;
            St !== null && St(Q, lt), wo(o, a, lt);
          } catch (It) {
            ga(o, a, It);
          } finally {
            Ee.T = I;
          }
        } else
          try {
            I = f(R, _), wo(o, a, I);
          } catch (It) {
            ga(o, a, It);
          }
      }
      function wo(o, a, f) {
        f !== null && typeof f == "object" && typeof f.then == "function" ? f.then(
          function(_) {
            Vs(o, a, _);
          },
          function(_) {
            return ga(o, a, _);
          }
        ) : Vs(o, a, f);
      }
      function Vs(o, a, f) {
        a.status = "fulfilled", a.value = f, kl(a), o.state = f, a = o.pending, a !== null && (f = a.next, f === a ? o.pending = null : (f = f.next, a.next = f, Co(o, f)));
      }
      function ga(o, a, f) {
        var _ = o.pending;
        if (o.pending = null, _ !== null) {
          _ = _.next;
          do
            a.status = "rejected", a.reason = f, kl(a), a = a.next;
          while (a !== _);
        }
        o.action = null;
      }
      function kl(o) {
        o = o.listeners;
        for (var a = 0; a < o.length; a++) (0, o[a])();
      }
      function ya(o, a) {
        return a;
      }
      function du(o, a) {
        if (Je) {
          var f = bn.formState;
          if (f !== null) {
            t: {
              var _ = De;
              if (Je) {
                if (Dr) {
                  var R = N4(
                    Dr,
                    bs
                  );
                  if (R) {
                    Dr = q1(R), _ = P4(R);
                    break t;
                  }
                }
                tt(_);
              }
              _ = !1;
            }
            _ && (a = f[0]);
          }
        }
        f = dr(), f.memoizedState = f.baseState = a, _ = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: ya,
          lastRenderedState: a
        }, f.queue = _, f = Ro.bind(
          null,
          De,
          _
        ), _.dispatch = f, _ = Al(!1);
        var I = Pl.bind(
          null,
          De,
          !1,
          _.queue
        );
        return _ = dr(), R = {
          state: a,
          dispatch: null,
          action: o,
          pending: null
        }, _.queue = R, f = gn.bind(
          null,
          De,
          R,
          I,
          f
        ), R.dispatch = f, _.memoizedState = o, [a, f, !1];
      }
      function va(o) {
        var a = Me();
        return hu(a, hn, o);
      }
      function hu(o, a, f) {
        a = fa(
          o,
          a,
          ya
        )[0], o = Us(Rr)[0], a = typeof a == "object" && a !== null && typeof a.then == "function" ? ci(a) : a;
        var _ = Me(), R = _.queue, I = R.dispatch;
        return f !== _.memoizedState && (De.flags |= 2048, Eo(
          9,
          ba.bind(null, R, f),
          { destroy: void 0 },
          null
        )), [a, I, o];
      }
      function ba(o, a) {
        o.action = a;
      }
      function fu(o) {
        var a = Me(), f = hn;
        if (f !== null)
          return hu(a, f, o);
        Me(), a = a.memoizedState, f = Me();
        var _ = f.queue.dispatch;
        return f.memoizedState = o, [a, _, !1];
      }
      function Eo(o, a, f, _) {
        return o = { tag: o, create: a, inst: f, deps: _, next: null }, a = De.updateQueue, a === null && (a = Qm(), De.updateQueue = a), f = a.lastEffect, f === null ? a.lastEffect = o.next = o : (_ = f.next, f.next = o, o.next = _, a.lastEffect = o), o;
      }
      function Ke() {
        return Me().memoizedState;
      }
      function Ao(o, a, f, _) {
        var R = dr();
        De.flags |= o, R.memoizedState = Eo(
          1 | a,
          f,
          { destroy: void 0 },
          _ === void 0 ? null : _
        );
      }
      function Rl(o, a, f, _) {
        var R = Me();
        _ = _ === void 0 ? null : _;
        var I = R.memoizedState.inst;
        hn !== null && _ !== null && ps(_, hn.memoizedState.deps) ? R.memoizedState = Eo(a, f, I, _) : (De.flags |= o, R.memoizedState = Eo(1 | a, f, I, _));
      }
      function Fh(o, a) {
        Ao(8390656, 8, o, a);
      }
      function xr(o, a) {
        Rl(2048, 8, o, a);
      }
      function Gs(o, a) {
        return Rl(4, 2, o, a);
      }
      function _a(o, a) {
        return Rl(4, 4, o, a);
      }
      function Yi(o, a) {
        if (typeof a == "function") {
          o = o();
          var f = a(o);
          return function() {
            typeof f == "function" ? f() : a(null);
          };
        }
        if (a != null)
          return o = o(), a.current = o, function() {
            a.current = null;
          };
      }
      function pu(o, a, f) {
        f = f != null ? f.concat([o]) : null, Rl(
          4,
          4,
          Yi.bind(null, a, o),
          f
        );
      }
      function Ml() {
      }
      function Wn(o, a) {
        var f = Me();
        a = a === void 0 ? null : a;
        var _ = f.memoizedState;
        return a !== null && ps(a, _[1]) ? _[0] : (f.memoizedState = [o, a], o);
      }
      function ui(o, a) {
        var f = Me();
        a = a === void 0 ? null : a;
        var _ = f.memoizedState;
        if (a !== null && ps(a, _[1]))
          return _[0];
        if (_ = o(), Ua) {
          H(!0);
          try {
            o();
          } finally {
            H(!1);
          }
        }
        return f.memoizedState = [_, a], _;
      }
      function qs(o, a, f) {
        return f === void 0 || (Vo & 1073741824) !== 0 ? o.memoizedState = a : (o.memoizedState = f, o = s1(), De.lanes |= o, qo |= o, f);
      }
      function ko(o, a, f, _) {
        return vi(f, a) ? f : lc.current !== null ? (o = qs(o, f, _), vi(o, a) || (mr = !0), o) : (Vo & 42) === 0 ? (mr = !0, o.memoizedState = f) : (o = s1(), De.lanes |= o, qo |= o, a);
      }
      function Ol(o, a, f, _, R) {
        var I = Fa();
        Zr(
          I !== 0 && 8 > I ? I : 8
        );
        var Q = Ee.T, lt = {};
        Ee.T = lt, Pl(o, !1, a, f);
        try {
          var St = R(), It = Ee.S;
          if (It !== null && It(lt, St), St !== null && typeof St == "object" && typeof St.then == "function") {
            var te = Ft(
              St,
              _
            );
            Hs(
              o,
              a,
              te,
              pi(o)
            );
          } else
            Hs(
              o,
              a,
              _,
              pi(o)
            );
        } catch (ae) {
          Hs(
            o,
            a,
            { then: function() {
            }, status: "rejected", reason: ae },
            pi()
          );
        } finally {
          Zr(I), Ee.T = Q;
        }
      }
      function Xi(o) {
        var a = o.memoizedState;
        if (a !== null) return a;
        a = {
          memoizedState: Xl,
          baseState: Xl,
          baseQueue: null,
          queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: Rr,
            lastRenderedState: Xl
          },
          next: null
        };
        var f = {};
        return a.next = {
          memoizedState: f,
          baseState: f,
          baseQueue: null,
          queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: Rr,
            lastRenderedState: f
          },
          next: null
        }, o.memoizedState = a, o = o.alternate, o !== null && (o.memoizedState = a), a;
      }
      function mu() {
        return hr(ja);
      }
      function di() {
        return Me().memoizedState;
      }
      function Nl() {
        return Me().memoizedState;
      }
      function jh(o) {
        for (var a = o.return; a !== null; ) {
          switch (a.tag) {
            case 24:
            case 3:
              var f = pi();
              o = ee(f);
              var _ = fe(a, o, f);
              _ !== null && (Gr(_, a, f), ie(_, a, f)), a = { cache: ql() }, o.payload = a;
              return;
          }
          a = a.return;
        }
      }
      function gu(o, a, f) {
        var _ = pi();
        f = {
          lane: _,
          revertLane: 0,
          action: f,
          hasEagerState: !1,
          eagerState: null,
          next: null
        }, Dl(o) ? Mo(a, f) : (f = Wt(o, a, f, _), f !== null && (Gr(f, o, _), Lh(f, a, _)));
      }
      function Ro(o, a, f) {
        var _ = pi();
        Hs(o, a, f, _);
      }
      function Hs(o, a, f, _) {
        var R = {
          lane: _,
          revertLane: 0,
          action: f,
          hasEagerState: !1,
          eagerState: null,
          next: null
        };
        if (Dl(o)) Mo(a, R);
        else {
          var I = o.alternate;
          if (o.lanes === 0 && (I === null || I.lanes === 0) && (I = a.lastRenderedReducer, I !== null))
            try {
              var Q = a.lastRenderedState, lt = I(Q, f);
              if (R.hasEagerState = !0, R.eagerState = lt, vi(lt, Q))
                return wt(o, a, R, 0), bn === null && $t(), !1;
            } catch {
            } finally {
            }
          if (f = Wt(o, a, R, _), f !== null)
            return Gr(f, o, _), Lh(f, a, _), !0;
        }
        return !1;
      }
      function Pl(o, a, f, _) {
        if (_ = {
          lane: 2,
          revertLane: Rt(),
          action: _,
          hasEagerState: !1,
          eagerState: null,
          next: null
        }, Dl(o)) {
          if (a) throw Error(i(479));
        } else
          a = Wt(
            o,
            f,
            _,
            2
          ), a !== null && Gr(a, o, 2);
      }
      function Dl(o) {
        var a = o.alternate;
        return o === De || a !== null && a === De;
      }
      function Mo(o, a) {
        cc = cf = !0;
        var f = o.pending;
        f === null ? a.next = a : (a.next = f.next, f.next = a), o.pending = a;
      }
      function Lh(o, a, f) {
        if ((f & 4194176) !== 0) {
          var _ = a.lanes;
          _ &= o.pendingLanes, f |= _, a.lanes = f, j(o, f);
        }
      }
      function yu(o, a, f, _) {
        a = o.memoizedState, f = f(_, a), f = f == null ? a : km({}, a, f), o.memoizedState = f, o.lanes === 0 && (o.updateQueue.baseState = f);
      }
      function Sa(o, a, f, _, R, I, Q) {
        return o = o.stateNode, typeof o.shouldComponentUpdate == "function" ? o.shouldComponentUpdate(_, I, Q) : a.prototype && a.prototype.isPureReactComponent ? !Sr(f, _) || !Sr(R, I) : !0;
      }
      function xa(o, a, f, _) {
        o = a.state, typeof a.componentWillReceiveProps == "function" && a.componentWillReceiveProps(f, _), typeof a.UNSAFE_componentWillReceiveProps == "function" && a.UNSAFE_componentWillReceiveProps(f, _), a.state !== o && Zm.enqueueReplaceState(a, a.state, null);
      }
      function Qi(o, a) {
        var f = a;
        if ("ref" in a) {
          f = {};
          for (var _ in a)
            _ !== "ref" && (f[_] = a[_]);
        }
        if (o = o.defaultProps) {
          f === a && (f = km({}, f));
          for (var R in o)
            f[R] === void 0 && (f[R] = o[R]);
        }
        return f;
      }
      function Il(o, a) {
        try {
          var f = o.onUncaughtError;
          f(a.value, { componentStack: a.stack });
        } catch (_) {
          setTimeout(function() {
            throw _;
          });
        }
      }
      function zh(o, a, f) {
        try {
          var _ = o.onCaughtError;
          _(f.value, {
            componentStack: f.stack,
            errorBoundary: a.tag === 1 ? a.stateNode : null
          });
        } catch (R) {
          setTimeout(function() {
            throw R;
          });
        }
      }
      function vu(o, a, f) {
        return f = ee(f), f.tag = 3, f.payload = { element: null }, f.callback = function() {
          Il(o, a);
        }, f;
      }
      function Bl(o) {
        return o = ee(o), o.tag = 3, o;
      }
      function Fl(o, a, f, _) {
        var R = f.type.getDerivedStateFromError;
        if (typeof R == "function") {
          var I = _.value;
          o.payload = function() {
            return R(I);
          }, o.callback = function() {
            zh(a, f, _);
          };
        }
        var Q = f.stateNode;
        Q !== null && typeof Q.componentDidCatch == "function" && (o.callback = function() {
          zh(a, f, _), typeof R != "function" && (Ho === null ? Ho = /* @__PURE__ */ new Set([this]) : Ho.add(this));
          var lt = _.stack;
          this.componentDidCatch(_.value, {
            componentStack: lt !== null ? lt : ""
          });
        });
      }
      function Uh(o, a, f, _, R) {
        if (f.flags |= 32768, _ !== null && typeof _ == "object" && typeof _.then == "function") {
          if (a = f.alternate, a !== null && Oa(
            a,
            f,
            R,
            !0
          ), f = Bi.current, f !== null) {
            switch (f.tag) {
              case 13:
                return _s === null ? Sm() : f.alternate === null && Ln === 0 && (Ln = 3), f.flags &= -257, f.flags |= 65536, f.lanes = R, _ === af ? f.flags |= 16384 : (a = f.updateQueue, a === null ? f.updateQueue = /* @__PURE__ */ new Set([_]) : a.add(_), Tm(o, _, R)), !1;
              case 22:
                return f.flags |= 65536, _ === af ? f.flags |= 16384 : (a = f.updateQueue, a === null ? (a = {
                  transitions: null,
                  markerInstances: null,
                  retryQueue: /* @__PURE__ */ new Set([_])
                }, f.updateQueue = a) : (f = a.retryQueue, f === null ? a.retryQueue = /* @__PURE__ */ new Set([_]) : f.add(_)), Tm(o, _, R)), !1;
            }
            throw Error(i(435, f.tag));
          }
          return Tm(o, _, R), Sm(), !1;
        }
        if (Je)
          return a = Bi.current, a !== null ? ((a.flags & 65536) === 0 && (a.flags |= 256), a.flags |= 65536, a.lanes = R, _ !== qm && (o = Error(i(422), { cause: _ }), Ht(
            Y(o, f)
          ))) : (_ !== qm && (a = Error(i(423), {
            cause: _
          }), Ht(
            Y(a, f)
          )), o = o.current.alternate, o.flags |= 65536, R &= -R, o.lanes |= R, _ = Y(_, f), R = vu(
            o.stateNode,
            _,
            R
          ), zt(o, R), Ln !== 4 && (Ln = 2)), !1;
        var I = Error(i(520), { cause: _ });
        if (I = Y(I, f), Bu === null ? Bu = [I] : Bu.push(I), Ln !== 4 && (Ln = 2), a === null) return !0;
        _ = Y(_, f), f = a;
        do {
          switch (f.tag) {
            case 3:
              return f.flags |= 65536, o = R & -R, f.lanes |= o, o = vu(f.stateNode, _, o), zt(f, o), !1;
            case 1:
              if (a = f.type, I = f.stateNode, (f.flags & 128) === 0 && (typeof a.getDerivedStateFromError == "function" || I !== null && typeof I.componentDidCatch == "function" && (Ho === null || !Ho.has(
                I
              ))))
                return f.flags |= 65536, R &= -R, f.lanes |= R, R = Bl(R), Fl(
                  R,
                  o,
                  f,
                  _
                ), zt(f, R), !1;
          }
          f = f.return;
        } while (f !== null);
        return !1;
      }
      function In(o, a, f, _) {
        a.child = o === null ? iv(a, null, f, _) : za(
          a,
          o.child,
          f,
          _
        );
      }
      function Ta(o, a, f, _, R) {
        f = f.render;
        var I = a.ref;
        if ("ref" in _) {
          var Q = {};
          for (var lt in _)
            lt !== "ref" && (Q[lt] = _[lt]);
        } else Q = _;
        return ts(a), _ = Mi(
          o,
          a,
          f,
          Q,
          I,
          R
        ), lt = Cl(), o !== null && !mr ? (Ki(o, a, R), hi(o, a, R)) : (Je && lt && ct(a), a.flags |= 1, In(o, a, _, R), a.child);
      }
      function Ca(o, a, f, _, R) {
        if (o === null) {
          var I = f.type;
          return typeof I == "function" && !Cm(I) && I.defaultProps === void 0 && f.compare === null ? (a.tag = 15, a.type = I, bu(
            o,
            a,
            I,
            _,
            R
          )) : (o = Kh(
            f.type,
            null,
            _,
            a,
            a.mode,
            R
          ), o.ref = a.ref, o.return = a, a.child = o);
        }
        if (I = o.child, !Ra(o, R)) {
          var Q = I.memoizedProps;
          if (f = f.compare, f = f !== null ? f : Sr, f(Q, _) && o.ref === a.ref)
            return hi(
              o,
              a,
              R
            );
        }
        return a.flags |= 1, o = Bo(I, _), o.ref = a.ref, o.return = a, a.child = o;
      }
      function bu(o, a, f, _, R) {
        if (o !== null) {
          var I = o.memoizedProps;
          if (Sr(I, _) && o.ref === a.ref)
            if (mr = !1, a.pendingProps = _ = I, Ra(o, R))
              (o.flags & 131072) !== 0 && (mr = !0);
            else
              return a.lanes = o.lanes, hi(o, a, R);
        }
        return Ea(
          o,
          a,
          f,
          _,
          R
        );
      }
      function Vh(o, a, f) {
        var _ = a.pendingProps, R = _.children, I = (a.stateNode._pendingVisibility & 2) !== 0, Q = o !== null ? o.memoizedState : null;
        if (Ws(o, a), _.mode === "hidden" || I) {
          if ((a.flags & 128) !== 0) {
            if (_ = Q !== null ? Q.baseLanes | f : f, o !== null) {
              for (R = a.child = o.child, I = 0; R !== null; )
                I = I | R.lanes | R.childLanes, R = R.sibling;
              a.childLanes = I & ~_;
            } else a.childLanes = 0, a.child = null;
            return wa(
              o,
              a,
              _,
              f
            );
          }
          if ((f & 536870912) !== 0)
            a.memoizedState = { baseLanes: 0, cachePool: null }, o !== null && Pa(
              a,
              Q !== null ? Q.cachePool : null
            ), Q !== null ? ua(a, Q) : dn(), da(a);
          else
            return a.lanes = a.childLanes = 536870912, wa(
              o,
              a,
              Q !== null ? Q.baseLanes | f : f,
              f
            );
        } else
          Q !== null ? (Pa(a, Q.cachePool), ua(a, Q), li(), a.memoizedState = null) : (o !== null && Pa(a, null), dn(), li());
        return In(o, a, R, f), a.child;
      }
      function wa(o, a, f, _) {
        var R = Su();
        return R = R === null ? null : {
          parent: Js ? Fn._currentValue : Fn._currentValue2,
          pool: R
        }, a.memoizedState = {
          baseLanes: f,
          cachePool: R
        }, o !== null && Pa(a, null), dn(), da(a), o !== null && Oa(o, a, _, !0), null;
      }
      function Ws(o, a) {
        var f = a.ref;
        if (f === null)
          o !== null && o.ref !== null && (a.flags |= 2097664);
        else {
          if (typeof f != "function" && typeof f != "object")
            throw Error(i(284));
          (o === null || o.ref !== f) && (a.flags |= 2097664);
        }
      }
      function Ea(o, a, f, _, R) {
        return ts(a), f = Mi(
          o,
          a,
          f,
          _,
          void 0,
          R
        ), _ = Cl(), o !== null && !mr ? (Ki(o, a, R), hi(o, a, R)) : (Je && _ && ct(a), a.flags |= 1, In(o, a, f, R), a.child);
      }
      function jl(o, a, f, _, R, I) {
        return ts(a), a.updateQueue = null, f = Bh(
          a,
          _,
          f,
          R
        ), ha(o), _ = Cl(), o !== null && !mr ? (Ki(o, a, I), hi(o, a, I)) : (Je && _ && ct(a), a.flags |= 1, In(o, a, f, I), a.child);
      }
      function Ll(o, a, f, _, R) {
        if (ts(a), a.stateNode === null) {
          var I = Zl, Q = f.contextType;
          typeof Q == "object" && Q !== null && (I = hr(Q)), I = new f(_, I), a.memoizedState = I.state !== null && I.state !== void 0 ? I.state : null, I.updater = Zm, a.stateNode = I, I._reactInternals = a, I = a.stateNode, I.props = _, I.state = a.memoizedState, I.refs = {}, Vt(a), Q = f.contextType, I.context = typeof Q == "object" && Q !== null ? hr(Q) : Zl, I.state = a.memoizedState, Q = f.getDerivedStateFromProps, typeof Q == "function" && (yu(
            a,
            f,
            Q,
            _
          ), I.state = a.memoizedState), typeof f.getDerivedStateFromProps == "function" || typeof I.getSnapshotBeforeUpdate == "function" || typeof I.UNSAFE_componentWillMount != "function" && typeof I.componentWillMount != "function" || (Q = I.state, typeof I.componentWillMount == "function" && I.componentWillMount(), typeof I.UNSAFE_componentWillMount == "function" && I.UNSAFE_componentWillMount(), Q !== I.state && Zm.enqueueReplaceState(
            I,
            I.state,
            null
          ), je(a, _, I, R), Pe(), I.state = a.memoizedState), typeof I.componentDidMount == "function" && (a.flags |= 4194308), _ = !0;
        } else if (o === null) {
          I = a.stateNode;
          var lt = a.memoizedProps, St = Qi(f, lt);
          I.props = St;
          var It = I.context, te = f.contextType;
          Q = Zl, typeof te == "object" && te !== null && (Q = hr(te));
          var ae = f.getDerivedStateFromProps;
          te = typeof ae == "function" || typeof I.getSnapshotBeforeUpdate == "function", lt = a.pendingProps !== lt, te || typeof I.UNSAFE_componentWillReceiveProps != "function" && typeof I.componentWillReceiveProps != "function" || (lt || It !== Q) && xa(
            a,
            I,
            _,
            Q
          ), Uo = !1;
          var de = a.memoizedState;
          I.state = de, je(a, _, I, R), Pe(), It = a.memoizedState, lt || de !== It || Uo ? (typeof ae == "function" && (yu(
            a,
            f,
            ae,
            _
          ), It = a.memoizedState), (St = Uo || Sa(
            a,
            f,
            St,
            _,
            de,
            It,
            Q
          )) ? (te || typeof I.UNSAFE_componentWillMount != "function" && typeof I.componentWillMount != "function" || (typeof I.componentWillMount == "function" && I.componentWillMount(), typeof I.UNSAFE_componentWillMount == "function" && I.UNSAFE_componentWillMount()), typeof I.componentDidMount == "function" && (a.flags |= 4194308)) : (typeof I.componentDidMount == "function" && (a.flags |= 4194308), a.memoizedProps = _, a.memoizedState = It), I.props = _, I.state = It, I.context = Q, _ = St) : (typeof I.componentDidMount == "function" && (a.flags |= 4194308), _ = !1);
        } else {
          I = a.stateNode, Yt(o, a), Q = a.memoizedProps, te = Qi(f, Q), I.props = te, ae = a.pendingProps, de = I.context, It = f.contextType, St = Zl, typeof It == "object" && It !== null && (St = hr(It)), lt = f.getDerivedStateFromProps, (It = typeof lt == "function" || typeof I.getSnapshotBeforeUpdate == "function") || typeof I.UNSAFE_componentWillReceiveProps != "function" && typeof I.componentWillReceiveProps != "function" || (Q !== ae || de !== St) && xa(
            a,
            I,
            _,
            St
          ), Uo = !1, de = a.memoizedState, I.state = de, je(a, _, I, R), Pe();
          var Oe = a.memoizedState;
          Q !== ae || de !== Oe || Uo || o !== null && o.dependencies !== null && Po(o.dependencies) ? (typeof lt == "function" && (yu(
            a,
            f,
            lt,
            _
          ), Oe = a.memoizedState), (te = Uo || Sa(
            a,
            f,
            te,
            _,
            de,
            Oe,
            St
          ) || o !== null && o.dependencies !== null && Po(o.dependencies)) ? (It || typeof I.UNSAFE_componentWillUpdate != "function" && typeof I.componentWillUpdate != "function" || (typeof I.componentWillUpdate == "function" && I.componentWillUpdate(_, Oe, St), typeof I.UNSAFE_componentWillUpdate == "function" && I.UNSAFE_componentWillUpdate(
            _,
            Oe,
            St
          )), typeof I.componentDidUpdate == "function" && (a.flags |= 4), typeof I.getSnapshotBeforeUpdate == "function" && (a.flags |= 1024)) : (typeof I.componentDidUpdate != "function" || Q === o.memoizedProps && de === o.memoizedState || (a.flags |= 4), typeof I.getSnapshotBeforeUpdate != "function" || Q === o.memoizedProps && de === o.memoizedState || (a.flags |= 1024), a.memoizedProps = _, a.memoizedState = Oe), I.props = _, I.state = Oe, I.context = St, _ = te) : (typeof I.componentDidUpdate != "function" || Q === o.memoizedProps && de === o.memoizedState || (a.flags |= 4), typeof I.getSnapshotBeforeUpdate != "function" || Q === o.memoizedProps && de === o.memoizedState || (a.flags |= 1024), _ = !1);
        }
        return I = _, Ws(o, a), _ = (a.flags & 128) !== 0, I || _ ? (I = a.stateNode, f = _ && typeof f.getDerivedStateFromError != "function" ? null : I.render(), a.flags |= 1, o !== null && _ ? (a.child = za(
          a,
          o.child,
          null,
          R
        ), a.child = za(
          a,
          null,
          f,
          R
        )) : In(o, a, f, R), a.memoizedState = I.state, o = a.child) : o = hi(
          o,
          a,
          R
        ), o;
      }
      function rr(o, a, f, _) {
        return bt(), a.flags |= 256, In(o, a, f, _), a.child;
      }
      function $s(o) {
        return { baseLanes: o, cachePool: Hl() };
      }
      function Ks(o, a, f) {
        return o = o !== null ? o.childLanes & ~f : 0, a && (o |= Fi), o;
      }
      function _u(o, a, f) {
        var _ = a.pendingProps, R = !1, I = (a.flags & 128) !== 0, Q;
        if ((Q = I) || (Q = o !== null && o.memoizedState === null ? !1 : (sr.current & 2) !== 0), Q && (R = !0, a.flags &= -129), Q = (a.flags & 32) !== 0, a.flags &= -33, o === null) {
          if (Je) {
            if (R ? fs(a) : li(), Je) {
              var lt = Dr, St;
              (St = lt) && (lt = j4(
                lt,
                bs
              ), lt !== null ? (a.memoizedState = {
                dehydrated: lt,
                treeContext: La !== null ? { id: to, overflow: eo } : null,
                retryLane: 536870912
              }, St = n(18, null, null, 0), St.stateNode = lt, St.return = a, a.child = St, qr = a, Dr = null, St = !0) : St = !1), St || tt(a);
            }
            if (lt = a.memoizedState, lt !== null && (lt = lt.dehydrated, lt !== null))
              return Lm(lt) ? a.lanes = 16 : a.lanes = 536870912, null;
            Xr(a);
          }
          return lt = _.children, _ = _.fallback, R ? (li(), R = a.mode, lt = zl(
            { mode: "hidden", children: lt },
            R
          ), _ = Ba(
            _,
            R,
            f,
            null
          ), lt.return = a, _.return = a, lt.sibling = _, a.child = lt, R = a.child, R.memoizedState = $s(f), R.childLanes = Ks(
            o,
            Q,
            f
          ), a.memoizedState = Jm, _) : (fs(a), Oo(a, lt));
        }
        if (St = o.memoizedState, St !== null && (lt = St.dehydrated, lt !== null)) {
          if (I)
            a.flags & 256 ? (fs(a), a.flags &= -257, a = Ul(
              o,
              a,
              f
            )) : a.memoizedState !== null ? (li(), a.child = o.child, a.flags |= 128, a = null) : (li(), R = _.fallback, lt = a.mode, _ = zl(
              { mode: "visible", children: _.children },
              lt
            ), R = Ba(
              R,
              lt,
              f,
              null
            ), R.flags |= 2, _.return = a, R.return = a, _.sibling = R, a.child = _, za(
              a,
              o.child,
              null,
              f
            ), _ = a.child, _.memoizedState = $s(f), _.childLanes = Ks(
              o,
              Q,
              f
            ), a.memoizedState = Jm, a = R);
          else if (fs(a), Lm(lt))
            Q = M4(lt).digest, _ = Error(i(419)), _.stack = "", _.digest = Q, Ht({ value: _, source: null, stack: null }), a = Ul(
              o,
              a,
              f
            );
          else if (mr || Oa(
            o,
            a,
            f,
            !1
          ), Q = (f & o.childLanes) !== 0, mr || Q) {
            if (Q = bn, Q !== null) {
              if (_ = f & -f, (_ & 42) !== 0) _ = 1;
              else
                switch (_) {
                  case 2:
                    _ = 1;
                    break;
                  case 8:
                    _ = 4;
                    break;
                  case 32:
                    _ = 16;
                    break;
                  case 128:
                  case 256:
                  case 512:
                  case 1024:
                  case 2048:
                  case 4096:
                  case 8192:
                  case 16384:
                  case 32768:
                  case 65536:
                  case 131072:
                  case 262144:
                  case 524288:
                  case 1048576:
                  case 2097152:
                  case 4194304:
                  case 8388608:
                  case 16777216:
                  case 33554432:
                    _ = 64;
                    break;
                  case 268435456:
                    _ = 134217728;
                    break;
                  default:
                    _ = 0;
                }
              if (_ = (_ & (Q.suspendedLanes | f)) !== 0 ? 0 : _, _ !== 0 && _ !== St.retryLane)
                throw St.retryLane = _, Ut(o, _), Gr(Q, o, _), ov;
            }
            jm(lt) || Sm(), a = Ul(
              o,
              a,
              f
            );
          } else
            jm(lt) ? (a.flags |= 128, a.child = o.child, a = Px.bind(
              null,
              o
            ), O4(lt, a), a = null) : (o = St.treeContext, Oi && (Dr = I4(lt), qr = a, Je = !0, is = null, bs = !1, o !== null && (Pi[Di++] = to, Pi[Di++] = eo, Pi[Di++] = La, to = o.id, eo = o.overflow, La = a)), a = Oo(
              a,
              _.children
            ), a.flags |= 4096);
          return a;
        }
        return R ? (li(), R = _.fallback, lt = a.mode, St = o.child, I = St.sibling, _ = Bo(St, {
          mode: "hidden",
          children: _.children
        }), _.subtreeFlags = St.subtreeFlags & 31457280, I !== null ? R = Bo(I, R) : (R = Ba(
          R,
          lt,
          f,
          null
        ), R.flags |= 2), R.return = a, _.return = a, _.sibling = R, a.child = _, _ = R, R = a.child, lt = o.child.memoizedState, lt === null ? lt = $s(f) : (St = lt.cachePool, St !== null ? (I = Js ? Fn._currentValue : Fn._currentValue2, St = St.parent !== I ? { parent: I, pool: I } : St) : St = Hl(), lt = {
          baseLanes: lt.baseLanes | f,
          cachePool: St
        }), R.memoizedState = lt, R.childLanes = Ks(
          o,
          Q,
          f
        ), a.memoizedState = Jm, _) : (fs(a), f = o.child, o = f.sibling, f = Bo(f, {
          mode: "visible",
          children: _.children
        }), f.return = a, f.sibling = null, o !== null && (Q = a.deletions, Q === null ? (a.deletions = [o], a.flags |= 16) : Q.push(o)), a.child = f, a.memoizedState = null, f);
      }
      function Oo(o, a) {
        return a = zl(
          { mode: "visible", children: a },
          o.mode
        ), a.return = o, o.child = a;
      }
      function zl(o, a) {
        return S1(o, a, 0, null);
      }
      function Ul(o, a, f) {
        return za(a, o.child, null, f), o = Oo(
          a,
          a.pendingProps.children
        ), o.flags |= 2, a.memoizedState = null, o;
      }
      function Aa(o, a, f) {
        o.lanes |= a;
        var _ = o.alternate;
        _ !== null && (_.lanes |= a), Ma(o.return, a, f);
      }
      function ka(o, a, f, _, R) {
        var I = o.memoizedState;
        I === null ? o.memoizedState = {
          isBackwards: a,
          rendering: null,
          renderingStartTime: 0,
          last: _,
          tail: f,
          tailMode: R
        } : (I.isBackwards = a, I.rendering = null, I.renderingStartTime = 0, I.last = _, I.tail = f, I.tailMode = R);
      }
      function ys(o, a, f) {
        var _ = a.pendingProps, R = _.revealOrder, I = _.tail;
        if (In(o, a, _.children, f), _ = sr.current, (_ & 2) !== 0)
          _ = _ & 1 | 2, a.flags |= 128;
        else {
          if (o !== null && (o.flags & 128) !== 0)
            t: for (o = a.child; o !== null; ) {
              if (o.tag === 13)
                o.memoizedState !== null && Aa(o, f, a);
              else if (o.tag === 19)
                Aa(o, f, a);
              else if (o.child !== null) {
                o.child.return = o, o = o.child;
                continue;
              }
              if (o === a) break t;
              for (; o.sibling === null; ) {
                if (o.return === null || o.return === a)
                  break t;
                o = o.return;
              }
              o.sibling.return = o.return, o = o.sibling;
            }
          _ &= 1;
        }
        switch (T(sr, _), R) {
          case "forwards":
            for (f = a.child, R = null; f !== null; )
              o = f.alternate, o !== null && Tl(o) === null && (R = f), f = f.sibling;
            f = R, f === null ? (R = a.child, a.child = null) : (R = f.sibling, f.sibling = null), ka(
              a,
              !1,
              R,
              f,
              I
            );
            break;
          case "backwards":
            for (f = null, R = a.child, a.child = null; R !== null; ) {
              if (o = R.alternate, o !== null && Tl(o) === null) {
                a.child = R;
                break;
              }
              o = R.sibling, R.sibling = f, f = R, R = o;
            }
            ka(
              a,
              !0,
              f,
              null,
              I
            );
            break;
          case "together":
            ka(a, !1, null, null, void 0);
            break;
          default:
            a.memoizedState = null;
        }
        return a.child;
      }
      function hi(o, a, f) {
        if (o !== null && (a.dependencies = o.dependencies), qo |= a.lanes, (f & a.childLanes) === 0)
          if (o !== null) {
            if (Oa(
              o,
              a,
              f,
              !1
            ), (f & a.childLanes) === 0)
              return null;
          } else return null;
        if (o !== null && a.child !== o.child)
          throw Error(i(153));
        if (a.child !== null) {
          for (o = a.child, f = Bo(o, o.pendingProps), a.child = f, f.return = a; o.sibling !== null; )
            o = o.sibling, f = f.sibling = Bo(o, o.pendingProps), f.return = a;
          f.sibling = null;
        }
        return a.child;
      }
      function Ra(o, a) {
        return (o.lanes & a) !== 0 ? !0 : (o = o.dependencies, !!(o !== null && Po(o)));
      }
      function Vl(o, a, f) {
        switch (a.tag) {
          case 3:
            rt(
              a,
              a.stateNode.containerInfo
            ), Zi(a, Fn, o.memoizedState.cache), bt();
            break;
          case 27:
          case 5:
            yt(a);
            break;
          case 4:
            rt(
              a,
              a.stateNode.containerInfo
            );
            break;
          case 10:
            Zi(
              a,
              a.type,
              a.memoizedProps.value
            );
            break;
          case 13:
            var _ = a.memoizedState;
            if (_ !== null)
              return _.dehydrated !== null ? (fs(a), a.flags |= 128, null) : (f & a.child.childLanes) !== 0 ? _u(
                o,
                a,
                f
              ) : (fs(a), o = hi(
                o,
                a,
                f
              ), o !== null ? o.sibling : null);
            fs(a);
            break;
          case 19:
            var R = (o.flags & 128) !== 0;
            if (_ = (f & a.childLanes) !== 0, _ || (Oa(
              o,
              a,
              f,
              !1
            ), _ = (f & a.childLanes) !== 0), R) {
              if (_)
                return ys(
                  o,
                  a,
                  f
                );
              a.flags |= 128;
            }
            if (R = a.memoizedState, R !== null && (R.rendering = null, R.tail = null, R.lastEffect = null), T(sr, sr.current), _) break;
            return null;
          case 22:
          case 23:
            return a.lanes = 0, Vh(o, a, f);
          case 24:
            Zi(a, Fn, o.memoizedState.cache);
        }
        return hi(o, a, f);
      }
      function Gl(o, a, f) {
        if (o !== null)
          if (o.memoizedProps !== a.pendingProps)
            mr = !0;
          else {
            if (!Ra(o, f) && (a.flags & 128) === 0)
              return mr = !1, Vl(
                o,
                a,
                f
              );
            mr = (o.flags & 131072) !== 0;
          }
        else
          mr = !1, Je && (a.flags & 1048576) !== 0 && Z(a, nf, a.index);
        switch (a.lanes = 0, a.tag) {
          case 16:
            t: {
              o = a.pendingProps;
              var _ = a.elementType, R = _._init;
              if (_ = R(_._payload), a.type = _, typeof _ == "function")
                Cm(_) ? (o = Qi(_, o), a.tag = 1, a = Ll(
                  null,
                  a,
                  _,
                  o,
                  f
                )) : (a.tag = 0, a = Ea(
                  null,
                  a,
                  _,
                  o,
                  f
                ));
              else {
                if (_ != null) {
                  if (R = _.$$typeof, R === Mm) {
                    a.tag = 11, a = Ta(
                      null,
                      a,
                      _,
                      o,
                      f
                    );
                    break t;
                  } else if (R === Pm) {
                    a.tag = 14, a = Ca(
                      null,
                      a,
                      _,
                      o,
                      f
                    );
                    break t;
                  }
                }
                throw a = l(_) || _, Error(i(306, a, ""));
              }
            }
            return a;
          case 0:
            return Ea(
              o,
              a,
              a.type,
              a.pendingProps,
              f
            );
          case 1:
            return _ = a.type, R = Qi(
              _,
              a.pendingProps
            ), Ll(
              o,
              a,
              _,
              R,
              f
            );
          case 3:
            t: {
              if (rt(
                a,
                a.stateNode.containerInfo
              ), o === null) throw Error(i(387));
              var I = a.pendingProps;
              R = a.memoizedState, _ = R.element, Yt(o, a), je(a, I, null, f);
              var Q = a.memoizedState;
              if (I = Q.cache, Zi(a, Fn, I), I !== R.cache && No(
                a,
                [Fn],
                f,
                !0
              ), Pe(), I = Q.element, Oi && R.isDehydrated)
                if (R = {
                  element: I,
                  isDehydrated: !1,
                  cache: Q.cache
                }, a.updateQueue.baseState = R, a.memoizedState = R, a.flags & 256) {
                  a = rr(
                    o,
                    a,
                    I,
                    f
                  );
                  break t;
                } else if (I !== _) {
                  _ = Y(
                    Error(i(424)),
                    a
                  ), Ht(_), a = rr(
                    o,
                    a,
                    I,
                    f
                  );
                  break t;
                } else
                  for (Oi && (Dr = D4(
                    a.stateNode.containerInfo
                  ), qr = a, Je = !0, is = null, bs = !0), f = iv(
                    a,
                    null,
                    I,
                    f
                  ), a.child = f; f; )
                    f.flags = f.flags & -3 | 4096, f = f.sibling;
              else {
                if (bt(), I === _) {
                  a = hi(
                    o,
                    a,
                    f
                  );
                  break t;
                }
                In(o, a, I, f);
              }
              a = a.child;
            }
            return a;
          case 26:
            if (Ni)
              return Ws(o, a), o === null ? (f = K1(
                a.type,
                null,
                a.pendingProps,
                null
              )) ? a.memoizedState = f : Je || (a.stateNode = X4(
                a.type,
                a.pendingProps,
                zo.current,
                a
              )) : a.memoizedState = K1(
                a.type,
                o.memoizedProps,
                a.pendingProps,
                o.memoizedState
              ), null;
          case 27:
            if (Pr)
              return yt(a), o === null && Pr && Je && (_ = a.stateNode = tv(
                a.type,
                a.pendingProps,
                zo.current,
                Tr.current,
                !1
              ), qr = a, bs = !0, Dr = H1(_)), _ = a.pendingProps.children, o !== null || Je ? In(
                o,
                a,
                _,
                f
              ) : a.child = za(
                a,
                null,
                _,
                f
              ), Ws(o, a), a.child;
          case 5:
            return o === null && Je && ($4(
              a.type,
              a.pendingProps,
              Tr.current
            ), (R = _ = Dr) && (_ = B4(
              _,
              a.type,
              a.pendingProps,
              bs
            ), _ !== null ? (a.stateNode = _, qr = a, Dr = H1(_), bs = !1, R = !0) : R = !1), R || tt(a)), yt(a), R = a.type, I = a.pendingProps, Q = o !== null ? o.memoizedProps : null, _ = I.children, Qh(R, I) ? _ = null : Q !== null && Qh(R, Q) && (a.flags |= 32), a.memoizedState !== null && (R = Mi(
              o,
              a,
              ms,
              null,
              null,
              f
            ), Js ? ja._currentValue = R : ja._currentValue2 = R), Ws(o, a), In(o, a, _, f), a.child;
          case 6:
            return o === null && Je && (K4(
              a.pendingProps,
              Tr.current
            ), (o = f = Dr) && (f = F4(
              f,
              a.pendingProps,
              bs
            ), f !== null ? (a.stateNode = f, qr = a, Dr = null, o = !0) : o = !1), o || tt(a)), null;
          case 13:
            return _u(o, a, f);
          case 4:
            return rt(
              a,
              a.stateNode.containerInfo
            ), _ = a.pendingProps, o === null ? a.child = za(
              a,
              null,
              _,
              f
            ) : In(
              o,
              a,
              _,
              f
            ), a.child;
          case 11:
            return Ta(
              o,
              a,
              a.type,
              a.pendingProps,
              f
            );
          case 7:
            return In(
              o,
              a,
              a.pendingProps,
              f
            ), a.child;
          case 8:
            return In(
              o,
              a,
              a.pendingProps.children,
              f
            ), a.child;
          case 12:
            return In(
              o,
              a,
              a.pendingProps.children,
              f
            ), a.child;
          case 10:
            return _ = a.pendingProps, Zi(
              a,
              a.type,
              _.value
            ), In(
              o,
              a,
              _.children,
              f
            ), a.child;
          case 9:
            return R = a.type._context, _ = a.pendingProps.children, ts(a), R = hr(R), _ = _(R), a.flags |= 1, In(
              o,
              a,
              _,
              f
            ), a.child;
          case 14:
            return Ca(
              o,
              a,
              a.type,
              a.pendingProps,
              f
            );
          case 15:
            return bu(
              o,
              a,
              a.type,
              a.pendingProps,
              f
            );
          case 19:
            return ys(
              o,
              a,
              f
            );
          case 22:
            return Vh(o, a, f);
          case 24:
            return ts(a), _ = hr(Fn), o === null ? (R = Su(), R === null && (R = bn, I = ql(), R.pooledCache = I, I.refCount++, I !== null && (R.pooledCacheLanes |= f), R = I), a.memoizedState = {
              parent: _,
              cache: R
            }, Vt(a), Zi(a, Fn, R)) : ((o.lanes & f) !== 0 && (Yt(o, a), je(a, null, null, f), Pe()), R = o.memoizedState, I = a.memoizedState, R.parent !== _ ? (R = { parent: _, cache: _ }, a.memoizedState = R, a.lanes === 0 && (a.memoizedState = a.updateQueue.baseState = R), Zi(a, Fn, _)) : (_ = I.cache, Zi(a, Fn, _), _ !== R.cache && No(
              a,
              [Fn],
              f,
              !0
            ))), In(
              o,
              a,
              a.pendingProps.children,
              f
            ), a.child;
          case 29:
            throw a.pendingProps;
        }
        throw Error(i(156, a.tag));
      }
      function Zi(o, a, f) {
        Js ? (T(df, a._currentValue), a._currentValue = f) : (T(df, a._currentValue2), a._currentValue2 = f);
      }
      function Ji(o) {
        var a = df.current;
        Js ? o._currentValue = a : o._currentValue2 = a, w(df);
      }
      function Ma(o, a, f) {
        for (; o !== null; ) {
          var _ = o.alternate;
          if ((o.childLanes & a) !== a ? (o.childLanes |= a, _ !== null && (_.childLanes |= a)) : _ !== null && (_.childLanes & a) !== a && (_.childLanes |= a), o === f) break;
          o = o.return;
        }
      }
      function No(o, a, f, _) {
        var R = o.child;
        for (R !== null && (R.return = o); R !== null; ) {
          var I = R.dependencies;
          if (I !== null) {
            var Q = R.child;
            I = I.firstContext;
            t: for (; I !== null; ) {
              var lt = I;
              I = R;
              for (var St = 0; St < a.length; St++)
                if (lt.context === a[St]) {
                  I.lanes |= f, lt = I.alternate, lt !== null && (lt.lanes |= f), Ma(
                    I.return,
                    f,
                    o
                  ), _ || (Q = null);
                  break t;
                }
              I = lt.next;
            }
          } else if (R.tag === 18) {
            if (Q = R.return, Q === null) throw Error(i(341));
            Q.lanes |= f, I = Q.alternate, I !== null && (I.lanes |= f), Ma(Q, f, o), Q = null;
          } else Q = R.child;
          if (Q !== null) Q.return = R;
          else
            for (Q = R; Q !== null; ) {
              if (Q === o) {
                Q = null;
                break;
              }
              if (R = Q.sibling, R !== null) {
                R.return = Q.return, Q = R;
                break;
              }
              Q = Q.return;
            }
          R = Q;
        }
      }
      function Oa(o, a, f, _) {
        o = null;
        for (var R = a, I = !1; R !== null; ) {
          if (!I) {
            if ((R.flags & 524288) !== 0) I = !0;
            else if ((R.flags & 262144) !== 0) break;
          }
          if (R.tag === 10) {
            var Q = R.alternate;
            if (Q === null) throw Error(i(387));
            if (Q = Q.memoizedProps, Q !== null) {
              var lt = R.type;
              vi(R.pendingProps.value, Q.value) || (o !== null ? o.push(lt) : o = [lt]);
            }
          } else if (R === rf.current) {
            if (Q = R.alternate, Q === null) throw Error(i(387));
            Q.memoizedState.memoizedState !== R.memoizedState.memoizedState && (o !== null ? o.push(ja) : o = [ja]);
          }
          R = R.return;
        }
        o !== null && No(
          a,
          o,
          f,
          _
        ), a.flags |= 262144;
      }
      function Po(o) {
        for (o = o.firstContext; o !== null; ) {
          var a = o.context;
          if (!vi(
            Js ? a._currentValue : a._currentValue2,
            o.memoizedValue
          ))
            return !0;
          o = o.next;
        }
        return !1;
      }
      function ts(o) {
        qa = o, no = null, o = o.dependencies, o !== null && (o.firstContext = null);
      }
      function hr(o) {
        return Gh(qa, o);
      }
      function Na(o, a) {
        return qa === null && ts(o), Gh(o, a);
      }
      function Gh(o, a) {
        var f = Js ? a._currentValue : a._currentValue2;
        if (a = { context: a, memoizedValue: f, next: null }, no === null) {
          if (o === null) throw Error(i(308));
          no = a, o.dependencies = { lanes: 0, firstContext: a }, o.flags |= 524288;
        } else no = no.next = a;
        return f;
      }
      function ql() {
        return {
          controller: new fT(),
          data: /* @__PURE__ */ new Map(),
          refCount: 0
        };
      }
      function Do(o) {
        o.refCount--, o.refCount === 0 && pT(mT, function() {
          o.controller.abort();
        });
      }
      function Su() {
        var o = Ha.current;
        return o !== null ? o : bn.pooledCache;
      }
      function Pa(o, a) {
        a === null ? T(Ha, Ha.current) : T(Ha, a.pool);
      }
      function Hl() {
        var o = Su();
        return o === null ? null : {
          parent: Js ? Fn._currentValue : Fn._currentValue2,
          pool: o
        };
      }
      function Mr(o) {
        o.flags |= 4;
      }
      function xu(o, a) {
        if (o !== null && o.child === a.child) return !1;
        if ((a.flags & 16) !== 0) return !0;
        for (o = a.child; o !== null; ) {
          if ((o.flags & 13878) !== 0 || (o.subtreeFlags & 13878) !== 0)
            return !0;
          o = o.sibling;
        }
        return !1;
      }
      function Tu(o, a, f, _) {
        if (Nr)
          for (f = a.child; f !== null; ) {
            if (f.tag === 5 || f.tag === 6)
              Bm(o, f.stateNode);
            else if (!(f.tag === 4 || Pr && f.tag === 27) && f.child !== null) {
              f.child.return = f, f = f.child;
              continue;
            }
            if (f === a) break;
            for (; f.sibling === null; ) {
              if (f.return === null || f.return === a)
                return;
              f = f.return;
            }
            f.sibling.return = f.return, f = f.sibling;
          }
        else if (Lo)
          for (var R = a.child; R !== null; ) {
            if (R.tag === 5) {
              var I = R.stateNode;
              f && _ && (I = V1(
                I,
                R.type,
                R.memoizedProps
              )), Bm(o, I);
            } else if (R.tag === 6)
              I = R.stateNode, f && _ && (I = G1(
                I,
                R.memoizedProps
              )), Bm(o, I);
            else if (R.tag !== 4) {
              if (R.tag === 22 && R.memoizedState !== null)
                I = R.child, I !== null && (I.return = R), Tu(o, R, !0, !0);
              else if (R.child !== null) {
                R.child.return = R, R = R.child;
                continue;
              }
            }
            if (R === a) break;
            for (; R.sibling === null; ) {
              if (R.return === null || R.return === a)
                return;
              R = R.return;
            }
            R.sibling.return = R.return, R = R.sibling;
          }
      }
      function qh(o, a, f, _) {
        if (Lo)
          for (var R = a.child; R !== null; ) {
            if (R.tag === 5) {
              var I = R.stateNode;
              f && _ && (I = V1(
                I,
                R.type,
                R.memoizedProps
              )), z1(o, I);
            } else if (R.tag === 6)
              I = R.stateNode, f && _ && (I = G1(
                I,
                R.memoizedProps
              )), z1(o, I);
            else if (R.tag !== 4) {
              if (R.tag === 22 && R.memoizedState !== null)
                I = R.child, I !== null && (I.return = R), qh(
                  o,
                  R,
                  !(R.memoizedProps !== null && R.memoizedProps.mode === "manual"),
                  !0
                );
              else if (R.child !== null) {
                R.child.return = R, R = R.child;
                continue;
              }
            }
            if (R === a) break;
            for (; R.sibling === null; ) {
              if (R.return === null || R.return === a) return;
              R = R.return;
            }
            R.sibling.return = R.return, R = R.sibling;
          }
      }
      function Hh(o, a) {
        if (Lo && xu(o, a)) {
          o = a.stateNode;
          var f = o.containerInfo, _ = L1();
          qh(_, a, !1, !1), o.pendingChildren = _, Mr(a), R4(f, _);
        }
      }
      function Io(o, a, f, _) {
        if (Nr)
          o.memoizedProps !== _ && Mr(a);
        else if (Lo) {
          var R = o.stateNode, I = o.memoizedProps;
          if ((o = xu(o, a)) || I !== _) {
            var Q = Tr.current;
            I = k4(
              R,
              f,
              I,
              _,
              !o,
              null
            ), I === R ? a.stateNode = R : (P1(
              I,
              f,
              _,
              Q
            ) && Mr(a), a.stateNode = I, o ? Tu(I, a, !1, !1) : Mr(a));
          } else a.stateNode = R;
        }
      }
      function fi(o, a, f) {
        if (n4(a, f)) {
          if (o.flags |= 16777216, !B1(a, f))
            if (u1()) o.flags |= 8192;
            else
              throw oc = af, Xm;
        } else o.flags &= -16777217;
      }
      function Rn(o, a) {
        if (Z4(a)) {
          if (o.flags |= 16777216, !J1(a))
            if (u1()) o.flags |= 8192;
            else
              throw oc = af, Xm;
        } else o.flags &= -16777217;
      }
      function Ys(o, a) {
        a !== null && (o.flags |= 4), o.flags & 16384 && (a = o.tag !== 22 ? L() : 536870912, o.lanes |= a, fc |= a);
      }
      function fr(o, a) {
        if (!Je)
          switch (o.tailMode) {
            case "hidden":
              a = o.tail;
              for (var f = null; a !== null; )
                a.alternate !== null && (f = a), a = a.sibling;
              f === null ? o.tail = null : f.sibling = null;
              break;
            case "collapsed":
              f = o.tail;
              for (var _ = null; f !== null; )
                f.alternate !== null && (_ = f), f = f.sibling;
              _ === null ? a || o.tail === null ? o.tail = null : o.tail.sibling = null : _.sibling = null;
          }
      }
      function Cn(o) {
        var a = o.alternate !== null && o.alternate.child === o.child, f = 0, _ = 0;
        if (a)
          for (var R = o.child; R !== null; )
            f |= R.lanes | R.childLanes, _ |= R.subtreeFlags & 31457280, _ |= R.flags & 31457280, R.return = o, R = R.sibling;
        else
          for (R = o.child; R !== null; )
            f |= R.lanes | R.childLanes, _ |= R.subtreeFlags, _ |= R.flags, R.return = o, R = R.sibling;
        return o.subtreeFlags |= _, o.childLanes = f, a;
      }
      function Cu(o, a, f) {
        var _ = a.pendingProps;
        switch (et(a), a.tag) {
          case 16:
          case 15:
          case 0:
          case 11:
          case 7:
          case 8:
          case 12:
          case 9:
          case 14:
            return Cn(a), null;
          case 1:
            return Cn(a), null;
          case 3:
            return f = a.stateNode, _ = null, o !== null && (_ = o.memoizedState.cache), a.memoizedState.cache !== _ && (a.flags |= 2048), Ji(Fn), st(), f.pendingContext && (f.context = f.pendingContext, f.pendingContext = null), (o === null || o.child === null) && (Ct(a) ? Mr(a) : o === null || o.memoizedState.isDehydrated && (a.flags & 256) === 0 || (a.flags |= 1024, is !== null && (bm(is), is = null))), Hh(o, a), Cn(a), null;
          case 26:
            if (Ni) {
              f = a.type;
              var R = a.memoizedState;
              return o === null ? (Mr(a), R !== null ? (Cn(a), Rn(
                a,
                R
              )) : (Cn(a), fi(
                a,
                f,
                _
              ))) : R ? R !== o.memoizedState ? (Mr(a), Cn(a), Rn(
                a,
                R
              )) : (Cn(a), a.flags &= -16777217) : (Nr ? o.memoizedProps !== _ && Mr(a) : Io(
                o,
                a,
                f,
                _
              ), Cn(a), fi(
                a,
                f,
                _
              )), null;
            }
          case 27:
            if (Pr) {
              if (J(a), f = zo.current, R = a.type, o !== null && a.stateNode != null)
                Nr ? o.memoizedProps !== _ && Mr(a) : Io(
                  o,
                  a,
                  R,
                  _
                );
              else {
                if (!_) {
                  if (a.stateNode === null)
                    throw Error(i(166));
                  return Cn(a), null;
                }
                o = Tr.current, Ct(a) ? ot(a, o) : (o = tv(
                  R,
                  _,
                  f,
                  o,
                  !0
                ), a.stateNode = o, Mr(a));
              }
              return Cn(a), null;
            }
          case 5:
            if (J(a), f = a.type, o !== null && a.stateNode != null)
              Io(o, a, f, _);
            else {
              if (!_) {
                if (a.stateNode === null)
                  throw Error(i(166));
                return Cn(a), null;
              }
              o = Tr.current, Ct(a) ? ot(a, o) : (R = Yx(
                f,
                _,
                zo.current,
                o,
                a
              ), Tu(R, a, !1, !1), a.stateNode = R, P1(
                R,
                f,
                _,
                o
              ) && Mr(a));
            }
            return Cn(a), fi(
              a,
              a.type,
              a.pendingProps
            ), null;
          case 6:
            if (o && a.stateNode != null)
              f = o.memoizedProps, Nr ? f !== _ && Mr(a) : Lo && (f !== _ ? (a.stateNode = D1(
                _,
                zo.current,
                Tr.current,
                a
              ), Mr(a)) : a.stateNode = o.stateNode);
            else {
              if (typeof _ != "string" && a.stateNode === null)
                throw Error(i(166));
              if (o = zo.current, f = Tr.current, Ct(a)) {
                if (!Oi) throw Error(i(176));
                if (o = a.stateNode, f = a.memoizedProps, _ = null, R = qr, R !== null)
                  switch (R.tag) {
                    case 27:
                    case 5:
                      _ = R.memoizedProps;
                  }
                z4(
                  o,
                  f,
                  a,
                  _
                ) || tt(a);
              } else
                a.stateNode = D1(
                  _,
                  o,
                  f,
                  a
                );
            }
            return Cn(a), null;
          case 13:
            if (_ = a.memoizedState, o === null || o.memoizedState !== null && o.memoizedState.dehydrated !== null) {
              if (R = Ct(a), _ !== null && _.dehydrated !== null) {
                if (o === null) {
                  if (!R) throw Error(i(318));
                  if (!Oi) throw Error(i(344));
                  if (R = a.memoizedState, R = R !== null ? R.dehydrated : null, !R) throw Error(i(317));
                  U4(R, a);
                } else
                  bt(), (a.flags & 128) === 0 && (a.memoizedState = null), a.flags |= 4;
                Cn(a), R = !1;
              } else
                is !== null && (bm(is), is = null), R = !0;
              if (!R)
                return a.flags & 256 ? (Xr(a), a) : (Xr(a), null);
            }
            if (Xr(a), (a.flags & 128) !== 0)
              return a.lanes = f, a;
            if (f = _ !== null, o = o !== null && o.memoizedState !== null, f) {
              _ = a.child, R = null, _.alternate !== null && _.alternate.memoizedState !== null && _.alternate.memoizedState.cachePool !== null && (R = _.alternate.memoizedState.cachePool.pool);
              var I = null;
              _.memoizedState !== null && _.memoizedState.cachePool !== null && (I = _.memoizedState.cachePool.pool), I !== R && (_.flags |= 2048);
            }
            return f !== o && f && (a.child.flags |= 8192), Ys(a, a.updateQueue), Cn(a), null;
          case 4:
            return st(), Hh(o, a), o === null && Zx(a.stateNode.containerInfo), Cn(a), null;
          case 10:
            return Ji(a.type), Cn(a), null;
          case 19:
            if (w(sr), R = a.memoizedState, R === null)
              return Cn(a), null;
            if (_ = (a.flags & 128) !== 0, I = R.rendering, I === null)
              if (_) fr(R, !1);
              else {
                if (Ln !== 0 || o !== null && (o.flags & 128) !== 0)
                  for (o = a.child; o !== null; ) {
                    if (I = Tl(o), I !== null) {
                      for (a.flags |= 128, fr(R, !1), o = I.updateQueue, a.updateQueue = o, Ys(a, o), a.subtreeFlags = 0, o = f, f = a.child; f !== null; )
                        _1(f, o), f = f.sibling;
                      return T(
                        sr,
                        sr.current & 1 | 2
                      ), a.child;
                    }
                    o = o.sibling;
                  }
                R.tail !== null && rs() > Fu && (a.flags |= 128, _ = !0, fr(R, !1), a.lanes = 4194304);
              }
            else {
              if (!_)
                if (o = Tl(I), o !== null) {
                  if (a.flags |= 128, _ = !0, o = o.updateQueue, a.updateQueue = o, Ys(a, o), fr(R, !0), R.tail === null && R.tailMode === "hidden" && !I.alternate && !Je)
                    return Cn(a), null;
                } else
                  2 * rs() - R.renderingStartTime > Fu && f !== 536870912 && (a.flags |= 128, _ = !0, fr(R, !1), a.lanes = 4194304);
              R.isBackwards ? (I.sibling = a.child, a.child = I) : (o = R.last, o !== null ? o.sibling = I : a.child = I, R.last = I);
            }
            return R.tail !== null ? (a = R.tail, R.rendering = a, R.tail = a.sibling, R.renderingStartTime = rs(), a.sibling = null, o = sr.current, T(
              sr,
              _ ? o & 1 | 2 : o & 1
            ), a) : (Cn(a), null);
          case 22:
          case 23:
            return Xr(a), Dn(), _ = a.memoizedState !== null, o !== null ? o.memoizedState !== null !== _ && (a.flags |= 8192) : _ && (a.flags |= 8192), _ ? (f & 536870912) !== 0 && (a.flags & 128) === 0 && (Cn(a), a.subtreeFlags & 6 && (a.flags |= 8192)) : Cn(a), f = a.updateQueue, f !== null && Ys(a, f.retryQueue), f = null, o !== null && o.memoizedState !== null && o.memoizedState.cachePool !== null && (f = o.memoizedState.cachePool.pool), _ = null, a.memoizedState !== null && a.memoizedState.cachePool !== null && (_ = a.memoizedState.cachePool.pool), _ !== f && (a.flags |= 2048), o !== null && w(Ha), null;
          case 24:
            return f = null, o !== null && (f = o.memoizedState.cache), a.memoizedState.cache !== f && (a.flags |= 2048), Ji(Fn), Cn(a), null;
          case 25:
            return null;
        }
        throw Error(i(156, a.tag));
      }
      function Wh(o, a) {
        switch (et(a), a.tag) {
          case 1:
            return o = a.flags, o & 65536 ? (a.flags = o & -65537 | 128, a) : null;
          case 3:
            return Ji(Fn), st(), o = a.flags, (o & 65536) !== 0 && (o & 128) === 0 ? (a.flags = o & -65537 | 128, a) : null;
          case 26:
          case 27:
          case 5:
            return J(a), null;
          case 13:
            if (Xr(a), o = a.memoizedState, o !== null && o.dehydrated !== null) {
              if (a.alternate === null)
                throw Error(i(340));
              bt();
            }
            return o = a.flags, o & 65536 ? (a.flags = o & -65537 | 128, a) : null;
          case 19:
            return w(sr), null;
          case 4:
            return st(), null;
          case 10:
            return Ji(a.type), null;
          case 22:
          case 23:
            return Xr(a), Dn(), o !== null && w(Ha), o = a.flags, o & 65536 ? (a.flags = o & -65537 | 128, a) : null;
          case 24:
            return Ji(Fn), null;
          case 25:
            return null;
          default:
            return null;
        }
      }
      function vs(o, a) {
        switch (et(a), a.tag) {
          case 3:
            Ji(Fn), st();
            break;
          case 26:
          case 27:
          case 5:
            J(a);
            break;
          case 4:
            st();
            break;
          case 13:
            Xr(a);
            break;
          case 19:
            w(sr);
            break;
          case 10:
            Ji(a.type);
            break;
          case 22:
          case 23:
            Xr(a), Dn(), o !== null && w(Ha);
            break;
          case 24:
            Ji(Fn);
        }
      }
      function Xs(o, a) {
        try {
          var f = a.updateQueue, _ = f !== null ? f.lastEffect : null;
          if (_ !== null) {
            var R = _.next;
            f = R;
            do {
              if ((f.tag & o) === o) {
                _ = void 0;
                var I = f.create, Q = f.inst;
                _ = I(), Q.destroy = _;
              }
              f = f.next;
            } while (f !== R);
          }
        } catch (lt) {
          cn(a, a.return, lt);
        }
      }
      function Vr(o, a, f) {
        try {
          var _ = a.updateQueue, R = _ !== null ? _.lastEffect : null;
          if (R !== null) {
            var I = R.next;
            _ = I;
            do {
              if ((_.tag & o) === o) {
                var Q = _.inst, lt = Q.destroy;
                if (lt !== void 0) {
                  Q.destroy = void 0, R = a;
                  var St = f;
                  try {
                    lt();
                  } catch (It) {
                    cn(
                      R,
                      St,
                      It
                    );
                  }
                }
              }
              _ = _.next;
            } while (_ !== I);
          }
        } catch (It) {
          cn(a, a.return, It);
        }
      }
      function es(o) {
        var a = o.updateQueue;
        if (a !== null) {
          var f = o.stateNode;
          try {
            se(a, f);
          } catch (_) {
            cn(o, o.return, _);
          }
        }
      }
      function wu(o, a, f) {
        f.props = Qi(
          o.type,
          o.memoizedProps
        ), f.state = o.memoizedState;
        try {
          f.componentWillUnmount();
        } catch (_) {
          cn(o, a, _);
        }
      }
      function y(o, a) {
        try {
          var f = o.ref;
          if (f !== null) {
            var _ = o.stateNode;
            switch (o.tag) {
              case 26:
              case 27:
              case 5:
                var R = Eu(_);
                break;
              default:
                R = _;
            }
            typeof f == "function" ? o.refCleanup = f(R) : f.current = R;
          }
        } catch (I) {
          cn(o, a, I);
        }
      }
      function A(o, a) {
        var f = o.ref, _ = o.refCleanup;
        if (f !== null)
          if (typeof _ == "function")
            try {
              _();
            } catch (R) {
              cn(o, a, R);
            } finally {
              o.refCleanup = null, o = o.alternate, o != null && (o.refCleanup = null);
            }
          else if (typeof f == "function")
            try {
              f(null);
            } catch (R) {
              cn(o, a, R);
            }
          else f.current = null;
      }
      function P(o) {
        var a = o.type, f = o.memoizedProps, _ = o.stateNode;
        try {
          y4(_, a, f, o);
        } catch (R) {
          cn(o, o.return, R);
        }
      }
      function U(o, a, f) {
        try {
          v4(
            o.stateNode,
            o.type,
            f,
            a,
            o
          );
        } catch (_) {
          cn(o, o.return, _);
        }
      }
      function q(o) {
        return o.tag === 5 || o.tag === 3 || (Ni ? o.tag === 26 : !1) || (Pr ? o.tag === 27 : !1) || o.tag === 4;
      }
      function $(o) {
        t: for (; ; ) {
          for (; o.sibling === null; ) {
            if (o.return === null || q(o.return)) return null;
            o = o.return;
          }
          for (o.sibling.return = o.return, o = o.sibling; o.tag !== 5 && o.tag !== 6 && (!Pr || o.tag !== 27) && o.tag !== 18; ) {
            if (o.flags & 2 || o.child === null || o.tag === 4) continue t;
            o.child.return = o, o = o.child;
          }
          if (!(o.flags & 2)) return o.stateNode;
        }
      }
      function nt(o, a, f) {
        var _ = o.tag;
        if (_ === 5 || _ === 6)
          o = o.stateNode, a ? _4(f, o, a) : m4(f, o);
        else if (!(_ === 4 || Pr && _ === 27) && (o = o.child, o !== null))
          for (nt(o, a, f), o = o.sibling; o !== null; )
            nt(o, a, f), o = o.sibling;
      }
      function it(o, a, f) {
        var _ = o.tag;
        if (_ === 5 || _ === 6)
          o = o.stateNode, a ? b4(f, o, a) : p4(f, o);
        else if (!(_ === 4 || Pr && _ === 27) && (o = o.child, o !== null))
          for (it(o, a, f), o = o.sibling; o !== null; )
            it(o, a, f), o = o.sibling;
      }
      function ut(o, a, f) {
        o = o.containerInfo;
        try {
          U1(o, f);
        } catch (_) {
          cn(a, a.return, _);
        }
      }
      function ht(o, a) {
        for ($x(o.containerInfo), gr = a; gr !== null; )
          if (o = gr, a = o.child, (o.subtreeFlags & 1028) !== 0 && a !== null)
            a.return = o, gr = a;
          else
            for (; gr !== null; ) {
              o = gr;
              var f = o.alternate;
              switch (a = o.flags, o.tag) {
                case 0:
                  break;
                case 11:
                case 15:
                  break;
                case 1:
                  if ((a & 1024) !== 0 && f !== null) {
                    a = void 0;
                    var _ = o, R = f.memoizedProps;
                    f = f.memoizedState;
                    var I = _.stateNode;
                    try {
                      var Q = Qi(
                        _.type,
                        R,
                        _.elementType === _.type
                      );
                      a = I.getSnapshotBeforeUpdate(
                        Q,
                        f
                      ), I.__reactInternalSnapshotBeforeUpdate = a;
                    } catch (lt) {
                      cn(
                        _,
                        _.return,
                        lt
                      );
                    }
                  }
                  break;
                case 3:
                  (a & 1024) !== 0 && Nr && A4(o.stateNode.containerInfo);
                  break;
                case 5:
                case 26:
                case 27:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  if ((a & 1024) !== 0)
                    throw Error(i(163));
              }
              if (a = o.sibling, a !== null) {
                a.return = o.return, gr = a;
                break;
              }
              gr = o.return;
            }
        return Q = cv, cv = !1, Q;
      }
      function mt(o, a, f) {
        var _ = f.flags;
        switch (f.tag) {
          case 0:
          case 11:
          case 15:
            Gt(o, f), _ & 4 && Xs(5, f);
            break;
          case 1:
            if (Gt(o, f), _ & 4)
              if (o = f.stateNode, a === null)
                try {
                  o.componentDidMount();
                } catch (lt) {
                  cn(f, f.return, lt);
                }
              else {
                var R = Qi(
                  f.type,
                  a.memoizedProps
                );
                a = a.memoizedState;
                try {
                  o.componentDidUpdate(
                    R,
                    a,
                    o.__reactInternalSnapshotBeforeUpdate
                  );
                } catch (lt) {
                  cn(
                    f,
                    f.return,
                    lt
                  );
                }
              }
            _ & 64 && es(f), _ & 512 && y(f, f.return);
            break;
          case 3:
            if (Gt(o, f), _ & 64 && (_ = f.updateQueue, _ !== null)) {
              if (o = null, f.child !== null)
                switch (f.child.tag) {
                  case 27:
                  case 5:
                    o = Eu(f.child.stateNode);
                    break;
                  case 1:
                    o = f.child.stateNode;
                }
              try {
                se(_, o);
              } catch (lt) {
                cn(f, f.return, lt);
              }
            }
            break;
          case 26:
            if (Ni) {
              Gt(o, f), _ & 512 && y(f, f.return);
              break;
            }
          case 27:
          case 5:
            Gt(o, f), a === null && _ & 4 && P(f), _ & 512 && y(f, f.return);
            break;
          case 12:
            Gt(o, f);
            break;
          case 13:
            Gt(o, f), _ & 4 && pt(o, f);
            break;
          case 22:
            if (R = f.memoizedState !== null || ro, !R) {
              a = a !== null && a.memoizedState !== null || jn;
              var I = ro, Q = jn;
              ro = R, (jn = a) && !Q ? qt(
                o,
                f,
                (f.subtreeFlags & 8772) !== 0
              ) : Gt(o, f), ro = I, jn = Q;
            }
            _ & 512 && (f.memoizedProps.mode === "manual" ? y(f, f.return) : A(f, f.return));
            break;
          default:
            Gt(o, f);
        }
      }
      function at(o) {
        var a = o.alternate;
        a !== null && (o.alternate = null, at(a)), o.child = null, o.deletions = null, o.sibling = null, o.tag === 5 && (a = o.stateNode, a !== null && e4(a)), o.stateNode = null, o.return = null, o.dependencies = null, o.memoizedProps = null, o.memoizedState = null, o.pendingProps = null, o.stateNode = null, o.updateQueue = null;
      }
      function gt(o, a, f) {
        for (f = f.child; f !== null; )
          dt(
            o,
            a,
            f
          ), f = f.sibling;
      }
      function dt(o, a, f) {
        if (yi && typeof yi.onCommitFiberUnmount == "function")
          try {
            yi.onCommitFiberUnmount(Ru, f);
          } catch {
          }
        switch (f.tag) {
          case 26:
            if (Ni) {
              jn || A(f, a), gt(
                o,
                a,
                f
              ), f.memoizedState ? X1(f.memoizedState) : f.stateNode && Z1(f.stateNode);
              break;
            }
          case 27:
            if (Pr) {
              jn || A(f, a);
              var _ = Zn, R = bi;
              Zn = f.stateNode, gt(
                o,
                a,
                f
              ), nT(f.stateNode), Zn = _, bi = R;
              break;
            }
          case 5:
            jn || A(f, a);
          case 6:
            if (Nr) {
              if (_ = Zn, R = bi, Zn = null, gt(
                o,
                a,
                f
              ), Zn = _, bi = R, Zn !== null)
                if (bi)
                  try {
                    x4(Zn, f.stateNode);
                  } catch (I) {
                    cn(
                      f,
                      a,
                      I
                    );
                  }
                else
                  try {
                    S4(Zn, f.stateNode);
                  } catch (I) {
                    cn(
                      f,
                      a,
                      I
                    );
                  }
            } else
              gt(
                o,
                a,
                f
              );
            break;
          case 18:
            Nr && Zn !== null && (bi ? W4(
              Zn,
              f.stateNode
            ) : H4(Zn, f.stateNode));
            break;
          case 4:
            Nr ? (_ = Zn, R = bi, Zn = f.stateNode.containerInfo, bi = !0, gt(
              o,
              a,
              f
            ), Zn = _, bi = R) : (Lo && ut(
              f.stateNode,
              f,
              L1()
            ), gt(
              o,
              a,
              f
            ));
            break;
          case 0:
          case 11:
          case 14:
          case 15:
            jn || Vr(2, f, a), jn || Vr(4, f, a), gt(
              o,
              a,
              f
            );
            break;
          case 1:
            jn || (A(f, a), _ = f.stateNode, typeof _.componentWillUnmount == "function" && wu(
              f,
              a,
              _
            )), gt(
              o,
              a,
              f
            );
            break;
          case 21:
            gt(
              o,
              a,
              f
            );
            break;
          case 22:
            jn || A(f, a), jn = (_ = jn) || f.memoizedState !== null, gt(
              o,
              a,
              f
            ), jn = _;
            break;
          default:
            gt(
              o,
              a,
              f
            );
        }
      }
      function pt(o, a) {
        if (Oi && a.memoizedState === null && (o = a.alternate, o !== null && (o = o.memoizedState, o !== null && (o = o.dehydrated, o !== null))))
          try {
            q4(o);
          } catch (f) {
            cn(a, a.return, f);
          }
      }
      function _t(o) {
        switch (o.tag) {
          case 13:
          case 19:
            var a = o.stateNode;
            return a === null && (a = o.stateNode = new lv()), a;
          case 22:
            return o = o.stateNode, a = o._retryCache, a === null && (a = o._retryCache = new lv()), a;
          default:
            throw Error(i(435, o.tag));
        }
      }
      function ft(o, a) {
        var f = _t(o);
        a.forEach(function(_) {
          var R = Dx.bind(null, o, _);
          f.has(_) || (f.add(_), _.then(R, R));
        });
      }
      function xt(o, a) {
        var f = a.deletions;
        if (f !== null)
          for (var _ = 0; _ < f.length; _++) {
            var R = f[_], I = o, Q = a;
            if (Nr) {
              var lt = Q;
              t: for (; lt !== null; ) {
                switch (lt.tag) {
                  case 27:
                  case 5:
                    Zn = lt.stateNode, bi = !1;
                    break t;
                  case 3:
                    Zn = lt.stateNode.containerInfo, bi = !0;
                    break t;
                  case 4:
                    Zn = lt.stateNode.containerInfo, bi = !0;
                    break t;
                }
                lt = lt.return;
              }
              if (Zn === null) throw Error(i(160));
              dt(I, Q, R), Zn = null, bi = !1;
            } else dt(I, Q, R);
            I = R.alternate, I !== null && (I.return = null), R.return = null;
          }
        if (a.subtreeFlags & 13878)
          for (a = a.child; a !== null; )
            kt(a, o), a = a.sibling;
      }
      function kt(o, a) {
        var f = o.alternate, _ = o.flags;
        switch (o.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            xt(a, o), Et(o), _ & 4 && (Vr(3, o, o.return), Xs(3, o), Vr(5, o, o.return));
            break;
          case 1:
            xt(a, o), Et(o), _ & 512 && (jn || f === null || A(f, f.return)), _ & 64 && ro && (o = o.updateQueue, o !== null && (_ = o.callbacks, _ !== null && (f = o.shared.hiddenCallbacks, o.shared.hiddenCallbacks = f === null ? _ : f.concat(_))));
            break;
          case 26:
            if (Ni) {
              var R = ss;
              xt(a, o), Et(o), _ & 512 && (jn || f === null || A(f, f.return)), _ & 4 && (_ = f !== null ? f.memoizedState : null, a = o.memoizedState, f === null ? a === null ? o.stateNode === null ? o.stateNode = Y4(
                R,
                o.type,
                o.memoizedProps,
                o
              ) : Q1(
                R,
                o.type,
                o.stateNode
              ) : o.stateNode = Y1(
                R,
                a,
                o.memoizedProps
              ) : _ !== a ? (_ === null ? f.stateNode !== null && Z1(f.stateNode) : X1(_), a === null ? Q1(
                R,
                o.type,
                o.stateNode
              ) : Y1(
                R,
                a,
                o.memoizedProps
              )) : a === null && o.stateNode !== null && U(
                o,
                o.memoizedProps,
                f.memoizedProps
              ));
              break;
            }
          case 27:
            if (Pr && _ & 4 && o.alternate === null) {
              R = o.stateNode;
              var I = o.memoizedProps;
              try {
                tT(R), eT(
                  o.type,
                  I,
                  R,
                  o
                );
              } catch (te) {
                cn(o, o.return, te);
              }
            }
          case 5:
            if (xt(a, o), Et(o), _ & 512 && (jn || f === null || A(f, f.return)), Nr) {
              if (o.flags & 32) {
                a = o.stateNode;
                try {
                  j1(a);
                } catch (te) {
                  cn(o, o.return, te);
                }
              }
              _ & 4 && o.stateNode != null && (a = o.memoizedProps, U(
                o,
                a,
                f !== null ? f.memoizedProps : a
              )), _ & 1024 && (tg = !0);
            }
            break;
          case 6:
            if (xt(a, o), Et(o), _ & 4 && Nr) {
              if (o.stateNode === null)
                throw Error(i(162));
              _ = o.memoizedProps, f = f !== null ? f.memoizedProps : _, a = o.stateNode;
              try {
                g4(a, f, _);
              } catch (te) {
                cn(o, o.return, te);
              }
            }
            break;
          case 3:
            if (Ni ? (Q4(), R = ss, ss = zm(a.containerInfo), xt(a, o), ss = R) : xt(a, o), Et(o), _ & 4) {
              if (Nr && Oi && f !== null && f.memoizedState.isDehydrated)
                try {
                  G4(a.containerInfo);
                } catch (te) {
                  cn(o, o.return, te);
                }
              if (Lo) {
                _ = a.containerInfo, f = a.pendingChildren;
                try {
                  U1(_, f);
                } catch (te) {
                  cn(o, o.return, te);
                }
              }
            }
            tg && (tg = !1, Pt(o));
            break;
          case 4:
            Ni ? (f = ss, ss = zm(
              o.stateNode.containerInfo
            ), xt(a, o), Et(o), ss = f) : (xt(a, o), Et(o)), _ & 4 && Lo && ut(
              o.stateNode,
              o,
              o.stateNode.pendingChildren
            );
            break;
          case 12:
            xt(a, o), Et(o);
            break;
          case 13:
            xt(a, o), Et(o), o.child.flags & 8192 && o.memoizedState !== null != (f !== null && f.memoizedState !== null) && (ig = rs()), _ & 4 && (_ = o.updateQueue, _ !== null && (o.updateQueue = null, ft(o, _)));
            break;
          case 22:
            _ & 512 && (jn || f === null || A(f, f.return)), R = o.memoizedState !== null;
            var Q = f !== null && f.memoizedState !== null, lt = ro, St = jn;
            if (ro = lt || R, jn = St || Q, xt(a, o), jn = St, ro = lt, Et(o), a = o.stateNode, a._current = o, a._visibility &= -3, a._visibility |= a._pendingVisibility & 2, _ & 8192 && (a._visibility = R ? a._visibility & -2 : a._visibility | 1, R && (a = ro || jn, f === null || Q || a || Jt(o)), Nr && (o.memoizedProps === null || o.memoizedProps.mode !== "manual"))) {
              t: if (f = null, Nr)
                for (a = o; ; ) {
                  if (a.tag === 5 || Ni && a.tag === 26 || Pr && a.tag === 27) {
                    if (f === null) {
                      Q = f = a;
                      try {
                        I = Q.stateNode, R ? T4(I) : w4(
                          Q.stateNode,
                          Q.memoizedProps
                        );
                      } catch (te) {
                        cn(Q, Q.return, te);
                      }
                    }
                  } else if (a.tag === 6) {
                    if (f === null) {
                      Q = a;
                      try {
                        var It = Q.stateNode;
                        R ? C4(It) : E4(It, Q.memoizedProps);
                      } catch (te) {
                        cn(Q, Q.return, te);
                      }
                    }
                  } else if ((a.tag !== 22 && a.tag !== 23 || a.memoizedState === null || a === o) && a.child !== null) {
                    a.child.return = a, a = a.child;
                    continue;
                  }
                  if (a === o) break t;
                  for (; a.sibling === null; ) {
                    if (a.return === null || a.return === o)
                      break t;
                    f === a && (f = null), a = a.return;
                  }
                  f === a && (f = null), a.sibling.return = a.return, a = a.sibling;
                }
            }
            _ & 4 && (_ = o.updateQueue, _ !== null && (f = _.retryQueue, f !== null && (_.retryQueue = null, ft(o, f))));
            break;
          case 19:
            xt(a, o), Et(o), _ & 4 && (_ = o.updateQueue, _ !== null && (o.updateQueue = null, ft(o, _)));
            break;
          case 21:
            break;
          default:
            xt(a, o), Et(o);
        }
      }
      function Et(o) {
        var a = o.flags;
        if (a & 2) {
          try {
            if (Nr && (!Pr || o.tag !== 27)) {
              t: {
                for (var f = o.return; f !== null; ) {
                  if (q(f)) {
                    var _ = f;
                    break t;
                  }
                  f = f.return;
                }
                throw Error(i(160));
              }
              switch (_.tag) {
                case 27:
                  if (Pr) {
                    var R = _.stateNode, I = $(o);
                    it(
                      o,
                      I,
                      R
                    );
                    break;
                  }
                case 5:
                  var Q = _.stateNode;
                  _.flags & 32 && (j1(Q), _.flags &= -33);
                  var lt = $(o);
                  it(o, lt, Q);
                  break;
                case 3:
                case 4:
                  var St = _.stateNode.containerInfo, It = $(o);
                  nt(
                    o,
                    It,
                    St
                  );
                  break;
                default:
                  throw Error(i(161));
              }
            }
          } catch (te) {
            cn(o, o.return, te);
          }
          o.flags &= -3;
        }
        a & 4096 && (o.flags &= -4097);
      }
      function Pt(o) {
        if (o.subtreeFlags & 1024)
          for (o = o.child; o !== null; ) {
            var a = o;
            Pt(a), a.tag === 5 && a.flags & 1024 && s4(a.stateNode), o = o.sibling;
          }
      }
      function Gt(o, a) {
        if (a.subtreeFlags & 8772)
          for (a = a.child; a !== null; )
            mt(o, a.alternate, a), a = a.sibling;
      }
      function Jt(o) {
        for (o = o.child; o !== null; ) {
          var a = o;
          switch (a.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              Vr(4, a, a.return), Jt(a);
              break;
            case 1:
              A(a, a.return);
              var f = a.stateNode;
              typeof f.componentWillUnmount == "function" && wu(
                a,
                a.return,
                f
              ), Jt(a);
              break;
            case 26:
            case 27:
            case 5:
              A(a, a.return), Jt(a);
              break;
            case 22:
              A(a, a.return), a.memoizedState === null && Jt(a);
              break;
            default:
              Jt(a);
          }
          o = o.sibling;
        }
      }
      function qt(o, a, f) {
        for (f = f && (a.subtreeFlags & 8772) !== 0, a = a.child; a !== null; ) {
          var _ = a.alternate, R = o, I = a, Q = I.flags;
          switch (I.tag) {
            case 0:
            case 11:
            case 15:
              qt(
                R,
                I,
                f
              ), Xs(4, I);
              break;
            case 1:
              if (qt(
                R,
                I,
                f
              ), _ = I, R = _.stateNode, typeof R.componentDidMount == "function")
                try {
                  R.componentDidMount();
                } catch (It) {
                  cn(_, _.return, It);
                }
              if (_ = I, R = _.updateQueue, R !== null) {
                var lt = _.stateNode;
                try {
                  var St = R.shared.hiddenCallbacks;
                  if (St !== null)
                    for (R.shared.hiddenCallbacks = null, R = 0; R < St.length; R++)
                      cr(St[R], lt);
                } catch (It) {
                  cn(_, _.return, It);
                }
              }
              f && Q & 64 && es(I), y(I, I.return);
              break;
            case 26:
            case 27:
            case 5:
              qt(
                R,
                I,
                f
              ), f && _ === null && Q & 4 && P(I), y(I, I.return);
              break;
            case 12:
              qt(
                R,
                I,
                f
              );
              break;
            case 13:
              qt(
                R,
                I,
                f
              ), f && Q & 4 && pt(R, I);
              break;
            case 22:
              I.memoizedState === null && qt(
                R,
                I,
                f
              ), y(I, I.return);
              break;
            default:
              qt(
                R,
                I,
                f
              );
          }
          a = a.sibling;
        }
      }
      function Qt(o, a) {
        var f = null;
        o !== null && o.memoizedState !== null && o.memoizedState.cachePool !== null && (f = o.memoizedState.cachePool.pool), o = null, a.memoizedState !== null && a.memoizedState.cachePool !== null && (o = a.memoizedState.cachePool.pool), o !== f && (o != null && o.refCount++, f != null && Do(f));
      }
      function oe(o, a) {
        o = null, a.alternate !== null && (o = a.alternate.memoizedState.cache), a = a.memoizedState.cache, a !== o && (a.refCount++, o != null && Do(o));
      }
      function Xt(o, a, f, _) {
        if (a.subtreeFlags & 10256)
          for (a = a.child; a !== null; )
            ue(
              o,
              a,
              f,
              _
            ), a = a.sibling;
      }
      function ue(o, a, f, _) {
        var R = a.flags;
        switch (a.tag) {
          case 0:
          case 11:
          case 15:
            Xt(
              o,
              a,
              f,
              _
            ), R & 2048 && Xs(9, a);
            break;
          case 3:
            Xt(
              o,
              a,
              f,
              _
            ), R & 2048 && (o = null, a.alternate !== null && (o = a.alternate.memoizedState.cache), a = a.memoizedState.cache, a !== o && (a.refCount++, o != null && Do(o)));
            break;
          case 12:
            if (R & 2048) {
              Xt(
                o,
                a,
                f,
                _
              ), o = a.stateNode;
              try {
                var I = a.memoizedProps, Q = I.id, lt = I.onPostCommit;
                typeof lt == "function" && lt(
                  Q,
                  a.alternate === null ? "mount" : "update",
                  o.passiveEffectDuration,
                  -0
                );
              } catch (St) {
                cn(a, a.return, St);
              }
            } else
              Xt(
                o,
                a,
                f,
                _
              );
            break;
          case 23:
            break;
          case 22:
            I = a.stateNode, a.memoizedState !== null ? I._visibility & 4 ? Xt(
              o,
              a,
              f,
              _
            ) : Ae(
              o,
              a
            ) : I._visibility & 4 ? Xt(
              o,
              a,
              f,
              _
            ) : (I._visibility |= 4, ve(
              o,
              a,
              f,
              _,
              (a.subtreeFlags & 10256) !== 0
            )), R & 2048 && Qt(
              a.alternate,
              a
            );
            break;
          case 24:
            Xt(
              o,
              a,
              f,
              _
            ), R & 2048 && oe(a.alternate, a);
            break;
          default:
            Xt(
              o,
              a,
              f,
              _
            );
        }
      }
      function ve(o, a, f, _, R) {
        for (R = R && (a.subtreeFlags & 10256) !== 0, a = a.child; a !== null; ) {
          var I = o, Q = a, lt = f, St = _, It = Q.flags;
          switch (Q.tag) {
            case 0:
            case 11:
            case 15:
              ve(
                I,
                Q,
                lt,
                St,
                R
              ), Xs(8, Q);
              break;
            case 23:
              break;
            case 22:
              var te = Q.stateNode;
              Q.memoizedState !== null ? te._visibility & 4 ? ve(
                I,
                Q,
                lt,
                St,
                R
              ) : Ae(
                I,
                Q
              ) : (te._visibility |= 4, ve(
                I,
                Q,
                lt,
                St,
                R
              )), R && It & 2048 && Qt(
                Q.alternate,
                Q
              );
              break;
            case 24:
              ve(
                I,
                Q,
                lt,
                St,
                R
              ), R && It & 2048 && oe(Q.alternate, Q);
              break;
            default:
              ve(
                I,
                Q,
                lt,
                St,
                R
              );
          }
          a = a.sibling;
        }
      }
      function Ae(o, a) {
        if (a.subtreeFlags & 10256)
          for (a = a.child; a !== null; ) {
            var f = o, _ = a, R = _.flags;
            switch (_.tag) {
              case 22:
                Ae(f, _), R & 2048 && Qt(
                  _.alternate,
                  _
                );
                break;
              case 24:
                Ae(f, _), R & 2048 && oe(
                  _.alternate,
                  _
                );
                break;
              default:
                Ae(f, _);
            }
            a = a.sibling;
          }
      }
      function Te(o) {
        if (o.subtreeFlags & dc)
          for (o = o.child; o !== null; )
            Or(o), o = o.sibling;
      }
      function Or(o) {
        switch (o.tag) {
          case 26:
            Te(o), o.flags & dc && (o.memoizedState !== null ? J4(
              ss,
              o.memoizedState,
              o.memoizedProps
            ) : F1(o.type, o.memoizedProps));
            break;
          case 5:
            Te(o), o.flags & dc && F1(o.type, o.memoizedProps);
            break;
          case 3:
          case 4:
            if (Ni) {
              var a = ss;
              ss = zm(
                o.stateNode.containerInfo
              ), Te(o), ss = a;
            } else Te(o);
            break;
          case 22:
            o.memoizedState === null && (a = o.alternate, a !== null && a.memoizedState !== null ? (a = dc, dc = 16777216, Te(o), dc = a) : Te(o));
            break;
          default:
            Te(o);
        }
      }
      function Ce(o) {
        var a = o.alternate;
        if (a !== null && (o = a.child, o !== null)) {
          a.child = null;
          do
            a = o.sibling, o.sibling = null, o = a;
          while (o !== null);
        }
      }
      function Bn(o) {
        var a = o.deletions;
        if ((o.flags & 16) !== 0) {
          if (a !== null)
            for (var f = 0; f < a.length; f++) {
              var _ = a[f];
              gr = _, pr(
                _,
                o
              );
            }
          Ce(o);
        }
        if (o.subtreeFlags & 10256)
          for (o = o.child; o !== null; )
            ir(o), o = o.sibling;
      }
      function ir(o) {
        switch (o.tag) {
          case 0:
          case 11:
          case 15:
            Bn(o), o.flags & 2048 && Vr(9, o, o.return);
            break;
          case 3:
            Bn(o);
            break;
          case 12:
            Bn(o);
            break;
          case 22:
            var a = o.stateNode;
            o.memoizedState !== null && a._visibility & 4 && (o.return === null || o.return.tag !== 13) ? (a._visibility &= -5, Qs(o)) : Bn(o);
            break;
          default:
            Bn(o);
        }
      }
      function Qs(o) {
        var a = o.deletions;
        if ((o.flags & 16) !== 0) {
          if (a !== null)
            for (var f = 0; f < a.length; f++) {
              var _ = a[f];
              gr = _, pr(
                _,
                o
              );
            }
          Ce(o);
        }
        for (o = o.child; o !== null; ) {
          switch (a = o, a.tag) {
            case 0:
            case 11:
            case 15:
              Vr(8, a, a.return), Qs(a);
              break;
            case 22:
              f = a.stateNode, f._visibility & 4 && (f._visibility &= -5, Qs(a));
              break;
            default:
              Qs(a);
          }
          o = o.sibling;
        }
      }
      function pr(o, a) {
        for (; gr !== null; ) {
          var f = gr;
          switch (f.tag) {
            case 0:
            case 11:
            case 15:
              Vr(8, f, a);
              break;
            case 23:
            case 22:
              if (f.memoizedState !== null && f.memoizedState.cachePool !== null) {
                var _ = f.memoizedState.cachePool.pool;
                _ != null && _.refCount++;
              }
              break;
            case 24:
              Do(f.memoizedState.cache);
          }
          if (_ = f.child, _ !== null) _.return = f, gr = _;
          else
            t: for (f = o; gr !== null; ) {
              _ = gr;
              var R = _.sibling, I = _.return;
              if (at(_), _ === f) {
                gr = null;
                break t;
              }
              if (R !== null) {
                R.return = I, gr = R;
                break t;
              }
              gr = I;
            }
        }
      }
      function ns(o) {
        var a = I1(o);
        if (a != null) {
          if (typeof a.memoizedProps["data-testname"] != "string")
            throw Error(i(364));
          return a;
        }
        if (o = l4(o), o === null) throw Error(i(362));
        return o.stateNode.current;
      }
      function Da(o, a) {
        var f = o.tag;
        switch (a.$$typeof) {
          case hf:
            if (o.type === a.value) return !0;
            break;
          case ff:
            t: {
              for (a = a.value, o = [o, 0], f = 0; f < o.length; ) {
                var _ = o[f++], R = _.tag, I = o[f++], Q = a[I];
                if (R !== 5 && R !== 26 && R !== 27 || !ku(_)) {
                  for (; Q != null && Da(_, Q); )
                    I++, Q = a[I];
                  if (I === a.length) {
                    a = !0;
                    break t;
                  } else
                    for (_ = _.child; _ !== null; )
                      o.push(_, I), _ = _.sibling;
                }
              }
              a = !1;
            }
            return a;
          case pf:
            if ((f === 5 || f === 26 || f === 27) && d4(o.stateNode, a.value))
              return !0;
            break;
          case gf:
            if ((f === 5 || f === 6 || f === 26 || f === 27) && (o = u4(o), o !== null && 0 <= o.indexOf(a.value)))
              return !0;
            break;
          case mf:
            if ((f === 5 || f === 26 || f === 27) && (o = o.memoizedProps["data-testname"], typeof o == "string" && o.toLowerCase() === a.value.toLowerCase()))
              return !0;
            break;
          default:
            throw Error(i(365));
        }
        return !1;
      }
      function ym(o) {
        switch (o.$$typeof) {
          case hf:
            return "<" + (l(o.value) || "Unknown") + ">";
          case ff:
            return ":has(" + (ym(o) || "") + ")";
          case pf:
            return '[role="' + o.value + '"]';
          case gf:
            return '"' + o.value + '"';
          case mf:
            return '[data-testname="' + o.value + '"]';
          default:
            throw Error(i(365));
        }
      }
      function i1(o, a) {
        var f = [];
        o = [o, 0];
        for (var _ = 0; _ < o.length; ) {
          var R = o[_++], I = R.tag, Q = o[_++], lt = a[Q];
          if (I !== 5 && I !== 26 && I !== 27 || !ku(R)) {
            for (; lt != null && Da(R, lt); )
              Q++, lt = a[Q];
            if (Q === a.length) f.push(R);
            else
              for (R = R.child; R !== null; )
                o.push(R, Q), R = R.sibling;
          }
        }
        return f;
      }
      function vm(o, a) {
        if (!Au) throw Error(i(363));
        o = ns(o), o = i1(o, a), a = [], o = Array.from(o);
        for (var f = 0; f < o.length; ) {
          var _ = o[f++], R = _.tag;
          if (R === 5 || R === 26 || R === 27)
            ku(_) || a.push(_.stateNode);
          else
            for (_ = _.child; _ !== null; )
              o.push(_), _ = _.sibling;
        }
        return a;
      }
      function pi() {
        if ((fn & 2) !== 0 && Ye !== 0)
          return Ye & -Ye;
        if (Ee.T !== null) {
          var o = ic;
          return o !== 0 ? o : Rt();
        }
        return Jx();
      }
      function s1() {
        Fi === 0 && (Fi = (Ye & 536870912) === 0 || Je ? N() : 536870912);
        var o = Bi.current;
        return o !== null && (o.flags |= 32), Fi;
      }
      function Gr(o, a, f) {
        (o === bn && _n === 2 || o.cancelPendingCommit !== null) && (Wl(o, 0), Zs(
          o,
          Ye,
          Fi,
          !1
        )), F(o, f), ((fn & 2) === 0 || o !== bn) && (o === bn && ((fn & 2) === 0 && (Wa |= f), Ln === 4 && Zs(
          o,
          Ye,
          Fi,
          !1
        )), re(o));
      }
      function o1(o, a, f) {
        if ((fn & 6) !== 0) throw Error(i(327));
        var _ = !f && (a & 60) === 0 && (a & o.expiredLanes) === 0 || O(o, a), R = _ ? Rx(o, a) : xm(o, a, !0), I = _;
        do {
          if (R === 0) {
            hc && !_ && Zs(o, a, 0, !1);
            break;
          } else if (R === 6)
            Zs(
              o,
              a,
              0,
              !io
            );
          else {
            if (f = o.current.alternate, I && !Ax(f)) {
              R = xm(o, a, !1), I = !1;
              continue;
            }
            if (R === 2) {
              if (I = a, o.errorRecoveryDisabledLanes & I)
                var Q = 0;
              else
                Q = o.pendingLanes & -536870913, Q = Q !== 0 ? Q : Q & 536870912 ? 536870912 : 0;
              if (Q !== 0) {
                a = Q;
                t: {
                  var lt = o;
                  R = Bu;
                  var St = Oi && lt.current.memoizedState.isDehydrated;
                  if (St && (Wl(lt, Q).flags |= 256), Q = xm(
                    lt,
                    Q,
                    !1
                  ), Q !== 2) {
                    if (eg && !St) {
                      lt.errorRecoveryDisabledLanes |= I, Wa |= I, R = 4;
                      break t;
                    }
                    I = xs, xs = R, I !== null && bm(I);
                  }
                  R = Q;
                }
                if (I = !1, R !== 2) continue;
              }
            }
            if (R === 1) {
              Wl(o, 0), Zs(o, a, 0, !0);
              break;
            }
            t: {
              switch (_ = o, R) {
                case 0:
                case 1:
                  throw Error(i(345));
                case 4:
                  if ((a & 4194176) === a) {
                    Zs(
                      _,
                      a,
                      Fi,
                      !io
                    );
                    break t;
                  }
                  break;
                case 2:
                  xs = null;
                  break;
                case 3:
                case 5:
                  break;
                default:
                  throw Error(i(329));
              }
              if (_.finishedWork = f, _.finishedLanes = a, (a & 62914560) === a && (I = ig + 300 - rs(), 10 < I)) {
                if (Zs(
                  _,
                  a,
                  Fi,
                  !io
                ), E(_, 0) !== 0) break t;
                _.timeoutHandle = Xx(
                  a1.bind(
                    null,
                    _,
                    f,
                    xs,
                    yf,
                    rg,
                    a,
                    Fi,
                    Wa,
                    fc,
                    io,
                    2,
                    -0,
                    0
                  ),
                  I
                );
                break t;
              }
              a1(
                _,
                f,
                xs,
                yf,
                rg,
                a,
                Fi,
                Wa,
                fc,
                io,
                0,
                -0,
                0
              );
            }
          }
          break;
        } while (!0);
        re(o);
      }
      function bm(o) {
        xs === null ? xs = o : xs.push.apply(
          xs,
          o
        );
      }
      function a1(o, a, f, _, R, I, Q, lt, St, It, te, ae, de) {
        var Oe = a.subtreeFlags;
        if ((Oe & 8192 || (Oe & 16785408) === 16785408) && (r4(), Or(a), a = i4(), a !== null)) {
          o.cancelPendingCommit = a(
            g1.bind(
              null,
              o,
              f,
              _,
              R,
              Q,
              lt,
              St,
              1,
              ae,
              de
            )
          ), Zs(o, I, Q, !It);
          return;
        }
        g1(
          o,
          f,
          _,
          R,
          Q,
          lt,
          St,
          te,
          ae,
          de
        );
      }
      function Ax(o) {
        for (var a = o; ; ) {
          var f = a.tag;
          if ((f === 0 || f === 11 || f === 15) && a.flags & 16384 && (f = a.updateQueue, f !== null && (f = f.stores, f !== null)))
            for (var _ = 0; _ < f.length; _++) {
              var R = f[_], I = R.getSnapshot;
              R = R.value;
              try {
                if (!vi(I(), R)) return !1;
              } catch {
                return !1;
              }
            }
          if (f = a.child, a.subtreeFlags & 16384 && f !== null)
            f.return = a, a = f;
          else {
            if (a === o) break;
            for (; a.sibling === null; ) {
              if (a.return === null || a.return === o) return !0;
              a = a.return;
            }
            a.sibling.return = a.return, a = a.sibling;
          }
        }
        return !0;
      }
      function Zs(o, a, f, _) {
        a &= ~ng, a &= ~Wa, o.suspendedLanes |= a, o.pingedLanes &= ~a, _ && (o.warmLanes |= a), _ = o.expirationTimes;
        for (var R = a; 0 < R; ) {
          var I = 31 - gi(R), Q = 1 << I;
          _[I] = -1, R &= ~Q;
        }
        f !== 0 && M(o, f, a);
      }
      function l1() {
        return (fn & 6) === 0 ? (le(0), !1) : !0;
      }
      function _m() {
        if (Ge !== null) {
          if (_n === 0)
            var o = Ge.return;
          else
            o = Ge, no = qa = null, wl(o), ac = null, Pu = 0, o = Ge;
          for (; o !== null; )
            vs(o.alternate, o), o = o.return;
          Ge = null;
        }
      }
      function Wl(o, a) {
        o.finishedWork = null, o.finishedLanes = 0;
        var f = o.timeoutHandle;
        f !== Fm && (o.timeoutHandle = Fm, Qx(f)), f = o.cancelPendingCommit, f !== null && (o.cancelPendingCommit = null, f()), _m(), bn = o, Ge = f = Bo(o.current, null), Ye = a, _n = 0, _i = null, io = !1, hc = O(o, a), eg = !1, fc = Fi = ng = Wa = qo = Ln = 0, xs = Bu = null, rg = !1, (a & 8) !== 0 && (a |= a & 32);
        var _ = o.entangledLanes;
        if (_ !== 0)
          for (o = o.entanglements, _ &= a; 0 < _; ) {
            var R = 31 - gi(_), I = 1 << R;
            a |= o[R], _ &= ~I;
          }
        return so = a, $t(), f;
      }
      function c1(o, a) {
        De = null, Ee.H = Ss, a === Nu ? (a = kr(), _n = 3) : a === Xm ? (a = kr(), _n = 4) : _n = a === ov ? 8 : a !== null && typeof a == "object" && typeof a.then == "function" ? 6 : 1, _i = a, Ge === null && (Ln = 1, Il(
          o,
          Y(a, o.current)
        ));
      }
      function u1() {
        var o = Bi.current;
        return o === null ? !0 : (Ye & 4194176) === Ye ? _s === null : (Ye & 62914560) === Ye || (Ye & 536870912) !== 0 ? o === _s : !1;
      }
      function d1() {
        var o = Ee.H;
        return Ee.H = Ss, o === null ? Ss : o;
      }
      function h1() {
        var o = Ee.A;
        return Ee.A = gT, o;
      }
      function Sm() {
        Ln = 4, io || (Ye & 4194176) !== Ye && Bi.current !== null || (hc = !0), (qo & 134217727) === 0 && (Wa & 134217727) === 0 || bn === null || Zs(
          bn,
          Ye,
          Fi,
          !1
        );
      }
      function xm(o, a, f) {
        var _ = fn;
        fn |= 2;
        var R = d1(), I = h1();
        (bn !== o || Ye !== a) && (yf = null, Wl(o, a)), a = !1;
        var Q = Ln;
        t: do
          try {
            if (_n !== 0 && Ge !== null) {
              var lt = Ge, St = _i;
              switch (_n) {
                case 8:
                  _m(), Q = 6;
                  break t;
                case 3:
                case 2:
                case 6:
                  Bi.current === null && (a = !0);
                  var It = _n;
                  if (_n = 0, _i = null, $l(o, lt, St, It), f && hc) {
                    Q = 0;
                    break t;
                  }
                  break;
                default:
                  It = _n, _n = 0, _i = null, $l(o, lt, St, It);
              }
            }
            kx(), Q = Ln;
            break;
          } catch (te) {
            c1(o, te);
          }
        while (!0);
        return a && o.shellSuspendCounter++, no = qa = null, fn = _, Ee.H = R, Ee.A = I, Ge === null && (bn = null, Ye = 0, $t()), Q;
      }
      function kx() {
        for (; Ge !== null; ) f1(Ge);
      }
      function Rx(o, a) {
        var f = fn;
        fn |= 2;
        var _ = d1(), R = h1();
        bn !== o || Ye !== a ? (yf = null, Fu = rs() + 500, Wl(o, a)) : hc = O(
          o,
          a
        );
        t: do
          try {
            if (_n !== 0 && Ge !== null) {
              a = Ge;
              var I = _i;
              e: switch (_n) {
                case 1:
                  _n = 0, _i = null, $l(o, a, I, 1);
                  break;
                case 2:
                  if (on(I)) {
                    _n = 0, _i = null, p1(a);
                    break;
                  }
                  a = function() {
                    _n === 2 && bn === o && (_n = 7), re(o);
                  }, I.then(a, a);
                  break t;
                case 3:
                  _n = 7;
                  break t;
                case 4:
                  _n = 5;
                  break t;
                case 7:
                  on(I) ? (_n = 0, _i = null, p1(a)) : (_n = 0, _i = null, $l(o, a, I, 7));
                  break;
                case 5:
                  var Q = null;
                  switch (Ge.tag) {
                    case 26:
                      Q = Ge.memoizedState;
                    case 5:
                    case 27:
                      var lt = Ge, St = lt.type, It = lt.pendingProps;
                      if (Q ? J1(Q) : B1(St, It)) {
                        _n = 0, _i = null;
                        var te = lt.sibling;
                        if (te !== null) Ge = te;
                        else {
                          var ae = lt.return;
                          ae !== null ? (Ge = ae, $h(ae)) : Ge = null;
                        }
                        break e;
                      }
                  }
                  _n = 0, _i = null, $l(o, a, I, 5);
                  break;
                case 6:
                  _n = 0, _i = null, $l(o, a, I, 6);
                  break;
                case 8:
                  _m(), Ln = 6;
                  break t;
                default:
                  throw Error(i(462));
              }
            }
            Mx();
            break;
          } catch (de) {
            c1(o, de);
          }
        while (!0);
        return no = qa = null, Ee.H = _, Ee.A = R, fn = f, Ge !== null ? 0 : (bn = null, Ye = 0, $t(), Ln);
      }
      function Mx() {
        for (; Ge !== null && !sT(); )
          f1(Ge);
      }
      function f1(o) {
        var a = Gl(
          o.alternate,
          o,
          so
        );
        o.memoizedProps = o.pendingProps, a === null ? $h(o) : Ge = a;
      }
      function p1(o) {
        var a = o, f = a.alternate;
        switch (a.tag) {
          case 15:
          case 0:
            a = jl(
              f,
              a,
              a.pendingProps,
              a.type,
              void 0,
              Ye
            );
            break;
          case 11:
            a = jl(
              f,
              a,
              a.pendingProps,
              a.type.render,
              a.ref,
              Ye
            );
            break;
          case 5:
            wl(a);
          default:
            vs(f, a), a = Ge = _1(a, so), a = Gl(f, a, so);
        }
        o.memoizedProps = o.pendingProps, a === null ? $h(o) : Ge = a;
      }
      function $l(o, a, f, _) {
        no = qa = null, wl(a), ac = null, Pu = 0;
        var R = a.return;
        try {
          if (Uh(
            o,
            R,
            a,
            f,
            Ye
          )) {
            Ln = 1, Il(
              o,
              Y(f, o.current)
            ), Ge = null;
            return;
          }
        } catch (I) {
          if (R !== null) throw Ge = R, I;
          Ln = 1, Il(
            o,
            Y(f, o.current)
          ), Ge = null;
          return;
        }
        a.flags & 32768 ? (Je || _ === 1 ? o = !0 : hc || (Ye & 536870912) !== 0 ? o = !1 : (io = o = !0, (_ === 2 || _ === 3 || _ === 6) && (_ = Bi.current, _ !== null && _.tag === 13 && (_.flags |= 16384))), m1(a, o)) : $h(a);
      }
      function $h(o) {
        var a = o;
        do {
          if ((a.flags & 32768) !== 0) {
            m1(
              a,
              io
            );
            return;
          }
          o = a.return;
          var f = Cu(
            a.alternate,
            a,
            so
          );
          if (f !== null) {
            Ge = f;
            return;
          }
          if (a = a.sibling, a !== null) {
            Ge = a;
            return;
          }
          Ge = a = o;
        } while (a !== null);
        Ln === 0 && (Ln = 5);
      }
      function m1(o, a) {
        do {
          var f = Wh(o.alternate, o);
          if (f !== null) {
            f.flags &= 32767, Ge = f;
            return;
          }
          if (f = o.return, f !== null && (f.flags |= 32768, f.subtreeFlags = 0, f.deletions = null), !a && (o = o.sibling, o !== null)) {
            Ge = o;
            return;
          }
          Ge = o = f;
        } while (o !== null);
        Ln = 6, Ge = null;
      }
      function g1(o, a, f, _, R, I, Q, lt, St, It) {
        var te = Ee.T, ae = Fa();
        try {
          Zr(2), Ee.T = null, Ox(
            o,
            a,
            f,
            _,
            ae,
            R,
            I,
            Q,
            lt,
            St,
            It
          );
        } finally {
          Ee.T = te, Zr(ae);
        }
      }
      function Ox(o, a, f, _, R, I, Q, lt) {
        do
          Ia();
        while ($a !== null);
        if ((fn & 6) !== 0) throw Error(i(327));
        var St = o.finishedWork;
        if (_ = o.finishedLanes, St === null) return null;
        if (o.finishedWork = null, o.finishedLanes = 0, St === o.current) throw Error(i(177));
        o.callbackNode = null, o.callbackPriority = 0, o.cancelPendingCommit = null;
        var It = St.lanes | St.childLanes;
        if (It |= Hm, G(
          o,
          _,
          It,
          I,
          Q,
          lt
        ), o === bn && (Ge = bn = null, Ye = 0), (St.subtreeFlags & 10256) === 0 && (St.flags & 10256) === 0 || vf || (vf = !0, sg = It, og = f, Ix(Gm, function() {
          return Ia(), null;
        })), f = (St.flags & 15990) !== 0, (St.subtreeFlags & 15990) !== 0 || f ? (f = Ee.T, Ee.T = null, I = Fa(), Zr(2), Q = fn, fn |= 4, ht(o, St), kt(St, o), Kx(o.containerInfo), o.current = St, mt(o, St.alternate, St), oT(), fn = Q, Zr(I), Ee.T = f) : o.current = St, vf ? (vf = !1, $a = o, ju = _) : y1(o, It), It = o.pendingLanes, It === 0 && (Ho = null), z(St.stateNode), re(o), a !== null)
          for (R = o.onRecoverableError, St = 0; St < a.length; St++)
            It = a[St], R(It.value, {
              componentStack: It.stack
            });
        return (ju & 3) !== 0 && Ia(), It = o.pendingLanes, (_ & 4194218) !== 0 && (It & 42) !== 0 ? o === ag ? Lu++ : (Lu = 0, ag = o) : Lu = 0, le(0), null;
      }
      function y1(o, a) {
        (o.pooledCacheLanes &= a) === 0 && (a = o.pooledCache, a != null && (o.pooledCache = null, Do(a)));
      }
      function Ia() {
        if ($a !== null) {
          var o = $a, a = sg;
          sg = 0;
          var f = D(ju), _ = 32 > f ? 32 : f;
          f = Ee.T;
          var R = Fa();
          try {
            if (Zr(_), Ee.T = null, $a === null)
              var I = !1;
            else {
              _ = og, og = null;
              var Q = $a, lt = ju;
              if ($a = null, ju = 0, (fn & 6) !== 0)
                throw Error(i(331));
              var St = fn;
              if (fn |= 4, ir(Q.current), ue(
                Q,
                Q.current,
                lt,
                _
              ), fn = St, le(0, !1), yi && typeof yi.onPostCommitFiberRoot == "function")
                try {
                  yi.onPostCommitFiberRoot(Ru, Q);
                } catch {
                }
              I = !0;
            }
            return I;
          } finally {
            Zr(R), Ee.T = f, y1(o, a);
          }
        }
        return !1;
      }
      function v1(o, a, f) {
        a = Y(f, a), a = vu(o.stateNode, a, 2), o = fe(o, a, 2), o !== null && (F(o, 2), re(o));
      }
      function cn(o, a, f) {
        if (o.tag === 3)
          v1(o, o, f);
        else
          for (; a !== null; ) {
            if (a.tag === 3) {
              v1(
                a,
                o,
                f
              );
              break;
            } else if (a.tag === 1) {
              var _ = a.stateNode;
              if (typeof a.type.getDerivedStateFromError == "function" || typeof _.componentDidCatch == "function" && (Ho === null || !Ho.has(_))) {
                o = Y(f, o), f = Bl(2), _ = fe(a, f, 2), _ !== null && (Fl(
                  f,
                  _,
                  a,
                  o
                ), F(_, 2), re(_));
                break;
              }
            }
            a = a.return;
          }
      }
      function Tm(o, a, f) {
        var _ = o.pingCache;
        if (_ === null) {
          _ = o.pingCache = new yT();
          var R = /* @__PURE__ */ new Set();
          _.set(a, R);
        } else
          R = _.get(a), R === void 0 && (R = /* @__PURE__ */ new Set(), _.set(a, R));
        R.has(f) || (eg = !0, R.add(f), o = Nx.bind(null, o, a, f), a.then(o, o));
      }
      function Nx(o, a, f) {
        var _ = o.pingCache;
        _ !== null && _.delete(a), o.pingedLanes |= o.suspendedLanes & f, o.warmLanes &= ~f, bn === o && (Ye & f) === f && (Ln === 4 || Ln === 3 && (Ye & 62914560) === Ye && 300 > rs() - ig ? (fn & 2) === 0 && Wl(o, 0) : ng |= f, fc === Ye && (fc = 0)), re(o);
      }
      function b1(o, a) {
        a === 0 && (a = L()), o = Ut(o, a), o !== null && (F(o, a), re(o));
      }
      function Px(o) {
        var a = o.memoizedState, f = 0;
        a !== null && (f = a.retryLane), b1(o, f);
      }
      function Dx(o, a) {
        var f = 0;
        switch (o.tag) {
          case 13:
            var _ = o.stateNode, R = o.memoizedState;
            R !== null && (f = R.retryLane);
            break;
          case 19:
            _ = o.stateNode;
            break;
          case 22:
            _ = o.stateNode._retryCache;
            break;
          default:
            throw Error(i(314));
        }
        _ !== null && _.delete(a), b1(o, f);
      }
      function Ix(o, a) {
        return tf(o, a);
      }
      function Bx(o, a, f, _) {
        this.tag = o, this.key = f, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = a, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = _, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
      }
      function Cm(o) {
        return o = o.prototype, !(!o || !o.isReactComponent);
      }
      function Bo(o, a) {
        var f = o.alternate;
        return f === null ? (f = n(
          o.tag,
          a,
          o.key,
          o.mode
        ), f.elementType = o.elementType, f.type = o.type, f.stateNode = o.stateNode, f.alternate = o, o.alternate = f) : (f.pendingProps = a, f.type = o.type, f.flags = 0, f.subtreeFlags = 0, f.deletions = null), f.flags = o.flags & 31457280, f.childLanes = o.childLanes, f.lanes = o.lanes, f.child = o.child, f.memoizedProps = o.memoizedProps, f.memoizedState = o.memoizedState, f.updateQueue = o.updateQueue, a = o.dependencies, f.dependencies = a === null ? null : {
          lanes: a.lanes,
          firstContext: a.firstContext
        }, f.sibling = o.sibling, f.index = o.index, f.ref = o.ref, f.refCleanup = o.refCleanup, f;
      }
      function _1(o, a) {
        o.flags &= 31457282;
        var f = o.alternate;
        return f === null ? (o.childLanes = 0, o.lanes = a, o.child = null, o.subtreeFlags = 0, o.memoizedProps = null, o.memoizedState = null, o.updateQueue = null, o.dependencies = null, o.stateNode = null) : (o.childLanes = f.childLanes, o.lanes = f.lanes, o.child = f.child, o.subtreeFlags = 0, o.deletions = null, o.memoizedProps = f.memoizedProps, o.memoizedState = f.memoizedState, o.updateQueue = f.updateQueue, o.type = f.type, a = f.dependencies, o.dependencies = a === null ? null : {
          lanes: a.lanes,
          firstContext: a.firstContext
        }), o;
      }
      function Kh(o, a, f, _, R, I) {
        var Q = 0;
        if (_ = o, typeof o == "function") Cm(o) && (Q = 1);
        else if (typeof o == "string")
          Q = Ni && Pr ? $1(o, f, Tr.current) ? 26 : ev(o) ? 27 : 5 : Ni ? $1(
            o,
            f,
            Tr.current
          ) ? 26 : 5 : Pr && ev(o) ? 27 : 5;
        else
          t: switch (o) {
            case Yl:
              return Ba(
                f.children,
                R,
                I,
                a
              );
            case A1:
              Q = 8, R |= 24;
              break;
            case Rm:
              return o = n(12, f, a, R | 2), o.elementType = Rm, o.lanes = I, o;
            case Om:
              return o = n(13, f, a, R), o.elementType = Om, o.lanes = I, o;
            case Nm:
              return o = n(19, f, a, R), o.elementType = Nm, o.lanes = I, o;
            case R1:
              return S1(f, R, I, a);
            default:
              if (typeof o == "object" && o !== null)
                switch (o.$$typeof) {
                  case zx:
                  case Fo:
                    Q = 10;
                    break t;
                  case k1:
                    Q = 9;
                    break t;
                  case Mm:
                    Q = 11;
                    break t;
                  case Pm:
                    Q = 14;
                    break t;
                  case jo:
                    Q = 16, _ = null;
                    break t;
                }
              Q = 29, f = Error(
                i(
                  130,
                  o === null ? "null" : typeof o,
                  ""
                )
              ), _ = null;
          }
        return a = n(Q, f, a, R), a.elementType = o, a.type = _, a.lanes = I, a;
      }
      function Ba(o, a, f, _) {
        return o = n(7, o, _, a), o.lanes = f, o;
      }
      function S1(o, a, f, _) {
        o = n(22, o, _, a), o.elementType = R1, o.lanes = f;
        var R = {
          _visibility: 1,
          _pendingVisibility: 1,
          _pendingMarkers: null,
          _retryCache: null,
          _transitions: null,
          _current: null,
          detach: function() {
            var I = R._current;
            if (I === null) throw Error(i(456));
            if ((R._pendingVisibility & 2) === 0) {
              var Q = Ut(I, 2);
              Q !== null && (R._pendingVisibility |= 2, Gr(Q, I, 2));
            }
          },
          attach: function() {
            var I = R._current;
            if (I === null) throw Error(i(456));
            if ((R._pendingVisibility & 2) !== 0) {
              var Q = Ut(I, 2);
              Q !== null && (R._pendingVisibility &= -3, Gr(Q, I, 2));
            }
          }
        };
        return o.stateNode = R, o;
      }
      function wm(o, a, f) {
        return o = n(6, o, null, a), o.lanes = f, o;
      }
      function Em(o, a, f) {
        return a = n(
          4,
          o.children !== null ? o.children : [],
          o.key,
          a
        ), a.lanes = f, a.stateNode = {
          containerInfo: o.containerInfo,
          pendingChildren: null,
          implementation: o.implementation
        }, a;
      }
      function Fx(o, a, f, _, R, I, Q, lt) {
        this.tag = 1, this.containerInfo = o, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = Fm, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = k(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.finishedLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = k(0), this.hiddenUpdates = k(null), this.identifierPrefix = _, this.onUncaughtError = R, this.onCaughtError = I, this.onRecoverableError = Q, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = lt, this.incompleteTransitions = /* @__PURE__ */ new Map();
      }
      function x1(o, a, f, _, R, I, Q, lt, St, It, te, ae) {
        return o = new Fx(
          o,
          a,
          f,
          Q,
          lt,
          St,
          It,
          ae
        ), a = 1, I === !0 && (a |= 24), I = n(3, null, null, a), o.current = I, I.stateNode = o, a = ql(), a.refCount++, o.pooledCache = a, a.refCount++, I.memoizedState = {
          element: _,
          isDehydrated: f,
          cache: a
        }, Vt(I), o;
      }
      function T1(o) {
        return o ? (o = Zl, o) : Zl;
      }
      function C1(o) {
        var a = o._reactInternals;
        if (a === void 0)
          throw typeof o.render == "function" ? Error(i(188)) : (o = Object.keys(o).join(","), Error(i(268, o)));
        return o = m(a), o = o !== null ? g(o) : null, o === null ? null : Eu(o.stateNode);
      }
      function w1(o, a, f, _, R, I) {
        R = T1(R), _.context === null ? _.context = R : _.pendingContext = R, _ = ee(a), _.payload = { element: f }, I = I === void 0 ? null : I, I !== null && (_.callback = I), f = fe(o, _, a), f !== null && (Gr(f, o, a), ie(f, o, a));
      }
      function E1(o, a) {
        if (o = o.memoizedState, o !== null && o.dehydrated !== null) {
          var f = o.retryLane;
          o.retryLane = f !== 0 && f < a ? f : a;
        }
      }
      function Am(o, a) {
        E1(o, a), (o = o.alternate) && E1(o, a);
      }
      var Ve = {}, jx = O0(), mi = bx(), km = Object.assign, Lx = Symbol.for("react.element"), Yh = Symbol.for("react.transitional.element"), Kl = Symbol.for("react.portal"), Yl = Symbol.for("react.fragment"), A1 = Symbol.for("react.strict_mode"), Rm = Symbol.for("react.profiler"), zx = Symbol.for("react.provider"), k1 = Symbol.for("react.consumer"), Fo = Symbol.for("react.context"), Mm = Symbol.for("react.forward_ref"), Om = Symbol.for("react.suspense"), Nm = Symbol.for("react.suspense_list"), Pm = Symbol.for("react.memo"), jo = Symbol.for("react.lazy"), R1 = Symbol.for("react.offscreen"), Ux = Symbol.for("react.memo_cache_sentinel"), M1 = Symbol.iterator, Vx = Symbol.for("react.client.reference"), Ee = jx.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, Dm, O1, Im = !1, Xh = Array.isArray, Gx = t.rendererVersion, qx = t.rendererPackageName, N1 = t.extraDevToolsConfig, Eu = t.getPublicInstance, Hx = t.getRootHostContext, Wx = t.getChildHostContext, $x = t.prepareForCommit, Kx = t.resetAfterCommit, Yx = t.createInstance, Bm = t.appendInitialChild, P1 = t.finalizeInitialChildren, Qh = t.shouldSetTextContent, D1 = t.createTextInstance, Xx = t.scheduleTimeout, Qx = t.cancelTimeout, Fm = t.noTimeout, Js = t.isPrimaryRenderer;
      t.warnsIfNotActing;
      var Nr = t.supportsMutation, Lo = t.supportsPersistence, Oi = t.supportsHydration, I1 = t.getInstanceFromNode;
      t.beforeActiveInstanceBlur, t.afterActiveInstanceBlur;
      var Zx = t.preparePortalMount;
      t.prepareScopeUpdate, t.getInstanceFromScope;
      var Zr = t.setCurrentUpdatePriority, Fa = t.getCurrentUpdatePriority, Jx = t.resolveUpdatePriority;
      t.resolveEventType, t.resolveEventTimeStamp;
      var t4 = t.shouldAttemptEagerTransition, e4 = t.detachDeletedInstance;
      t.requestPostPaintCallback;
      var n4 = t.maySuspendCommit, B1 = t.preloadInstance, r4 = t.startSuspendingCommit, F1 = t.suspendInstance, i4 = t.waitForCommitToBeReady, Xl = t.NotPendingTransition, ja = t.HostTransitionContext, s4 = t.resetFormInstance;
      t.bindToConsole;
      var o4 = t.supportsMicrotasks, a4 = t.scheduleMicrotask, Au = t.supportsTestSelectors, l4 = t.findFiberRoot, c4 = t.getBoundingRect, u4 = t.getTextContent, ku = t.isHiddenSubtree, d4 = t.matchAccessibilityRole, h4 = t.setFocusIfFocusable, f4 = t.setupIntersectionObserver, p4 = t.appendChild, m4 = t.appendChildToContainer, g4 = t.commitTextUpdate, y4 = t.commitMount, v4 = t.commitUpdate, b4 = t.insertBefore, _4 = t.insertInContainerBefore, S4 = t.removeChild, x4 = t.removeChildFromContainer, j1 = t.resetTextContent, T4 = t.hideInstance, C4 = t.hideTextInstance, w4 = t.unhideInstance, E4 = t.unhideTextInstance, A4 = t.clearContainer, k4 = t.cloneInstance, L1 = t.createContainerChildSet, z1 = t.appendChildToContainerChildSet, R4 = t.finalizeContainerChildren, U1 = t.replaceContainerChildren, V1 = t.cloneHiddenInstance, G1 = t.cloneHiddenTextInstance, jm = t.isSuspenseInstancePending, Lm = t.isSuspenseInstanceFallback, M4 = t.getSuspenseInstanceFallbackErrorDetails, O4 = t.registerSuspenseInstanceRetry, N4 = t.canHydrateFormStateMarker, P4 = t.isFormStateMarkerMatching, q1 = t.getNextHydratableSibling, H1 = t.getFirstHydratableChild, D4 = t.getFirstHydratableChildWithinContainer, I4 = t.getFirstHydratableChildWithinSuspenseInstance, B4 = t.canHydrateInstance, F4 = t.canHydrateTextInstance, j4 = t.canHydrateSuspenseInstance, L4 = t.hydrateInstance, z4 = t.hydrateTextInstance, U4 = t.hydrateSuspenseInstance, V4 = t.getNextHydratableInstanceAfterSuspenseInstance, G4 = t.commitHydratedContainer, q4 = t.commitHydratedSuspenseInstance, H4 = t.clearSuspenseBoundary, W4 = t.clearSuspenseBoundaryFromContainer, W1 = t.shouldDeleteUnhydratedTailInstances;
      t.diffHydratedPropsForDevWarnings, t.diffHydratedTextForDevWarnings, t.describeHydratableInstanceForDevWarnings;
      var $4 = t.validateHydratableInstance, K4 = t.validateHydratableTextInstance, Ni = t.supportsResources, $1 = t.isHostHoistableType, zm = t.getHoistableRoot, K1 = t.getResource, Y1 = t.acquireResource, X1 = t.releaseResource, Y4 = t.hydrateHoistable, Q1 = t.mountHoistable, Z1 = t.unmountHoistable, X4 = t.createHoistableInstance, Q4 = t.prepareToCommitHoistables, Z4 = t.mayResourceSuspendCommit, J1 = t.preloadResource, J4 = t.suspendResource, Pr = t.supportsSingletons, tv = t.resolveSingletonInstance, tT = t.clearSingleton, eT = t.acquireSingletonInstance, nT = t.releaseSingletonInstance, ev = t.isHostSingletonType, Um = [], Ql = -1, Zl = {}, gi = Math.clz32 ? Math.clz32 : S, rT = Math.log, iT = Math.LN2, Zh = 128, Jh = 4194304, tf = mi.unstable_scheduleCallback, Vm = mi.unstable_cancelCallback, sT = mi.unstable_shouldYield, oT = mi.unstable_requestPaint, rs = mi.unstable_now, nv = mi.unstable_ImmediatePriority, aT = mi.unstable_UserBlockingPriority, Gm = mi.unstable_NormalPriority, lT = mi.unstable_IdlePriority, cT = mi.log, uT = mi.unstable_setDisableYieldValue, Ru = null, yi = null, vi = typeof Object.is == "function" ? Object.is : X, rv = /* @__PURE__ */ new WeakMap(), Jl = [], tc = 0, ef = null, nf = 0, Pi = [], Di = 0, La = null, to = 1, eo = "", Tr = x(null), Mu = x(null), zo = x(null), rf = x(null), qr = null, Dr = null, Je = !1, is = null, bs = !1, qm = Error(i(519)), Ii = [], ec = 0, Hm = 0, sf = null, nc = null, Wm = !1, of = !1, $m = !1, rc = 0, Ou = null, Km = 0, ic = 0, sc = null, Uo = !1, Ym = !1, dT = Object.prototype.hasOwnProperty, Nu = Error(i(460)), Xm = Error(i(474)), af = { then: function() {
      } }, oc = null, ac = null, Pu = 0, za = xl(!0), iv = xl(!1), lc = x(null), lf = x(0), Bi = x(null), _s = null, sr = x(0), Vo = 0, De = null, hn = null, Qn = null, cf = !1, cc = !1, Ua = !1, uf = 0, Du = 0, uc = null, hT = 0, Qm = function() {
        return { lastEffect: null, events: null, stores: null, memoCache: null };
      }, Ss = {
        readContext: hr,
        use: Qr,
        useCallback: an,
        useContext: an,
        useEffect: an,
        useImperativeHandle: an,
        useLayoutEffect: an,
        useInsertionEffect: an,
        useMemo: an,
        useReducer: an,
        useRef: an,
        useState: an,
        useDebugValue: an,
        useDeferredValue: an,
        useTransition: an,
        useSyncExternalStore: an,
        useId: an
      };
      Ss.useCacheRefresh = an, Ss.useMemoCache = an, Ss.useHostTransitionStatus = an, Ss.useFormState = an, Ss.useActionState = an, Ss.useOptimistic = an;
      var Va = {
        readContext: hr,
        use: Qr,
        useCallback: function(o, a) {
          return dr().memoizedState = [
            o,
            a === void 0 ? null : a
          ], o;
        },
        useContext: hr,
        useEffect: Fh,
        useImperativeHandle: function(o, a, f) {
          f = f != null ? f.concat([o]) : null, Ao(
            4194308,
            4,
            Yi.bind(null, a, o),
            f
          );
        },
        useLayoutEffect: function(o, a) {
          return Ao(4194308, 4, o, a);
        },
        useInsertionEffect: function(o, a) {
          Ao(4, 2, o, a);
        },
        useMemo: function(o, a) {
          var f = dr();
          a = a === void 0 ? null : a;
          var _ = o();
          if (Ua) {
            H(!0);
            try {
              o();
            } finally {
              H(!1);
            }
          }
          return f.memoizedState = [_, a], _;
        },
        useReducer: function(o, a, f) {
          var _ = dr();
          if (f !== void 0) {
            var R = f(a);
            if (Ua) {
              H(!0);
              try {
                f(a);
              } finally {
                H(!1);
              }
            }
          } else R = a;
          return _.memoizedState = _.baseState = R, o = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: o,
            lastRenderedState: R
          }, _.queue = o, o = o.dispatch = gu.bind(
            null,
            De,
            o
          ), [_.memoizedState, o];
        },
        useRef: function(o) {
          var a = dr();
          return o = { current: o }, a.memoizedState = o;
        },
        useState: function(o) {
          o = Al(o);
          var a = o.queue, f = Ro.bind(
            null,
            De,
            a
          );
          return a.dispatch = f, [o.memoizedState, f];
        },
        useDebugValue: Ml,
        useDeferredValue: function(o, a) {
          var f = dr();
          return qs(f, o, a);
        },
        useTransition: function() {
          var o = Al(!1);
          return o = Ol.bind(
            null,
            De,
            o.queue,
            !0,
            !1
          ), dr().memoizedState = o, [!1, o];
        },
        useSyncExternalStore: function(o, a, f) {
          var _ = De, R = dr();
          if (Je) {
            if (f === void 0)
              throw Error(i(407));
            f = f();
          } else {
            if (f = a(), bn === null)
              throw Error(i(349));
            (Ye & 60) !== 0 || au(_, a, f);
          }
          R.memoizedState = f;
          var I = { value: f, getSnapshot: a };
          return R.queue = I, Fh(lu.bind(null, _, I, o), [
            o
          ]), _.flags |= 2048, Eo(
            9,
            ma.bind(
              null,
              _,
              I,
              f,
              a
            ),
            { destroy: void 0 },
            null
          ), f;
        },
        useId: function() {
          var o = dr(), a = bn.identifierPrefix;
          if (Je) {
            var f = eo, _ = to;
            f = (_ & ~(1 << 32 - gi(_) - 1)).toString(32) + f, a = ":" + a + "R" + f, f = uf++, 0 < f && (a += "H" + f.toString(32)), a += ":";
          } else
            f = hT++, a = ":" + a + "r" + f.toString(32) + ":";
          return o.memoizedState = a;
        },
        useCacheRefresh: function() {
          return dr().memoizedState = jh.bind(
            null,
            De
          );
        }
      };
      Va.useMemoCache = El, Va.useHostTransitionStatus = mu, Va.useFormState = du, Va.useActionState = du, Va.useOptimistic = function(o) {
        var a = dr();
        a.memoizedState = a.baseState = o;
        var f = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: null,
          lastRenderedState: null
        };
        return a.queue = f, a = Pl.bind(
          null,
          De,
          !0,
          f
        ), f.dispatch = a, [o, a];
      };
      var Go = {
        readContext: hr,
        use: Qr,
        useCallback: Wn,
        useContext: hr,
        useEffect: xr,
        useImperativeHandle: pu,
        useInsertionEffect: Gs,
        useLayoutEffect: _a,
        useMemo: ui,
        useReducer: Us,
        useRef: Ke,
        useState: function() {
          return Us(Rr);
        },
        useDebugValue: Ml,
        useDeferredValue: function(o, a) {
          var f = Me();
          return ko(
            f,
            hn.memoizedState,
            o,
            a
          );
        },
        useTransition: function() {
          var o = Us(Rr)[0], a = Me().memoizedState;
          return [
            typeof o == "boolean" ? o : ci(o),
            a
          ];
        },
        useSyncExternalStore: gs,
        useId: di
      };
      Go.useCacheRefresh = Nl, Go.useMemoCache = El, Go.useHostTransitionStatus = mu, Go.useFormState = va, Go.useActionState = va, Go.useOptimistic = function(o, a) {
        var f = Me();
        return uu(f, hn, o, a);
      };
      var Ga = {
        readContext: hr,
        use: Qr,
        useCallback: Wn,
        useContext: hr,
        useEffect: xr,
        useImperativeHandle: pu,
        useInsertionEffect: Gs,
        useLayoutEffect: _a,
        useMemo: ui,
        useReducer: pa,
        useRef: Ke,
        useState: function() {
          return pa(Rr);
        },
        useDebugValue: Ml,
        useDeferredValue: function(o, a) {
          var f = Me();
          return hn === null ? qs(f, o, a) : ko(
            f,
            hn.memoizedState,
            o,
            a
          );
        },
        useTransition: function() {
          var o = pa(Rr)[0], a = Me().memoizedState;
          return [
            typeof o == "boolean" ? o : ci(o),
            a
          ];
        },
        useSyncExternalStore: gs,
        useId: di
      };
      Ga.useCacheRefresh = Nl, Ga.useMemoCache = El, Ga.useHostTransitionStatus = mu, Ga.useFormState = fu, Ga.useActionState = fu, Ga.useOptimistic = function(o, a) {
        var f = Me();
        return hn !== null ? uu(f, hn, o, a) : (f.baseState = o, [o, f.queue.dispatch]);
      };
      var Zm = {
        isMounted: function(o) {
          return (o = o._reactInternals) ? p(o) === o : !1;
        },
        enqueueSetState: function(o, a, f) {
          o = o._reactInternals;
          var _ = pi(), R = ee(_);
          R.payload = a, f != null && (R.callback = f), a = fe(o, R, _), a !== null && (Gr(a, o, _), ie(a, o, _));
        },
        enqueueReplaceState: function(o, a, f) {
          o = o._reactInternals;
          var _ = pi(), R = ee(_);
          R.tag = 1, R.payload = a, f != null && (R.callback = f), a = fe(o, R, _), a !== null && (Gr(a, o, _), ie(a, o, _));
        },
        enqueueForceUpdate: function(o, a) {
          o = o._reactInternals;
          var f = pi(), _ = ee(f);
          _.tag = 2, a != null && (_.callback = a), a = fe(o, _, f), a !== null && (Gr(a, o, f), ie(a, o, f));
        }
      }, sv = typeof reportError == "function" ? reportError : function(o) {
        if (typeof window == "object" && typeof window.ErrorEvent == "function") {
          var a = new window.ErrorEvent("error", {
            bubbles: !0,
            cancelable: !0,
            message: typeof o == "object" && o !== null && typeof o.message == "string" ? String(o.message) : String(o),
            error: o
          });
          if (!window.dispatchEvent(a)) return;
        } else if (typeof process == "object" && typeof process.emit == "function") {
          process.emit("uncaughtException", o);
          return;
        }
        console.error(o);
      }, ov = Error(i(461)), mr = !1, Jm = { dehydrated: null, treeContext: null, retryLane: 0 }, df = x(null), qa = null, no = null, fT = typeof AbortController < "u" ? AbortController : function() {
        var o = [], a = this.signal = {
          aborted: !1,
          addEventListener: function(f, _) {
            o.push(_);
          }
        };
        this.abort = function() {
          a.aborted = !0, o.forEach(function(f) {
            return f();
          });
        };
      }, pT = mi.unstable_scheduleCallback, mT = mi.unstable_NormalPriority, Fn = {
        $$typeof: Fo,
        Consumer: null,
        Provider: null,
        _currentValue: null,
        _currentValue2: null,
        _threadCount: 0
      }, av = Ee.S;
      Ee.S = function(o, a) {
        typeof a == "object" && a !== null && typeof a.then == "function" && Dt(o, a), av !== null && av(o, a);
      };
      var Ha = x(null), ro = !1, jn = !1, tg = !1, lv = typeof WeakSet == "function" ? WeakSet : Set, gr = null, cv = !1, Zn = null, bi = !1, ss = null, dc = 8192, gT = {
        getCacheForType: function(o) {
          var a = hr(Fn), f = a.data.get(o);
          return f === void 0 && (f = o(), a.data.set(o, f)), f;
        }
      }, hf = 0, ff = 1, pf = 2, mf = 3, gf = 4;
      if (typeof Symbol == "function" && Symbol.for) {
        var Iu = Symbol.for;
        hf = Iu("selector.component"), ff = Iu("selector.has_pseudo_class"), pf = Iu("selector.role"), mf = Iu("selector.test_id"), gf = Iu("selector.text");
      }
      var yT = typeof WeakMap == "function" ? WeakMap : Map, fn = 0, bn = null, Ge = null, Ye = 0, _n = 0, _i = null, io = !1, hc = !1, eg = !1, so = 0, Ln = 0, qo = 0, Wa = 0, ng = 0, Fi = 0, fc = 0, Bu = null, xs = null, rg = !1, ig = 0, Fu = 1 / 0, yf = null, Ho = null, vf = !1, $a = null, ju = 0, sg = 0, og = null, Lu = 0, ag = null;
      return Ve.attemptContinuousHydration = function(o) {
        if (o.tag === 13) {
          var a = Ut(o, 67108864);
          a !== null && Gr(a, o, 67108864), Am(o, 67108864);
        }
      }, Ve.attemptHydrationAtCurrentPriority = function(o) {
        if (o.tag === 13) {
          var a = pi(), f = Ut(o, a);
          f !== null && Gr(f, o, a), Am(o, a);
        }
      }, Ve.attemptSynchronousHydration = function(o) {
        switch (o.tag) {
          case 3:
            if (o = o.stateNode, o.current.memoizedState.isDehydrated) {
              var a = C(o.pendingLanes);
              if (a !== 0) {
                for (o.pendingLanes |= 2, o.entangledLanes |= 2; a; ) {
                  var f = 1 << 31 - gi(a);
                  o.entanglements[1] |= f, a &= ~f;
                }
                re(o), (fn & 6) === 0 && (Fu = rs() + 500, le(0));
              }
            }
            break;
          case 13:
            a = Ut(o, 2), a !== null && Gr(a, o, 2), l1(), Am(o, 2);
        }
      }, Ve.batchedUpdates = function(o, a) {
        return o(a);
      }, Ve.createComponentSelector = function(o) {
        return { $$typeof: hf, value: o };
      }, Ve.createContainer = function(o, a, f, _, R, I, Q, lt, St, It) {
        return x1(
          o,
          a,
          !1,
          null,
          f,
          _,
          I,
          Q,
          lt,
          St,
          It,
          null
        );
      }, Ve.createHasPseudoClassSelector = function(o) {
        return { $$typeof: ff, value: o };
      }, Ve.createHydrationContainer = function(o, a, f, _, R, I, Q, lt, St, It, te, ae, de) {
        return o = x1(
          f,
          _,
          !0,
          o,
          R,
          I,
          lt,
          St,
          It,
          te,
          ae,
          de
        ), o.context = T1(null), f = o.current, _ = pi(), R = ee(_), R.callback = a ?? null, fe(f, R, _), o.current.lanes = _, F(o, _), re(o), o;
      }, Ve.createPortal = function(o, a, f) {
        var _ = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
        return {
          $$typeof: Kl,
          key: _ == null ? null : "" + _,
          children: o,
          containerInfo: a,
          implementation: f
        };
      }, Ve.createRoleSelector = function(o) {
        return { $$typeof: pf, value: o };
      }, Ve.createTestNameSelector = function(o) {
        return { $$typeof: mf, value: o };
      }, Ve.createTextSelector = function(o) {
        return { $$typeof: gf, value: o };
      }, Ve.defaultOnCaughtError = function(o) {
        console.error(o);
      }, Ve.defaultOnRecoverableError = function(o) {
        sv(o);
      }, Ve.defaultOnUncaughtError = function(o) {
        sv(o);
      }, Ve.deferredUpdates = function(o) {
        var a = Ee.T, f = Fa();
        try {
          return Zr(32), Ee.T = null, o();
        } finally {
          Zr(f), Ee.T = a;
        }
      }, Ve.discreteUpdates = function(o, a, f, _, R) {
        var I = Ee.T, Q = Fa();
        try {
          return Zr(2), Ee.T = null, o(a, f, _, R);
        } finally {
          Zr(Q), Ee.T = I, fn === 0 && (Fu = rs() + 500);
        }
      }, Ve.findAllNodes = vm, Ve.findBoundingRects = function(o, a) {
        if (!Au) throw Error(i(363));
        a = vm(o, a), o = [];
        for (var f = 0; f < a.length; f++)
          o.push(c4(a[f]));
        for (a = o.length - 1; 0 < a; a--) {
          f = o[a];
          for (var _ = f.x, R = _ + f.width, I = f.y, Q = I + f.height, lt = a - 1; 0 <= lt; lt--)
            if (a !== lt) {
              var St = o[lt], It = St.x, te = It + St.width, ae = St.y, de = ae + St.height;
              if (_ >= It && I >= ae && R <= te && Q <= de) {
                o.splice(a, 1);
                break;
              } else if (_ !== It || f.width !== St.width || de < I || ae > Q) {
                if (!(I !== ae || f.height !== St.height || te < _ || It > R)) {
                  It > _ && (St.width += It - _, St.x = _), te < R && (St.width = R - It), o.splice(a, 1);
                  break;
                }
              } else {
                ae > I && (St.height += ae - I, St.y = I), de < Q && (St.height = Q - ae), o.splice(a, 1);
                break;
              }
            }
        }
        return o;
      }, Ve.findHostInstance = C1, Ve.findHostInstanceWithNoPortals = function(o) {
        return o = m(o), o = o !== null ? b(o) : null, o === null ? null : Eu(o.stateNode);
      }, Ve.findHostInstanceWithWarning = function(o) {
        return C1(o);
      }, Ve.flushPassiveEffects = Ia, Ve.flushSyncFromReconciler = function(o) {
        var a = fn;
        fn |= 1;
        var f = Ee.T, _ = Fa();
        try {
          if (Zr(2), Ee.T = null, o)
            return o();
        } finally {
          Zr(_), Ee.T = f, fn = a, (fn & 6) === 0 && le(0);
        }
      }, Ve.flushSyncWork = l1, Ve.focusWithin = function(o, a) {
        if (!Au) throw Error(i(363));
        for (o = ns(o), a = i1(o, a), a = Array.from(a), o = 0; o < a.length; ) {
          var f = a[o++], _ = f.tag;
          if (!ku(f)) {
            if ((_ === 5 || _ === 26 || _ === 27) && h4(f.stateNode))
              return !0;
            for (f = f.child; f !== null; )
              a.push(f), f = f.sibling;
          }
        }
        return !1;
      }, Ve.getFindAllNodesFailureDescription = function(o, a) {
        if (!Au) throw Error(i(363));
        var f = 0, _ = [];
        o = [ns(o), 0];
        for (var R = 0; R < o.length; ) {
          var I = o[R++], Q = I.tag, lt = o[R++], St = a[lt];
          if ((Q !== 5 && Q !== 26 && Q !== 27 || !ku(I)) && (Da(I, St) && (_.push(ym(St)), lt++, lt > f && (f = lt)), lt < a.length))
            for (I = I.child; I !== null; )
              o.push(I, lt), I = I.sibling;
        }
        if (f < a.length) {
          for (o = []; f < a.length; f++)
            o.push(ym(a[f]));
          return `findAllNodes was able to match part of the selector:
  ` + (_.join(" > ") + `

No matching component was found for:
  `) + o.join(" > ");
        }
        return null;
      }, Ve.getPublicRootInstance = function(o) {
        if (o = o.current, !o.child) return null;
        switch (o.child.tag) {
          case 27:
          case 5:
            return Eu(o.child.stateNode);
          default:
            return o.child.stateNode;
        }
      }, Ve.injectIntoDevTools = function() {
        var o = {
          bundleType: 0,
          version: Gx,
          rendererPackageName: qx,
          currentDispatcherRef: Ee,
          findFiberByHostInstance: I1,
          reconcilerVersion: "19.0.0"
        };
        if (N1 !== null && (o.rendererConfig = N1), typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u") o = !1;
        else {
          var a = __REACT_DEVTOOLS_GLOBAL_HOOK__;
          if (a.isDisabled || !a.supportsFiber) o = !0;
          else {
            try {
              Ru = a.inject(o), yi = a;
            } catch {
            }
            o = !!a.checkDCE;
          }
        }
        return o;
      }, Ve.isAlreadyRendering = function() {
        return !1;
      }, Ve.observeVisibleRects = function(o, a, f, _) {
        if (!Au) throw Error(i(363));
        o = vm(o, a);
        var R = f4(
          o,
          f,
          _
        ).disconnect;
        return {
          disconnect: function() {
            R();
          }
        };
      }, Ve.shouldError = function() {
        return null;
      }, Ve.shouldSuspend = function() {
        return !1;
      }, Ve.startHostTransition = function(o, a, f, _) {
        if (o.tag !== 5) throw Error(i(476));
        var R = Xi(o).queue;
        Ol(
          o,
          R,
          a,
          Xl,
          f === null ? r : function() {
            var I = Xi(o).next.queue;
            return Hs(
              o,
              I,
              {},
              pi()
            ), f(_);
          }
        );
      }, Ve.updateContainer = function(o, a, f, _) {
        var R = a.current, I = pi();
        return w1(
          R,
          I,
          o,
          a,
          f,
          _
        ), I;
      }, Ve.updateContainerSync = function(o, a, f, _) {
        return a.tag === 0 && Ia(), w1(
          a.current,
          2,
          o,
          a,
          f,
          _
        ), 2;
      }, Ve;
    }, e.exports.default = e.exports, Object.defineProperty(e.exports, "__esModule", { value: !0 });
  }(Vg)), Vg.exports;
}
var N_;
function FD() {
  return N_ || (N_ = 1, Ug.exports = BD()), Ug.exports;
}
var jD = FD();
const LD = /* @__PURE__ */ hh(jD);
var Hg = { exports: {} }, ho = {};
/**
 * @license React
 * react-reconciler-constants.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var P_;
function zD() {
  return P_ || (P_ = 1, ho.ConcurrentRoot = 1, ho.ContinuousEventPriority = 8, ho.DefaultEventPriority = 32, ho.DiscreteEventPriority = 2, ho.IdleEventPriority = 268435456, ho.LegacyRoot = 0, ho.NoEventPriority = 0), ho;
}
var D_;
function UD() {
  return D_ || (D_ = 1, Hg.exports = zD()), Hg.exports;
}
var mm = UD(), VD = Fe();
const I_ = {
  children: !0,
  ref: !0,
  key: !0,
  style: !0,
  forwardedRef: !0,
  unstable_applyCache: !0,
  unstable_applyDrawHitFromCache: !0
};
let B_ = !1, F_ = !1;
const n1 = ".react-konva-event", GD = `ReactKonva: You have a Konva node with draggable = true and position defined but no onDragMove or onDragEnd events are handled.
Position of a node will be changed during drag&drop, so you should update state of the react app as well.
Consider to add onDragMove or onDragEnd events.
For more info see: https://github.com/konvajs/react-konva/issues/256
`, qD = `ReactKonva: You are using "zIndex" attribute for a Konva node.
react-konva may get confused with ordering. Just define correct order of elements in your render function of a component.
For more info see: https://github.com/konvajs/react-konva/issues/194
`, HD = {};
function gm(e, t, n = HD) {
  if (!B_ && "zIndex" in t && (console.warn(qD), B_ = !0), !F_ && t.draggable) {
    var r = t.x !== void 0 || t.y !== void 0, i = t.onDragEnd || t.onDragMove;
    r && !i && (console.warn(GD), F_ = !0);
  }
  for (var s in n)
    if (!I_[s]) {
      var l = s.slice(0, 2) === "on", c = n[s] !== t[s];
      if (l && c) {
        var u = s.substr(2).toLowerCase();
        u.substr(0, 7) === "content" && (u = "content" + u.substr(7, 1).toUpperCase() + u.substr(8)), e.off(u, n[s]);
      }
      var d = !t.hasOwnProperty(s);
      d && e.setAttr(s, void 0);
    }
  var h = t._useStrictMode, p = {}, v = !1;
  const m = {};
  for (var s in t)
    if (!I_[s]) {
      var l = s.slice(0, 2) === "on", g = n[s] !== t[s];
      if (l && g) {
        var u = s.substr(2).toLowerCase();
        u.substr(0, 7) === "content" && (u = "content" + u.substr(7, 1).toUpperCase() + u.substr(8)), t[s] && (m[u] = t[s]);
      }
      !l && (t[s] !== n[s] || h && t[s] !== e.getAttr(s)) && (v = !0, p[s] = t[s]);
    }
  v && (e.setAttrs(p), ca(e));
  for (var u in m)
    e.on(u + n1, m[u]);
}
function ca(e) {
  if (!VD.Konva.autoDrawEnabled) {
    var t = e.getLayer() || e.getStage();
    t && t.batchDraw();
  }
}
var Wg = bx();
const _x = {}, WD = {};
wp.Node.prototype._applyProps = gm;
let Sx = mm.DefaultEventPriority;
function $D(e, t) {
  if (typeof t == "string") {
    console.error(`Do not use plain text as child of Konva.Node. You are using text: ${t}`);
    return;
  }
  e.add(t), ca(e);
}
function KD(e, t, n) {
  let r = wp[e];
  r || (console.error(`Konva has no node with the type ${e}. Group will be used instead. If you use minimal version of react-konva, just import required nodes into Konva: "import "konva/lib/shapes/${e}"  If you want to render DOM elements as part of canvas tree take a look into this demo: https://konvajs.github.io/docs/react/DOM_Portal.html`), r = wp.Group);
  const i = {}, s = {};
  for (var l in t) {
    var c = l.slice(0, 2) === "on";
    c ? s[l] = t[l] : i[l] = t[l];
  }
  const u = new r(i);
  return gm(u, s), u;
}
function YD(e, t, n) {
  console.error(`Text components are not supported for now in ReactKonva. Your text is: "${e}"`);
}
function XD(e, t, n) {
  return !1;
}
function QD(e) {
  return e;
}
function ZD() {
  return null;
}
function JD() {
  return null;
}
function tI(e, t, n, r) {
  return WD;
}
function eI() {
}
function nI(e) {
}
function rI(e, t) {
  return !1;
}
function iI() {
  return _x;
}
function sI() {
  return _x;
}
const oI = setTimeout, aI = clearTimeout, lI = !0, cI = (e) => {
  e();
}, uI = -1;
function dI(e, t) {
  return !1;
}
const hI = !1, fI = !1, pI = !0, mI = !1, gI = !1;
function yI(e, t) {
  t.parent === e ? t.moveToTop() : e.add(t), ca(e);
}
function vI(e, t) {
  t.parent === e ? t.moveToTop() : e.add(t), ca(e);
}
function xx(e, t, n) {
  t._remove(), e.add(t), t.setZIndex(n.getZIndex()), ca(e);
}
function bI(e, t, n) {
  xx(e, t, n);
}
function _I(e, t) {
  t.destroy(), t.off(n1), ca(e);
}
function SI(e, t) {
  t.destroy(), t.off(n1), ca(e);
}
function xI(e, t, n) {
  console.error(`Text components are not yet supported in ReactKonva. You text is: "${n}"`);
}
function TI(e, t, n) {
}
function CI(e, t, n, r) {
  gm(e, r, n);
}
function wI(e) {
  e.hide(), ca(e);
}
function EI(e) {
}
function AI(e, t) {
  (t.visible == null || t.visible) && e.show();
}
function kI(e, t) {
}
function RI(e) {
}
function MI() {
}
function OI() {
  return mm.DefaultEventPriority;
}
function NI() {
}
function PI() {
  return null;
}
function DI(e) {
  Sx = e;
}
function II() {
  return Sx;
}
function BI() {
  return mm.DiscreteEventPriority;
}
function FI() {
  return !1;
}
function jI() {
}
function LI() {
  return !1;
}
function zI() {
  return !0;
}
function UI() {
}
function VI() {
}
function GI() {
  return null;
}
const qI = null;
function HI() {
}
const WI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  NotPendingTransition: qI,
  appendChild: yI,
  appendChildToContainer: vI,
  appendInitialChild: $D,
  cancelTimeout: aI,
  clearContainer: RI,
  commitMount: TI,
  commitTextUpdate: xI,
  commitUpdate: CI,
  createInstance: KD,
  createTextInstance: YD,
  detachDeletedInstance: MI,
  finalizeInitialChildren: XD,
  getChildHostContext: sI,
  getCurrentEventPriority: OI,
  getCurrentUpdatePriority: II,
  getInstanceFromScope: PI,
  getPublicInstance: QD,
  getRootHostContext: iI,
  hideInstance: wI,
  hideTextInstance: EI,
  idlePriority: Wg.unstable_IdlePriority,
  insertBefore: xx,
  insertInContainerBefore: bI,
  isPrimaryRenderer: hI,
  maySuspendCommit: LI,
  noTimeout: uI,
  now: Wg.unstable_now,
  preloadInstance: zI,
  prepareForCommit: ZD,
  preparePortalMount: JD,
  prepareScopeUpdate: NI,
  prepareUpdate: tI,
  removeChild: _I,
  removeChildFromContainer: SI,
  requestPostPaintCallback: jI,
  resetAfterCommit: eI,
  resetFormInstance: HI,
  resetTextContent: nI,
  resolveUpdatePriority: BI,
  run: Wg.unstable_runWithPriority,
  scheduleMicrotask: cI,
  scheduleTimeout: oI,
  setCurrentUpdatePriority: DI,
  shouldAttemptEagerTransition: FI,
  shouldDeprioritizeSubtree: rI,
  shouldSetTextContent: dI,
  startSuspendingCommit: UI,
  supportsHydration: gI,
  supportsMicrotasks: lI,
  supportsMutation: pI,
  supportsPersistence: mI,
  suspendInstance: VI,
  unhideInstance: AI,
  unhideTextInstance: kI,
  waitForCommitToBeReady: GI,
  warnsIfNotActing: fI
}, Symbol.toStringTag, { value: "Module" }));
function Tx(e, t, n) {
  if (!e) return;
  if (n(e) === !0) return e;
  let r = e.child;
  for (; r; ) {
    const i = Tx(r, t, n);
    if (i) return i;
    r = r.sibling;
  }
}
function Cx(e) {
  try {
    return Object.defineProperties(e, {
      _currentRenderer: {
        get() {
          return null;
        },
        set() {
        }
      },
      _currentRenderer2: {
        get() {
          return null;
        },
        set() {
        }
      }
    });
  } catch {
    return e;
  }
}
const r1 = /* @__PURE__ */ Cx(/* @__PURE__ */ K.createContext(null));
class wx extends K.Component {
  render() {
    return /* @__PURE__ */ K.createElement(r1.Provider, { value: this._reactInternals }, this.props.children);
  }
}
function $I() {
  const e = K.useContext(r1);
  if (e === null) throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");
  const t = K.useId();
  return K.useMemo(() => {
    for (const n of [e, e == null ? void 0 : e.alternate]) {
      if (!n) continue;
      const r = Tx(n, !1, (i) => {
        let s = i.memoizedState;
        for (; s; ) {
          if (s.memoizedState === t) return !0;
          s = s.next;
        }
      });
      if (r) return r;
    }
  }, [e, t]);
}
const KI = Symbol.for("react.context"), YI = (e) => e !== null && typeof e == "object" && "$$typeof" in e && e.$$typeof === KI;
function XI() {
  const e = $I(), [t] = K.useState(() => /* @__PURE__ */ new Map());
  t.clear();
  let n = e;
  for (; n; ) {
    const r = n.type;
    YI(r) && r !== r1 && !t.has(r) && t.set(r, K.use(Cx(r))), n = n.return;
  }
  return t;
}
function QI() {
  const e = XI();
  return K.useMemo(
    () => Array.from(e.keys()).reduce(
      (t, n) => (r) => /* @__PURE__ */ K.createElement(t, null, /* @__PURE__ */ K.createElement(n.Provider, { ...r, value: e.get(n) })),
      (t) => /* @__PURE__ */ K.createElement(wx, { ...t })
    ),
    [e]
  );
}
if (ke.version.indexOf("19") === -1)
  throw new Error("react-konva version 19 is only compatible with React 19. Make sure to have the last version of react-konva and react or downgrade react-konva to version 18.");
function ZI(e) {
  const t = ke.useRef({});
  return ke.useLayoutEffect(() => {
    t.current = e;
  }), ke.useLayoutEffect(() => () => {
    t.current = {};
  }, []), t.current;
}
const JI = (e) => {
  const t = ke.useRef(null), n = ke.useRef(null), r = ke.useRef(null), i = ZI(e), s = QI(), l = (c) => {
    const { forwardedRef: u } = e;
    u && (typeof u == "function" ? u(c) : u.current = c);
  };
  return ke.useLayoutEffect(() => (n.current = new wp.Stage({
    width: e.width,
    height: e.height,
    container: t.current
  }), l(n.current), r.current = Wd.createContainer(n.current, mm.ConcurrentRoot, null, !1, null, "", console.error, console.error, console.error, null), Wd.updateContainer(ke.createElement(s, {}, e.children), r.current, null, () => {
  }), () => {
    l(null), Wd.updateContainer(null, r.current, null), n.current.destroy();
  }), []), ke.useLayoutEffect(() => {
    l(n.current), gm(n.current, e, i), Wd.updateContainer(ke.createElement(s, {}, e.children), r.current, null);
  }), ke.createElement("div", {
    ref: t,
    id: e.id,
    accessKey: e.accessKey,
    className: e.className,
    role: e.role,
    style: e.style,
    tabIndex: e.tabIndex,
    title: e.title
  });
}, zf = "Layer", Uf = "Group", Xo = "Rect", $g = "Line", tB = "Text", Wd = LD(WI);
Wd.injectIntoDevTools({
  // @ts-ignore
  findHostInstanceByFiber: () => null,
  bundleType: 0,
  version: ke.version,
  rendererPackageName: "react-konva"
});
const eB = ke.forwardRef((e, t) => ke.createElement(wx, {}, ke.createElement(JI, { ...e, forwardedRef: t }))), nB = ({ trackId: e, color: t }) => {
  const { notesByTrack: n, createNote: r, moveNote: i, resizeNote: s, playPreview: l, stopPreview: c } = Sl(), u = n[e] || [], [d, h] = K.useState(null), [p, v] = K.useState(null), [m, g] = K.useState({ x: 0, y: 0 }), [b, x] = K.useState(!1), [w, T] = K.useState(null), [S, C] = K.useState(null), [E, O] = K.useState(null), [B, N] = K.useState(null), [L, k] = K.useState(null), F = K.useRef(null), G = K.useRef(null), [M, j] = K.useState({ width: 800, height: 600 }), H = 10 * 12, X = 24, Y = 20, V = 64, Z = 32, [ct, et] = K.useState(Z), rt = ct * X, st = H * Y, yt = V + rt, [J, tt] = K.useState([]), [ot, Tt] = K.useState([]), [Ct, bt] = K.useState({ x: 0, y: 0 });
  K.useEffect(() => {
    tt(u);
  }, [u]);
  const Ht = (Rt) => H - 1 - Rt, $t = (Rt) => H - 1 - Rt, wt = (Rt) => {
    const Dt = Rt % 12;
    return [1, 3, 6, 8, 10].includes(Dt);
  };
  K.useEffect(() => {
    if (!F.current) return;
    const Rt = () => {
      if (!F.current) return;
      const { clientWidth: jt, clientHeight: Ft } = F.current;
      j({
        width: jt,
        height: Ft
      });
      const Vt = jt - V, Yt = Math.floor(Vt / X), ee = Math.ceil(Yt * 1.2), fe = Vt * 0.2, ie = ct * X;
      Math.abs(ie - Vt) < fe && et(Math.max(Z, ee));
    };
    Rt();
    const Dt = new ResizeObserver(Rt);
    return Dt.observe(F.current), () => Dt.disconnect();
  }, [ct, X, Z, V]), K.useEffect(() => {
    const Rt = Math.floor(Ct.x / X), Dt = Rt + Math.ceil(M.width / X), jt = Math.floor(Ct.y / Y), Ft = jt + Math.ceil(M.height / Y), Vt = J.filter((Yt) => {
      const ee = $t(Yt.row);
      return Yt.column + Yt.length >= Rt && Yt.column <= Dt && ee >= jt && ee <= Ft;
    });
    Tt(Vt);
  }, [J, Ct, M, X, Y]);
  const Wt = K.useCallback((Rt) => {
    const Dt = Rt.target;
    if (bt({
      x: Dt.scrollLeft,
      y: Dt.scrollTop
    }), b) return;
    const { scrollLeft: jt, scrollWidth: Ft, clientWidth: Vt } = Dt;
    (jt + Vt) / Ft > 0.8 && et((fe) => fe + 1);
  }, [b]), Ut = K.useCallback((Rt) => {
    if (b) return;
    const Dt = Rt.target, { column: jt, row: Ft } = Dt.attrs.gridPosition, Vt = Ht(Ft);
    if (!J.some(
      (ee) => ee.row === Vt && ee.column === jt
    )) {
      const ee = {
        id: Date.now(),
        // Use timestamp as unique ID
        row: Vt,
        column: jt,
        length: 1,
        velocity: 100,
        trackId: e
      };
      tt((fe) => [...fe, ee]), r(e, ee), l(Vt), setTimeout(() => c(Vt), 300);
    }
  }, [b, J, r, e, Ht, l, c]), ne = K.useCallback((Rt, Dt) => {
    Rt.evt.stopPropagation();
    const jt = J.find((ee) => ee.id === Dt);
    if (!jt) return;
    x(!0), h(Dt), v({ row: jt.row, column: jt.column });
    const Ft = G.current.getPointerPosition(), Vt = V + jt.column * X, Yt = $t(jt.row) * Y;
    g({
      x: Ft.x - Vt,
      y: Ft.y - Yt
    }), l(jt.row);
  }, [J, l, V, X, Y, $t]), ce = K.useCallback((Rt, Dt, jt) => {
    Rt.evt.stopPropagation();
    const Ft = J.find((Vt) => Vt.id === Dt);
    Ft && (T(Dt), N(jt), C(Ft.length), O(Ft.column), x(!0));
  }, [J]), re = K.useCallback((Rt) => {
    if (!G.current) return;
    const jt = G.current.getPointerPosition();
    if (w !== null) {
      const Ft = J.find((fe) => fe.id === w);
      if (!Ft) return;
      const Yt = jt.x - V + Ct.x, ee = Math.floor(Yt / X);
      if (B === "right") {
        const fe = Math.max(1, ee - Ft.column + 1), ie = ct - Ft.column, zt = Math.min(fe, ie);
        tt((Pe) => Pe.map(
          (je) => je.id === w ? { ...je, length: zt } : je
        ));
      } else {
        const fe = Ft.column + Ft.length - 1, ie = Math.max(0, Math.min(ee, fe)), zt = fe - ie + 1;
        tt((Pe) => Pe.map(
          (je) => je.id === w ? { ...je, column: ie, length: zt } : je
        ));
      }
    } else if (d !== null) {
      const Ft = jt.x - m.x, Vt = jt.y - m.y, Yt = Ft - V + Ct.x, ee = Vt + Ct.y, fe = Math.floor(Ct.x / X), ie = Math.ceil(M.width / X), zt = fe + ie, je = Math.min(zt + 32, ct - 1), cr = Math.max(0, Math.min(Math.floor(Yt / X), je)), se = Math.max(0, Math.min(Math.floor(ee / Y), H - 1)), Sr = Ht(se), on = J.map((Le) => {
        if (Le.id === d) {
          const ai = Math.min(je - Le.length, ct - Le.length), kr = Math.min(cr, ai);
          if (Le.row !== Sr || Le.column !== kr)
            return Le.row !== Sr && (c(Le.row), l(Sr)), { ...Le, row: Sr, column: kr };
        }
        return Le;
      });
      tt(on);
    }
  }, [w, d, J, ct, Ct, m, X, Y, l, c, Ht]), le = K.useCallback(async () => {
    if (d !== null && p) {
      const Rt = J.find((Dt) => Dt.id === d);
      Rt && (c(Rt.row), (Rt.column !== p.column || Rt.row !== p.row) && await i(
        e,
        d,
        { x: p.column, y: p.row },
        { x: Rt.column, y: Rt.row }
      ));
    }
    if (w !== null && S !== null) {
      const Rt = J.find((Dt) => Dt.id === w);
      if (Rt) {
        const Dt = Rt.length !== S, jt = B === "left" && E !== null && Rt.column !== E;
        (Dt || jt) && await s(
          e,
          w,
          S,
          Rt.length,
          B === "left" ? E : void 0,
          B === "left" ? Rt.column : void 0
        );
      }
    }
    h(null), v(null), T(null), C(null), O(null), N(null), setTimeout(() => {
      x(!1);
    }, 10);
  }, [d, p, w, S, E, B, J, e, i, s, c]), Lt = K.useCallback((Rt, Dt) => {
    Rt.evt.stopPropagation();
    const jt = J.find((Ft) => Ft.id === Dt);
    jt && (l(jt.row), setTimeout(() => c(jt.row), 300));
  }, [J, l, c]), ye = K.useCallback(() => {
    const Rt = [];
    for (let Dt = 0; Dt <= H; Dt++) {
      const Vt = Ht(Dt) % 12 === 0;
      Rt.push(
        /* @__PURE__ */ W.jsx(
          $g,
          {
            points: [V, Dt * Y, V + rt, Dt * Y],
            stroke: Vt ? "rgba(100, 100, 100, 0.5)" : "rgba(50, 50, 50, 0.5)",
            strokeWidth: 1,
            listening: !1,
            perfectDrawEnabled: !0
          },
          `h-line-${Dt}`
        )
      );
    }
    for (let Dt = 0; Dt <= ct; Dt++)
      Rt.push(
        /* @__PURE__ */ W.jsx(
          $g,
          {
            points: [V + Dt * X, 0, V + Dt * X, st],
            stroke: Dt % 4 === 0 ? "rgba(100, 100, 100, 0.5)" : "rgba(50, 50, 50, 0.5)",
            strokeWidth: 1,
            listening: !1,
            perfectDrawEnabled: !0
          },
          `v-line-${Dt}`
        )
      );
    return Rt;
  }, [rt, st, ct, X, Y, H, Ht, V]), be = K.useCallback(() => {
    const Rt = [], Dt = Math.floor(Ct.y / Y), jt = Math.min(H, Dt + Math.ceil(M.height / Y) + 1), Ft = Math.floor(Ct.x / X), Vt = Math.min(ct, Ft + Math.ceil(M.width / X) + 1);
    for (let Yt = Dt; Yt < jt; Yt++)
      for (let ee = Ft; ee < Vt; ee++)
        Rt.push(
          /* @__PURE__ */ W.jsx(
            Xo,
            {
              x: ee * X,
              y: Yt * Y,
              width: X,
              height: Y,
              fill: "transparent",
              gridPosition: { row: Yt, column: ee },
              onClick: Ut
            },
            `cell-${Yt}-${ee}`
          )
        );
    return Rt;
  }, [
    X,
    Y,
    ct,
    H,
    Ut,
    Ct,
    M
  ]), Nt = K.useCallback(() => {
    const Rt = [];
    for (let Dt = 0; Dt < H; Dt++) {
      const jt = Ht(Dt), Ft = Math.floor(jt / 12), Vt = jt % 12, Yt = wt(jt), ee = Vt === 0;
      Rt.push(
        /* @__PURE__ */ W.jsxs(Uf, { children: [
          /* @__PURE__ */ W.jsx(
            Xo,
            {
              x: 0,
              y: Dt * Y,
              width: V,
              height: Y,
              fill: Yt ? "#222" : "#333",
              stroke: "#444",
              strokeWidth: 1,
              onClick: () => l(jt),
              onMouseDown: () => l(jt),
              onMouseUp: () => c(jt)
            }
          ),
          ee && /* @__PURE__ */ W.jsx(
            tB,
            {
              x: 5,
              y: Dt * Y + 5,
              text: `C${Ft}`,
              fontSize: 11,
              fill: "#aaa"
            }
          )
        ] }, `key-${Dt}`)
      );
    }
    return Rt;
  }, [Y, H, Ht, l, c]), Bt = K.useCallback(() => ot.map((Rt) => {
    const Dt = d === Rt.id, jt = w === Rt.id, Ft = L === Rt.id, Vt = $t(Rt.row);
    return /* @__PURE__ */ W.jsxs(
      Uf,
      {
        x: Rt.column * X,
        y: Vt * Y,
        onClick: (Yt) => Lt(Yt, Rt.id),
        onMouseDown: (Yt) => ne(Yt, Rt.id),
        onMouseEnter: () => {
          document.body.style.cursor = "pointer", k(Rt.id);
        },
        onMouseLeave: () => {
          document.body.style.cursor = "default", k(null);
        },
        children: [
          /* @__PURE__ */ W.jsx(
            Xo,
            {
              width: Rt.length * X - 1,
              height: Y - 1,
              fill: t,
              cornerRadius: 3,
              opacity: Dt || jt ? 0.75 : 1,
              shadowColor: "rgba(0,0,0,0.5)",
              shadowBlur: Dt || jt || Ft ? 5 : 0,
              shadowOffset: Ft && !Dt && !jt ? { x: 0, y: 2 } : { x: 0, y: 0 },
              perfectDrawEnabled: !0
            }
          ),
          /* @__PURE__ */ W.jsx(
            Xo,
            {
              x: 0,
              y: 0,
              width: 4,
              height: Y - 1,
              fill: "rgba(0,0,0,0.3)",
              onMouseDown: (Yt) => ce(Yt, Rt.id, "left"),
              onMouseOver: (Yt) => {
                document.body.style.cursor = "ew-resize", Yt.target.opacity(1);
              },
              onMouseOut: (Yt) => {
                document.body.style.cursor = "default", Yt.target.opacity(0.5);
              },
              opacity: 0.5
            }
          ),
          /* @__PURE__ */ W.jsx(
            Xo,
            {
              x: Rt.length * X - 5,
              y: 0,
              width: 4,
              height: Y - 1,
              fill: "rgba(0,0,0,0.3)",
              onMouseDown: (Yt) => ce(Yt, Rt.id, "right"),
              onMouseOver: (Yt) => {
                document.body.style.cursor = "ew-resize", Yt.target.opacity(1);
              },
              onMouseOut: (Yt) => {
                document.body.style.cursor = "default", Yt.target.opacity(0.5);
              },
              opacity: 0.5
            }
          )
        ]
      },
      `note-${Rt.id}`
    );
  }), [ot, X, Y, d, w, Lt, ne, ce, $t]);
  return /* @__PURE__ */ W.jsx(
    Zt,
    {
      ref: F,
      sx: {
        display: "flex",
        height: "100%",
        bgcolor: "#111",
        overflow: "auto",
        "&::-webkit-scrollbar": {
          width: 10,
          height: 10,
          backgroundColor: "#222"
        },
        "&::-webkit-scrollbar-thumb": {
          backgroundColor: "#444",
          borderRadius: 2,
          "&:hover": {
            backgroundColor: "#555"
          }
        },
        "&::-webkit-scrollbar-corner": {
          backgroundColor: "#222"
        }
      },
      onScroll: Wt,
      children: /* @__PURE__ */ W.jsxs(
        eB,
        {
          ref: G,
          width: yt,
          height: st,
          onMouseMove: re,
          onMouseUp: le,
          onMouseLeave: le,
          children: [
            /* @__PURE__ */ W.jsxs(zf, { children: [
              /* @__PURE__ */ W.jsx(
                Xo,
                {
                  x: V,
                  y: 0,
                  width: rt,
                  height: st,
                  fill: "#181818",
                  perfectDrawEnabled: !0,
                  listening: !1
                }
              ),
              /* @__PURE__ */ W.jsx(
                Xo,
                {
                  x: 0,
                  y: 0,
                  width: V,
                  height: st,
                  fill: "#111",
                  perfectDrawEnabled: !0,
                  listening: !1
                }
              ),
              [...Array(H)].map((Rt, Dt) => {
                const jt = Ht(Dt);
                return wt(jt) ? /* @__PURE__ */ W.jsx(
                  Xo,
                  {
                    x: V,
                    y: Dt * Y,
                    width: rt,
                    height: Y,
                    fill: "rgba(0, 0, 0, 0.2)",
                    perfectDrawEnabled: !0,
                    listening: !1
                  },
                  `row-bg-${Dt}`
                ) : null;
              }),
              ye(),
              /* @__PURE__ */ W.jsx(
                $g,
                {
                  points: [V, 0, V, st],
                  stroke: "rgba(100, 100, 100, 0.8)",
                  strokeWidth: 2,
                  listening: !1,
                  perfectDrawEnabled: !0
                }
              )
            ] }),
            /* @__PURE__ */ W.jsx(zf, { children: /* @__PURE__ */ W.jsx(Uf, { x: V, children: be() }) }),
            /* @__PURE__ */ W.jsx(zf, { children: Nt() }),
            /* @__PURE__ */ W.jsx(zf, { children: /* @__PURE__ */ W.jsx(Uf, { x: V, children: Bt() }) })
          ]
        }
      )
    }
  );
}, j_ = {
  36: "Kick",
  38: "Snare",
  42: "Hi-Hat Closed",
  46: "Hi-Hat Open",
  41: "Tom 1",
  43: "Tom 2",
  45: "Tom 3",
  49: "Crash",
  51: "Ride",
  39: "Clap"
}, rB = ({ trackId: e }) => {
  const { notesByTrack: t, createNote: n, moveNote: r, resizeNote: i, playPreview: s, stopPreview: l } = Sl(), c = t[e] || [], [u, d] = K.useState(null), [h, p] = K.useState(null), [v, m] = K.useState(!1), [g, b] = K.useState(null), [x, w] = K.useState(null), [T, S] = K.useState(null), C = K.useRef(null), E = K.useRef(null), O = 24, B = 30, N = 32, [L, k] = K.useState(N), F = 0.8, G = Object.keys(j_).map(Number).sort((et, rt) => et - rt), M = G.length, j = () => {
    if (!E.current || !C.current) return;
    const { scrollLeft: et, scrollWidth: rt, clientWidth: st } = E.current;
    (et + st) / rt > F && k((J) => J + N);
  };
  K.useEffect(() => {
    const et = () => {
      if (!C.current) return;
      const st = C.current.clientWidth;
      k(Math.max(N, Math.floor(st / O)));
    }, rt = new ResizeObserver(et);
    return C.current && rt.observe(C.current), () => rt.disconnect();
  }, []);
  const D = (et) => G[et] || 36, z = (et) => G.indexOf(et), H = async (et) => {
    if (!C.current || v) return;
    const rt = C.current.getBoundingClientRect(), st = et.clientX - rt.left, yt = et.clientY - rt.top, J = Math.floor(st / O), tt = Math.floor(yt / B);
    if (tt < 0 || tt >= M) return;
    const ot = D(tt);
    if (!c.some((Ct) => Ct.row === ot && Ct.column === J)) {
      const Ct = {
        id: Date.now(),
        // Use timestamp as unique ID
        row: ot,
        column: J,
        length: 1,
        velocity: 100,
        trackId: e
      };
      await n(e, Ct), s(ot), setTimeout(() => l(ot), 300);
    }
  }, X = (et, rt) => {
    et.stopPropagation();
    const st = c.find((yt) => yt.id === rt);
    st && (m(!0), d(rt), p({ row: st.row, column: st.column }), s(st.row));
  }, Y = (et, rt, st) => {
    et.stopPropagation();
    const yt = c.find((J) => J.id === rt);
    yt && (b(rt), S(st), w(yt.length), m(!0));
  }, V = (et) => {
    if (!C.current) return;
    const rt = C.current.getBoundingClientRect();
    if (g !== null) {
      const st = c.find((tt) => tt.id === g);
      if (!st) return;
      const yt = et.clientX - rt.left, J = Math.floor(yt / O);
      if (T === "right") {
        const tt = Math.max(1, J - st.column + 1), ot = L - st.column, Tt = Math.min(tt, ot), Ct = c.map(
          (bt) => bt.id === g ? { ...bt, length: Tt } : bt
        );
        t[e] = Ct;
      } else {
        const tt = st.column + st.length - 1, ot = Math.max(0, Math.min(J, tt)), Tt = tt - ot + 1, Ct = c.map(
          (bt) => bt.id === g ? { ...bt, column: ot, length: Tt } : bt
        );
        t[e] = Ct;
      }
    } else if (u !== null) {
      const st = c.find((Tt) => Tt.id === u);
      if (!st) return;
      const yt = et.clientX - rt.left, J = et.clientY - rt.top, tt = Math.max(0, Math.min(Math.floor(yt / O), L - 1)), ot = Math.floor(J / B);
      if (ot >= 0 && ot < M) {
        const Tt = D(ot), Ct = c.map((bt) => {
          if (bt.id === u) {
            const Ht = L - bt.length, $t = Math.min(tt, Ht);
            return { ...bt, row: Tt, column: $t };
          }
          return bt;
        });
        t[e] = Ct, st.row !== Tt && (l(st.row), s(Tt));
      }
    }
  }, Z = async () => {
    if (u !== null && h) {
      const et = c.find((rt) => rt.id === u);
      et && (l(et.row), (et.column !== h.column || et.row !== h.row) && await r(
        e,
        u,
        { x: h.column, y: h.row },
        { x: et.column, y: et.row }
      ));
    }
    if (g !== null && x !== null) {
      const et = c.find((rt) => rt.id === g);
      et && et.length !== x && await i(
        e,
        g,
        x,
        et.length
      );
    }
    d(null), p(null), b(null), w(null), S(null), setTimeout(() => {
      m(!1);
    }, 10);
  }, ct = (et, rt) => {
    et.stopPropagation();
    const st = c.find((yt) => yt.id === rt);
    st && (s(st.row), setTimeout(() => l(st.row), 300));
  };
  return /* @__PURE__ */ W.jsx(Zt, { sx: {
    display: "flex",
    height: "100%",
    bgcolor: "#111",
    overflow: "hidden"
  }, children: /* @__PURE__ */ W.jsx(
    Zt,
    {
      ref: E,
      sx: {
        display: "flex",
        width: "100%",
        height: "100%",
        position: "relative",
        overflow: "auto",
        "&::-webkit-scrollbar": {
          width: 10,
          height: 10,
          backgroundColor: "#222"
        },
        "&::-webkit-scrollbar-thumb": {
          backgroundColor: "#444",
          borderRadius: 2,
          "&:hover": {
            backgroundColor: "#555"
          }
        },
        "&::-webkit-scrollbar-corner": {
          backgroundColor: "#222"
        }
      },
      onScroll: j,
      children: /* @__PURE__ */ W.jsxs(Zt, { sx: {
        display: "flex",
        minWidth: "100%",
        height: "fit-content"
      }, children: [
        /* @__PURE__ */ W.jsx(Zt, { sx: {
          width: "120px",
          flexShrink: 0,
          display: "flex",
          flexDirection: "column",
          borderRight: 1,
          borderColor: "#333",
          position: "sticky",
          left: 0,
          zIndex: 3,
          backgroundColor: "#111"
        }, children: G.map((et, rt) => {
          const st = j_[et] || `Note ${et}`;
          return /* @__PURE__ */ W.jsx(
            Zt,
            {
              sx: {
                height: `${B}px`,
                bgcolor: rt % 2 === 0 ? "#222" : "#1A1A1A",
                color: "#aaa",
                display: "flex",
                alignItems: "center",
                pl: 1,
                fontSize: "12px",
                borderBottom: 1,
                borderColor: "#333",
                cursor: "pointer",
                "&:hover": {
                  bgcolor: "#2a2a2a"
                }
              },
              onClick: () => {
                s(et), setTimeout(() => l(et), 300);
              },
              children: st
            },
            `drum-${et}`
          );
        }) }),
        /* @__PURE__ */ W.jsx(
          Zt,
          {
            ref: C,
            sx: {
              position: "relative",
              overflow: "visible",
              display: "flex"
            },
            onClick: H,
            onMouseMove: V,
            onMouseUp: Z,
            onMouseLeave: Z,
            children: /* @__PURE__ */ W.jsxs(
              Zt,
              {
                sx: {
                  position: "relative",
                  height: `${M * B}px`,
                  width: `${L * O}px`,
                  minWidth: "100%",
                  backgroundColor: "#181818",
                  flexShrink: 0
                },
                children: [
                  /* @__PURE__ */ W.jsx(Zt, { sx: {
                    position: "absolute",
                    top: 0,
                    left: 0,
                    right: 0,
                    height: `${M * B}px`,
                    zIndex: 0
                  }, children: [...Array(M)].map((et, rt) => /* @__PURE__ */ W.jsx(
                    Zt,
                    {
                      sx: {
                        position: "absolute",
                        width: "100%",
                        height: `${B}px`,
                        top: `${rt * B}px`,
                        bgcolor: rt % 2 === 0 ? "rgba(255, 255, 255, 0.02)" : "transparent",
                        borderBottom: 1,
                        borderColor: "rgba(50, 50, 50, 0.5)",
                        boxSizing: "border-box"
                      }
                    },
                    `row-bg-${rt}`
                  )) }),
                  [...Array(L + 1)].map((et, rt) => /* @__PURE__ */ W.jsx(
                    Zt,
                    {
                      sx: {
                        position: "absolute",
                        height: "100%",
                        width: "1px",
                        left: `${rt * O}px`,
                        bgcolor: rt % 4 === 0 ? "rgba(100, 100, 100, 0.5)" : "rgba(50, 50, 50, 0.5)",
                        zIndex: 1
                      }
                    },
                    `gridline-${rt}`
                  )),
                  c.map((et) => {
                    const rt = z(et.row);
                    return rt === -1 ? null : /* @__PURE__ */ W.jsxs(
                      Zt,
                      {
                        sx: {
                          position: "absolute",
                          top: `${rt * B + 2}px`,
                          left: `${et.column * O}px`,
                          width: `${et.length * O - 1}px`,
                          height: `${B - 4}px`,
                          bgcolor: "#ff9800",
                          backgroundImage: "linear-gradient(to bottom, rgba(255,255,255,0.1) 0%, rgba(0,0,0,0.1) 100%)",
                          borderRadius: "3px",
                          cursor: "move",
                          opacity: u === et.id || g === et.id ? 0.75 : 1,
                          "&:hover": {
                            boxShadow: "0 0 0 1px rgba(255,255,255,0.5)",
                            "& .resize-handle": {
                              opacity: 1
                            }
                          },
                          zIndex: 2
                        },
                        onClick: (st) => ct(st, et.id),
                        onMouseDown: (st) => X(st, et.id),
                        children: [
                          /* @__PURE__ */ W.jsx(
                            Zt,
                            {
                              className: "resize-handle",
                              sx: {
                                position: "absolute",
                                left: 0,
                                top: 0,
                                bottom: 0,
                                width: "4px",
                                cursor: "ew-resize",
                                bgcolor: "rgba(0,0,0,0.3)",
                                opacity: 0,
                                transition: "opacity 0.2s",
                                borderTopLeftRadius: "3px",
                                borderBottomLeftRadius: "3px",
                                "&:hover": {
                                  opacity: 1,
                                  bgcolor: "rgba(0,0,0,0.5)"
                                }
                              },
                              onMouseDown: (st) => Y(st, et.id, "left")
                            }
                          ),
                          /* @__PURE__ */ W.jsx(
                            Zt,
                            {
                              className: "resize-handle",
                              sx: {
                                position: "absolute",
                                right: 0,
                                top: 0,
                                bottom: 0,
                                width: "4px",
                                cursor: "ew-resize",
                                bgcolor: "rgba(0,0,0,0.3)",
                                opacity: 0,
                                transition: "opacity 0.2s",
                                borderTopRightRadius: "3px",
                                borderBottomRightRadius: "3px",
                                "&:hover": {
                                  opacity: 1,
                                  bgcolor: "rgba(0,0,0,0.5)"
                                }
                              },
                              onMouseDown: (st) => Y(st, et.id, "right")
                            }
                          )
                        ]
                      },
                      et.id
                    );
                  })
                ]
              }
            )
          }
        )
      ] })
    }
  ) });
}, iB = ({ trackId: e }) => {
  const { openedPianoRolls: t, closePianoRoll: n } = Sl(), r = t[e] || !1, { tracks: i } = Yc(), s = i.find((h) => h.id === e), l = () => {
    n(e);
  };
  if (!s) return null;
  const c = s.type === "drum", u = `${c ? "Drum Editor" : "Piano Roll"} - ${s.name}`, d = ke.useMemo(() => {
    const h = window.innerWidth, p = window.innerHeight;
    return {
      x: Math.max(0, (h - 840) / 2),
      y: Math.max(0, (p - 500) / 3)
      // Position slightly above center
    };
  }, []);
  return /* @__PURE__ */ W.jsx(
    $P,
    {
      isOpen: r,
      onClose: l,
      title: u,
      initialPosition: d,
      initialSize: { width: 840, height: 500 },
      children: /* @__PURE__ */ W.jsxs(Zt, { sx: { height: "100%", display: "flex", flexDirection: "column" }, children: [
        /* @__PURE__ */ W.jsx(Zt, { sx: {
          height: "40px",
          bgcolor: "#222",
          borderBottom: "1px solid #333",
          display: "flex",
          alignItems: "center",
          px: 1
        }, children: /* @__PURE__ */ W.jsxs(Hr, { variant: "body2", sx: { color: "#aaa", mr: 2 }, children: [
          "Track: ",
          s.name
        ] }) }),
        /* @__PURE__ */ W.jsx(Zt, { sx: { flex: 1, overflow: "hidden" }, children: c ? /* @__PURE__ */ W.jsx(rB, { trackId: e }) : /* @__PURE__ */ W.jsx(nB, { trackId: e, color: py(i.findIndex((h) => h.id === e)) }) })
      ] })
    }
  );
}, L_ = ({
  trackId: e,
  width: t,
  height: n,
  trackColor: r
}) => {
  const { notesByTrack: i } = Sl(), s = i[e] || [];
  let l = 127, c = 0;
  if (s.length > 0 ? s.forEach((m) => {
    m.row < l && (l = m.row), m.row > c && (c = m.row), m.column + m.length;
  }) : (l = 60, c = 72), c - l < 6) {
    const m = Math.floor((c + l) / 2);
    l = m - 3, c = m + 3;
  }
  l = Math.max(0, l - 2), c = Math.min(127, c + 2);
  const u = c - l + 1, h = n / u, v = t / 64;
  return /* @__PURE__ */ W.jsxs(
    Zt,
    {
      sx: {
        width: "100%",
        // Extend width to fit notes
        height: "100%",
        position: "relative",
        overflow: "hidden"
        // Allow content to extend beyond container
      },
      children: [
        s.map((m) => {
          const g = m.column * v, x = (c - m.row) * h, w = m.length * v, T = h * 0.9;
          return /* @__PURE__ */ W.jsx(
            Zt,
            {
              sx: {
                position: "absolute",
                left: `${g}px`,
                top: `${x}px`,
                width: `${w}px`,
                height: `${T}px`,
                bgcolor: "white",
                opacity: 1,
                borderRadius: "2px",
                boxSizing: "border-box",
                boxShadow: "0 0 3px rgba(255,255,255,0.7)"
              }
            },
            m.id
          );
        }),
        s.length === 0 && /* @__PURE__ */ W.jsx(Zt, { sx: {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          width: "100%",
          height: "100%",
          opacity: 0.6,
          fontSize: "10px",
          color: "#fff"
        }, children: Array.from({ length: 12 }).map((m, g) => /* @__PURE__ */ W.jsx(
          Zt,
          {
            sx: {
              height: Math.random() * 12 + 4,
              width: 4,
              mx: 0.5,
              bgcolor: "white",
              borderRadius: "2px"
            }
          },
          g
        )) })
      ]
    }
  );
}, sB = ({ children: e }) => /* @__PURE__ */ W.jsx(WP, { children: e }), oB = () => {
  const { openedPianoRolls: e } = Sl();
  console.log("Rendering PianoRollWindows with state:", e);
  const t = Object.entries(e).filter(([n, r]) => r);
  return t.length === 0 ? null : /* @__PURE__ */ W.jsx(W.Fragment, { children: t.map(([n, r]) => /* @__PURE__ */ W.jsx(iB, { trackId: n }, `piano-roll-${n}`)) });
}, aB = ({
  track: e,
  isPlaying: t,
  currentTime: n,
  measureCount: r,
  gridLineStyle: i,
  onPositionChange: s,
  bpm: l,
  timeSignature: c = [4, 4],
  trackIndex: u = 0
}) => {
  const d = ke.useRef(null), [h, p] = ke.useState(!1), [v, m] = ke.useState({ x: 0, y: 0 }), [g, b] = ke.useState({ x: 0, y: 0 }), x = ke.useRef(e.position), w = ke.useMemo(() => e._calculatedWidth || 500, [e._calculatedWidth]), T = py(u), S = {
    display: "flex",
    height: Ie.trackHeight,
    position: "absolute",
    boxSizing: "border-box",
    borderBottom: `1px solid ${Ie.borderColor}`,
    borderRadius: "6px",
    left: `${e.position.x}px`,
    top: `${e.position.y}px`,
    cursor: h ? "grabbing" : "grab",
    zIndex: h ? 1001 : 1e3,
    transition: h ? "none" : "width 0.2s ease",
    "&:hover": {
      boxShadow: `0 0 12px ${T}`,
      zIndex: 9999
    },
    bgcolor: "rgba(26, 26, 26, 0.8)",
    margin: 0,
    padding: 0,
    width: typeof w == "number" ? `${w}px` : "100%",
    overflow: "hidden"
  }, C = (B) => {
    var L;
    if (!d.current) {
      console.error("TrackPreview: trackRef is null in mouseDown");
      return;
    }
    if (B.target.closest(".track-control")) {
      console.log("TrackPreview: Clicked on control - not dragging");
      return;
    }
    const N = d.current.closest(".timeline-container") || d.current.closest(".MuiBox-root") || ((L = d.current.parentElement) == null ? void 0 : L.parentElement);
    if (!N) {
      console.error("TrackPreview: Could not find container element for drag");
      return;
    }
    console.log("TrackPreview: Starting drag", {
      trackId: e.id,
      initialPosition: e.position,
      containerFound: !!N,
      containerElement: N,
      scrollLeft: N.scrollLeft,
      scrollTop: N.scrollTop
    }), m({
      x: B.clientX + (N.scrollLeft || 0),
      y: B.clientY + (N.scrollTop || 0)
    }), b({
      x: e.position.x,
      y: e.position.y
    }), x.current = e.position, d.current && (d.current.style.left = `${e.position.x}px`, d.current.style.top = `${e.position.y}px`, d.current.style.transition = "none"), p(!0), B.preventDefault();
  }, E = ke.useCallback((B) => {
    var et;
    if (!h)
      return;
    if (!d.current) {
      console.error("TrackPreview: trackRef is null in mouseMove");
      return;
    }
    const N = d.current.closest(".timeline-container") || d.current.closest(".MuiBox-root") || ((et = d.current.parentElement) == null ? void 0 : et.parentElement);
    if (!N) {
      console.error("TrackPreview: Could not find container element in mouseMove");
      return;
    }
    console.log("TrackPreview: Mouse move", {
      isDragging: h,
      mousePosition: { x: B.clientX, y: B.clientY },
      scrollOffset: { left: N.scrollLeft, top: N.scrollTop },
      startDragMousePosition: v,
      startDragTrackPosition: g
    });
    const L = B.clientX + N.scrollLeft, k = B.clientY + N.scrollTop, F = L - v.x, G = k - v.y, M = g.x + F, j = g.y + G, D = (rt, st) => Math.round(rt / st) * st, z = c[0], H = c[1], X = z * H, Y = Ie.measureWidth / X, V = D(M, Y), Z = D(j, Ie.trackHeight), ct = {
      x: Math.max(0, V),
      // Prevent negative X
      y: Math.max(0, Z)
      // Prevent negative Y
    };
    d.current && (d.current.style.left = `${ct.x}px`, d.current.style.top = `${ct.y}px`), console.log("TrackPreview: Visual update during drag", {
      trackId: e.id,
      visualPosition: ct,
      styleUpdated: !!d.current
    }), x.current = ct;
  }, [h, v, g, e.id, c]), O = ke.useCallback(() => {
    console.log("TrackPreview: Mouse up", {
      isDragging: h,
      trackId: e.id,
      lastPosition: x.current
    }), h && d.current && (console.log("TrackPreview: Final position update", {
      trackId: e.id,
      finalPosition: x.current,
      isDragEnd: !0
    }), s(e.id, x.current, !0)), d.current && (d.current.style.transition = "left 0.2s ease, top 0.2s ease"), p(!1);
  }, [h, e.id, s]);
  return ke.useEffect(() => (h && (window.addEventListener("mousemove", E), window.addEventListener("mouseup", O)), () => {
    window.removeEventListener("mousemove", E), window.removeEventListener("mouseup", O);
  }), [h, E, O]), ke.useEffect(() => {
    d.current && !h && (console.log("Track position sync effect:", {
      trackId: e.id,
      x: e.position.x,
      y: e.position.y
    }), d.current.style.left = `${e.position.x}px`, d.current.style.top = `${e.position.y}px`);
  }, [e.position.x, e.position.y, e.id, h]), /* @__PURE__ */ W.jsx(
    Zt,
    {
      ref: d,
      onMouseDown: C,
      className: "track",
      sx: S,
      children: /* @__PURE__ */ W.jsxs(Zt, { sx: {
        display: "flex",
        flex: 1,
        position: "relative",
        overflow: "hidden",
        height: "100%",
        width: typeof w == "number" ? `${w}px` : "100%",
        margin: 0,
        padding: 0,
        boxSizing: "border-box",
        borderLeft: "none",
        borderRight: "none",
        background: `linear-gradient(180deg, ${T}80 0%, ${T} 100%)`,
        opacity: e.muted ? 0.4 : 0.85,
        "&:hover": {
          opacity: e.muted ? 0.5 : 1,
          boxShadow: "inset 0 0 10px rgba(255,255,255,0.3)"
        },
        transition: "opacity 0.2s ease"
      }, children: [
        /* @__PURE__ */ W.jsx(Zt, { sx: {
          position: "absolute",
          right: 10,
          top: 5,
          bgcolor: e.type === "audio" ? "#4caf50" : e.type === "midi" ? "#2196f3" : e.type === "drum" ? "#ff9800" : "#9c27b0",
          color: "white",
          fontSize: "10px",
          fontWeight: "bold",
          padding: "2px 6px",
          borderRadius: "3px",
          textTransform: "uppercase",
          opacity: 0.7
        }, children: e.type }),
        /* @__PURE__ */ W.jsxs(Zt, { sx: {
          position: "absolute",
          top: "0",
          left: "0",
          width: "100%",
          height: "100%",
          display: "flex",
          alignItems: "center",
          justifyContent: "flex-start",
          opacity: 0.8,
          // Full opacity for all track types
          pointerEvents: "none"
          // Don't interfere with drag events
        }, children: [
          e.type === "audio" && e.audioFile && /* @__PURE__ */ W.jsx(
            pA,
            {
              audioFile: e.audioFile,
              trackColor: T,
              duration: e.duration || 0,
              width: typeof w == "number" ? w : 500
            }
          ),
          e.type === "audio" && !e.audioFile && Array.from({ length: 40 }).map((B, N) => /* @__PURE__ */ W.jsx(
            Zt,
            {
              sx: {
                height: Math.sin(N * 0.3) * 10 + 10,
                width: 2,
                bgcolor: "rgba(255,255,255,0.7)",
                mx: 0.2
              }
            },
            N
          )),
          e.type === "midi" && /* @__PURE__ */ W.jsxs(W.Fragment, { children: [
            /* @__PURE__ */ W.jsx(
              Zt,
              {
                className: "piano-roll-trigger",
                "data-testid": "piano-roll-trigger",
                "data-track-id": e.id,
                "data-track-type": e.type,
                sx: {
                  position: "absolute",
                  top: 0,
                  left: 0,
                  width: "100%",
                  height: "100%",
                  cursor: "pointer",
                  zIndex: 100,
                  // Increased zIndex to ensure it's on top
                  opacity: 0.3,
                  // Make more visible for debugging
                  backgroundColor: "rgba(0, 100, 255, 0.1)",
                  // Add background color
                  "&:hover": {
                    bgcolor: "rgba(255,255,255,0.3)"
                  }
                }
              }
            ),
            /* @__PURE__ */ W.jsx(
              L_,
              {
                trackId: e.id,
                width: typeof w == "number" ? w : 500,
                height: Ie.trackHeight - 6,
                trackColor: T
              }
            )
          ] }),
          e.type === "drum" && /* @__PURE__ */ W.jsxs(W.Fragment, { children: [
            /* @__PURE__ */ W.jsx(
              Zt,
              {
                className: "piano-roll-trigger",
                "data-testid": "piano-roll-trigger",
                "data-track-id": e.id,
                "data-track-type": e.type,
                sx: {
                  position: "absolute",
                  top: 0,
                  left: 0,
                  width: "100%",
                  height: "100%",
                  cursor: "pointer",
                  zIndex: 10,
                  opacity: 0.1,
                  // Make slightly visible for debugging
                  "&:hover": {
                    bgcolor: "rgba(255,255,255,0.15)"
                  }
                }
              }
            ),
            /* @__PURE__ */ W.jsx(
              L_,
              {
                trackId: e.id,
                width: typeof w == "number" ? w : 500,
                height: Ie.trackHeight - 6,
                trackColor: T
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ W.jsx(Zt, { sx: {
          position: "absolute",
          left: 10,
          top: 6,
          color: "white",
          fontSize: "12px",
          fontWeight: "bold",
          textShadow: "1px 1px 2px rgba(0,0,0,0.7)"
        }, children: e.name }),
        e.muted && /* @__PURE__ */ W.jsx(Zt, { sx: {
          position: "absolute",
          width: "100%",
          height: "100%",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          backgroundColor: "rgba(0,0,0,0.4)",
          color: "white",
          fontSize: "14px",
          fontWeight: "bold"
        }, children: "MUTED" })
      ] })
    }
  );
}, lB = ke.memo(aB, (e, t) => !(e.track.position.x !== t.track.position.x || e.track.position.y !== t.track.position.y || e.track.muted !== t.track.muted || e.track._calculatedWidth !== t.track._calculatedWidth || e.isPlaying !== t.isPlaying || e.currentTime !== t.currentTime || e.measureCount !== t.measureCount || e.bpm !== t.bpm));
function cB(e) {
  var O;
  const {
    name: t,
    id: n,
    type: r,
    audioFile: i,
    isPlaying: s,
    currentTime: l,
    measureCount: c,
    gridLineStyle: u,
    position: d,
    onPositionChange: h,
    bpm: p,
    duration: v,
    _calculatedWidth: m,
    index: g,
    timeSignature: b = [4, 4]
  } = e, x = Yc((B) => B.store), w = (O = x == null ? void 0 : x.getTrackById) == null ? void 0 : O.call(x, n), { openPianoRoll: T } = Sl(), S = {
    name: t,
    id: n,
    type: r,
    audioFile: i,
    position: d,
    duration: v,
    _calculatedWidth: m,
    // Get actual values from the store if available, otherwise use defaults
    muted: (w == null ? void 0 : w.muted) ?? !1,
    soloed: (w == null ? void 0 : w.soloed) ?? !1,
    volume: (w == null ? void 0 : w.volume) ?? 80,
    pan: (w == null ? void 0 : w.pan) ?? 0,
    channel: (w == null ? void 0 : w.channel) ?? {}
  }, C = (B) => {
    console.log("Track clicked", {
      target: B.target,
      trackId: n,
      type: r,
      eventType: B.type
    }), r === "midi" || r === "drum" ? (B.stopPropagation(), console.log("Opening piano roll for track:", {
      trackId: n,
      type: r
    }), T(n)) : console.log("Not opening piano roll - track type is not midi or drum:", r);
  }, E = (B, N, L) => {
    console.log("Track: Position change called", {
      trackId: B,
      newPosition: N,
      oldPosition: d,
      isDragEnd: L
    }), h(N, L);
  };
  return /* @__PURE__ */ W.jsx(
    Zt,
    {
      onClick: C,
      sx: {
        position: "relative",
        cursor: "pointer"
      },
      "data-track-id": n,
      "data-track-type": r,
      children: /* @__PURE__ */ W.jsx(
        lB,
        {
          track: S,
          isPlaying: s,
          currentTime: l,
          measureCount: c,
          gridLineStyle: u,
          onPositionChange: E,
          bpm: p,
          timeSignature: b,
          trackIndex: g
        }
      )
    }
  );
}
function Ex({ currentTime: e, isPlaying: t = !1, bpm: n = 120, timeSignature: r = [4, 4] }) {
  const i = dA(e, n, r), s = Ie.cursorColor, l = Ie.cursorColorInactive;
  return /* @__PURE__ */ W.jsx(
    Zt,
    {
      sx: {
        position: "absolute",
        left: `${i}px`,
        top: 0,
        bottom: 0,
        width: "2px",
        bgcolor: t ? s : l,
        // Red when playing, gray when paused
        zIndex: 1500,
        // Higher z-index to stay on top
        pointerEvents: "none",
        transition: t ? "none" : "left 0.1s ease-out",
        // Smooth transition when manually positioning
        boxShadow: t ? "0 0 8px rgba(255, 85, 85, 0.6)" : "none",
        // Glow effect when playing
        "&::before": {
          content: '""',
          position: "absolute",
          top: 0,
          left: "-4px",
          width: 0,
          height: 0,
          borderLeft: "5px solid transparent",
          borderRight: "5px solid transparent",
          borderTop: `8px solid ${t ? s : l}`,
          zIndex: 1501
        }
      }
    }
  );
}
const uB = K.forwardRef(({
  tracks: e,
  currentTime: t = 0,
  isPlaying: n = !1,
  measureCount: r = Ie.measureCount,
  zoomLevel: i = 1,
  bpm: s = 120,
  timeSignature: l = [4, 4],
  onTrackPositionChange: c = () => {
  },
  onTimeChange: u = () => {
  },
  gridLineStyle: d = {
    borderRight: `${Ie.borderWidth} solid ${Ie.borderColor}`
  }
}, h) => {
  const p = r * Ie.measureWidth;
  return /* @__PURE__ */ W.jsxs(
    Zt,
    {
      ref: h,
      className: "timeline-container",
      sx: {
        flex: 1,
        position: "relative",
        overflow: "auto"
      },
      children: [
        /* @__PURE__ */ W.jsx(
          Ex,
          {
            currentTime: t,
            isPlaying: n,
            bpm: s,
            timeSignature: l
          }
        ),
        /* @__PURE__ */ W.jsx(
          dB,
          {
            measureCount: r,
            zoomLevel: i,
            gridLineStyle: d,
            bpm: s,
            timeSignature: l,
            onTimeChange: u,
            totalWidth: p
          }
        ),
        e.length > -1 ? /* @__PURE__ */ W.jsx(
          hB,
          {
            tracks: e,
            measureCount: r,
            zoomLevel: i,
            currentTime: t,
            isPlaying: n,
            bpm: s,
            timeSignature: l,
            gridLineStyle: d,
            onTrackPositionChange: c,
            onTimeChange: u,
            totalWidth: p
          }
        ) : /* @__PURE__ */ W.jsx(pB, { onTimeChange: u, bpm: s, timeSignature: l })
      ]
    }
  );
});
function dB({ measureCount: e, zoomLevel: t, bpm: n = 120, timeSignature: r = [4, 4], onTimeChange: i = () => {
}, gridLineStyle: s, totalWidth: l }) {
  const c = r[0], u = Ie.measureWidth / c, d = (h) => {
    const p = h.currentTarget.getBoundingClientRect(), v = h.clientX - p.left, m = v / t, g = fy(m, n, r);
    console.log("Timeline ruler clicked!", {
      clickX: v,
      adjustedX: m,
      newTime: g,
      zoomLevel: t,
      bpm: n,
      timeSignature: r
    }), i(g);
  };
  return /* @__PURE__ */ W.jsx(
    Zt,
    {
      sx: {
        display: "flex",
        position: "sticky",
        top: 0,
        bgcolor: "#111",
        zIndex: 2,
        height: Ie.headerHeight,
        boxSizing: "border-box",
        transform: `scaleX(${t})`,
        willChange: "transform",
        imageRendering: "crisp-edges",
        transformOrigin: "top left",
        borderBottom: "1px solid #444",
        boxShadow: `
          inset 0 12px 12px -10px rgba(255,255,255,0.12),
          0 1px 6px rgba(0,0,0,0.4)
        `,
        background: `
          linear-gradient(180deg, 
            rgba(255,255,255,0.08) 0%, 
            rgba(17,17,17,1) 30%
          )
        `,
        "& > div > div > div": {
          "&:first-of-type": {
            top: "8px",
            fontSize: "14px"
          }
        }
      },
      style: {
        width: l ? `${l}px` : "100%"
      },
      children: /* @__PURE__ */ W.jsxs(
        Zt,
        {
          sx: {
            display: "flex",
            position: "relative",
            width: "100%",
            // Ensure it fills the full width
            cursor: "pointer"
            // Show pointer cursor to indicate clickable
          },
          onClick: d,
          children: [
            Array.from({ length: e }).map((h, p) => /* @__PURE__ */ W.jsxs(
              Zt,
              {
                sx: {
                  position: "relative",
                  width: Ie.measureWidth,
                  height: "100%",
                  display: "flex"
                },
                children: [
                  /* @__PURE__ */ W.jsx(Zt, { sx: {
                    position: "absolute",
                    top: "8px",
                    left: "6px",
                    fontSize: "14px",
                    fontWeight: "bold",
                    color: "#999",
                    userSelect: "none"
                  }, children: p + 1 }),
                  Array.from({ length: c }).map((v, m) => /* @__PURE__ */ W.jsxs(
                    Zt,
                    {
                      sx: {
                        position: "relative",
                        width: u,
                        height: "100%",
                        borderLeft: m === 0 ? "1px solid #555" : "1px solid #333",
                        // Lighter line for beats
                        "&:first-of-type": {
                          borderLeft: "1px solid #555"
                          // Ensure first beat has stronger line
                        }
                      },
                      children: [
                        m !== 0 && /* @__PURE__ */ W.jsx(Zt, { sx: {
                          position: "absolute",
                          bottom: "6px",
                          left: "4px",
                          width: "100%",
                          textAlign: "left",
                          fontSize: "8px",
                          color: "#777",
                          userSelect: "none"
                        }, children: m + 1 }),
                        m !== c && (() => {
                          const g = r[1], b = g - 1;
                          return b <= 0 ? null : Array.from({ length: b }).map((x, w) => {
                            const T = (w + 1) * (u / g), C = w === Math.floor(b / 2) - 1 ? "#444" : "#333";
                            return /* @__PURE__ */ W.jsx(
                              Zt,
                              {
                                sx: {
                                  position: "absolute",
                                  top: "95%",
                                  left: `${T}px`,
                                  height: "4px",
                                  width: "1px",
                                  bgcolor: C,
                                  transform: "translateY(-2px)"
                                }
                              },
                              `sub-${p}-${m}-${w}`
                            );
                          });
                        })()
                      ]
                    },
                    `beat-${p}-${m}`
                  ))
                ]
              },
              `measure-${p}`
            )),
            /* @__PURE__ */ W.jsx(
              Zt,
              {
                sx: {
                  position: "absolute",
                  right: 0,
                  top: 0,
                  bottom: 0,
                  width: "1px",
                  bgcolor: "#555"
                }
              }
            )
          ]
        }
      )
    }
  );
}
function hB({
  tracks: e,
  measureCount: t,
  zoomLevel: n,
  currentTime: r,
  isPlaying: i,
  bpm: s,
  timeSignature: l,
  gridLineStyle: c,
  onTrackPositionChange: u,
  onTimeChange: d,
  totalWidth: h
}) {
  const p = (v) => {
    if (v.target.closest(".track")) {
      console.log("Click on track - ignoring for timeline click");
      return;
    }
    const m = v.currentTarget.getBoundingClientRect(), g = v.clientX - m.left, b = g / n, x = fy(b, s, l);
    console.log("Timeline content clicked!", {
      clickX: g,
      adjustedX: b,
      newTime: x,
      zoomLevel: n,
      bpm: s,
      timeSignature: l,
      target: v.target,
      currentTarget: v.currentTarget
    }), d(x);
  };
  return /* @__PURE__ */ W.jsxs(
    Zt,
    {
      sx: {
        minHeight: "100%",
        position: "relative",
        transform: `scaleX(${n})`,
        willChange: "transform",
        imageRendering: "crisp-edges",
        transformOrigin: "top left",
        cursor: "pointer"
        // Show pointer cursor to indicate clickable
      },
      style: {
        width: h ? `${h}px` : "100%"
      },
      onClick: p,
      children: [
        /* @__PURE__ */ W.jsx(fB, { measureCount: t, timeSignature: l }),
        e.map((v, m) => /* @__PURE__ */ W.jsx(
          cB,
          {
            id: v.id,
            name: v.name,
            index: m,
            type: v.type,
            audioFile: v.audioFile,
            isPlaying: i,
            currentTime: r,
            gridLineStyle: c,
            measureCount: Ie.measureCount,
            position: v.position,
            onPositionChange: (g, b) => u(v.id, g, b),
            bpm: s,
            duration: v.duration,
            _calculatedWidth: v._calculatedWidth,
            timeSignature: l
          },
          v.id
        ))
      ]
    }
  );
}
function fB({ measureCount: e, timeSignature: t = [4, 4] }) {
  const n = ke.useRef(null), r = ke.useRef(null), i = t[0], s = Ie.measureWidth / i;
  return ke.useEffect(() => {
    const l = n.current, c = r.current;
    if (!l || !c) return;
    const u = new ResizeObserver((h) => {
      for (const p of h)
        p.target === c && (l.width = c.clientWidth, l.height = c.clientHeight, d());
    });
    u.observe(c), l.width = c.clientWidth, l.height = c.clientHeight;
    function d() {
      const h = l.getContext("2d");
      if (!h) return;
      const p = window.devicePixelRatio || 1;
      l.width = c.clientWidth * p, l.height = c.clientHeight * p, h.scale(p, p), h.clearRect(0, 0, c.clientWidth, c.clientHeight), t[1];
      const v = "rgba(85, 85, 85, 0.9)", m = "rgba(51, 51, 51, 0.7)", g = (T, S, C) => {
        const E = Math.round(T) + 0.5;
        h.beginPath(), h.moveTo(E, 0), h.lineTo(E, c.clientHeight), h.strokeStyle = C || `rgba(34, 34, 34, ${S})`, h.lineWidth = 1, h.stroke();
      };
      console.log(`Drawing grid with time signature ${t[0]}/${t[1]}`);
      const b = t[1], x = e * i, w = s / b;
      console.log("Grid subdivision calculation:", {
        measureWidth: Ie.measureWidth,
        beatsPerMeasure: i,
        beatWidth: s,
        denominator: t[1],
        subdivisionsPerBeat: b,
        subdivisionWidth: w,
        expectedSubdivisionsPerMeasure: i * b
      });
      for (let T = 0; T < x; T++) {
        const S = T * s;
        for (let C = 1; C < b; C++) {
          const E = S + C * w;
          let O = 0.15;
          const B = C === Math.floor(b / 2), N = C === Math.floor(b / 4) || C === Math.floor(3 * b / 4);
          B ? O = 0.7 : N ? O = 0.5 : O = 0.35, g(E, O);
        }
      }
      for (let T = 0; T <= x; T++)
        if (T % i !== 0) {
          const S = T * s;
          g(S, 0.7, m);
        }
      for (let T = 0; T <= e; T++) {
        const S = T * Ie.measureWidth;
        g(S, 0.9, v);
      }
    }
    return d(), () => {
      u.disconnect();
    };
  }, [e, i, s, t]), /* @__PURE__ */ W.jsx(
    Zt,
    {
      ref: r,
      sx: {
        position: "absolute",
        top: 0,
        left: 0,
        bottom: 0,
        width: "100%",
        // Fill the full width of the parent container
        pointerEvents: "none",
        // Important: this makes the grid not catch any mouse events
        zIndex: 1e3
      },
      children: /* @__PURE__ */ W.jsx(
        "canvas",
        {
          ref: n,
          style: {
            position: "absolute",
            top: 0,
            left: 0,
            width: "100%",
            height: "100%",
            display: "block"
          }
        }
      )
    }
  );
}
function pB({ onTimeChange: e = () => {
}, bpm: t = 120, timeSignature: n = [4, 4] }) {
  return /* @__PURE__ */ W.jsxs(Zt, { sx: {
    flex: 1,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    flexDirection: "column",
    color: "#666",
    height: "100%",
    border: "2px dashed #333",
    m: 2,
    borderRadius: 2,
    position: "relative"
    // For positioning the cursor inside
  }, children: [
    /* @__PURE__ */ W.jsx(Zt, { sx: { fontSize: 24, mb: 1 }, children: "" }),
    /* @__PURE__ */ W.jsx(Zt, { children: "Drop a loop or an audio/MIDI/Video file" }),
    /* @__PURE__ */ W.jsx(Ex, { currentTime: 0, isPlaying: !1, bpm: t, timeSignature: n })
  ] });
}
const mB = zr(/* @__PURE__ */ W.jsx("path", {
  d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2m-5 11.5h.25V19h-4.5v-4.5H10c.55 0 1-.45 1-1V5h2v8.5c0 .55.45 1 1 1M5 5h2v8.5c0 .55.45 1 1 1h.25V19H5zm14 14h-3.25v-4.5H16c.55 0 1-.45 1-1V5h2z"
}), "Piano"), gB = zr(/* @__PURE__ */ W.jsx("path", {
  d: "M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8zm2 11h-3v3.75c0 1.24-1.01 2.25-2.25 2.25S8.5 17.99 8.5 16.75s1.01-2.25 2.25-2.25c.46 0 .89.14 1.25.38V11h4zm-3-4V3.5L18.5 9z"
}), "AudioFile"), yB = zr(/* @__PURE__ */ W.jsx("path", {
  d: "M7 18h2V6H7zm4 4h2V2h-2zm-8-8h2v-4H3zm12 4h2V6h-2zm4-8v4h2v-4z"
}), "GraphicEq"), vB = ({
  isOpen: e,
  anchorEl: t,
  onClose: n,
  onAddTrack: r,
  onFileUpload: i
}) => {
  const s = (l) => {
    const c = l.target.files;
    if (c && c.length > 0) {
      const u = c[0];
      i && i(u), n();
    }
  };
  return /* @__PURE__ */ W.jsxs(
    ly,
    {
      open: e,
      anchorEl: t,
      onClose: n,
      PaperProps: {
        sx: { bgcolor: "#222", color: "white", minWidth: 180 }
      },
      children: [
        /* @__PURE__ */ W.jsxs(
          ks,
          {
            onClick: () => {
              r("midi"), n();
            },
            sx: {
              fontSize: "13px",
              py: 1,
              "&:hover": {
                bgcolor: "rgba(33, 150, 243, 0.2)"
              }
            },
            children: [
              /* @__PURE__ */ W.jsx(Sg, { children: /* @__PURE__ */ W.jsx(mB, { sx: { color: "#2196f3" } }) }),
              /* @__PURE__ */ W.jsx(xg, { primary: "MIDI Track" })
            ]
          }
        ),
        /* @__PURE__ */ W.jsxs(
          ks,
          {
            onClick: () => {
              r("drum"), n();
            },
            sx: {
              fontSize: "13px",
              py: 1,
              "&:hover": {
                bgcolor: "rgba(255, 152, 0, 0.2)"
              }
            },
            children: [
              /* @__PURE__ */ W.jsx(Sg, { children: /* @__PURE__ */ W.jsx(yB, { sx: { color: "#ff9800" } }) }),
              /* @__PURE__ */ W.jsx(xg, { primary: "Drum Machine" })
            ]
          }
        ),
        /* @__PURE__ */ W.jsx(f0, { sx: { bgcolor: "#444" } }),
        /* @__PURE__ */ W.jsx(
          ks,
          {
            sx: {
              fontSize: "13px",
              py: 1,
              "&:hover": {
                bgcolor: "rgba(76, 175, 80, 0.2)"
              }
            },
            children: /* @__PURE__ */ W.jsxs("label", { style: { display: "flex", alignItems: "center", width: "100%", cursor: "pointer" }, children: [
              /* @__PURE__ */ W.jsx(Sg, { children: /* @__PURE__ */ W.jsx(gB, { sx: { color: "#4caf50" } }) }),
              /* @__PURE__ */ W.jsx(xg, { primary: "Import Audio" }),
              /* @__PURE__ */ W.jsx(
                "input",
                {
                  type: "file",
                  accept: "audio/*",
                  style: { display: "none" },
                  onChange: s
                }
              )
            ] })
          }
        )
      ]
    }
  );
};
function bB() {
  const { openPianoRoll: e } = Sl(), { tracks: t } = Yc(), n = () => {
    const r = t.find((i) => i.type === "midi" || i.type === "drum");
    r ? (console.log("TEST: Opening piano roll for track:", r.id), e(r.id)) : (console.log("TEST: No MIDI or drum tracks found to open piano roll"), Yc.getState().handleAddTrack("midi"));
  };
  return /* @__PURE__ */ W.jsx(
    Nc,
    {
      variant: "contained",
      color: "error",
      onClick: n,
      sx: { fontSize: "10px" },
      children: "Test Piano Roll"
    }
  );
}
function _B() {
  const {
    store: e,
    tracks: t,
    isPlaying: n,
    currentTime: r,
    bpm: i,
    timeSignature: s,
    keySignature: l,
    zoomLevel: c,
    projectTitle: u,
    canUndo: d,
    canRedo: h,
    measureCount: p,
    isInitialized: v,
    addMenuAnchor: m,
    // Actions
    initializeAudio: g,
    setZoomLevel: b,
    setProjectTitle: x,
    setTimeSignature: w,
    setKeySignature: T,
    playPause: S,
    stop: C,
    setCurrentTime: E,
    setMeasureCount: O,
    undo: B,
    redo: N,
    handleTrackVolumeChange: L,
    handleTrackPanChange: k,
    handleTrackMuteToggle: F,
    handleTrackSoloToggle: G,
    handleTrackDelete: M,
    handleAddTrack: j,
    handleTrackPositionChange: D,
    handleTrackNameChange: z,
    uploadAudioFile: H,
    setBpm: X,
    setAddMenuAnchor: Y
  } = Yc(), V = K.useRef(null), Z = K.useRef(null);
  K.useEffect(() => (g(), () => {
    delete window.storeInstance;
  }), [g]);
  const ct = (tt) => {
    const ot = parseInt(tt.target.value, 10);
    !isNaN(ot) && ot > 0 && ot <= 999 && X(ot);
  }, et = (tt, ot) => {
    const [Tt, Ct] = s;
    w(
      tt ?? Tt,
      ot ?? Ct
    );
  }, rt = () => {
    b(Math.min(c + 0.1, 4));
  }, st = () => {
    b(Math.max(c - 0.1, 0.3));
  }, yt = (tt) => {
    x(tt.target.value);
  };
  K.useEffect(() => {
    if (!n || !e) return;
    const tt = () => {
      const ot = e.getTransport();
      ot && (E(ot.position), Z.current = requestAnimationFrame(tt));
    };
    return Z.current = requestAnimationFrame(tt), () => {
      Z.current && cancelAnimationFrame(Z.current);
    };
  }, [n, e, E]);
  const J = ke.useCallback(() => {
    if (!V.current) return;
    const { scrollLeft: tt, scrollWidth: ot, clientWidth: Tt } = V.current;
    tt + Tt >= ot - 100 && O(p + 20);
  }, [p, O]);
  return K.useEffect(() => {
    const tt = V.current;
    if (!tt) return;
    const ot = () => requestAnimationFrame(J);
    return tt.addEventListener("scroll", ot), () => tt.removeEventListener("scroll", ot);
  }, [J]), /* @__PURE__ */ W.jsxs(Zt, { sx: {
    height: "100vh",
    bgcolor: "#000000",
    color: "white",
    display: "flex",
    flexDirection: "column"
  }, children: [
    /* @__PURE__ */ W.jsxs(Zt, { sx: {
      display: "flex",
      alignItems: "center",
      p: 1,
      borderBottom: "1px solid #333",
      gap: 2,
      paddingLeft: 2,
      position: "relative",
      zIndex: 1300
    }, children: [
      /* @__PURE__ */ W.jsxs(Zt, { sx: { display: "flex", gap: 1 }, children: [
        /* @__PURE__ */ W.jsx(
          Qo,
          {
            size: "small",
            sx: { color: d ? "white" : "#666" },
            onClick: B,
            disabled: !d,
            title: "Undo",
            children: /* @__PURE__ */ W.jsx(J7, {})
          }
        ),
        /* @__PURE__ */ W.jsx(
          Qo,
          {
            size: "small",
            sx: { color: h ? "white" : "#666" },
            onClick: N,
            disabled: !h,
            title: "Redo",
            children: /* @__PURE__ */ W.jsx(tA, {})
          }
        )
      ] }),
      /* @__PURE__ */ W.jsx(Zt, { sx: {
        display: "flex",
        alignItems: "center",
        bgcolor: "#1E1E1E",
        borderRadius: 1,
        px: 2,
        py: 0.5,
        gap: 1
      }, children: /* @__PURE__ */ W.jsx(nA, { bpm: i, onBpmChange: ct }) }),
      /* @__PURE__ */ W.jsx(
        rA,
        {
          topNumber: s[0],
          bottomNumber: s[1],
          onTopNumberChange: (tt) => et(tt, void 0),
          onBottomNumberChange: (tt) => et(void 0, tt)
        }
      ),
      /* @__PURE__ */ W.jsx(
        oA,
        {
          selectedKey: l,
          onKeyChange: T
        }
      ),
      /* @__PURE__ */ W.jsxs(Zt, { sx: { display: "flex", gap: 1 }, children: [
        /* @__PURE__ */ W.jsx(
          Qo,
          {
            size: "small",
            sx: { color: "white" },
            onClick: S,
            children: n ? /* @__PURE__ */ W.jsx(Y7, {}) : /* @__PURE__ */ W.jsx(K7, {})
          }
        ),
        /* @__PURE__ */ W.jsx(
          Qo,
          {
            size: "small",
            sx: { color: "white" },
            onClick: C,
            children: /* @__PURE__ */ W.jsx(X7, {})
          }
        )
      ] }),
      /* @__PURE__ */ W.jsx(Zt, { sx: {
        position: "absolute",
        left: "50%",
        top: "50%",
        transform: "translate(-50%, -50%)",
        zIndex: 1
      }, children: /* @__PURE__ */ W.jsx(
        hy,
        {
          variant: "standard",
          value: u,
          onChange: yt,
          sx: {
            "& input": {
              color: "white",
              textAlign: "center",
              fontSize: "1rem",
              fontWeight: 500,
              padding: "4px 8px",
              "&:hover": {
                backgroundColor: "rgba(255, 255, 255, 0.05)"
              }
            },
            "& .MuiInput-underline:before": {
              borderBottom: "none"
            },
            "& .MuiInput-underline:hover:before": {
              borderBottom: "1px solid rgba(255, 255, 255, 0.2)"
            },
            "& .MuiInput-underline:after": {
              borderBottom: "2px solid white"
            }
          }
        }
      ) }),
      /* @__PURE__ */ W.jsx(Zt, { sx: {
        marginLeft: "auto",
        display: "flex",
        alignItems: "center",
        gap: 2,
        pr: 2
      }, children: /* @__PURE__ */ W.jsxs(Zt, { sx: {
        display: "flex",
        alignItems: "center",
        gap: 1
      }, children: [
        /* @__PURE__ */ W.jsx(Qo, { size: "small", sx: { color: "white" }, onClick: rt, children: /* @__PURE__ */ W.jsx(Q7, {}) }),
        /* @__PURE__ */ W.jsxs(Zt, { sx: { color: "white", fontWeight: "bold", backgroundColor: "#333", minWidth: 40, textAlign: "center", border: "1px solid rgba(255, 255, 255, 0.2)", padding: "4px 4px", borderRadius: "6px" }, children: [
          c.toFixed(1),
          "x"
        ] }),
        /* @__PURE__ */ W.jsx(Qo, { size: "small", sx: { color: "white" }, onClick: st, children: /* @__PURE__ */ W.jsx(Z7, {}) })
      ] }) })
    ] }),
    /* @__PURE__ */ W.jsxs(Zt, { sx: {
      display: "flex",
      flex: 1,
      overflow: "hidden",
      position: "relative"
    }, children: [
      /* @__PURE__ */ W.jsx(Zt, { sx: {
        position: "absolute",
        top: 10,
        right: 10,
        zIndex: 9999
      }, children: /* @__PURE__ */ W.jsx(bB, {}) }),
      /* @__PURE__ */ W.jsxs(Zt, { sx: {
        width: Ie.sidebarWidth,
        borderRight: `${Ie.borderWidth} solid ${Ie.borderColor}`,
        bgcolor: "#1A1A1A",
        display: "flex",
        flexDirection: "column"
      }, children: [
        /* @__PURE__ */ W.jsx(Zt, { sx: {
          height: Ie.headerHeight,
          borderBottom: `${Ie.borderWidth} solid ${Ie.borderColor}`,
          display: "flex",
          alignItems: "center",
          p: 0.3,
          boxSizing: "border-box"
        }, children: /* @__PURE__ */ W.jsxs(Zt, { sx: {
          position: "relative",
          display: "flex",
          width: "100%"
        }, children: [
          /* @__PURE__ */ W.jsx(
            Nc,
            {
              startIcon: /* @__PURE__ */ W.jsx(eA, {}),
              variant: "contained",
              onClick: (tt) => Y(tt.currentTarget),
              sx: {
                bgcolor: "#1A1A1A",
                color: "white",
                "&:hover": { bgcolor: "#444" },
                height: 24,
                textTransform: "none",
                width: "100%",
                mx: "auto",
                display: "flex",
                fontSize: "12px",
                fontWeight: "bold"
              },
              children: "Add Track"
            }
          ),
          /* @__PURE__ */ W.jsx(
            vB,
            {
              isOpen: !!m,
              anchorEl: m,
              onClose: () => Y(null),
              onAddTrack: j,
              onFileUpload: H
            }
          )
        ] }) }),
        /* @__PURE__ */ W.jsx(Zt, { sx: {
          flex: 1,
          overflow: "auto"
        }, children: /* @__PURE__ */ W.jsx(
          hA,
          {
            tracks: t,
            onVolumeChange: L,
            onPanChange: k,
            onMuteToggle: F,
            onSoloToggle: G,
            onTrackDelete: M,
            onTrackNameChange: z
          }
        ) })
      ] }),
      /* @__PURE__ */ W.jsx(
        uB,
        {
          tracks: t,
          currentTime: r,
          isPlaying: n,
          measureCount: p,
          zoomLevel: c,
          bpm: i,
          timeSignature: s,
          onTrackPositionChange: D,
          onTimeChange: (tt) => {
            E(tt), e && e.getTransport() && e.getTransport().setPosition(tt);
          },
          gridLineStyle: {
            borderRight: `${Ie.borderWidth} solid ${Ie.borderColor}`
          },
          ref: V
        }
      )
    ] })
  ] });
}
const SB = () => /* @__PURE__ */ W.jsxs(sB, { children: [
  /* @__PURE__ */ W.jsx(_B, {}),
  /* @__PURE__ */ W.jsx(oB, {})
] }), TF = () => (K.useEffect(() => {
  document.getElementById("studio-vite-root") && (document.body.style.overflow = "hidden", document.body.style.margin = "0", document.body.style.padding = "0");
}, []), /* @__PURE__ */ W.jsx(SB, {}));
export {
  TF as default
};
//# sourceMappingURL=Studio.js.map

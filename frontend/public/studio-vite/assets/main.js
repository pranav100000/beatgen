var KC = Object.defineProperty;
var YC = (e, t, n) => t in e ? KC(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var Qe = (e, t, n) => YC(e, typeof t != "symbol" ? t + "" : t, n);
function XC(e, t) {
  for (var n = 0; n < t.length; n++) {
    const i = t[n];
    if (typeof i != "string" && !Array.isArray(i)) {
      for (const s in i)
        if (s !== "default" && !(s in e)) {
          const o = Object.getOwnPropertyDescriptor(i, s);
          o && Object.defineProperty(e, s, o.get ? o : {
            enumerable: !0,
            get: () => i[s]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
var Pb = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function lp(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function WC(e) {
  if (Object.prototype.hasOwnProperty.call(e, "__esModule")) return e;
  var t = e.default;
  if (typeof t == "function") {
    var n = function i() {
      return this instanceof i ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    n.prototype = t.prototype;
  } else n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(e).forEach(function(i) {
    var s = Object.getOwnPropertyDescriptor(e, i);
    Object.defineProperty(n, i, s.get ? s : {
      enumerable: !0,
      get: function() {
        return e[i];
      }
    });
  }), n;
}
var Yv = { exports: {} }, um = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var RS;
function $C() {
  if (RS) return um;
  RS = 1;
  var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.fragment");
  function n(i, s, o) {
    var u = null;
    if (o !== void 0 && (u = "" + o), s.key !== void 0 && (u = "" + s.key), "key" in s) {
      o = {};
      for (var h in s)
        h !== "key" && (o[h] = s[h]);
    } else o = s;
    return s = o.ref, {
      $$typeof: e,
      type: i,
      key: u,
      ref: s !== void 0 ? s : null,
      props: o
    };
  }
  return um.Fragment = t, um.jsx = n, um.jsxs = n, um;
}
var OS;
function QC() {
  return OS || (OS = 1, Yv.exports = $C()), Yv.exports;
}
var J = QC(), Xv = { exports: {} }, hn = {};
/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var NS;
function ZC() {
  if (NS) return hn;
  NS = 1;
  var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), o = Symbol.for("react.consumer"), u = Symbol.for("react.context"), h = Symbol.for("react.forward_ref"), f = Symbol.for("react.suspense"), p = Symbol.for("react.memo"), g = Symbol.for("react.lazy"), v = Symbol.iterator;
  function x(X) {
    return X === null || typeof X != "object" ? null : (X = v && X[v] || X["@@iterator"], typeof X == "function" ? X : null);
  }
  var b = {
    isMounted: function() {
      return !1;
    },
    enqueueForceUpdate: function() {
    },
    enqueueReplaceState: function() {
    },
    enqueueSetState: function() {
    }
  }, _ = Object.assign, T = {};
  function A(X, rt, vt) {
    this.props = X, this.context = rt, this.refs = T, this.updater = vt || b;
  }
  A.prototype.isReactComponent = {}, A.prototype.setState = function(X, rt) {
    if (typeof X != "object" && typeof X != "function" && X != null)
      throw Error(
        "takes an object of state variables to update or a function which returns an object of state variables."
      );
    this.updater.enqueueSetState(this, X, rt, "setState");
  }, A.prototype.forceUpdate = function(X) {
    this.updater.enqueueForceUpdate(this, X, "forceUpdate");
  };
  function O() {
  }
  O.prototype = A.prototype;
  function M(X, rt, vt) {
    this.props = X, this.context = rt, this.refs = T, this.updater = vt || b;
  }
  var E = M.prototype = new O();
  E.constructor = M, _(E, A.prototype), E.isPureReactComponent = !0;
  var R = Array.isArray, N = { H: null, A: null, T: null, S: null }, U = Object.prototype.hasOwnProperty;
  function q(X, rt, vt, ct, dt, ht) {
    return vt = ht.ref, {
      $$typeof: e,
      type: X,
      key: rt,
      ref: vt !== void 0 ? vt : null,
      props: ht
    };
  }
  function j(X, rt) {
    return q(
      X.type,
      rt,
      void 0,
      void 0,
      void 0,
      X.props
    );
  }
  function V(X) {
    return typeof X == "object" && X !== null && X.$$typeof === e;
  }
  function D(X) {
    var rt = { "=": "=0", ":": "=2" };
    return "$" + X.replace(/[=:]/g, function(vt) {
      return rt[vt];
    });
  }
  var G = /\/+/g;
  function W(X, rt) {
    return typeof X == "object" && X !== null && X.key != null ? D("" + X.key) : rt.toString(36);
  }
  function P() {
  }
  function H(X) {
    switch (X.status) {
      case "fulfilled":
        return X.value;
      case "rejected":
        throw X.reason;
      default:
        switch (typeof X.status == "string" ? X.then(P, P) : (X.status = "pending", X.then(
          function(rt) {
            X.status === "pending" && (X.status = "fulfilled", X.value = rt);
          },
          function(rt) {
            X.status === "pending" && (X.status = "rejected", X.reason = rt);
          }
        )), X.status) {
          case "fulfilled":
            return X.value;
          case "rejected":
            throw X.reason;
        }
    }
    throw X;
  }
  function I(X, rt, vt, ct, dt) {
    var ht = typeof X;
    (ht === "undefined" || ht === "boolean") && (X = null);
    var Et = !1;
    if (X === null) Et = !0;
    else
      switch (ht) {
        case "bigint":
        case "string":
        case "number":
          Et = !0;
          break;
        case "object":
          switch (X.$$typeof) {
            case e:
            case t:
              Et = !0;
              break;
            case g:
              return Et = X._init, I(
                Et(X._payload),
                rt,
                vt,
                ct,
                dt
              );
          }
      }
    if (Et)
      return dt = dt(X), Et = ct === "" ? "." + W(X, 0) : ct, R(dt) ? (vt = "", Et != null && (vt = Et.replace(G, "$&/") + "/"), I(dt, rt, vt, "", function(ft) {
        return ft;
      })) : dt != null && (V(dt) && (dt = j(
        dt,
        vt + (dt.key == null || X && X.key === dt.key ? "" : ("" + dt.key).replace(
          G,
          "$&/"
        ) + "/") + Et
      )), rt.push(dt)), 1;
    Et = 0;
    var ot = ct === "" ? "." : ct + ":";
    if (R(X))
      for (var lt = 0; lt < X.length; lt++)
        ct = X[lt], ht = ot + W(ct, lt), Et += I(
          ct,
          rt,
          vt,
          ht,
          dt
        );
    else if (lt = x(X), typeof lt == "function")
      for (X = lt.call(X), lt = 0; !(ct = X.next()).done; )
        ct = ct.value, ht = ot + W(ct, lt++), Et += I(
          ct,
          rt,
          vt,
          ht,
          dt
        );
    else if (ht === "object") {
      if (typeof X.then == "function")
        return I(
          H(X),
          rt,
          vt,
          ct,
          dt
        );
      throw rt = String(X), Error(
        "Objects are not valid as a React child (found: " + (rt === "[object Object]" ? "object with keys {" + Object.keys(X).join(", ") + "}" : rt) + "). If you meant to render a collection of children, use an array instead."
      );
    }
    return Et;
  }
  function K(X, rt, vt) {
    if (X == null) return X;
    var ct = [], dt = 0;
    return I(X, ct, "", "", function(ht) {
      return rt.call(vt, ht, dt++);
    }), ct;
  }
  function Q(X) {
    if (X._status === -1) {
      var rt = X._result;
      rt = rt(), rt.then(
        function(vt) {
          (X._status === 0 || X._status === -1) && (X._status = 1, X._result = vt);
        },
        function(vt) {
          (X._status === 0 || X._status === -1) && (X._status = 2, X._result = vt);
        }
      ), X._status === -1 && (X._status = 0, X._result = rt);
    }
    if (X._status === 1) return X._result.default;
    throw X._result;
  }
  var it = typeof reportError == "function" ? reportError : function(X) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var rt = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof X == "object" && X !== null && typeof X.message == "string" ? String(X.message) : String(X),
        error: X
      });
      if (!window.dispatchEvent(rt)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", X);
      return;
    }
    console.error(X);
  };
  function nt() {
  }
  return hn.Children = {
    map: K,
    forEach: function(X, rt, vt) {
      K(
        X,
        function() {
          rt.apply(this, arguments);
        },
        vt
      );
    },
    count: function(X) {
      var rt = 0;
      return K(X, function() {
        rt++;
      }), rt;
    },
    toArray: function(X) {
      return K(X, function(rt) {
        return rt;
      }) || [];
    },
    only: function(X) {
      if (!V(X))
        throw Error(
          "React.Children.only expected to receive a single React element child."
        );
      return X;
    }
  }, hn.Component = A, hn.Fragment = n, hn.Profiler = s, hn.PureComponent = M, hn.StrictMode = i, hn.Suspense = f, hn.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = N, hn.act = function() {
    throw Error("act(...) is not supported in production builds of React.");
  }, hn.cache = function(X) {
    return function() {
      return X.apply(null, arguments);
    };
  }, hn.cloneElement = function(X, rt, vt) {
    if (X == null)
      throw Error(
        "The argument must be a React element, but you passed " + X + "."
      );
    var ct = _({}, X.props), dt = X.key, ht = void 0;
    if (rt != null)
      for (Et in rt.ref !== void 0 && (ht = void 0), rt.key !== void 0 && (dt = "" + rt.key), rt)
        !U.call(rt, Et) || Et === "key" || Et === "__self" || Et === "__source" || Et === "ref" && rt.ref === void 0 || (ct[Et] = rt[Et]);
    var Et = arguments.length - 2;
    if (Et === 1) ct.children = vt;
    else if (1 < Et) {
      for (var ot = Array(Et), lt = 0; lt < Et; lt++)
        ot[lt] = arguments[lt + 2];
      ct.children = ot;
    }
    return q(X.type, dt, void 0, void 0, ht, ct);
  }, hn.createContext = function(X) {
    return X = {
      $$typeof: u,
      _currentValue: X,
      _currentValue2: X,
      _threadCount: 0,
      Provider: null,
      Consumer: null
    }, X.Provider = X, X.Consumer = {
      $$typeof: o,
      _context: X
    }, X;
  }, hn.createElement = function(X, rt, vt) {
    var ct, dt = {}, ht = null;
    if (rt != null)
      for (ct in rt.key !== void 0 && (ht = "" + rt.key), rt)
        U.call(rt, ct) && ct !== "key" && ct !== "__self" && ct !== "__source" && (dt[ct] = rt[ct]);
    var Et = arguments.length - 2;
    if (Et === 1) dt.children = vt;
    else if (1 < Et) {
      for (var ot = Array(Et), lt = 0; lt < Et; lt++)
        ot[lt] = arguments[lt + 2];
      dt.children = ot;
    }
    if (X && X.defaultProps)
      for (ct in Et = X.defaultProps, Et)
        dt[ct] === void 0 && (dt[ct] = Et[ct]);
    return q(X, ht, void 0, void 0, null, dt);
  }, hn.createRef = function() {
    return { current: null };
  }, hn.forwardRef = function(X) {
    return { $$typeof: h, render: X };
  }, hn.isValidElement = V, hn.lazy = function(X) {
    return {
      $$typeof: g,
      _payload: { _status: -1, _result: X },
      _init: Q
    };
  }, hn.memo = function(X, rt) {
    return {
      $$typeof: p,
      type: X,
      compare: rt === void 0 ? null : rt
    };
  }, hn.startTransition = function(X) {
    var rt = N.T, vt = {};
    N.T = vt;
    try {
      var ct = X(), dt = N.S;
      dt !== null && dt(vt, ct), typeof ct == "object" && ct !== null && typeof ct.then == "function" && ct.then(nt, it);
    } catch (ht) {
      it(ht);
    } finally {
      N.T = rt;
    }
  }, hn.unstable_useCacheRefresh = function() {
    return N.H.useCacheRefresh();
  }, hn.use = function(X) {
    return N.H.use(X);
  }, hn.useActionState = function(X, rt, vt) {
    return N.H.useActionState(X, rt, vt);
  }, hn.useCallback = function(X, rt) {
    return N.H.useCallback(X, rt);
  }, hn.useContext = function(X) {
    return N.H.useContext(X);
  }, hn.useDebugValue = function() {
  }, hn.useDeferredValue = function(X, rt) {
    return N.H.useDeferredValue(X, rt);
  }, hn.useEffect = function(X, rt) {
    return N.H.useEffect(X, rt);
  }, hn.useId = function() {
    return N.H.useId();
  }, hn.useImperativeHandle = function(X, rt, vt) {
    return N.H.useImperativeHandle(X, rt, vt);
  }, hn.useInsertionEffect = function(X, rt) {
    return N.H.useInsertionEffect(X, rt);
  }, hn.useLayoutEffect = function(X, rt) {
    return N.H.useLayoutEffect(X, rt);
  }, hn.useMemo = function(X, rt) {
    return N.H.useMemo(X, rt);
  }, hn.useOptimistic = function(X, rt) {
    return N.H.useOptimistic(X, rt);
  }, hn.useReducer = function(X, rt, vt) {
    return N.H.useReducer(X, rt, vt);
  }, hn.useRef = function(X) {
    return N.H.useRef(X);
  }, hn.useState = function(X) {
    return N.H.useState(X);
  }, hn.useSyncExternalStore = function(X, rt, vt) {
    return N.H.useSyncExternalStore(
      X,
      rt,
      vt
    );
  }, hn.useTransition = function() {
    return N.H.useTransition();
  }, hn.version = "19.0.0", hn;
}
var kS;
function C1() {
  return kS || (kS = 1, Xv.exports = ZC()), Xv.exports;
}
var tt = C1();
const an = /* @__PURE__ */ lp(tt), Ub = /* @__PURE__ */ XC({
  __proto__: null,
  default: an
}, [tt]);
var Wv = { exports: {} }, dm = {}, $v = { exports: {} }, Qv = {};
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var DS;
function JC() {
  return DS || (DS = 1, function(e) {
    function t(K, Q) {
      var it = K.length;
      K.push(Q);
      t: for (; 0 < it; ) {
        var nt = it - 1 >>> 1, X = K[nt];
        if (0 < s(X, Q))
          K[nt] = Q, K[it] = X, it = nt;
        else break t;
      }
    }
    function n(K) {
      return K.length === 0 ? null : K[0];
    }
    function i(K) {
      if (K.length === 0) return null;
      var Q = K[0], it = K.pop();
      if (it !== Q) {
        K[0] = it;
        t: for (var nt = 0, X = K.length, rt = X >>> 1; nt < rt; ) {
          var vt = 2 * (nt + 1) - 1, ct = K[vt], dt = vt + 1, ht = K[dt];
          if (0 > s(ct, it))
            dt < X && 0 > s(ht, ct) ? (K[nt] = ht, K[dt] = it, nt = dt) : (K[nt] = ct, K[vt] = it, nt = vt);
          else if (dt < X && 0 > s(ht, it))
            K[nt] = ht, K[dt] = it, nt = dt;
          else break t;
        }
      }
      return Q;
    }
    function s(K, Q) {
      var it = K.sortIndex - Q.sortIndex;
      return it !== 0 ? it : K.id - Q.id;
    }
    if (e.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
      var o = performance;
      e.unstable_now = function() {
        return o.now();
      };
    } else {
      var u = Date, h = u.now();
      e.unstable_now = function() {
        return u.now() - h;
      };
    }
    var f = [], p = [], g = 1, v = null, x = 3, b = !1, _ = !1, T = !1, A = typeof setTimeout == "function" ? setTimeout : null, O = typeof clearTimeout == "function" ? clearTimeout : null, M = typeof setImmediate < "u" ? setImmediate : null;
    function E(K) {
      for (var Q = n(p); Q !== null; ) {
        if (Q.callback === null) i(p);
        else if (Q.startTime <= K)
          i(p), Q.sortIndex = Q.expirationTime, t(f, Q);
        else break;
        Q = n(p);
      }
    }
    function R(K) {
      if (T = !1, E(K), !_)
        if (n(f) !== null)
          _ = !0, H();
        else {
          var Q = n(p);
          Q !== null && I(R, Q.startTime - K);
        }
    }
    var N = !1, U = -1, q = 5, j = -1;
    function V() {
      return !(e.unstable_now() - j < q);
    }
    function D() {
      if (N) {
        var K = e.unstable_now();
        j = K;
        var Q = !0;
        try {
          t: {
            _ = !1, T && (T = !1, O(U), U = -1), b = !0;
            var it = x;
            try {
              e: {
                for (E(K), v = n(f); v !== null && !(v.expirationTime > K && V()); ) {
                  var nt = v.callback;
                  if (typeof nt == "function") {
                    v.callback = null, x = v.priorityLevel;
                    var X = nt(
                      v.expirationTime <= K
                    );
                    if (K = e.unstable_now(), typeof X == "function") {
                      v.callback = X, E(K), Q = !0;
                      break e;
                    }
                    v === n(f) && i(f), E(K);
                  } else i(f);
                  v = n(f);
                }
                if (v !== null) Q = !0;
                else {
                  var rt = n(p);
                  rt !== null && I(
                    R,
                    rt.startTime - K
                  ), Q = !1;
                }
              }
              break t;
            } finally {
              v = null, x = it, b = !1;
            }
            Q = void 0;
          }
        } finally {
          Q ? G() : N = !1;
        }
      }
    }
    var G;
    if (typeof M == "function")
      G = function() {
        M(D);
      };
    else if (typeof MessageChannel < "u") {
      var W = new MessageChannel(), P = W.port2;
      W.port1.onmessage = D, G = function() {
        P.postMessage(null);
      };
    } else
      G = function() {
        A(D, 0);
      };
    function H() {
      N || (N = !0, G());
    }
    function I(K, Q) {
      U = A(function() {
        K(e.unstable_now());
      }, Q);
    }
    e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function(K) {
      K.callback = null;
    }, e.unstable_continueExecution = function() {
      _ || b || (_ = !0, H());
    }, e.unstable_forceFrameRate = function(K) {
      0 > K || 125 < K ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      ) : q = 0 < K ? Math.floor(1e3 / K) : 5;
    }, e.unstable_getCurrentPriorityLevel = function() {
      return x;
    }, e.unstable_getFirstCallbackNode = function() {
      return n(f);
    }, e.unstable_next = function(K) {
      switch (x) {
        case 1:
        case 2:
        case 3:
          var Q = 3;
          break;
        default:
          Q = x;
      }
      var it = x;
      x = Q;
      try {
        return K();
      } finally {
        x = it;
      }
    }, e.unstable_pauseExecution = function() {
    }, e.unstable_requestPaint = function() {
    }, e.unstable_runWithPriority = function(K, Q) {
      switch (K) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          K = 3;
      }
      var it = x;
      x = K;
      try {
        return Q();
      } finally {
        x = it;
      }
    }, e.unstable_scheduleCallback = function(K, Q, it) {
      var nt = e.unstable_now();
      switch (typeof it == "object" && it !== null ? (it = it.delay, it = typeof it == "number" && 0 < it ? nt + it : nt) : it = nt, K) {
        case 1:
          var X = -1;
          break;
        case 2:
          X = 250;
          break;
        case 5:
          X = 1073741823;
          break;
        case 4:
          X = 1e4;
          break;
        default:
          X = 5e3;
      }
      return X = it + X, K = {
        id: g++,
        callback: Q,
        priorityLevel: K,
        startTime: it,
        expirationTime: X,
        sortIndex: -1
      }, it > nt ? (K.sortIndex = it, t(p, K), n(f) === null && K === n(p) && (T ? (O(U), U = -1) : T = !0, I(R, it - nt))) : (K.sortIndex = X, t(f, K), _ || b || (_ = !0, H())), K;
    }, e.unstable_shouldYield = V, e.unstable_wrapCallback = function(K) {
      var Q = x;
      return function() {
        var it = x;
        x = Q;
        try {
          return K.apply(this, arguments);
        } finally {
          x = it;
        }
      };
    };
  }(Qv)), Qv;
}
var BS;
function b2() {
  return BS || (BS = 1, $v.exports = JC()), $v.exports;
}
var Zv = { exports: {} }, Ra = {};
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var zS;
function t8() {
  if (zS) return Ra;
  zS = 1;
  var e = C1();
  function t(f) {
    var p = "https://react.dev/errors/" + f;
    if (1 < arguments.length) {
      p += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var g = 2; g < arguments.length; g++)
        p += "&args[]=" + encodeURIComponent(arguments[g]);
    }
    return "Minified React error #" + f + "; visit " + p + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function n() {
  }
  var i = {
    d: {
      f: n,
      r: function() {
        throw Error(t(522));
      },
      D: n,
      C: n,
      L: n,
      m: n,
      X: n,
      S: n,
      M: n
    },
    p: 0,
    findDOMNode: null
  }, s = Symbol.for("react.portal");
  function o(f, p, g) {
    var v = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
      $$typeof: s,
      key: v == null ? null : "" + v,
      children: f,
      containerInfo: p,
      implementation: g
    };
  }
  var u = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  function h(f, p) {
    if (f === "font") return "";
    if (typeof p == "string")
      return p === "use-credentials" ? p : "";
  }
  return Ra.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = i, Ra.createPortal = function(f, p) {
    var g = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!p || p.nodeType !== 1 && p.nodeType !== 9 && p.nodeType !== 11)
      throw Error(t(299));
    return o(f, p, null, g);
  }, Ra.flushSync = function(f) {
    var p = u.T, g = i.p;
    try {
      if (u.T = null, i.p = 2, f) return f();
    } finally {
      u.T = p, i.p = g, i.d.f();
    }
  }, Ra.preconnect = function(f, p) {
    typeof f == "string" && (p ? (p = p.crossOrigin, p = typeof p == "string" ? p === "use-credentials" ? p : "" : void 0) : p = null, i.d.C(f, p));
  }, Ra.prefetchDNS = function(f) {
    typeof f == "string" && i.d.D(f);
  }, Ra.preinit = function(f, p) {
    if (typeof f == "string" && p && typeof p.as == "string") {
      var g = p.as, v = h(g, p.crossOrigin), x = typeof p.integrity == "string" ? p.integrity : void 0, b = typeof p.fetchPriority == "string" ? p.fetchPriority : void 0;
      g === "style" ? i.d.S(
        f,
        typeof p.precedence == "string" ? p.precedence : void 0,
        {
          crossOrigin: v,
          integrity: x,
          fetchPriority: b
        }
      ) : g === "script" && i.d.X(f, {
        crossOrigin: v,
        integrity: x,
        fetchPriority: b,
        nonce: typeof p.nonce == "string" ? p.nonce : void 0
      });
    }
  }, Ra.preinitModule = function(f, p) {
    if (typeof f == "string")
      if (typeof p == "object" && p !== null) {
        if (p.as == null || p.as === "script") {
          var g = h(
            p.as,
            p.crossOrigin
          );
          i.d.M(f, {
            crossOrigin: g,
            integrity: typeof p.integrity == "string" ? p.integrity : void 0,
            nonce: typeof p.nonce == "string" ? p.nonce : void 0
          });
        }
      } else p == null && i.d.M(f);
  }, Ra.preload = function(f, p) {
    if (typeof f == "string" && typeof p == "object" && p !== null && typeof p.as == "string") {
      var g = p.as, v = h(g, p.crossOrigin);
      i.d.L(f, g, {
        crossOrigin: v,
        integrity: typeof p.integrity == "string" ? p.integrity : void 0,
        nonce: typeof p.nonce == "string" ? p.nonce : void 0,
        type: typeof p.type == "string" ? p.type : void 0,
        fetchPriority: typeof p.fetchPriority == "string" ? p.fetchPriority : void 0,
        referrerPolicy: typeof p.referrerPolicy == "string" ? p.referrerPolicy : void 0,
        imageSrcSet: typeof p.imageSrcSet == "string" ? p.imageSrcSet : void 0,
        imageSizes: typeof p.imageSizes == "string" ? p.imageSizes : void 0,
        media: typeof p.media == "string" ? p.media : void 0
      });
    }
  }, Ra.preloadModule = function(f, p) {
    if (typeof f == "string")
      if (p) {
        var g = h(p.as, p.crossOrigin);
        i.d.m(f, {
          as: typeof p.as == "string" && p.as !== "script" ? p.as : void 0,
          crossOrigin: g,
          integrity: typeof p.integrity == "string" ? p.integrity : void 0
        });
      } else i.d.m(f);
  }, Ra.requestFormReset = function(f) {
    i.d.r(f);
  }, Ra.unstable_batchedUpdates = function(f, p) {
    return f(p);
  }, Ra.useFormState = function(f, p, g) {
    return u.H.useFormState(f, p, g);
  }, Ra.useFormStatus = function() {
    return u.H.useHostTransitionStatus();
  }, Ra.version = "19.0.0", Ra;
}
var PS;
function u3() {
  if (PS) return Zv.exports;
  PS = 1;
  function e() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (t) {
        console.error(t);
      }
  }
  return e(), Zv.exports = t8(), Zv.exports;
}
/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var US;
function e8() {
  if (US) return dm;
  US = 1;
  var e = b2(), t = C1(), n = u3();
  function i(r) {
    var a = "https://react.dev/errors/" + r;
    if (1 < arguments.length) {
      a += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var d = 2; d < arguments.length; d++)
        a += "&args[]=" + encodeURIComponent(arguments[d]);
    }
    return "Minified React error #" + r + "; visit " + a + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function s(r) {
    return !(!r || r.nodeType !== 1 && r.nodeType !== 9 && r.nodeType !== 11);
  }
  var o = Symbol.for("react.element"), u = Symbol.for("react.transitional.element"), h = Symbol.for("react.portal"), f = Symbol.for("react.fragment"), p = Symbol.for("react.strict_mode"), g = Symbol.for("react.profiler"), v = Symbol.for("react.provider"), x = Symbol.for("react.consumer"), b = Symbol.for("react.context"), _ = Symbol.for("react.forward_ref"), T = Symbol.for("react.suspense"), A = Symbol.for("react.suspense_list"), O = Symbol.for("react.memo"), M = Symbol.for("react.lazy"), E = Symbol.for("react.offscreen"), R = Symbol.for("react.memo_cache_sentinel"), N = Symbol.iterator;
  function U(r) {
    return r === null || typeof r != "object" ? null : (r = N && r[N] || r["@@iterator"], typeof r == "function" ? r : null);
  }
  var q = Symbol.for("react.client.reference");
  function j(r) {
    if (r == null) return null;
    if (typeof r == "function")
      return r.$$typeof === q ? null : r.displayName || r.name || null;
    if (typeof r == "string") return r;
    switch (r) {
      case f:
        return "Fragment";
      case h:
        return "Portal";
      case g:
        return "Profiler";
      case p:
        return "StrictMode";
      case T:
        return "Suspense";
      case A:
        return "SuspenseList";
    }
    if (typeof r == "object")
      switch (r.$$typeof) {
        case b:
          return (r.displayName || "Context") + ".Provider";
        case x:
          return (r._context.displayName || "Context") + ".Consumer";
        case _:
          var a = r.render;
          return r = r.displayName, r || (r = a.displayName || a.name || "", r = r !== "" ? "ForwardRef(" + r + ")" : "ForwardRef"), r;
        case O:
          return a = r.displayName || null, a !== null ? a : j(r.type) || "Memo";
        case M:
          a = r._payload, r = r._init;
          try {
            return j(r(a));
          } catch {
          }
      }
    return null;
  }
  var V = t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, D = Object.assign, G, W;
  function P(r) {
    if (G === void 0)
      try {
        throw Error();
      } catch (d) {
        var a = d.stack.trim().match(/\n( *(at )?)/);
        G = a && a[1] || "", W = -1 < d.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < d.stack.indexOf("@") ? "@unknown:0:0" : "";
      }
    return `
` + G + r + W;
  }
  var H = !1;
  function I(r, a) {
    if (!r || H) return "";
    H = !0;
    var d = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      var m = {
        DetermineComponentFrameRoot: function() {
          try {
            if (a) {
              var he = function() {
                throw Error();
              };
              if (Object.defineProperty(he.prototype, "props", {
                set: function() {
                  throw Error();
                }
              }), typeof Reflect == "object" && Reflect.construct) {
                try {
                  Reflect.construct(he, []);
                } catch ($t) {
                  var qt = $t;
                }
                Reflect.construct(r, [], he);
              } else {
                try {
                  he.call();
                } catch ($t) {
                  qt = $t;
                }
                r.call(he.prototype);
              }
            } else {
              try {
                throw Error();
              } catch ($t) {
                qt = $t;
              }
              (he = r()) && typeof he.catch == "function" && he.catch(function() {
              });
            }
          } catch ($t) {
            if ($t && qt && typeof $t.stack == "string")
              return [$t.stack, qt.stack];
          }
          return [null, null];
        }
      };
      m.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var C = Object.getOwnPropertyDescriptor(
        m.DetermineComponentFrameRoot,
        "name"
      );
      C && C.configurable && Object.defineProperty(
        m.DetermineComponentFrameRoot,
        "name",
        { value: "DetermineComponentFrameRoot" }
      );
      var B = m.DetermineComponentFrameRoot(), $ = B[0], at = B[1];
      if ($ && at) {
        var pt = $.split(`
`), Mt = at.split(`
`);
        for (C = m = 0; m < pt.length && !pt[m].includes("DetermineComponentFrameRoot"); )
          m++;
        for (; C < Mt.length && !Mt[C].includes(
          "DetermineComponentFrameRoot"
        ); )
          C++;
        if (m === pt.length || C === Mt.length)
          for (m = pt.length - 1, C = Mt.length - 1; 1 <= m && 0 <= C && pt[m] !== Mt[C]; )
            C--;
        for (; 1 <= m && 0 <= C; m--, C--)
          if (pt[m] !== Mt[C]) {
            if (m !== 1 || C !== 1)
              do
                if (m--, C--, 0 > C || pt[m] !== Mt[C]) {
                  var Zt = `
` + pt[m].replace(" at new ", " at ");
                  return r.displayName && Zt.includes("<anonymous>") && (Zt = Zt.replace("<anonymous>", r.displayName)), Zt;
                }
              while (1 <= m && 0 <= C);
            break;
          }
      }
    } finally {
      H = !1, Error.prepareStackTrace = d;
    }
    return (d = r ? r.displayName || r.name : "") ? P(d) : "";
  }
  function K(r) {
    switch (r.tag) {
      case 26:
      case 27:
      case 5:
        return P(r.type);
      case 16:
        return P("Lazy");
      case 13:
        return P("Suspense");
      case 19:
        return P("SuspenseList");
      case 0:
      case 15:
        return r = I(r.type, !1), r;
      case 11:
        return r = I(r.type.render, !1), r;
      case 1:
        return r = I(r.type, !0), r;
      default:
        return "";
    }
  }
  function Q(r) {
    try {
      var a = "";
      do
        a += K(r), r = r.return;
      while (r);
      return a;
    } catch (d) {
      return `
Error generating stack: ` + d.message + `
` + d.stack;
    }
  }
  function it(r) {
    var a = r, d = r;
    if (r.alternate) for (; a.return; ) a = a.return;
    else {
      r = a;
      do
        a = r, (a.flags & 4098) !== 0 && (d = a.return), r = a.return;
      while (r);
    }
    return a.tag === 3 ? d : null;
  }
  function nt(r) {
    if (r.tag === 13) {
      var a = r.memoizedState;
      if (a === null && (r = r.alternate, r !== null && (a = r.memoizedState)), a !== null) return a.dehydrated;
    }
    return null;
  }
  function X(r) {
    if (it(r) !== r)
      throw Error(i(188));
  }
  function rt(r) {
    var a = r.alternate;
    if (!a) {
      if (a = it(r), a === null) throw Error(i(188));
      return a !== r ? null : r;
    }
    for (var d = r, m = a; ; ) {
      var C = d.return;
      if (C === null) break;
      var B = C.alternate;
      if (B === null) {
        if (m = C.return, m !== null) {
          d = m;
          continue;
        }
        break;
      }
      if (C.child === B.child) {
        for (B = C.child; B; ) {
          if (B === d) return X(C), r;
          if (B === m) return X(C), a;
          B = B.sibling;
        }
        throw Error(i(188));
      }
      if (d.return !== m.return) d = C, m = B;
      else {
        for (var $ = !1, at = C.child; at; ) {
          if (at === d) {
            $ = !0, d = C, m = B;
            break;
          }
          if (at === m) {
            $ = !0, m = C, d = B;
            break;
          }
          at = at.sibling;
        }
        if (!$) {
          for (at = B.child; at; ) {
            if (at === d) {
              $ = !0, d = B, m = C;
              break;
            }
            if (at === m) {
              $ = !0, m = B, d = C;
              break;
            }
            at = at.sibling;
          }
          if (!$) throw Error(i(189));
        }
      }
      if (d.alternate !== m) throw Error(i(190));
    }
    if (d.tag !== 3) throw Error(i(188));
    return d.stateNode.current === d ? r : a;
  }
  function vt(r) {
    var a = r.tag;
    if (a === 5 || a === 26 || a === 27 || a === 6) return r;
    for (r = r.child; r !== null; ) {
      if (a = vt(r), a !== null) return a;
      r = r.sibling;
    }
    return null;
  }
  var ct = Array.isArray, dt = n.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ht = {
    pending: !1,
    data: null,
    method: null,
    action: null
  }, Et = [], ot = -1;
  function lt(r) {
    return { current: r };
  }
  function ft(r) {
    0 > ot || (r.current = Et[ot], Et[ot] = null, ot--);
  }
  function Tt(r, a) {
    ot++, Et[ot] = r.current, r.current = a;
  }
  var Bt = lt(null), Ot = lt(null), ie = lt(null), ce = lt(null);
  function Ut(r, a) {
    switch (Tt(ie, a), Tt(Ot, r), Tt(Bt, null), r = a.nodeType, r) {
      case 9:
      case 11:
        a = (a = a.documentElement) && (a = a.namespaceURI) ? rS(a) : 0;
        break;
      default:
        if (r = r === 8 ? a.parentNode : a, a = r.tagName, r = r.namespaceURI)
          r = rS(r), a = aS(r, a);
        else
          switch (a) {
            case "svg":
              a = 1;
              break;
            case "math":
              a = 2;
              break;
            default:
              a = 0;
          }
    }
    ft(Bt), Tt(Bt, a);
  }
  function se() {
    ft(Bt), ft(Ot), ft(ie);
  }
  function re(r) {
    r.memoizedState !== null && Tt(ce, r);
    var a = Bt.current, d = aS(a, r.type);
    a !== d && (Tt(Ot, r), Tt(Bt, d));
  }
  function ue(r) {
    Ot.current === r && (ft(Bt), ft(Ot)), ce.current === r && (ft(ce), am._currentValue = ht);
  }
  var Ae = Object.prototype.hasOwnProperty, ve = e.unstable_scheduleCallback, Re = e.unstable_cancelCallback, oe = e.unstable_shouldYield, Le = e.unstable_requestPaint, De = e.unstable_now, Kt = e.unstable_getCurrentPriorityLevel, te = e.unstable_ImmediatePriority, It = e.unstable_UserBlockingPriority, Ht = e.unstable_NormalPriority, Jt = e.unstable_LowPriority, Yt = e.unstable_IdlePriority, ae = e.log, le = e.unstable_setDisableYieldValue, fe = null, Me = null;
  function Te(r) {
    if (Me && typeof Me.onCommitFiberRoot == "function")
      try {
        Me.onCommitFiberRoot(
          fe,
          r,
          void 0,
          (r.current.flags & 128) === 128
        );
      } catch {
      }
  }
  function ne(r) {
    if (typeof ae == "function" && le(r), Me && typeof Me.setStrictMode == "function")
      try {
        Me.setStrictMode(fe, r);
      } catch {
      }
  }
  var Ve = Math.clz32 ? Math.clz32 : Ce, fn = Math.log, _r = Math.LN2;
  function Ce(r) {
    return r >>>= 0, r === 0 ? 32 : 31 - (fn(r) / _r | 0) | 0;
  }
  var Xi = 128, Rn = 4194304;
  function Ze(r) {
    var a = r & 42;
    if (a !== 0) return a;
    switch (r & -r) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
        return 64;
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return r & 4194176;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return r & 62914560;
      case 67108864:
        return 67108864;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 0;
      default:
        return r;
    }
  }
  function Vr(r, a) {
    var d = r.pendingLanes;
    if (d === 0) return 0;
    var m = 0, C = r.suspendedLanes, B = r.pingedLanes, $ = r.warmLanes;
    r = r.finishedLanes !== 0;
    var at = d & 134217727;
    return at !== 0 ? (d = at & ~C, d !== 0 ? m = Ze(d) : (B &= at, B !== 0 ? m = Ze(B) : r || ($ = at & ~$, $ !== 0 && (m = Ze($))))) : (at = d & ~C, at !== 0 ? m = Ze(at) : B !== 0 ? m = Ze(B) : r || ($ = d & ~$, $ !== 0 && (m = Ze($)))), m === 0 ? 0 : a !== 0 && a !== m && (a & C) === 0 && (C = m & -m, $ = a & -a, C >= $ || C === 32 && ($ & 4194176) !== 0) ? a : m;
  }
  function Wi(r, a) {
    return (r.pendingLanes & ~(r.suspendedLanes & ~r.pingedLanes) & a) === 0;
  }
  function Sr(r, a) {
    switch (r) {
      case 1:
      case 2:
      case 4:
      case 8:
        return a + 250;
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return a + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return -1;
      case 67108864:
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function Ke() {
    var r = Xi;
    return Xi <<= 1, (Xi & 4194176) === 0 && (Xi = 128), r;
  }
  function gi() {
    var r = Rn;
    return Rn <<= 1, (Rn & 62914560) === 0 && (Rn = 4194304), r;
  }
  function va(r) {
    for (var a = [], d = 0; 31 > d; d++) a.push(r);
    return a;
  }
  function to(r, a) {
    r.pendingLanes |= a, a !== 268435456 && (r.suspendedLanes = 0, r.pingedLanes = 0, r.warmLanes = 0);
  }
  function zc(r, a, d, m, C, B) {
    var $ = r.pendingLanes;
    r.pendingLanes = d, r.suspendedLanes = 0, r.pingedLanes = 0, r.warmLanes = 0, r.expiredLanes &= d, r.entangledLanes &= d, r.errorRecoveryDisabledLanes &= d, r.shellSuspendCounter = 0;
    var at = r.entanglements, pt = r.expirationTimes, Mt = r.hiddenUpdates;
    for (d = $ & ~d; 0 < d; ) {
      var Zt = 31 - Ve(d), he = 1 << Zt;
      at[Zt] = 0, pt[Zt] = -1;
      var qt = Mt[Zt];
      if (qt !== null)
        for (Mt[Zt] = null, Zt = 0; Zt < qt.length; Zt++) {
          var $t = qt[Zt];
          $t !== null && ($t.lane &= -536870913);
        }
      d &= ~he;
    }
    m !== 0 && Fn(r, m, 0), B !== 0 && C === 0 && r.tag !== 0 && (r.suspendedLanes |= B & ~($ & ~a));
  }
  function Fn(r, a, d) {
    r.pendingLanes |= a, r.suspendedLanes &= ~a;
    var m = 31 - Ve(a);
    r.entangledLanes |= a, r.entanglements[m] = r.entanglements[m] | 1073741824 | d & 4194218;
  }
  function Ci(r, a) {
    var d = r.entangledLanes |= a;
    for (r = r.entanglements; d; ) {
      var m = 31 - Ve(d), C = 1 << m;
      C & a | r[m] & a && (r[m] |= a), d &= ~C;
    }
  }
  function Es(r) {
    return r &= -r, 2 < r ? 8 < r ? (r & 134217727) !== 0 ? 32 : 268435456 : 8 : 2;
  }
  function wl() {
    var r = dt.p;
    return r !== 0 ? r : (r = window.event, r === void 0 ? 32 : TS(r.type));
  }
  function Pa(r, a) {
    var d = dt.p;
    try {
      return dt.p = r, a();
    } finally {
      dt.p = d;
    }
  }
  var zi = Math.random().toString(36).slice(2), Pi = "__reactFiber$" + zi, rn = "__reactProps$" + zi, ea = "__reactContainer$" + zi, ba = "__reactEvents$" + zi, Pc = "__reactListeners$" + zi, Gh = "__reactHandles$" + zi, As = "__reactResources$" + zi, eo = "__reactMarker$" + zi;
  function Ua(r) {
    delete r[Pi], delete r[rn], delete r[ba], delete r[Pc], delete r[Gh];
  }
  function ts(r) {
    var a = r[Pi];
    if (a) return a;
    for (var d = r.parentNode; d; ) {
      if (a = d[ea] || d[Pi]) {
        if (d = a.alternate, a.child !== null || d !== null && d.child !== null)
          for (r = lS(r); r !== null; ) {
            if (d = r[Pi]) return d;
            r = lS(r);
          }
        return a;
      }
      r = d, d = r.parentNode;
    }
    return null;
  }
  function wi(r) {
    if (r = r[Pi] || r[ea]) {
      var a = r.tag;
      if (a === 5 || a === 6 || a === 13 || a === 26 || a === 27 || a === 3)
        return r;
    }
    return null;
  }
  function $e(r) {
    var a = r.tag;
    if (a === 5 || a === 26 || a === 27 || a === 6) return r.stateNode;
    throw Error(i(33));
  }
  function xr(r) {
    var a = r[As];
    return a || (a = r[As] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() }), a;
  }
  function Pn(r) {
    r[eo] = !0;
  }
  var Uc = /* @__PURE__ */ new Set(), kr = {};
  function na(r, a) {
    es(r, a), es(r + "Capture", a);
  }
  function es(r, a) {
    for (kr[r] = a, r = 0; r < a.length; r++)
      Uc.add(a[r]);
  }
  var ia = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), no = RegExp(
    "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
  ), Fu = {}, El = {};
  function Gd(r) {
    return Ae.call(El, r) ? !0 : Ae.call(Fu, r) ? !1 : no.test(r) ? El[r] = !0 : (Fu[r] = !0, !1);
  }
  function ln(r, a, d) {
    if (Gd(a))
      if (d === null) r.removeAttribute(a);
      else {
        switch (typeof d) {
          case "undefined":
          case "function":
          case "symbol":
            r.removeAttribute(a);
            return;
          case "boolean":
            var m = a.toLowerCase().slice(0, 5);
            if (m !== "data-" && m !== "aria-") {
              r.removeAttribute(a);
              return;
            }
        }
        r.setAttribute(a, "" + d);
      }
  }
  function Al(r, a, d) {
    if (d === null) r.removeAttribute(a);
    else {
      switch (typeof d) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          r.removeAttribute(a);
          return;
      }
      r.setAttribute(a, "" + d);
    }
  }
  function _a(r, a, d, m) {
    if (m === null) r.removeAttribute(d);
    else {
      switch (typeof m) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          r.removeAttribute(d);
          return;
      }
      r.setAttributeNS(a, d, "" + m);
    }
  }
  function Ir(r) {
    switch (typeof r) {
      case "bigint":
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return r;
      case "object":
        return r;
      default:
        return "";
    }
  }
  function Yn(r) {
    var a = r.type;
    return (r = r.nodeName) && r.toLowerCase() === "input" && (a === "checkbox" || a === "radio");
  }
  function Ml(r) {
    var a = Yn(r) ? "checked" : "value", d = Object.getOwnPropertyDescriptor(
      r.constructor.prototype,
      a
    ), m = "" + r[a];
    if (!r.hasOwnProperty(a) && typeof d < "u" && typeof d.get == "function" && typeof d.set == "function") {
      var C = d.get, B = d.set;
      return Object.defineProperty(r, a, {
        configurable: !0,
        get: function() {
          return C.call(this);
        },
        set: function($) {
          m = "" + $, B.call(this, $);
        }
      }), Object.defineProperty(r, a, {
        enumerable: d.enumerable
      }), {
        getValue: function() {
          return m;
        },
        setValue: function($) {
          m = "" + $;
        },
        stopTracking: function() {
          r._valueTracker = null, delete r[a];
        }
      };
    }
  }
  function Ms(r) {
    r._valueTracker || (r._valueTracker = Ml(r));
  }
  function io(r) {
    if (!r) return !1;
    var a = r._valueTracker;
    if (!a) return !0;
    var d = a.getValue(), m = "";
    return r && (m = Yn(r) ? r.checked ? "true" : "false" : r.value), r = m, r !== d ? (a.setValue(r), !0) : !1;
  }
  function ro(r) {
    if (r = r || (typeof document < "u" ? document : void 0), typeof r > "u") return null;
    try {
      return r.activeElement || r.body;
    } catch {
      return r.body;
    }
  }
  var qu = /[\n"\\]/g;
  function Tr(r) {
    return r.replace(
      qu,
      function(a) {
        return "\\" + a.charCodeAt(0).toString(16) + " ";
      }
    );
  }
  function jc(r, a, d, m, C, B, $, at) {
    r.name = "", $ != null && typeof $ != "function" && typeof $ != "symbol" && typeof $ != "boolean" ? r.type = $ : r.removeAttribute("type"), a != null ? $ === "number" ? (a === 0 && r.value === "" || r.value != a) && (r.value = "" + Ir(a)) : r.value !== "" + Ir(a) && (r.value = "" + Ir(a)) : $ !== "submit" && $ !== "reset" || r.removeAttribute("value"), a != null ? Lc(r, $, Ir(a)) : d != null ? Lc(r, $, Ir(d)) : m != null && r.removeAttribute("value"), C == null && B != null && (r.defaultChecked = !!B), C != null && (r.checked = C && typeof C != "function" && typeof C != "symbol"), at != null && typeof at != "function" && typeof at != "symbol" && typeof at != "boolean" ? r.name = "" + Ir(at) : r.removeAttribute("name");
  }
  function Rl(r, a, d, m, C, B, $, at) {
    if (B != null && typeof B != "function" && typeof B != "symbol" && typeof B != "boolean" && (r.type = B), a != null || d != null) {
      if (!(B !== "submit" && B !== "reset" || a != null))
        return;
      d = d != null ? "" + Ir(d) : "", a = a != null ? "" + Ir(a) : d, at || a === r.value || (r.value = a), r.defaultValue = a;
    }
    m = m ?? C, m = typeof m != "function" && typeof m != "symbol" && !!m, r.checked = at ? r.checked : !!m, r.defaultChecked = !!m, $ != null && typeof $ != "function" && typeof $ != "symbol" && typeof $ != "boolean" && (r.name = $);
  }
  function Lc(r, a, d) {
    a === "number" && ro(r.ownerDocument) === r || r.defaultValue === "" + d || (r.defaultValue = "" + d);
  }
  function ns(r, a, d, m) {
    if (r = r.options, a) {
      a = {};
      for (var C = 0; C < d.length; C++)
        a["$" + d[C]] = !0;
      for (d = 0; d < r.length; d++)
        C = a.hasOwnProperty("$" + r[d].value), r[d].selected !== C && (r[d].selected = C), C && m && (r[d].defaultSelected = !0);
    } else {
      for (d = "" + Ir(d), a = null, C = 0; C < r.length; C++) {
        if (r[C].value === d) {
          r[C].selected = !0, m && (r[C].defaultSelected = !0);
          return;
        }
        a !== null || r[C].disabled || (a = r[C]);
      }
      a !== null && (a.selected = !0);
    }
  }
  function Gu(r, a, d) {
    if (a != null && (a = "" + Ir(a), a !== r.value && (r.value = a), d == null)) {
      r.defaultValue !== a && (r.defaultValue = a);
      return;
    }
    r.defaultValue = d != null ? "" + Ir(d) : "";
  }
  function Uo(r, a, d, m) {
    if (a == null) {
      if (m != null) {
        if (d != null) throw Error(i(92));
        if (ct(m)) {
          if (1 < m.length) throw Error(i(93));
          m = m[0];
        }
        d = m;
      }
      d == null && (d = ""), a = d;
    }
    d = Ir(a), r.defaultValue = d, m = r.textContent, m === d && m !== "" && m !== null && (r.value = m);
  }
  function cn(r, a) {
    if (a) {
      var d = r.firstChild;
      if (d && d === r.lastChild && d.nodeType === 3) {
        d.nodeValue = a;
        return;
      }
    }
    r.textContent = a;
  }
  var Ol = new Set(
    "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
      " "
    )
  );
  function Vc(r, a, d) {
    var m = a.indexOf("--") === 0;
    d == null || typeof d == "boolean" || d === "" ? m ? r.setProperty(a, "") : a === "float" ? r.cssFloat = "" : r[a] = "" : m ? r.setProperty(a, d) : typeof d != "number" || d === 0 || Ol.has(a) ? a === "float" ? r.cssFloat = d : r[a] = ("" + d).trim() : r[a] = d + "px";
  }
  function Hd(r, a, d) {
    if (a != null && typeof a != "object")
      throw Error(i(62));
    if (r = r.style, d != null) {
      for (var m in d)
        !d.hasOwnProperty(m) || a != null && a.hasOwnProperty(m) || (m.indexOf("--") === 0 ? r.setProperty(m, "") : m === "float" ? r.cssFloat = "" : r[m] = "");
      for (var C in a)
        m = a[C], a.hasOwnProperty(C) && d[C] !== m && Vc(r, C, m);
    } else
      for (var B in a)
        a.hasOwnProperty(B) && Vc(r, B, a[B]);
  }
  function cr(r) {
    if (r.indexOf("-") === -1) return !1;
    switch (r) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var jo = /* @__PURE__ */ new Map([
    ["acceptCharset", "accept-charset"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"],
    ["crossOrigin", "crossorigin"],
    ["accentHeight", "accent-height"],
    ["alignmentBaseline", "alignment-baseline"],
    ["arabicForm", "arabic-form"],
    ["baselineShift", "baseline-shift"],
    ["capHeight", "cap-height"],
    ["clipPath", "clip-path"],
    ["clipRule", "clip-rule"],
    ["colorInterpolation", "color-interpolation"],
    ["colorInterpolationFilters", "color-interpolation-filters"],
    ["colorProfile", "color-profile"],
    ["colorRendering", "color-rendering"],
    ["dominantBaseline", "dominant-baseline"],
    ["enableBackground", "enable-background"],
    ["fillOpacity", "fill-opacity"],
    ["fillRule", "fill-rule"],
    ["floodColor", "flood-color"],
    ["floodOpacity", "flood-opacity"],
    ["fontFamily", "font-family"],
    ["fontSize", "font-size"],
    ["fontSizeAdjust", "font-size-adjust"],
    ["fontStretch", "font-stretch"],
    ["fontStyle", "font-style"],
    ["fontVariant", "font-variant"],
    ["fontWeight", "font-weight"],
    ["glyphName", "glyph-name"],
    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
    ["glyphOrientationVertical", "glyph-orientation-vertical"],
    ["horizAdvX", "horiz-adv-x"],
    ["horizOriginX", "horiz-origin-x"],
    ["imageRendering", "image-rendering"],
    ["letterSpacing", "letter-spacing"],
    ["lightingColor", "lighting-color"],
    ["markerEnd", "marker-end"],
    ["markerMid", "marker-mid"],
    ["markerStart", "marker-start"],
    ["overlinePosition", "overline-position"],
    ["overlineThickness", "overline-thickness"],
    ["paintOrder", "paint-order"],
    ["panose-1", "panose-1"],
    ["pointerEvents", "pointer-events"],
    ["renderingIntent", "rendering-intent"],
    ["shapeRendering", "shape-rendering"],
    ["stopColor", "stop-color"],
    ["stopOpacity", "stop-opacity"],
    ["strikethroughPosition", "strikethrough-position"],
    ["strikethroughThickness", "strikethrough-thickness"],
    ["strokeDasharray", "stroke-dasharray"],
    ["strokeDashoffset", "stroke-dashoffset"],
    ["strokeLinecap", "stroke-linecap"],
    ["strokeLinejoin", "stroke-linejoin"],
    ["strokeMiterlimit", "stroke-miterlimit"],
    ["strokeOpacity", "stroke-opacity"],
    ["strokeWidth", "stroke-width"],
    ["textAnchor", "text-anchor"],
    ["textDecoration", "text-decoration"],
    ["textRendering", "text-rendering"],
    ["transformOrigin", "transform-origin"],
    ["underlinePosition", "underline-position"],
    ["underlineThickness", "underline-thickness"],
    ["unicodeBidi", "unicode-bidi"],
    ["unicodeRange", "unicode-range"],
    ["unitsPerEm", "units-per-em"],
    ["vAlphabetic", "v-alphabetic"],
    ["vHanging", "v-hanging"],
    ["vIdeographic", "v-ideographic"],
    ["vMathematical", "v-mathematical"],
    ["vectorEffect", "vector-effect"],
    ["vertAdvY", "vert-adv-y"],
    ["vertOriginX", "vert-origin-x"],
    ["vertOriginY", "vert-origin-y"],
    ["wordSpacing", "word-spacing"],
    ["writingMode", "writing-mode"],
    ["xmlnsXlink", "xmlns:xlink"],
    ["xHeight", "x-height"]
  ]), Ic = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
  function Sa(r) {
    return Ic.test("" + r) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : r;
  }
  var Fc = null;
  function Nl(r) {
    return r = r.target || r.srcElement || window, r.correspondingUseElement && (r = r.correspondingUseElement), r.nodeType === 3 ? r.parentNode : r;
  }
  var ni = null, Cr = null;
  function ao(r) {
    var a = wi(r);
    if (a && (r = a.stateNode)) {
      var d = r[rn] || null;
      t: switch (r = a.stateNode, a.type) {
        case "input":
          if (jc(
            r,
            d.value,
            d.defaultValue,
            d.defaultValue,
            d.checked,
            d.defaultChecked,
            d.type,
            d.name
          ), a = d.name, d.type === "radio" && a != null) {
            for (d = r; d.parentNode; ) d = d.parentNode;
            for (d = d.querySelectorAll(
              'input[name="' + Tr(
                "" + a
              ) + '"][type="radio"]'
            ), a = 0; a < d.length; a++) {
              var m = d[a];
              if (m !== r && m.form === r.form) {
                var C = m[rn] || null;
                if (!C) throw Error(i(90));
                jc(
                  m,
                  C.value,
                  C.defaultValue,
                  C.defaultValue,
                  C.checked,
                  C.defaultChecked,
                  C.type,
                  C.name
                );
              }
            }
            for (a = 0; a < d.length; a++)
              m = d[a], m.form === r.form && io(m);
          }
          break t;
        case "textarea":
          Gu(r, d.value, d.defaultValue);
          break t;
        case "select":
          a = d.value, a != null && ns(r, !!d.multiple, a, !1);
      }
    }
  }
  var so = !1;
  function qc(r, a, d) {
    if (so) return r(a, d);
    so = !0;
    try {
      var m = r(a);
      return m;
    } finally {
      if (so = !1, (ni !== null || Cr !== null) && (_u(), ni && (a = ni, r = Cr, Cr = ni = null, ao(a), r)))
        for (a = 0; a < r.length; a++) ao(r[a]);
    }
  }
  function ra(r, a) {
    var d = r.stateNode;
    if (d === null) return null;
    var m = d[rn] || null;
    if (m === null) return null;
    d = m[a];
    t: switch (a) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (m = !m.disabled) || (r = r.type, m = !(r === "button" || r === "input" || r === "select" || r === "textarea")), r = !m;
        break t;
      default:
        r = !1;
    }
    if (r) return null;
    if (d && typeof d != "function")
      throw Error(
        i(231, a, typeof d)
      );
    return d;
  }
  var Gc = !1;
  if (ia)
    try {
      var Dr = {};
      Object.defineProperty(Dr, "passive", {
        get: function() {
          Gc = !0;
        }
      }), window.addEventListener("test", Dr, Dr), window.removeEventListener("test", Dr, Dr);
    } catch {
      Gc = !1;
    }
  var ja = null, Hu = null, kl = null;
  function Lo() {
    if (kl) return kl;
    var r, a = Hu, d = a.length, m, C = "value" in ja ? ja.value : ja.textContent, B = C.length;
    for (r = 0; r < d && a[r] === C[r]; r++) ;
    var $ = d - r;
    for (m = 1; m <= $ && a[d - m] === C[B - m]; m++) ;
    return kl = C.slice(r, 1 < m ? 1 - m : void 0);
  }
  function is(r) {
    var a = r.keyCode;
    return "charCode" in r ? (r = r.charCode, r === 0 && a === 13 && (r = 13)) : r = a, r === 10 && (r = 13), 32 <= r || r === 13 ? r : 0;
  }
  function Vo() {
    return !0;
  }
  function Hc() {
    return !1;
  }
  function Ui(r) {
    function a(d, m, C, B, $) {
      this._reactName = d, this._targetInst = C, this.type = m, this.nativeEvent = B, this.target = $, this.currentTarget = null;
      for (var at in r)
        r.hasOwnProperty(at) && (d = r[at], this[at] = d ? d(B) : B[at]);
      return this.isDefaultPrevented = (B.defaultPrevented != null ? B.defaultPrevented : B.returnValue === !1) ? Vo : Hc, this.isPropagationStopped = Hc, this;
    }
    return D(a.prototype, {
      preventDefault: function() {
        this.defaultPrevented = !0;
        var d = this.nativeEvent;
        d && (d.preventDefault ? d.preventDefault() : typeof d.returnValue != "unknown" && (d.returnValue = !1), this.isDefaultPrevented = Vo);
      },
      stopPropagation: function() {
        var d = this.nativeEvent;
        d && (d.stopPropagation ? d.stopPropagation() : typeof d.cancelBubble != "unknown" && (d.cancelBubble = !0), this.isPropagationStopped = Vo);
      },
      persist: function() {
      },
      isPersistent: Vo
    }), a;
  }
  var oo = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(r) {
      return r.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  }, Dl = Ui(oo), Rs = D({}, oo, { view: 0, detail: 0 }), Kc = Ui(Rs), La, Bl, zl, Pl = D({}, Rs, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: Os,
    button: 0,
    buttons: 0,
    relatedTarget: function(r) {
      return r.relatedTarget === void 0 ? r.fromElement === r.srcElement ? r.toElement : r.fromElement : r.relatedTarget;
    },
    movementX: function(r) {
      return "movementX" in r ? r.movementX : (r !== zl && (zl && r.type === "mousemove" ? (La = r.screenX - zl.screenX, Bl = r.screenY - zl.screenY) : Bl = La = 0, zl = r), La);
    },
    movementY: function(r) {
      return "movementY" in r ? r.movementY : Bl;
    }
  }), Yc = Ui(Pl), Ku = D({}, Pl, { dataTransfer: 0 }), Hh = Ui(Ku), Oi = D({}, Rs, { relatedTarget: 0 }), Io = Ui(Oi), Xc = D({}, oo, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), Kd = Ui(Xc), Kh = D({}, oo, {
    clipboardData: function(r) {
      return "clipboardData" in r ? r.clipboardData : window.clipboardData;
    }
  }), Wc = Ui(Kh), Fo = D({}, oo, { data: 0 }), Ul = Ui(Fo), Yu = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, Xu = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, ur = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };
  function qo(r) {
    var a = this.nativeEvent;
    return a.getModifierState ? a.getModifierState(r) : (r = ur[r]) ? !!a[r] : !1;
  }
  function Os() {
    return qo;
  }
  var Yd = D({}, Rs, {
    key: function(r) {
      if (r.key) {
        var a = Yu[r.key] || r.key;
        if (a !== "Unidentified") return a;
      }
      return r.type === "keypress" ? (r = is(r), r === 13 ? "Enter" : String.fromCharCode(r)) : r.type === "keydown" || r.type === "keyup" ? Xu[r.keyCode] || "Unidentified" : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: Os,
    charCode: function(r) {
      return r.type === "keypress" ? is(r) : 0;
    },
    keyCode: function(r) {
      return r.type === "keydown" || r.type === "keyup" ? r.keyCode : 0;
    },
    which: function(r) {
      return r.type === "keypress" ? is(r) : r.type === "keydown" || r.type === "keyup" ? r.keyCode : 0;
    }
  }), jl = Ui(Yd), Wu = D({}, Pl, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }), $c = Ui(Wu), Qc = D({}, Rs, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: Os
  }), Zc = Ui(Qc), lo = D({}, oo, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), Va = Ui(lo), Jc = D({}, Pl, {
    deltaX: function(r) {
      return "deltaX" in r ? r.deltaX : "wheelDeltaX" in r ? -r.wheelDeltaX : 0;
    },
    deltaY: function(r) {
      return "deltaY" in r ? r.deltaY : "wheelDeltaY" in r ? -r.wheelDeltaY : "wheelDelta" in r ? -r.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), $u = Ui(Jc), Qu = D({}, oo, {
    newState: 0,
    oldState: 0
  }), Ns = Ui(Qu), ks = [9, 13, 27, 32], Go = ia && "CompositionEvent" in window, rs = null;
  ia && "documentMode" in document && (rs = document.documentMode);
  var tu = ia && "TextEvent" in window && !rs, Ho = ia && (!Go || rs && 8 < rs && 11 >= rs), as = " ", dr = !1;
  function Ll(r, a) {
    switch (r) {
      case "keyup":
        return ks.indexOf(a.keyCode) !== -1;
      case "keydown":
        return a.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function Xd(r) {
    return r = r.detail, typeof r == "object" && "data" in r ? r.data : null;
  }
  var Ds = !1;
  function Vl(r, a) {
    switch (r) {
      case "compositionend":
        return Xd(a);
      case "keypress":
        return a.which !== 32 ? null : (dr = !0, as);
      case "textInput":
        return r = a.data, r === as && dr ? null : r;
      default:
        return null;
    }
  }
  function Wd(r, a) {
    if (Ds)
      return r === "compositionend" || !Go && Ll(r, a) ? (r = Lo(), kl = Hu = ja = null, Ds = !1, r) : null;
    switch (r) {
      case "paste":
        return null;
      case "keypress":
        if (!(a.ctrlKey || a.altKey || a.metaKey) || a.ctrlKey && a.altKey) {
          if (a.char && 1 < a.char.length)
            return a.char;
          if (a.which) return String.fromCharCode(a.which);
        }
        return null;
      case "compositionend":
        return Ho && a.locale !== "ko" ? null : a.data;
      default:
        return null;
    }
  }
  var eu = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
  };
  function nu(r) {
    var a = r && r.nodeName && r.nodeName.toLowerCase();
    return a === "input" ? !!eu[r.type] : a === "textarea";
  }
  function Br(r, a, d, m) {
    ni ? Cr ? Cr.push(m) : Cr = [m] : ni = m, a = ey(a, "onChange"), 0 < a.length && (d = new Dl(
      "onChange",
      "change",
      null,
      d,
      m
    ), r.push({ event: d, listeners: a }));
  }
  var Ko = null, Yo = null;
  function Yh(r) {
    J_(r, 0);
  }
  function iu(r) {
    var a = $e(r);
    if (io(a)) return r;
  }
  function Xo(r, a) {
    if (r === "change") return a;
  }
  var xa = !1;
  if (ia) {
    var ii;
    if (ia) {
      var Bs = "oninput" in document;
      if (!Bs) {
        var hr = document.createElement("div");
        hr.setAttribute("oninput", "return;"), Bs = typeof hr.oninput == "function";
      }
      ii = Bs;
    } else ii = !1;
    xa = ii && (!document.documentMode || 9 < document.documentMode);
  }
  function ri() {
    Ko && (Ko.detachEvent("onpropertychange", Zu), Yo = Ko = null);
  }
  function Zu(r) {
    if (r.propertyName === "value" && iu(Yo)) {
      var a = [];
      Br(
        a,
        Yo,
        r,
        Nl(r)
      ), qc(Yh, a);
    }
  }
  function Xh(r, a, d) {
    r === "focusin" ? (ri(), Ko = a, Yo = d, Ko.attachEvent("onpropertychange", Zu)) : r === "focusout" && ri();
  }
  function co(r) {
    if (r === "selectionchange" || r === "keyup" || r === "keydown")
      return iu(Yo);
  }
  function Wo(r, a) {
    if (r === "click") return iu(a);
  }
  function aa(r, a) {
    if (r === "input" || r === "change")
      return iu(a);
  }
  function zs(r, a) {
    return r === a && (r !== 0 || 1 / r === 1 / a) || r !== r && a !== a;
  }
  var zr = typeof Object.is == "function" ? Object.is : zs;
  function S(r, a) {
    if (zr(r, a)) return !0;
    if (typeof r != "object" || r === null || typeof a != "object" || a === null)
      return !1;
    var d = Object.keys(r), m = Object.keys(a);
    if (d.length !== m.length) return !1;
    for (m = 0; m < d.length; m++) {
      var C = d[m];
      if (!Ae.call(a, C) || !zr(r[C], a[C]))
        return !1;
    }
    return !0;
  }
  function k(r) {
    for (; r && r.firstChild; ) r = r.firstChild;
    return r;
  }
  function L(r, a) {
    var d = k(r);
    r = 0;
    for (var m; d; ) {
      if (d.nodeType === 3) {
        if (m = r + d.textContent.length, r <= a && m >= a)
          return { node: d, offset: a - r };
        r = m;
      }
      t: {
        for (; d; ) {
          if (d.nextSibling) {
            d = d.nextSibling;
            break t;
          }
          d = d.parentNode;
        }
        d = void 0;
      }
      d = k(d);
    }
  }
  function Y(r, a) {
    return r && a ? r === a ? !0 : r && r.nodeType === 3 ? !1 : a && a.nodeType === 3 ? Y(r, a.parentNode) : "contains" in r ? r.contains(a) : r.compareDocumentPosition ? !!(r.compareDocumentPosition(a) & 16) : !1 : !1;
  }
  function Z(r) {
    r = r != null && r.ownerDocument != null && r.ownerDocument.defaultView != null ? r.ownerDocument.defaultView : window;
    for (var a = ro(r.document); a instanceof r.HTMLIFrameElement; ) {
      try {
        var d = typeof a.contentWindow.location.href == "string";
      } catch {
        d = !1;
      }
      if (d) r = a.contentWindow;
      else break;
      a = ro(r.document);
    }
    return a;
  }
  function et(r) {
    var a = r && r.nodeName && r.nodeName.toLowerCase();
    return a && (a === "input" && (r.type === "text" || r.type === "search" || r.type === "tel" || r.type === "url" || r.type === "password") || a === "textarea" || r.contentEditable === "true");
  }
  function ut(r, a) {
    var d = Z(a);
    a = r.focusedElem;
    var m = r.selectionRange;
    if (d !== a && a && a.ownerDocument && Y(a.ownerDocument.documentElement, a)) {
      if (m !== null && et(a)) {
        if (r = m.start, d = m.end, d === void 0 && (d = r), "selectionStart" in a)
          a.selectionStart = r, a.selectionEnd = Math.min(
            d,
            a.value.length
          );
        else if (d = (r = a.ownerDocument || document) && r.defaultView || window, d.getSelection) {
          d = d.getSelection();
          var C = a.textContent.length, B = Math.min(m.start, C);
          m = m.end === void 0 ? B : Math.min(m.end, C), !d.extend && B > m && (C = m, m = B, B = C), C = L(a, B);
          var $ = L(
            a,
            m
          );
          C && $ && (d.rangeCount !== 1 || d.anchorNode !== C.node || d.anchorOffset !== C.offset || d.focusNode !== $.node || d.focusOffset !== $.offset) && (r = r.createRange(), r.setStart(C.node, C.offset), d.removeAllRanges(), B > m ? (d.addRange(r), d.extend($.node, $.offset)) : (r.setEnd(
            $.node,
            $.offset
          ), d.addRange(r)));
        }
      }
      for (r = [], d = a; d = d.parentNode; )
        d.nodeType === 1 && r.push({
          element: d,
          left: d.scrollLeft,
          top: d.scrollTop
        });
      for (typeof a.focus == "function" && a.focus(), a = 0; a < r.length; a++)
        d = r[a], d.element.scrollLeft = d.left, d.element.scrollTop = d.top;
    }
  }
  var mt = ia && "documentMode" in document && 11 >= document.documentMode, bt = null, St = null, At = null, gt = !1;
  function Rt(r, a, d) {
    var m = d.window === d ? d.document : d.nodeType === 9 ? d : d.ownerDocument;
    gt || bt == null || bt !== ro(m) || (m = bt, "selectionStart" in m && et(m) ? m = { start: m.selectionStart, end: m.selectionEnd } : (m = (m.ownerDocument && m.ownerDocument.defaultView || window).getSelection(), m = {
      anchorNode: m.anchorNode,
      anchorOffset: m.anchorOffset,
      focusNode: m.focusNode,
      focusOffset: m.focusOffset
    }), At && S(At, m) || (At = m, m = ey(St, "onSelect"), 0 < m.length && (a = new Dl(
      "onSelect",
      "select",
      null,
      a,
      d
    ), r.push({ event: a, listeners: m }), a.target = bt)));
  }
  function _t(r, a) {
    var d = {};
    return d[r.toLowerCase()] = a.toLowerCase(), d["Webkit" + r] = "webkit" + a, d["Moz" + r] = "moz" + a, d;
  }
  var wt = {
    animationend: _t("Animation", "AnimationEnd"),
    animationiteration: _t("Animation", "AnimationIteration"),
    animationstart: _t("Animation", "AnimationStart"),
    transitionrun: _t("Transition", "TransitionRun"),
    transitionstart: _t("Transition", "TransitionStart"),
    transitioncancel: _t("Transition", "TransitionCancel"),
    transitionend: _t("Transition", "TransitionEnd")
  }, Nt = {}, xt = {};
  ia && (xt = document.createElement("div").style, "AnimationEvent" in window || (delete wt.animationend.animation, delete wt.animationiteration.animation, delete wt.animationstart.animation), "TransitionEvent" in window || delete wt.transitionend.transition);
  function Dt(r) {
    if (Nt[r]) return Nt[r];
    if (!wt[r]) return r;
    var a = wt[r], d;
    for (d in a)
      if (a.hasOwnProperty(d) && d in xt)
        return Nt[r] = a[d];
    return r;
  }
  var Ft = Dt("animationend"), Lt = Dt("animationiteration"), Xt = Dt("animationstart"), de = Dt("transitionrun"), Se = Dt("transitionstart"), pe = Dt("transitioncancel"), _e = Dt("transitionend"), we = /* @__PURE__ */ new Map(), be = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll scrollEnd toggle touchMove waiting wheel".split(
    " "
  );
  function Ee(r, a) {
    we.set(r, a), na(a, [r]);
  }
  var Be = [], qe = 0, Ye = 0;
  function fr() {
    for (var r = qe, a = Ye = qe = 0; a < r; ) {
      var d = Be[a];
      Be[a++] = null;
      var m = Be[a];
      Be[a++] = null;
      var C = Be[a];
      Be[a++] = null;
      var B = Be[a];
      if (Be[a++] = null, m !== null && C !== null) {
        var $ = m.pending;
        $ === null ? C.next = C : (C.next = $.next, $.next = C), m.pending = C;
      }
      B !== 0 && uo(d, C, B);
    }
  }
  function Ge(r, a, d, m) {
    Be[qe++] = r, Be[qe++] = a, Be[qe++] = d, Be[qe++] = m, Ye |= m, r.lanes |= m, r = r.alternate, r !== null && (r.lanes |= m);
  }
  function yi(r, a, d, m) {
    return Ge(r, a, d, m), ji(r);
  }
  function ai(r, a) {
    return Ge(r, null, null, a), ji(r);
  }
  function uo(r, a, d) {
    r.lanes |= d;
    var m = r.alternate;
    m !== null && (m.lanes |= d);
    for (var C = !1, B = r.return; B !== null; )
      B.childLanes |= d, m = B.alternate, m !== null && (m.childLanes |= d), B.tag === 22 && (r = B.stateNode, r === null || r._visibility & 1 || (C = !0)), r = B, B = B.return;
    C && a !== null && r.tag === 3 && (B = r.stateNode, C = 31 - Ve(d), B = B.hiddenUpdates, r = B[C], r === null ? B[C] = [a] : r.push(a), a.lane = d | 536870912);
  }
  function ji(r) {
    if (50 < ms)
      throw ms = 0, gl = null, Error(i(185));
    for (var a = r.return; a !== null; )
      r = a, a = r.return;
    return r.tag === 3 ? r.stateNode : null;
  }
  var Fr = {}, Il = /* @__PURE__ */ new WeakMap();
  function Ta(r, a) {
    if (typeof r == "object" && r !== null) {
      var d = Il.get(r);
      return d !== void 0 ? d : (a = {
        value: r,
        source: a,
        stack: Q(a)
      }, Il.set(r, a), a);
    }
    return {
      value: r,
      source: a,
      stack: Q(a)
    };
  }
  var ru = [], Fl = 0, qr = null, $d = 0, si = [], Ia = 0, $o = null, ho = 1, Qo = "";
  function sa(r, a) {
    ru[Fl++] = $d, ru[Fl++] = qr, qr = r, $d = a;
  }
  function _p(r, a, d) {
    si[Ia++] = ho, si[Ia++] = Qo, si[Ia++] = $o, $o = r;
    var m = ho;
    r = Qo;
    var C = 32 - Ve(m) - 1;
    m &= ~(1 << C), d += 1;
    var B = 32 - Ve(a) + C;
    if (30 < B) {
      var $ = C - C % 5;
      B = (m & (1 << $) - 1).toString(32), m >>= $, C -= $, ho = 1 << 32 - Ve(a) + C | d << C | m, Qo = B + r;
    } else
      ho = 1 << B | d << C | m, Qo = r;
  }
  function Qd(r) {
    r.return !== null && (sa(r, 1), _p(r, 1, 0));
  }
  function ql(r) {
    for (; r === qr; )
      qr = ru[--Fl], ru[Fl] = null, $d = ru[--Fl], ru[Fl] = null;
    for (; r === $o; )
      $o = si[--Ia], si[Ia] = null, Qo = si[--Ia], si[Ia] = null, ho = si[--Ia], si[Ia] = null;
  }
  var Gr = null, wr = null, On = !1, ss = null, os = !1, Zd = Error(i(519));
  function au(r) {
    var a = Error(i(418, ""));
    throw fo(Ta(a, r)), Zd;
  }
  function s0(r) {
    var a = r.stateNode, d = r.type, m = r.memoizedProps;
    switch (a[Pi] = r, a[rn] = m, d) {
      case "dialog":
        kn("cancel", a), kn("close", a);
        break;
      case "iframe":
      case "object":
      case "embed":
        kn("load", a);
        break;
      case "video":
      case "audio":
        for (d = 0; d < tm.length; d++)
          kn(tm[d], a);
        break;
      case "source":
        kn("error", a);
        break;
      case "img":
      case "image":
      case "link":
        kn("error", a), kn("load", a);
        break;
      case "details":
        kn("toggle", a);
        break;
      case "input":
        kn("invalid", a), Rl(
          a,
          m.value,
          m.defaultValue,
          m.checked,
          m.defaultChecked,
          m.type,
          m.name,
          !0
        ), Ms(a);
        break;
      case "select":
        kn("invalid", a);
        break;
      case "textarea":
        kn("invalid", a), Uo(a, m.value, m.defaultValue, m.children), Ms(a);
    }
    d = m.children, typeof d != "string" && typeof d != "number" && typeof d != "bigint" || a.textContent === "" + d || m.suppressHydrationWarning === !0 || iS(a.textContent, d) ? (m.popover != null && (kn("beforetoggle", a), kn("toggle", a)), m.onScroll != null && kn("scroll", a), m.onScrollEnd != null && kn("scrollend", a), m.onClick != null && (a.onclick = ny), a = !0) : a = !1, a || au(r);
  }
  function o0(r) {
    for (Gr = r.return; Gr; )
      switch (Gr.tag) {
        case 3:
        case 27:
          os = !0;
          return;
        case 5:
        case 13:
          os = !1;
          return;
        default:
          Gr = Gr.return;
      }
  }
  function Ju(r) {
    if (r !== Gr) return !1;
    if (!On) return o0(r), On = !0, !1;
    var a = !1, d;
    if ((d = r.tag !== 3 && r.tag !== 27) && ((d = r.tag === 5) && (d = r.type, d = !(d !== "form" && d !== "button") || Bv(r.type, r.memoizedProps)), d = !d), d && (a = !0), a && wr && au(r), o0(r), r.tag === 13) {
      if (r = r.memoizedState, r = r !== null ? r.dehydrated : null, !r) throw Error(i(317));
      t: {
        for (r = r.nextSibling, a = 0; r; ) {
          if (r.nodeType === 8)
            if (d = r.data, d === "/$") {
              if (a === 0) {
                wr = vl(r.nextSibling);
                break t;
              }
              a--;
            } else
              d !== "$" && d !== "$!" && d !== "$?" || a++;
          r = r.nextSibling;
        }
        wr = null;
      }
    } else
      wr = Gr ? vl(r.stateNode.nextSibling) : null;
    return !0;
  }
  function td() {
    wr = Gr = null, On = !1;
  }
  function fo(r) {
    ss === null ? ss = [r] : ss.push(r);
  }
  var Gl = Error(i(460)), Sp = Error(i(474)), Wh = { then: function() {
  } };
  function l0(r) {
    return r = r.status, r === "fulfilled" || r === "rejected";
  }
  function Jd() {
  }
  function Hl(r, a, d) {
    switch (d = r[d], d === void 0 ? r.push(a) : d !== a && (a.then(Jd, Jd), a = d), a.status) {
      case "fulfilled":
        return a.value;
      case "rejected":
        throw r = a.reason, r === Gl ? Error(i(483)) : r;
      default:
        if (typeof a.status == "string") a.then(Jd, Jd);
        else {
          if (r = Wn, r !== null && 100 < r.shellSuspendCounter)
            throw Error(i(482));
          r = a, r.status = "pending", r.then(
            function(m) {
              if (a.status === "pending") {
                var C = a;
                C.status = "fulfilled", C.value = m;
              }
            },
            function(m) {
              if (a.status === "pending") {
                var C = a;
                C.status = "rejected", C.reason = m;
              }
            }
          );
        }
        switch (a.status) {
          case "fulfilled":
            return a.value;
          case "rejected":
            throw r = a.reason, r === Gl ? Error(i(483)) : r;
        }
        throw ed = a, Gl;
    }
  }
  var ed = null;
  function Ln() {
    if (ed === null) throw Error(i(459));
    var r = ed;
    return ed = null, r;
  }
  var Kl = null, th = 0;
  function eh(r) {
    var a = th;
    return th += 1, Kl === null && (Kl = []), Hl(Kl, r, a);
  }
  function nh(r, a) {
    a = a.props.ref, r.ref = a !== void 0 ? a : null;
  }
  function $h(r, a) {
    throw a.$$typeof === o ? Error(i(525)) : (r = Object.prototype.toString.call(a), Error(
      i(
        31,
        r === "[object Object]" ? "object with keys {" + Object.keys(a).join(", ") + "}" : r
      )
    ));
  }
  function c0(r) {
    var a = r._init;
    return a(r._payload);
  }
  function u0(r) {
    function a(zt, Ct) {
      if (r) {
        var jt = zt.deletions;
        jt === null ? (zt.deletions = [Ct], zt.flags |= 16) : jt.push(Ct);
      }
    }
    function d(zt, Ct) {
      if (!r) return null;
      for (; Ct !== null; )
        a(zt, Ct), Ct = Ct.sibling;
      return null;
    }
    function m(zt) {
      for (var Ct = /* @__PURE__ */ new Map(); zt !== null; )
        zt.key !== null ? Ct.set(zt.key, zt) : Ct.set(zt.index, zt), zt = zt.sibling;
      return Ct;
    }
    function C(zt, Ct) {
      return zt = ua(zt, Ct), zt.index = 0, zt.sibling = null, zt;
    }
    function B(zt, Ct, jt) {
      return zt.index = jt, r ? (jt = zt.alternate, jt !== null ? (jt = jt.index, jt < Ct ? (zt.flags |= 33554434, Ct) : jt) : (zt.flags |= 33554434, Ct)) : (zt.flags |= 1048576, Ct);
    }
    function $(zt) {
      return r && zt.alternate === null && (zt.flags |= 33554434), zt;
    }
    function at(zt, Ct, jt, ee) {
      return Ct === null || Ct.tag !== 6 ? (Ct = Ji(jt, zt.mode, ee), Ct.return = zt, Ct) : (Ct = C(Ct, jt), Ct.return = zt, Ct);
    }
    function pt(zt, Ct, jt, ee) {
      var ke = jt.type;
      return ke === f ? Zt(
        zt,
        Ct,
        jt.props.children,
        ee,
        jt.key
      ) : Ct !== null && (Ct.elementType === ke || typeof ke == "object" && ke !== null && ke.$$typeof === M && c0(ke) === Ct.type) ? (Ct = C(Ct, jt.props), nh(Ct, jt), Ct.return = zt, Ct) : (Ct = gd(
        jt.type,
        jt.key,
        jt.props,
        null,
        zt.mode,
        ee
      ), nh(Ct, jt), Ct.return = zt, Ct);
    }
    function Mt(zt, Ct, jt, ee) {
      return Ct === null || Ct.tag !== 4 || Ct.stateNode.containerInfo !== jt.containerInfo || Ct.stateNode.implementation !== jt.implementation ? (Ct = ph(jt, zt.mode, ee), Ct.return = zt, Ct) : (Ct = C(Ct, jt.children || []), Ct.return = zt, Ct);
    }
    function Zt(zt, Ct, jt, ee, ke) {
      return Ct === null || Ct.tag !== 7 ? (Ct = dc(
        jt,
        zt.mode,
        ee,
        ke
      ), Ct.return = zt, Ct) : (Ct = C(Ct, jt), Ct.return = zt, Ct);
    }
    function he(zt, Ct, jt) {
      if (typeof Ct == "string" && Ct !== "" || typeof Ct == "number" || typeof Ct == "bigint")
        return Ct = Ji(
          "" + Ct,
          zt.mode,
          jt
        ), Ct.return = zt, Ct;
      if (typeof Ct == "object" && Ct !== null) {
        switch (Ct.$$typeof) {
          case u:
            return jt = gd(
              Ct.type,
              Ct.key,
              Ct.props,
              null,
              zt.mode,
              jt
            ), nh(jt, Ct), jt.return = zt, jt;
          case h:
            return Ct = ph(
              Ct,
              zt.mode,
              jt
            ), Ct.return = zt, Ct;
          case M:
            var ee = Ct._init;
            return Ct = ee(Ct._payload), he(zt, Ct, jt);
        }
        if (ct(Ct) || U(Ct))
          return Ct = dc(
            Ct,
            zt.mode,
            jt,
            null
          ), Ct.return = zt, Ct;
        if (typeof Ct.then == "function")
          return he(zt, eh(Ct), jt);
        if (Ct.$$typeof === b)
          return he(
            zt,
            pf(zt, Ct),
            jt
          );
        $h(zt, Ct);
      }
      return null;
    }
    function qt(zt, Ct, jt, ee) {
      var ke = Ct !== null ? Ct.key : null;
      if (typeof jt == "string" && jt !== "" || typeof jt == "number" || typeof jt == "bigint")
        return ke !== null ? null : at(zt, Ct, "" + jt, ee);
      if (typeof jt == "object" && jt !== null) {
        switch (jt.$$typeof) {
          case u:
            return jt.key === ke ? pt(zt, Ct, jt, ee) : null;
          case h:
            return jt.key === ke ? Mt(zt, Ct, jt, ee) : null;
          case M:
            return ke = jt._init, jt = ke(jt._payload), qt(zt, Ct, jt, ee);
        }
        if (ct(jt) || U(jt))
          return ke !== null ? null : Zt(zt, Ct, jt, ee, null);
        if (typeof jt.then == "function")
          return qt(
            zt,
            Ct,
            eh(jt),
            ee
          );
        if (jt.$$typeof === b)
          return qt(
            zt,
            Ct,
            pf(zt, jt),
            ee
          );
        $h(zt, jt);
      }
      return null;
    }
    function $t(zt, Ct, jt, ee, ke) {
      if (typeof ee == "string" && ee !== "" || typeof ee == "number" || typeof ee == "bigint")
        return zt = zt.get(jt) || null, at(Ct, zt, "" + ee, ke);
      if (typeof ee == "object" && ee !== null) {
        switch (ee.$$typeof) {
          case u:
            return zt = zt.get(
              ee.key === null ? jt : ee.key
            ) || null, pt(Ct, zt, ee, ke);
          case h:
            return zt = zt.get(
              ee.key === null ? jt : ee.key
            ) || null, Mt(Ct, zt, ee, ke);
          case M:
            var Tn = ee._init;
            return ee = Tn(ee._payload), $t(
              zt,
              Ct,
              jt,
              ee,
              ke
            );
        }
        if (ct(ee) || U(ee))
          return zt = zt.get(jt) || null, Zt(Ct, zt, ee, ke, null);
        if (typeof ee.then == "function")
          return $t(
            zt,
            Ct,
            jt,
            eh(ee),
            ke
          );
        if (ee.$$typeof === b)
          return $t(
            zt,
            Ct,
            jt,
            pf(Ct, ee),
            ke
          );
        $h(Ct, ee);
      }
      return null;
    }
    function Pe(zt, Ct, jt, ee) {
      for (var ke = null, Tn = null, je = Ct, We = Ct = 0, Qr = null; je !== null && We < jt.length; We++) {
        je.index > We ? (Qr = je, je = null) : Qr = je.sibling;
        var Vn = qt(
          zt,
          je,
          jt[We],
          ee
        );
        if (Vn === null) {
          je === null && (je = Qr);
          break;
        }
        r && je && Vn.alternate === null && a(zt, je), Ct = B(Vn, Ct, We), Tn === null ? ke = Vn : Tn.sibling = Vn, Tn = Vn, je = Qr;
      }
      if (We === jt.length)
        return d(zt, je), On && sa(zt, We), ke;
      if (je === null) {
        for (; We < jt.length; We++)
          je = he(zt, jt[We], ee), je !== null && (Ct = B(
            je,
            Ct,
            We
          ), Tn === null ? ke = je : Tn.sibling = je, Tn = je);
        return On && sa(zt, We), ke;
      }
      for (je = m(je); We < jt.length; We++)
        Qr = $t(
          je,
          zt,
          We,
          jt[We],
          ee
        ), Qr !== null && (r && Qr.alternate !== null && je.delete(
          Qr.key === null ? We : Qr.key
        ), Ct = B(
          Qr,
          Ct,
          We
        ), Tn === null ? ke = Qr : Tn.sibling = Qr, Tn = Qr);
      return r && je.forEach(function(wd) {
        return a(zt, wd);
      }), On && sa(zt, We), ke;
    }
    function sn(zt, Ct, jt, ee) {
      if (jt == null) throw Error(i(151));
      for (var ke = null, Tn = null, je = Ct, We = Ct = 0, Qr = null, Vn = jt.next(); je !== null && !Vn.done; We++, Vn = jt.next()) {
        je.index > We ? (Qr = je, je = null) : Qr = je.sibling;
        var wd = qt(zt, je, Vn.value, ee);
        if (wd === null) {
          je === null && (je = Qr);
          break;
        }
        r && je && wd.alternate === null && a(zt, je), Ct = B(wd, Ct, We), Tn === null ? ke = wd : Tn.sibling = wd, Tn = wd, je = Qr;
      }
      if (Vn.done)
        return d(zt, je), On && sa(zt, We), ke;
      if (je === null) {
        for (; !Vn.done; We++, Vn = jt.next())
          Vn = he(zt, Vn.value, ee), Vn !== null && (Ct = B(Vn, Ct, We), Tn === null ? ke = Vn : Tn.sibling = Vn, Tn = Vn);
        return On && sa(zt, We), ke;
      }
      for (je = m(je); !Vn.done; We++, Vn = jt.next())
        Vn = $t(je, zt, We, Vn.value, ee), Vn !== null && (r && Vn.alternate !== null && je.delete(Vn.key === null ? We : Vn.key), Ct = B(Vn, Ct, We), Tn === null ? ke = Vn : Tn.sibling = Vn, Tn = Vn);
      return r && je.forEach(function(HC) {
        return a(zt, HC);
      }), On && sa(zt, We), ke;
    }
    function nr(zt, Ct, jt, ee) {
      if (typeof jt == "object" && jt !== null && jt.type === f && jt.key === null && (jt = jt.props.children), typeof jt == "object" && jt !== null) {
        switch (jt.$$typeof) {
          case u:
            t: {
              for (var ke = jt.key; Ct !== null; ) {
                if (Ct.key === ke) {
                  if (ke = jt.type, ke === f) {
                    if (Ct.tag === 7) {
                      d(
                        zt,
                        Ct.sibling
                      ), ee = C(
                        Ct,
                        jt.props.children
                      ), ee.return = zt, zt = ee;
                      break t;
                    }
                  } else if (Ct.elementType === ke || typeof ke == "object" && ke !== null && ke.$$typeof === M && c0(ke) === Ct.type) {
                    d(
                      zt,
                      Ct.sibling
                    ), ee = C(Ct, jt.props), nh(ee, jt), ee.return = zt, zt = ee;
                    break t;
                  }
                  d(zt, Ct);
                  break;
                } else a(zt, Ct);
                Ct = Ct.sibling;
              }
              jt.type === f ? (ee = dc(
                jt.props.children,
                zt.mode,
                ee,
                jt.key
              ), ee.return = zt, zt = ee) : (ee = gd(
                jt.type,
                jt.key,
                jt.props,
                null,
                zt.mode,
                ee
              ), nh(ee, jt), ee.return = zt, zt = ee);
            }
            return $(zt);
          case h:
            t: {
              for (ke = jt.key; Ct !== null; ) {
                if (Ct.key === ke)
                  if (Ct.tag === 4 && Ct.stateNode.containerInfo === jt.containerInfo && Ct.stateNode.implementation === jt.implementation) {
                    d(
                      zt,
                      Ct.sibling
                    ), ee = C(Ct, jt.children || []), ee.return = zt, zt = ee;
                    break t;
                  } else {
                    d(zt, Ct);
                    break;
                  }
                else a(zt, Ct);
                Ct = Ct.sibling;
              }
              ee = ph(jt, zt.mode, ee), ee.return = zt, zt = ee;
            }
            return $(zt);
          case M:
            return ke = jt._init, jt = ke(jt._payload), nr(
              zt,
              Ct,
              jt,
              ee
            );
        }
        if (ct(jt))
          return Pe(
            zt,
            Ct,
            jt,
            ee
          );
        if (U(jt)) {
          if (ke = U(jt), typeof ke != "function") throw Error(i(150));
          return jt = ke.call(jt), sn(
            zt,
            Ct,
            jt,
            ee
          );
        }
        if (typeof jt.then == "function")
          return nr(
            zt,
            Ct,
            eh(jt),
            ee
          );
        if (jt.$$typeof === b)
          return nr(
            zt,
            Ct,
            pf(zt, jt),
            ee
          );
        $h(zt, jt);
      }
      return typeof jt == "string" && jt !== "" || typeof jt == "number" || typeof jt == "bigint" ? (jt = "" + jt, Ct !== null && Ct.tag === 6 ? (d(zt, Ct.sibling), ee = C(Ct, jt), ee.return = zt, zt = ee) : (d(zt, Ct), ee = Ji(jt, zt.mode, ee), ee.return = zt, zt = ee), $(zt)) : d(zt, Ct);
    }
    return function(zt, Ct, jt, ee) {
      try {
        th = 0;
        var ke = nr(
          zt,
          Ct,
          jt,
          ee
        );
        return Kl = null, ke;
      } catch (je) {
        if (je === Gl) throw je;
        var Tn = Hi(29, je, null, zt.mode);
        return Tn.lanes = ee, Tn.return = zt, Tn;
      } finally {
      }
    };
  }
  var Zo = u0(!0), Jo = u0(!1), su = lt(null), ou = lt(0);
  function Yl(r, a) {
    r = ml, Tt(ou, r), Tt(su, a), ml = r | a.baseLanes;
  }
  function Qh() {
    Tt(ou, ml), Tt(su, su.current);
  }
  function ih() {
    ml = ou.current, ft(su), ft(ou);
  }
  var Ca = lt(null), po = null;
  function tl(r) {
    var a = r.alternate;
    Tt($i, $i.current & 1), Tt(Ca, r), po === null && (a === null || su.current !== null || a.memoizedState !== null) && (po = r);
  }
  function xp(r) {
    if (r.tag === 22) {
      if (Tt($i, $i.current), Tt(Ca, r), po === null) {
        var a = r.alternate;
        a !== null && a.memoizedState !== null && (po = r);
      }
    } else el();
  }
  function el() {
    Tt($i, $i.current), Tt(Ca, Ca.current);
  }
  function mo(r) {
    ft(Ca), po === r && (po = null), ft($i);
  }
  var $i = lt(0);
  function nd(r) {
    for (var a = r; a !== null; ) {
      if (a.tag === 13) {
        var d = a.memoizedState;
        if (d !== null && (d = d.dehydrated, d === null || d.data === "$?" || d.data === "$!"))
          return a;
      } else if (a.tag === 19 && a.memoizedProps.revealOrder !== void 0) {
        if ((a.flags & 128) !== 0) return a;
      } else if (a.child !== null) {
        a.child.return = a, a = a.child;
        continue;
      }
      if (a === r) break;
      for (; a.sibling === null; ) {
        if (a.return === null || a.return === r) return null;
        a = a.return;
      }
      a.sibling.return = a.return, a = a.sibling;
    }
    return null;
  }
  var gn = typeof AbortController < "u" ? AbortController : function() {
    var r = [], a = this.signal = {
      aborted: !1,
      addEventListener: function(d, m) {
        r.push(m);
      }
    };
    this.abort = function() {
      a.aborted = !0, r.forEach(function(d) {
        return d();
      });
    };
  }, mv = e.unstable_scheduleCallback, Fa = e.unstable_NormalPriority, Li = {
    $$typeof: b,
    Consumer: null,
    Provider: null,
    _currentValue: null,
    _currentValue2: null,
    _threadCount: 0
  };
  function Tp() {
    return {
      controller: new gn(),
      data: /* @__PURE__ */ new Map(),
      refCount: 0
    };
  }
  function Xl(r) {
    r.refCount--, r.refCount === 0 && mv(Fa, function() {
      r.controller.abort();
    });
  }
  var go = null, Wl = 0, lu = 0, $l = null;
  function gv(r, a) {
    if (go === null) {
      var d = go = [];
      Wl = 0, lu = wv(), $l = {
        status: "pending",
        value: void 0,
        then: function(m) {
          d.push(m);
        }
      };
    }
    return Wl++, a.then(Cp, Cp), a;
  }
  function Cp() {
    if (--Wl === 0 && go !== null) {
      $l !== null && ($l.status = "fulfilled");
      var r = go;
      go = null, lu = 0, $l = null;
      for (var a = 0; a < r.length; a++) (0, r[a])();
    }
  }
  function Ql(r, a) {
    var d = [], m = {
      status: "pending",
      value: null,
      reason: null,
      then: function(C) {
        d.push(C);
      }
    };
    return r.then(
      function() {
        m.status = "fulfilled", m.value = a;
        for (var C = 0; C < d.length; C++) (0, d[C])(a);
      },
      function(C) {
        for (m.status = "rejected", m.reason = C, C = 0; C < d.length; C++)
          (0, d[C])(void 0);
      }
    ), m;
  }
  var Zh = V.S;
  V.S = function(r, a) {
    typeof a == "object" && a !== null && typeof a.then == "function" && gv(r, a), Zh !== null && Zh(r, a);
  };
  var nl = lt(null);
  function rh() {
    var r = nl.current;
    return r !== null ? r : Wn.pooledCache;
  }
  function id(r, a) {
    a === null ? Tt(nl, nl.current) : Tt(nl, a.pool);
  }
  function il() {
    var r = rh();
    return r === null ? null : { parent: Li._currentValue, pool: r };
  }
  var rl = 0, un = null, qn = null, Qi = null, Xe = !1, Zl = !1, Jl = !1, rd = 0, tc = 0, ad = null, yv = 0;
  function Ni() {
    throw Error(i(321));
  }
  function cu(r, a) {
    if (a === null) return !1;
    for (var d = 0; d < a.length && d < r.length; d++)
      if (!zr(r[d], a[d])) return !1;
    return !0;
  }
  function wp(r, a, d, m, C, B) {
    return rl = B, un = a, a.memoizedState = null, a.updateQueue = null, a.lanes = 0, V.H = r === null || r.memoizedState === null ? nc : sl, Jl = !1, B = d(m, C), Jl = !1, Zl && (B = h0(
      a,
      d,
      m,
      C
    )), d0(r), B;
  }
  function d0(r) {
    V.H = vo;
    var a = qn !== null && qn.next !== null;
    if (rl = 0, Qi = qn = un = null, Xe = !1, tc = 0, ad = null, a) throw Error(i(300));
    r === null || pr || (r = r.dependencies, r !== null && ud(r) && (pr = !0));
  }
  function h0(r, a, d, m) {
    un = r;
    var C = 0;
    do {
      if (Zl && (ad = null), tc = 0, Zl = !1, 25 <= C) throw Error(i(301));
      if (C += 1, Qi = qn = null, r.updateQueue != null) {
        var B = r.updateQueue;
        B.lastEffect = null, B.events = null, B.stores = null, B.memoCache != null && (B.memoCache.index = 0);
      }
      V.H = hu, B = a(d, m);
    } while (Zl);
    return B;
  }
  function vv() {
    var r = V.H, a = r.useState()[0];
    return a = typeof a.then == "function" ? sh(a) : a, r = r.useState()[0], (qn !== null ? qn.memoizedState : null) !== r && (un.flags |= 1024), a;
  }
  function Ep() {
    var r = rd !== 0;
    return rd = 0, r;
  }
  function ah(r, a, d) {
    a.updateQueue = r.updateQueue, a.flags &= -2053, r.lanes &= ~d;
  }
  function Jh(r) {
    if (Xe) {
      for (r = r.memoizedState; r !== null; ) {
        var a = r.queue;
        a !== null && (a.pending = null), r = r.next;
      }
      Xe = !1;
    }
    rl = 0, Qi = qn = un = null, Zl = !1, tc = rd = 0, ad = null;
  }
  function Pr() {
    var r = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null
    };
    return Qi === null ? un.memoizedState = Qi = r : Qi = Qi.next = r, Qi;
  }
  function Vi() {
    if (qn === null) {
      var r = un.alternate;
      r = r !== null ? r.memoizedState : null;
    } else r = qn.next;
    var a = Qi === null ? un.memoizedState : Qi.next;
    if (a !== null)
      Qi = a, qn = r;
    else {
      if (r === null)
        throw un.alternate === null ? Error(i(467)) : Error(i(310));
      qn = r, r = {
        memoizedState: qn.memoizedState,
        baseState: qn.baseState,
        baseQueue: qn.baseQueue,
        queue: qn.queue,
        next: null
      }, Qi === null ? un.memoizedState = Qi = r : Qi = Qi.next = r;
    }
    return Qi;
  }
  var tf;
  tf = function() {
    return { lastEffect: null, events: null, stores: null, memoCache: null };
  };
  function sh(r) {
    var a = tc;
    return tc += 1, ad === null && (ad = []), r = Hl(ad, r, a), a = un, (Qi === null ? a.memoizedState : Qi.next) === null && (a = a.alternate, V.H = a === null || a.memoizedState === null ? nc : sl), r;
  }
  function sd(r) {
    if (r !== null && typeof r == "object") {
      if (typeof r.then == "function") return sh(r);
      if (r.$$typeof === b) return Hr(r);
    }
    throw Error(i(438, String(r)));
  }
  function Ps(r) {
    var a = null, d = un.updateQueue;
    if (d !== null && (a = d.memoCache), a == null) {
      var m = un.alternate;
      m !== null && (m = m.updateQueue, m !== null && (m = m.memoCache, m != null && (a = {
        data: m.data.map(function(C) {
          return C.slice();
        }),
        index: 0
      })));
    }
    if (a == null && (a = { data: [], index: 0 }), d === null && (d = tf(), un.updateQueue = d), d.memoCache = a, d = a.data[a.index], d === void 0)
      for (d = a.data[a.index] = Array(r), m = 0; m < r; m++)
        d[m] = R;
    return a.index++, d;
  }
  function vi(r, a) {
    return typeof a == "function" ? a(r) : a;
  }
  function Us(r) {
    var a = Vi();
    return wa(a, qn, r);
  }
  function wa(r, a, d) {
    var m = r.queue;
    if (m === null) throw Error(i(311));
    m.lastRenderedReducer = d;
    var C = r.baseQueue, B = m.pending;
    if (B !== null) {
      if (C !== null) {
        var $ = C.next;
        C.next = B.next, B.next = $;
      }
      a.baseQueue = C = B, m.pending = null;
    }
    if (B = r.baseState, C === null) r.memoizedState = B;
    else {
      a = C.next;
      var at = $ = null, pt = null, Mt = a, Zt = !1;
      do {
        var he = Mt.lane & -536870913;
        if (he !== Mt.lane ? (Ie & he) === he : (rl & he) === he) {
          var qt = Mt.revertLane;
          if (qt === 0)
            pt !== null && (pt = pt.next = {
              lane: 0,
              revertLane: 0,
              action: Mt.action,
              hasEagerState: Mt.hasEagerState,
              eagerState: Mt.eagerState,
              next: null
            }), he === lu && (Zt = !0);
          else if ((rl & qt) === qt) {
            Mt = Mt.next, qt === lu && (Zt = !0);
            continue;
          } else
            he = {
              lane: 0,
              revertLane: Mt.revertLane,
              action: Mt.action,
              hasEagerState: Mt.hasEagerState,
              eagerState: Mt.eagerState,
              next: null
            }, pt === null ? (at = pt = he, $ = B) : pt = pt.next = he, un.lanes |= qt, Gs |= qt;
          he = Mt.action, Jl && d(B, he), B = Mt.hasEagerState ? Mt.eagerState : d(B, he);
        } else
          qt = {
            lane: he,
            revertLane: Mt.revertLane,
            action: Mt.action,
            hasEagerState: Mt.hasEagerState,
            eagerState: Mt.eagerState,
            next: null
          }, pt === null ? (at = pt = qt, $ = B) : pt = pt.next = qt, un.lanes |= he, Gs |= he;
        Mt = Mt.next;
      } while (Mt !== null && Mt !== a);
      if (pt === null ? $ = B : pt.next = at, !zr(B, r.memoizedState) && (pr = !0, Zt && (d = $l, d !== null)))
        throw d;
      r.memoizedState = B, r.baseState = $, r.baseQueue = pt, m.lastRenderedState = B;
    }
    return C === null && (m.lanes = 0), [r.memoizedState, m.dispatch];
  }
  function ef(r) {
    var a = Vi(), d = a.queue;
    if (d === null) throw Error(i(311));
    d.lastRenderedReducer = r;
    var m = d.dispatch, C = d.pending, B = a.memoizedState;
    if (C !== null) {
      d.pending = null;
      var $ = C = C.next;
      do
        B = r(B, $.action), $ = $.next;
      while ($ !== C);
      zr(B, a.memoizedState) || (pr = !0), a.memoizedState = B, a.baseQueue === null && (a.baseState = B), d.lastRenderedState = B;
    }
    return [B, m];
  }
  function f0(r, a, d) {
    var m = un, C = Vi(), B = On;
    if (B) {
      if (d === void 0) throw Error(i(407));
      d = d();
    } else d = a();
    var $ = !zr(
      (qn || C).memoizedState,
      d
    );
    if ($ && (C.memoizedState = d, pr = !0), C = C.queue, Op(p0.bind(null, m, C, r), [
      r
    ]), C.getSnapshot !== a || $ || Qi !== null && Qi.memoizedState.tag & 1) {
      if (m.flags |= 2048, yo(
        9,
        ec.bind(
          null,
          m,
          C,
          d,
          a
        ),
        { destroy: void 0 },
        null
      ), Wn === null) throw Error(i(349));
      B || (rl & 60) !== 0 || oa(m, a, d);
    }
    return d;
  }
  function oa(r, a, d) {
    r.flags |= 16384, r = { getSnapshot: a, value: d }, a = un.updateQueue, a === null ? (a = tf(), un.updateQueue = a, a.stores = [r]) : (d = a.stores, d === null ? a.stores = [r] : d.push(r));
  }
  function ec(r, a, d, m) {
    a.value = d, a.getSnapshot = m, m0(a) && g0(r);
  }
  function p0(r, a, d) {
    return d(function() {
      m0(a) && g0(r);
    });
  }
  function m0(r) {
    var a = r.getSnapshot;
    r = r.value;
    try {
      var d = a();
      return !zr(r, d);
    } catch {
      return !0;
    }
  }
  function g0(r) {
    var a = ai(r, 2);
    a !== null && er(a, r, 2);
  }
  function Ap(r) {
    var a = Pr();
    if (typeof r == "function") {
      var d = r;
      if (r = d(), Jl) {
        ne(!0);
        try {
          d();
        } finally {
          ne(!1);
        }
      }
    }
    return a.memoizedState = a.baseState = r, a.queue = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: vi,
      lastRenderedState: r
    }, a;
  }
  function Mp(r, a, d, m) {
    return r.baseState = d, wa(
      r,
      qn,
      typeof m == "function" ? m : vi
    );
  }
  function bv(r, a, d, m, C) {
    if (of(r)) throw Error(i(485));
    if (r = a.action, r !== null) {
      var B = {
        payload: C,
        action: r,
        next: null,
        isTransition: !0,
        status: "pending",
        value: null,
        reason: null,
        listeners: [],
        then: function($) {
          B.listeners.push($);
        }
      };
      V.T !== null ? d(!0) : B.isTransition = !1, m(B), d = a.pending, d === null ? (B.next = a.pending = B, Rp(a, B)) : (B.next = d.next, a.pending = d.next = B);
    }
  }
  function Rp(r, a) {
    var d = a.action, m = a.payload, C = r.state;
    if (a.isTransition) {
      var B = V.T, $ = {};
      V.T = $;
      try {
        var at = d(C, m), pt = V.S;
        pt !== null && pt($, at), y0(r, a, at);
      } catch (Mt) {
        al(r, a, Mt);
      } finally {
        V.T = B;
      }
    } else
      try {
        B = d(C, m), y0(r, a, B);
      } catch (Mt) {
        al(r, a, Mt);
      }
  }
  function y0(r, a, d) {
    d !== null && typeof d == "object" && typeof d.then == "function" ? d.then(
      function(m) {
        uu(r, a, m);
      },
      function(m) {
        return al(r, a, m);
      }
    ) : uu(r, a, d);
  }
  function uu(r, a, d) {
    a.status = "fulfilled", a.value = d, v0(a), r.state = d, a = r.pending, a !== null && (d = a.next, d === a ? r.pending = null : (d = d.next, a.next = d, Rp(r, d)));
  }
  function al(r, a, d) {
    var m = r.pending;
    if (r.pending = null, m !== null) {
      m = m.next;
      do
        a.status = "rejected", a.reason = d, v0(a), a = a.next;
      while (a !== m);
    }
    r.action = null;
  }
  function v0(r) {
    r = r.listeners;
    for (var a = 0; a < r.length; a++) (0, r[a])();
  }
  function b0(r, a) {
    return a;
  }
  function _0(r, a) {
    if (On) {
      var d = Wn.formState;
      if (d !== null) {
        t: {
          var m = un;
          if (On) {
            if (wr) {
              e: {
                for (var C = wr, B = os; C.nodeType !== 8; ) {
                  if (!B) {
                    C = null;
                    break e;
                  }
                  if (C = vl(
                    C.nextSibling
                  ), C === null) {
                    C = null;
                    break e;
                  }
                }
                B = C.data, C = B === "F!" || B === "F" ? C : null;
              }
              if (C) {
                wr = vl(
                  C.nextSibling
                ), m = C.data === "F!";
                break t;
              }
            }
            au(m);
          }
          m = !1;
        }
        m && (a = d[0]);
      }
    }
    return d = Pr(), d.memoizedState = d.baseState = a, m = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: b0,
      lastRenderedState: a
    }, d.queue = m, d = Bp.bind(
      null,
      un,
      m
    ), m.dispatch = d, m = Ap(!1), B = oh.bind(
      null,
      un,
      !1,
      m.queue
    ), m = Pr(), C = {
      state: a,
      dispatch: null,
      action: r,
      pending: null
    }, m.queue = C, d = bv.bind(
      null,
      un,
      C,
      B,
      d
    ), C.dispatch = d, m.memoizedState = r, [a, d, !1];
  }
  function od(r) {
    var a = Vi();
    return S0(a, qn, r);
  }
  function S0(r, a, d) {
    a = wa(
      r,
      a,
      b0
    )[0], r = Us(vi)[0], a = typeof a == "object" && a !== null && typeof a.then == "function" ? sh(a) : a;
    var m = Vi(), C = m.queue, B = C.dispatch;
    return d !== m.memoizedState && (un.flags |= 2048, yo(
      9,
      _v.bind(null, C, d),
      { destroy: void 0 },
      null
    )), [a, B, r];
  }
  function _v(r, a) {
    r.action = a;
  }
  function x0(r) {
    var a = Vi(), d = qn;
    if (d !== null)
      return S0(a, d, r);
    Vi(), a = a.memoizedState, d = Vi();
    var m = d.queue.dispatch;
    return d.memoizedState = r, [a, m, !1];
  }
  function yo(r, a, d, m) {
    return r = { tag: r, create: a, inst: d, deps: m, next: null }, a = un.updateQueue, a === null && (a = tf(), un.updateQueue = a), d = a.lastEffect, d === null ? a.lastEffect = r.next = r : (m = d.next, d.next = r, r.next = m, a.lastEffect = r), r;
  }
  function T0() {
    return Vi().memoizedState;
  }
  function nf(r, a, d, m) {
    var C = Pr();
    un.flags |= r, C.memoizedState = yo(
      1 | a,
      d,
      { destroy: void 0 },
      m === void 0 ? null : m
    );
  }
  function rf(r, a, d, m) {
    var C = Vi();
    m = m === void 0 ? null : m;
    var B = C.memoizedState.inst;
    qn !== null && m !== null && cu(m, qn.memoizedState.deps) ? C.memoizedState = yo(a, d, B, m) : (un.flags |= r, C.memoizedState = yo(1 | a, d, B, m));
  }
  function C0(r, a) {
    nf(8390656, 8, r, a);
  }
  function Op(r, a) {
    rf(2048, 8, r, a);
  }
  function w0(r, a) {
    return rf(4, 2, r, a);
  }
  function E0(r, a) {
    return rf(4, 4, r, a);
  }
  function A0(r, a) {
    if (typeof a == "function") {
      r = r();
      var d = a(r);
      return function() {
        typeof d == "function" ? d() : a(null);
      };
    }
    if (a != null)
      return r = r(), a.current = r, function() {
        a.current = null;
      };
  }
  function M0(r, a, d) {
    d = d != null ? d.concat([r]) : null, rf(4, 4, A0.bind(null, a, r), d);
  }
  function Np() {
  }
  function R0(r, a) {
    var d = Vi();
    a = a === void 0 ? null : a;
    var m = d.memoizedState;
    return a !== null && cu(a, m[1]) ? m[0] : (d.memoizedState = [r, a], r);
  }
  function O0(r, a) {
    var d = Vi();
    a = a === void 0 ? null : a;
    var m = d.memoizedState;
    if (a !== null && cu(a, m[1]))
      return m[0];
    if (m = r(), Jl) {
      ne(!0);
      try {
        r();
      } finally {
        ne(!1);
      }
    }
    return d.memoizedState = [m, a], m;
  }
  function af(r, a, d) {
    return d === void 0 || (rl & 1073741824) !== 0 ? r.memoizedState = a : (r.memoizedState = d, r = Ya(), un.lanes |= r, Gs |= r, d);
  }
  function N0(r, a, d, m) {
    return zr(d, a) ? d : su.current !== null ? (r = af(r, d, m), zr(r, a) || (pr = !0), r) : (rl & 42) === 0 ? (pr = !0, r.memoizedState = d) : (r = Ya(), un.lanes |= r, Gs |= r, a);
  }
  function k0(r, a, d, m, C) {
    var B = dt.p;
    dt.p = B !== 0 && 8 > B ? B : 8;
    var $ = V.T, at = {};
    V.T = at, oh(r, !1, a, d);
    try {
      var pt = C(), Mt = V.S;
      if (Mt !== null && Mt(at, pt), pt !== null && typeof pt == "object" && typeof pt.then == "function") {
        var Zt = Ql(
          pt,
          m
        );
        du(
          r,
          a,
          Zt,
          ha(r)
        );
      } else
        du(
          r,
          a,
          m,
          ha(r)
        );
    } catch (he) {
      du(
        r,
        a,
        { then: function() {
        }, status: "rejected", reason: he },
        ha()
      );
    } finally {
      dt.p = B, V.T = $;
    }
  }
  function Sv() {
  }
  function kp(r, a, d, m) {
    if (r.tag !== 5) throw Error(i(476));
    var C = D0(r).queue;
    k0(
      r,
      C,
      a,
      ht,
      d === null ? Sv : function() {
        return B0(r), d(m);
      }
    );
  }
  function D0(r) {
    var a = r.memoizedState;
    if (a !== null) return a;
    a = {
      memoizedState: ht,
      baseState: ht,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: vi,
        lastRenderedState: ht
      },
      next: null
    };
    var d = {};
    return a.next = {
      memoizedState: d,
      baseState: d,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: vi,
        lastRenderedState: d
      },
      next: null
    }, r.memoizedState = a, r = r.alternate, r !== null && (r.memoizedState = a), a;
  }
  function B0(r) {
    var a = D0(r).next.queue;
    du(r, a, {}, ha());
  }
  function sf() {
    return Hr(am);
  }
  function Dp() {
    return Vi().memoizedState;
  }
  function z0() {
    return Vi().memoizedState;
  }
  function P0(r) {
    for (var a = r.return; a !== null; ) {
      switch (a.tag) {
        case 24:
        case 3:
          var d = ha();
          r = Ha(d);
          var m = Ka(a, r, d);
          m !== null && (er(m, a, d), ac(m, a, d)), a = { cache: Tp() }, r.payload = a;
          return;
      }
      a = a.return;
    }
  }
  function U0(r, a, d) {
    var m = ha();
    d = {
      lane: m,
      revertLane: 0,
      action: d,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, of(r) ? j0(a, d) : (d = yi(r, a, d, m), d !== null && (er(d, r, m), L0(d, a, m)));
  }
  function Bp(r, a, d) {
    var m = ha();
    du(r, a, d, m);
  }
  function du(r, a, d, m) {
    var C = {
      lane: m,
      revertLane: 0,
      action: d,
      hasEagerState: !1,
      eagerState: null,
      next: null
    };
    if (of(r)) j0(a, C);
    else {
      var B = r.alternate;
      if (r.lanes === 0 && (B === null || B.lanes === 0) && (B = a.lastRenderedReducer, B !== null))
        try {
          var $ = a.lastRenderedState, at = B($, d);
          if (C.hasEagerState = !0, C.eagerState = at, zr(at, $))
            return Ge(r, a, C, 0), Wn === null && fr(), !1;
        } catch {
        } finally {
        }
      if (d = yi(r, a, C, m), d !== null)
        return er(d, r, m), L0(d, a, m), !0;
    }
    return !1;
  }
  function oh(r, a, d, m) {
    if (m = {
      lane: 2,
      revertLane: wv(),
      action: m,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, of(r)) {
      if (a) throw Error(i(479));
    } else
      a = yi(
        r,
        d,
        m,
        2
      ), a !== null && er(a, r, 2);
  }
  function of(r) {
    var a = r.alternate;
    return r === un || a !== null && a === un;
  }
  function j0(r, a) {
    Zl = Xe = !0;
    var d = r.pending;
    d === null ? a.next = a : (a.next = d.next, d.next = a), r.pending = a;
  }
  function L0(r, a, d) {
    if ((d & 4194176) !== 0) {
      var m = a.lanes;
      m &= r.pendingLanes, d |= m, a.lanes = d, Ci(r, d);
    }
  }
  var vo = {
    readContext: Hr,
    use: sd,
    useCallback: Ni,
    useContext: Ni,
    useEffect: Ni,
    useImperativeHandle: Ni,
    useLayoutEffect: Ni,
    useInsertionEffect: Ni,
    useMemo: Ni,
    useReducer: Ni,
    useRef: Ni,
    useState: Ni,
    useDebugValue: Ni,
    useDeferredValue: Ni,
    useTransition: Ni,
    useSyncExternalStore: Ni,
    useId: Ni
  };
  vo.useCacheRefresh = Ni, vo.useMemoCache = Ni, vo.useHostTransitionStatus = Ni, vo.useFormState = Ni, vo.useActionState = Ni, vo.useOptimistic = Ni;
  var nc = {
    readContext: Hr,
    use: sd,
    useCallback: function(r, a) {
      return Pr().memoizedState = [
        r,
        a === void 0 ? null : a
      ], r;
    },
    useContext: Hr,
    useEffect: C0,
    useImperativeHandle: function(r, a, d) {
      d = d != null ? d.concat([r]) : null, nf(
        4194308,
        4,
        A0.bind(null, a, r),
        d
      );
    },
    useLayoutEffect: function(r, a) {
      return nf(4194308, 4, r, a);
    },
    useInsertionEffect: function(r, a) {
      nf(4, 2, r, a);
    },
    useMemo: function(r, a) {
      var d = Pr();
      a = a === void 0 ? null : a;
      var m = r();
      if (Jl) {
        ne(!0);
        try {
          r();
        } finally {
          ne(!1);
        }
      }
      return d.memoizedState = [m, a], m;
    },
    useReducer: function(r, a, d) {
      var m = Pr();
      if (d !== void 0) {
        var C = d(a);
        if (Jl) {
          ne(!0);
          try {
            d(a);
          } finally {
            ne(!1);
          }
        }
      } else C = a;
      return m.memoizedState = m.baseState = C, r = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: r,
        lastRenderedState: C
      }, m.queue = r, r = r.dispatch = U0.bind(
        null,
        un,
        r
      ), [m.memoizedState, r];
    },
    useRef: function(r) {
      var a = Pr();
      return r = { current: r }, a.memoizedState = r;
    },
    useState: function(r) {
      r = Ap(r);
      var a = r.queue, d = Bp.bind(null, un, a);
      return a.dispatch = d, [r.memoizedState, d];
    },
    useDebugValue: Np,
    useDeferredValue: function(r, a) {
      var d = Pr();
      return af(d, r, a);
    },
    useTransition: function() {
      var r = Ap(!1);
      return r = k0.bind(
        null,
        un,
        r.queue,
        !0,
        !1
      ), Pr().memoizedState = r, [!1, r];
    },
    useSyncExternalStore: function(r, a, d) {
      var m = un, C = Pr();
      if (On) {
        if (d === void 0)
          throw Error(i(407));
        d = d();
      } else {
        if (d = a(), Wn === null) throw Error(i(349));
        (Ie & 60) !== 0 || oa(m, a, d);
      }
      C.memoizedState = d;
      var B = { value: d, getSnapshot: a };
      return C.queue = B, C0(p0.bind(null, m, B, r), [
        r
      ]), m.flags |= 2048, yo(
        9,
        ec.bind(
          null,
          m,
          B,
          d,
          a
        ),
        { destroy: void 0 },
        null
      ), d;
    },
    useId: function() {
      var r = Pr(), a = Wn.identifierPrefix;
      if (On) {
        var d = Qo, m = ho;
        d = (m & ~(1 << 32 - Ve(m) - 1)).toString(32) + d, a = ":" + a + "R" + d, d = rd++, 0 < d && (a += "H" + d.toString(32)), a += ":";
      } else
        d = yv++, a = ":" + a + "r" + d.toString(32) + ":";
      return r.memoizedState = a;
    },
    useCacheRefresh: function() {
      return Pr().memoizedState = P0.bind(
        null,
        un
      );
    }
  };
  nc.useMemoCache = Ps, nc.useHostTransitionStatus = sf, nc.useFormState = _0, nc.useActionState = _0, nc.useOptimistic = function(r) {
    var a = Pr();
    a.memoizedState = a.baseState = r;
    var d = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: null,
      lastRenderedState: null
    };
    return a.queue = d, a = oh.bind(
      null,
      un,
      !0,
      d
    ), d.dispatch = a, [r, a];
  };
  var sl = {
    readContext: Hr,
    use: sd,
    useCallback: R0,
    useContext: Hr,
    useEffect: Op,
    useImperativeHandle: M0,
    useInsertionEffect: w0,
    useLayoutEffect: E0,
    useMemo: O0,
    useReducer: Us,
    useRef: T0,
    useState: function() {
      return Us(vi);
    },
    useDebugValue: Np,
    useDeferredValue: function(r, a) {
      var d = Vi();
      return N0(
        d,
        qn.memoizedState,
        r,
        a
      );
    },
    useTransition: function() {
      var r = Us(vi)[0], a = Vi().memoizedState;
      return [
        typeof r == "boolean" ? r : sh(r),
        a
      ];
    },
    useSyncExternalStore: f0,
    useId: Dp
  };
  sl.useCacheRefresh = z0, sl.useMemoCache = Ps, sl.useHostTransitionStatus = sf, sl.useFormState = od, sl.useActionState = od, sl.useOptimistic = function(r, a) {
    var d = Vi();
    return Mp(d, qn, r, a);
  };
  var hu = {
    readContext: Hr,
    use: sd,
    useCallback: R0,
    useContext: Hr,
    useEffect: Op,
    useImperativeHandle: M0,
    useInsertionEffect: w0,
    useLayoutEffect: E0,
    useMemo: O0,
    useReducer: ef,
    useRef: T0,
    useState: function() {
      return ef(vi);
    },
    useDebugValue: Np,
    useDeferredValue: function(r, a) {
      var d = Vi();
      return qn === null ? af(d, r, a) : N0(
        d,
        qn.memoizedState,
        r,
        a
      );
    },
    useTransition: function() {
      var r = ef(vi)[0], a = Vi().memoizedState;
      return [
        typeof r == "boolean" ? r : sh(r),
        a
      ];
    },
    useSyncExternalStore: f0,
    useId: Dp
  };
  hu.useCacheRefresh = z0, hu.useMemoCache = Ps, hu.useHostTransitionStatus = sf, hu.useFormState = x0, hu.useActionState = x0, hu.useOptimistic = function(r, a) {
    var d = Vi();
    return qn !== null ? Mp(d, qn, r, a) : (d.baseState = r, [r, d.queue.dispatch]);
  };
  function zp(r, a, d, m) {
    a = r.memoizedState, d = d(m, a), d = d == null ? a : D({}, a, d), r.memoizedState = d, r.lanes === 0 && (r.updateQueue.baseState = d);
  }
  var Pp = {
    isMounted: function(r) {
      return (r = r._reactInternals) ? it(r) === r : !1;
    },
    enqueueSetState: function(r, a, d) {
      r = r._reactInternals;
      var m = ha(), C = Ha(m);
      C.payload = a, d != null && (C.callback = d), a = Ka(r, C, m), a !== null && (er(a, r, m), ac(a, r, m));
    },
    enqueueReplaceState: function(r, a, d) {
      r = r._reactInternals;
      var m = ha(), C = Ha(m);
      C.tag = 1, C.payload = a, d != null && (C.callback = d), a = Ka(r, C, m), a !== null && (er(a, r, m), ac(a, r, m));
    },
    enqueueForceUpdate: function(r, a) {
      r = r._reactInternals;
      var d = ha(), m = Ha(d);
      m.tag = 2, a != null && (m.callback = a), a = Ka(r, m, d), a !== null && (er(a, r, d), ac(a, r, d));
    }
  };
  function V0(r, a, d, m, C, B, $) {
    return r = r.stateNode, typeof r.shouldComponentUpdate == "function" ? r.shouldComponentUpdate(m, B, $) : a.prototype && a.prototype.isPureReactComponent ? !S(d, m) || !S(C, B) : !0;
  }
  function I0(r, a, d, m) {
    r = a.state, typeof a.componentWillReceiveProps == "function" && a.componentWillReceiveProps(d, m), typeof a.UNSAFE_componentWillReceiveProps == "function" && a.UNSAFE_componentWillReceiveProps(d, m), a.state !== r && Pp.enqueueReplaceState(a, a.state, null);
  }
  function fu(r, a) {
    var d = a;
    if ("ref" in a) {
      d = {};
      for (var m in a)
        m !== "ref" && (d[m] = a[m]);
    }
    if (r = r.defaultProps) {
      d === a && (d = D({}, d));
      for (var C in r)
        d[C] === void 0 && (d[C] = r[C]);
    }
    return d;
  }
  var lf = typeof reportError == "function" ? reportError : function(r) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var a = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof r == "object" && r !== null && typeof r.message == "string" ? String(r.message) : String(r),
        error: r
      });
      if (!window.dispatchEvent(a)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", r);
      return;
    }
    console.error(r);
  };
  function F0(r) {
    lf(r);
  }
  function q0(r) {
    console.error(r);
  }
  function G0(r) {
    lf(r);
  }
  function cf(r, a) {
    try {
      var d = r.onUncaughtError;
      d(a.value, { componentStack: a.stack });
    } catch (m) {
      setTimeout(function() {
        throw m;
      });
    }
  }
  function H0(r, a, d) {
    try {
      var m = r.onCaughtError;
      m(d.value, {
        componentStack: d.stack,
        errorBoundary: a.tag === 1 ? a.stateNode : null
      });
    } catch (C) {
      setTimeout(function() {
        throw C;
      });
    }
  }
  function Up(r, a, d) {
    return d = Ha(d), d.tag = 3, d.payload = { element: null }, d.callback = function() {
      cf(r, a);
    }, d;
  }
  function jp(r) {
    return r = Ha(r), r.tag = 3, r;
  }
  function K0(r, a, d, m) {
    var C = d.type.getDerivedStateFromError;
    if (typeof C == "function") {
      var B = m.value;
      r.payload = function() {
        return C(B);
      }, r.callback = function() {
        H0(a, d, m);
      };
    }
    var $ = d.stateNode;
    $ !== null && typeof $.componentDidCatch == "function" && (r.callback = function() {
      H0(a, d, m), typeof C != "function" && (tr === null ? tr = /* @__PURE__ */ new Set([this]) : tr.add(this));
      var at = m.stack;
      this.componentDidCatch(m.value, {
        componentStack: at !== null ? at : ""
      });
    });
  }
  function xv(r, a, d, m, C) {
    if (d.flags |= 32768, m !== null && typeof m == "object" && typeof m.then == "function") {
      if (a = d.alternate, a !== null && ch(
        a,
        d,
        C,
        !0
      ), d = Ca.current, d !== null) {
        switch (d.tag) {
          case 13:
            return po === null ? yh() : d.alternate === null && fi === 0 && (fi = 3), d.flags &= -257, d.flags |= 65536, d.lanes = C, m === Wh ? d.flags |= 16384 : (a = d.updateQueue, a === null ? d.updateQueue = /* @__PURE__ */ new Set([m]) : a.add(m), en(r, m, C)), !1;
          case 22:
            return d.flags |= 65536, m === Wh ? d.flags |= 16384 : (a = d.updateQueue, a === null ? (a = {
              transitions: null,
              markerInstances: null,
              retryQueue: /* @__PURE__ */ new Set([m])
            }, d.updateQueue = a) : (d = a.retryQueue, d === null ? a.retryQueue = /* @__PURE__ */ new Set([m]) : d.add(m)), en(r, m, C)), !1;
        }
        throw Error(i(435, d.tag));
      }
      return en(r, m, C), yh(), !1;
    }
    if (On)
      return a = Ca.current, a !== null ? ((a.flags & 65536) === 0 && (a.flags |= 256), a.flags |= 65536, a.lanes = C, m !== Zd && (r = Error(i(422), { cause: m }), fo(Ta(r, d)))) : (m !== Zd && (a = Error(i(423), {
        cause: m
      }), fo(
        Ta(a, d)
      )), r = r.current.alternate, r.flags |= 65536, C &= -C, r.lanes |= C, m = Ta(m, d), C = Up(
        r.stateNode,
        m,
        C
      ), hd(r, C), fi !== 4 && (fi = 2)), !1;
    var B = Error(i(520), { cause: m });
    if (B = Ta(B, d), gh === null ? gh = [B] : gh.push(B), fi !== 4 && (fi = 2), a === null) return !0;
    m = Ta(m, d), d = a;
    do {
      switch (d.tag) {
        case 3:
          return d.flags |= 65536, r = C & -C, d.lanes |= r, r = Up(d.stateNode, m, r), hd(d, r), !1;
        case 1:
          if (a = d.type, B = d.stateNode, (d.flags & 128) === 0 && (typeof a.getDerivedStateFromError == "function" || B !== null && typeof B.componentDidCatch == "function" && (tr === null || !tr.has(B))))
            return d.flags |= 65536, C &= -C, d.lanes |= C, C = jp(C), K0(
              C,
              r,
              d,
              m
            ), hd(d, C), !1;
      }
      d = d.return;
    } while (d !== null);
    return !1;
  }
  var qa = Error(i(461)), pr = !1;
  function mr(r, a, d, m) {
    a.child = r === null ? Jo(a, null, d, m) : Zo(
      a,
      r.child,
      d,
      m
    );
  }
  function Lp(r, a, d, m, C) {
    d = d.render;
    var B = a.ref;
    if ("ref" in m) {
      var $ = {};
      for (var at in m)
        at !== "ref" && ($[at] = m[at]);
    } else $ = m;
    return mu(a), m = wp(
      r,
      a,
      d,
      $,
      B,
      C
    ), at = Ep(), r !== null && !pr ? (ah(r, a, C), Ii(r, a, C)) : (On && at && Qd(a), a.flags |= 1, mr(r, a, m, C), a.child);
  }
  function Vp(r, a, d, m, C) {
    if (r === null) {
      var B = d.type;
      return typeof B == "function" && !fl(B) && B.defaultProps === void 0 && d.compare === null ? (a.tag = 15, a.type = B, Ip(
        r,
        a,
        B,
        m,
        C
      )) : (r = gd(
        d.type,
        null,
        m,
        a,
        a.mode,
        C
      ), r.ref = a.ref, r.return = a, a.child = r);
    }
    if (B = r.child, !Xp(r, C)) {
      var $ = B.memoizedProps;
      if (d = d.compare, d = d !== null ? d : S, d($, m) && r.ref === a.ref)
        return Ii(r, a, C);
    }
    return a.flags |= 1, r = ua(B, m), r.ref = a.ref, r.return = a, a.child = r;
  }
  function Ip(r, a, d, m, C) {
    if (r !== null) {
      var B = r.memoizedProps;
      if (S(B, m) && r.ref === a.ref)
        if (pr = !1, a.pendingProps = m = B, Xp(r, C))
          (r.flags & 131072) !== 0 && (pr = !0);
        else
          return a.lanes = r.lanes, Ii(r, a, C);
    }
    return qp(
      r,
      a,
      d,
      m,
      C
    );
  }
  function Y0(r, a, d) {
    var m = a.pendingProps, C = m.children, B = (a.stateNode._pendingVisibility & 2) !== 0, $ = r !== null ? r.memoizedState : null;
    if (ld(r, a), m.mode === "hidden" || B) {
      if ((a.flags & 128) !== 0) {
        if (m = $ !== null ? $.baseLanes | d : d, r !== null) {
          for (C = a.child = r.child, B = 0; C !== null; )
            B = B | C.lanes | C.childLanes, C = C.sibling;
          a.childLanes = B & ~m;
        } else a.childLanes = 0, a.child = null;
        return Fp(
          r,
          a,
          m,
          d
        );
      }
      if ((d & 536870912) !== 0)
        a.memoizedState = { baseLanes: 0, cachePool: null }, r !== null && id(
          a,
          $ !== null ? $.cachePool : null
        ), $ !== null ? Yl(a, $) : Qh(), xp(a);
      else
        return a.lanes = a.childLanes = 536870912, Fp(
          r,
          a,
          $ !== null ? $.baseLanes | d : d,
          d
        );
    } else
      $ !== null ? (id(a, $.cachePool), Yl(a, $), el(), a.memoizedState = null) : (r !== null && id(a, null), Qh(), el());
    return mr(r, a, C, d), a.child;
  }
  function Fp(r, a, d, m) {
    var C = rh();
    return C = C === null ? null : { parent: Li._currentValue, pool: C }, a.memoizedState = {
      baseLanes: d,
      cachePool: C
    }, r !== null && id(a, null), Qh(), xp(a), r !== null && ch(r, a, m, !0), null;
  }
  function ld(r, a) {
    var d = a.ref;
    if (d === null)
      r !== null && r.ref !== null && (a.flags |= 2097664);
    else {
      if (typeof d != "function" && typeof d != "object")
        throw Error(i(284));
      (r === null || r.ref !== d) && (a.flags |= 2097664);
    }
  }
  function qp(r, a, d, m, C) {
    return mu(a), d = wp(
      r,
      a,
      d,
      m,
      void 0,
      C
    ), m = Ep(), r !== null && !pr ? (ah(r, a, C), Ii(r, a, C)) : (On && m && Qd(a), a.flags |= 1, mr(r, a, d, C), a.child);
  }
  function X0(r, a, d, m, C, B) {
    return mu(a), a.updateQueue = null, d = h0(
      a,
      m,
      d,
      C
    ), d0(r), m = Ep(), r !== null && !pr ? (ah(r, a, B), Ii(r, a, B)) : (On && m && Qd(a), a.flags |= 1, mr(r, a, d, B), a.child);
  }
  function W0(r, a, d, m, C) {
    if (mu(a), a.stateNode === null) {
      var B = Fr, $ = d.contextType;
      typeof $ == "object" && $ !== null && (B = Hr($)), B = new d(m, B), a.memoizedState = B.state !== null && B.state !== void 0 ? B.state : null, B.updater = Pp, a.stateNode = B, B._reactInternals = a, B = a.stateNode, B.props = m, B.state = a.memoizedState, B.refs = {}, la(a), $ = d.contextType, B.context = typeof $ == "object" && $ !== null ? Hr($) : Fr, B.state = a.memoizedState, $ = d.getDerivedStateFromProps, typeof $ == "function" && (zp(
        a,
        d,
        $,
        m
      ), B.state = a.memoizedState), typeof d.getDerivedStateFromProps == "function" || typeof B.getSnapshotBeforeUpdate == "function" || typeof B.UNSAFE_componentWillMount != "function" && typeof B.componentWillMount != "function" || ($ = B.state, typeof B.componentWillMount == "function" && B.componentWillMount(), typeof B.UNSAFE_componentWillMount == "function" && B.UNSAFE_componentWillMount(), $ !== B.state && Pp.enqueueReplaceState(B, B.state, null), Ls(a, m, B, C), Kr(), B.state = a.memoizedState), typeof B.componentDidMount == "function" && (a.flags |= 4194308), m = !0;
    } else if (r === null) {
      B = a.stateNode;
      var at = a.memoizedProps, pt = fu(d, at);
      B.props = pt;
      var Mt = B.context, Zt = d.contextType;
      $ = Fr, typeof Zt == "object" && Zt !== null && ($ = Hr(Zt));
      var he = d.getDerivedStateFromProps;
      Zt = typeof he == "function" || typeof B.getSnapshotBeforeUpdate == "function", at = a.pendingProps !== at, Zt || typeof B.UNSAFE_componentWillReceiveProps != "function" && typeof B.componentWillReceiveProps != "function" || (at || Mt !== $) && I0(
        a,
        B,
        m,
        $
      ), Zi = !1;
      var qt = a.memoizedState;
      B.state = qt, Ls(a, m, B, C), Kr(), Mt = a.memoizedState, at || qt !== Mt || Zi ? (typeof he == "function" && (zp(
        a,
        d,
        he,
        m
      ), Mt = a.memoizedState), (pt = Zi || V0(
        a,
        d,
        pt,
        m,
        qt,
        Mt,
        $
      )) ? (Zt || typeof B.UNSAFE_componentWillMount != "function" && typeof B.componentWillMount != "function" || (typeof B.componentWillMount == "function" && B.componentWillMount(), typeof B.UNSAFE_componentWillMount == "function" && B.UNSAFE_componentWillMount()), typeof B.componentDidMount == "function" && (a.flags |= 4194308)) : (typeof B.componentDidMount == "function" && (a.flags |= 4194308), a.memoizedProps = m, a.memoizedState = Mt), B.props = m, B.state = Mt, B.context = $, m = pt) : (typeof B.componentDidMount == "function" && (a.flags |= 4194308), m = !1);
    } else {
      B = a.stateNode, mf(r, a), $ = a.memoizedProps, Zt = fu(d, $), B.props = Zt, he = a.pendingProps, qt = B.context, Mt = d.contextType, pt = Fr, typeof Mt == "object" && Mt !== null && (pt = Hr(Mt)), at = d.getDerivedStateFromProps, (Mt = typeof at == "function" || typeof B.getSnapshotBeforeUpdate == "function") || typeof B.UNSAFE_componentWillReceiveProps != "function" && typeof B.componentWillReceiveProps != "function" || ($ !== he || qt !== pt) && I0(
        a,
        B,
        m,
        pt
      ), Zi = !1, qt = a.memoizedState, B.state = qt, Ls(a, m, B, C), Kr();
      var $t = a.memoizedState;
      $ !== he || qt !== $t || Zi || r !== null && r.dependencies !== null && ud(r.dependencies) ? (typeof at == "function" && (zp(
        a,
        d,
        at,
        m
      ), $t = a.memoizedState), (Zt = Zi || V0(
        a,
        d,
        Zt,
        m,
        qt,
        $t,
        pt
      ) || r !== null && r.dependencies !== null && ud(r.dependencies)) ? (Mt || typeof B.UNSAFE_componentWillUpdate != "function" && typeof B.componentWillUpdate != "function" || (typeof B.componentWillUpdate == "function" && B.componentWillUpdate(m, $t, pt), typeof B.UNSAFE_componentWillUpdate == "function" && B.UNSAFE_componentWillUpdate(
        m,
        $t,
        pt
      )), typeof B.componentDidUpdate == "function" && (a.flags |= 4), typeof B.getSnapshotBeforeUpdate == "function" && (a.flags |= 1024)) : (typeof B.componentDidUpdate != "function" || $ === r.memoizedProps && qt === r.memoizedState || (a.flags |= 4), typeof B.getSnapshotBeforeUpdate != "function" || $ === r.memoizedProps && qt === r.memoizedState || (a.flags |= 1024), a.memoizedProps = m, a.memoizedState = $t), B.props = m, B.state = $t, B.context = pt, m = Zt) : (typeof B.componentDidUpdate != "function" || $ === r.memoizedProps && qt === r.memoizedState || (a.flags |= 4), typeof B.getSnapshotBeforeUpdate != "function" || $ === r.memoizedProps && qt === r.memoizedState || (a.flags |= 1024), m = !1);
    }
    return B = m, ld(r, a), m = (a.flags & 128) !== 0, B || m ? (B = a.stateNode, d = m && typeof d.getDerivedStateFromError != "function" ? null : B.render(), a.flags |= 1, r !== null && m ? (a.child = Zo(
      a,
      r.child,
      null,
      C
    ), a.child = Zo(
      a,
      null,
      d,
      C
    )) : mr(r, a, d, C), a.memoizedState = B.state, r = a.child) : r = Ii(
      r,
      a,
      C
    ), r;
  }
  function Gp(r, a, d, m) {
    return td(), a.flags |= 256, mr(r, a, d, m), a.child;
  }
  var Hp = { dehydrated: null, treeContext: null, retryLane: 0 };
  function Er(r) {
    return { baseLanes: r, cachePool: il() };
  }
  function uf(r, a, d) {
    return r = r !== null ? r.childLanes & ~d : 0, a && (r |= da), r;
  }
  function $0(r, a, d) {
    var m = a.pendingProps, C = !1, B = (a.flags & 128) !== 0, $;
    if (($ = B) || ($ = r !== null && r.memoizedState === null ? !1 : ($i.current & 2) !== 0), $ && (C = !0, a.flags &= -129), $ = (a.flags & 32) !== 0, a.flags &= -33, r === null) {
      if (On) {
        if (C ? tl(a) : el(), On) {
          var at = wr, pt;
          if (pt = at) {
            t: {
              for (pt = at, at = os; pt.nodeType !== 8; ) {
                if (!at) {
                  at = null;
                  break t;
                }
                if (pt = vl(
                  pt.nextSibling
                ), pt === null) {
                  at = null;
                  break t;
                }
              }
              at = pt;
            }
            at !== null ? (a.memoizedState = {
              dehydrated: at,
              treeContext: $o !== null ? { id: ho, overflow: Qo } : null,
              retryLane: 536870912
            }, pt = Hi(
              18,
              null,
              null,
              0
            ), pt.stateNode = at, pt.return = a, a.child = pt, Gr = a, wr = null, pt = !0) : pt = !1;
          }
          pt || au(a);
        }
        if (at = a.memoizedState, at !== null && (at = at.dehydrated, at !== null))
          return at.data === "$!" ? a.lanes = 16 : a.lanes = 536870912, null;
        mo(a);
      }
      return at = m.children, m = m.fallback, C ? (el(), C = a.mode, at = Yp(
        { mode: "hidden", children: at },
        C
      ), m = dc(
        m,
        C,
        d,
        null
      ), at.return = a, m.return = a, at.sibling = m, a.child = at, C = a.child, C.memoizedState = Er(d), C.childLanes = uf(
        r,
        $,
        d
      ), a.memoizedState = Hp, m) : (tl(a), Kp(a, at));
    }
    if (pt = r.memoizedState, pt !== null && (at = pt.dehydrated, at !== null)) {
      if (B)
        a.flags & 256 ? (tl(a), a.flags &= -257, a = df(
          r,
          a,
          d
        )) : a.memoizedState !== null ? (el(), a.child = r.child, a.flags |= 128, a = null) : (el(), C = m.fallback, at = a.mode, m = Yp(
          { mode: "visible", children: m.children },
          at
        ), C = dc(
          C,
          at,
          d,
          null
        ), C.flags |= 2, m.return = a, C.return = a, m.sibling = C, a.child = m, Zo(
          a,
          r.child,
          null,
          d
        ), m = a.child, m.memoizedState = Er(d), m.childLanes = uf(
          r,
          $,
          d
        ), a.memoizedState = Hp, a = C);
      else if (tl(a), at.data === "$!") {
        if ($ = at.nextSibling && at.nextSibling.dataset, $) var Mt = $.dgst;
        $ = Mt, m = Error(i(419)), m.stack = "", m.digest = $, fo({ value: m, source: null, stack: null }), a = df(
          r,
          a,
          d
        );
      } else if (pr || ch(r, a, d, !1), $ = (d & r.childLanes) !== 0, pr || $) {
        if ($ = Wn, $ !== null) {
          if (m = d & -d, (m & 42) !== 0) m = 1;
          else
            switch (m) {
              case 2:
                m = 1;
                break;
              case 8:
                m = 4;
                break;
              case 32:
                m = 16;
                break;
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
                m = 64;
                break;
              case 268435456:
                m = 134217728;
                break;
              default:
                m = 0;
            }
          if (m = (m & ($.suspendedLanes | d)) !== 0 ? 0 : m, m !== 0 && m !== pt.retryLane)
            throw pt.retryLane = m, ai(r, m), er($, r, m), qa;
        }
        at.data === "$?" || yh(), a = df(
          r,
          a,
          d
        );
      } else
        at.data === "$?" ? (a.flags |= 128, a.child = r.child, a = xu.bind(
          null,
          r
        ), at._reactRetry = a, a = null) : (r = pt.treeContext, wr = vl(
          at.nextSibling
        ), Gr = a, On = !0, ss = null, os = !1, r !== null && (si[Ia++] = ho, si[Ia++] = Qo, si[Ia++] = $o, ho = r.id, Qo = r.overflow, $o = a), a = Kp(
          a,
          m.children
        ), a.flags |= 4096);
      return a;
    }
    return C ? (el(), C = m.fallback, at = a.mode, pt = r.child, Mt = pt.sibling, m = ua(pt, {
      mode: "hidden",
      children: m.children
    }), m.subtreeFlags = pt.subtreeFlags & 31457280, Mt !== null ? C = ua(Mt, C) : (C = dc(
      C,
      at,
      d,
      null
    ), C.flags |= 2), C.return = a, m.return = a, m.sibling = C, a.child = m, m = C, C = a.child, at = r.child.memoizedState, at === null ? at = Er(d) : (pt = at.cachePool, pt !== null ? (Mt = Li._currentValue, pt = pt.parent !== Mt ? { parent: Mt, pool: Mt } : pt) : pt = il(), at = {
      baseLanes: at.baseLanes | d,
      cachePool: pt
    }), C.memoizedState = at, C.childLanes = uf(
      r,
      $,
      d
    ), a.memoizedState = Hp, m) : (tl(a), d = r.child, r = d.sibling, d = ua(d, {
      mode: "visible",
      children: m.children
    }), d.return = a, d.sibling = null, r !== null && ($ = a.deletions, $ === null ? (a.deletions = [r], a.flags |= 16) : $.push(r)), a.child = d, a.memoizedState = null, d);
  }
  function Kp(r, a) {
    return a = Yp(
      { mode: "visible", children: a },
      r.mode
    ), a.return = r, r.child = a;
  }
  function Yp(r, a) {
    return $p(r, a, 0, null);
  }
  function df(r, a, d) {
    return Zo(a, r.child, null, d), r = Kp(
      a,
      a.pendingProps.children
    ), r.flags |= 2, a.memoizedState = null, r;
  }
  function hf(r, a, d) {
    r.lanes |= a;
    var m = r.alternate;
    m !== null && (m.lanes |= a), Ga(r.return, a, d);
  }
  function ic(r, a, d, m, C) {
    var B = r.memoizedState;
    B === null ? r.memoizedState = {
      isBackwards: a,
      rendering: null,
      renderingStartTime: 0,
      last: m,
      tail: d,
      tailMode: C
    } : (B.isBackwards = a, B.rendering = null, B.renderingStartTime = 0, B.last = m, B.tail = d, B.tailMode = C);
  }
  function pu(r, a, d) {
    var m = a.pendingProps, C = m.revealOrder, B = m.tail;
    if (mr(r, a, m.children, d), m = $i.current, (m & 2) !== 0)
      m = m & 1 | 2, a.flags |= 128;
    else {
      if (r !== null && (r.flags & 128) !== 0)
        t: for (r = a.child; r !== null; ) {
          if (r.tag === 13)
            r.memoizedState !== null && hf(r, d, a);
          else if (r.tag === 19)
            hf(r, d, a);
          else if (r.child !== null) {
            r.child.return = r, r = r.child;
            continue;
          }
          if (r === a) break t;
          for (; r.sibling === null; ) {
            if (r.return === null || r.return === a)
              break t;
            r = r.return;
          }
          r.sibling.return = r.return, r = r.sibling;
        }
      m &= 1;
    }
    switch (Tt($i, m), C) {
      case "forwards":
        for (d = a.child, C = null; d !== null; )
          r = d.alternate, r !== null && nd(r) === null && (C = d), d = d.sibling;
        d = C, d === null ? (C = a.child, a.child = null) : (C = d.sibling, d.sibling = null), ic(
          a,
          !1,
          C,
          d,
          B
        );
        break;
      case "backwards":
        for (d = null, C = a.child, a.child = null; C !== null; ) {
          if (r = C.alternate, r !== null && nd(r) === null) {
            a.child = C;
            break;
          }
          r = C.sibling, C.sibling = d, d = C, C = r;
        }
        ic(
          a,
          !0,
          d,
          null,
          B
        );
        break;
      case "together":
        ic(a, !1, null, null, void 0);
        break;
      default:
        a.memoizedState = null;
    }
    return a.child;
  }
  function Ii(r, a, d) {
    if (r !== null && (a.dependencies = r.dependencies), Gs |= a.lanes, (d & a.childLanes) === 0)
      if (r !== null) {
        if (ch(
          r,
          a,
          d,
          !1
        ), (d & a.childLanes) === 0)
          return null;
      } else return null;
    if (r !== null && a.child !== r.child)
      throw Error(i(153));
    if (a.child !== null) {
      for (r = a.child, d = ua(r, r.pendingProps), a.child = d, d.return = a; r.sibling !== null; )
        r = r.sibling, d = d.sibling = ua(r, r.pendingProps), d.return = a;
      d.sibling = null;
    }
    return a.child;
  }
  function Xp(r, a) {
    return (r.lanes & a) !== 0 ? !0 : (r = r.dependencies, !!(r !== null && ud(r)));
  }
  function Tv(r, a, d) {
    switch (a.tag) {
      case 3:
        Ut(a, a.stateNode.containerInfo), rc(a, Li, r.memoizedState.cache), td();
        break;
      case 27:
      case 5:
        re(a);
        break;
      case 4:
        Ut(a, a.stateNode.containerInfo);
        break;
      case 10:
        rc(
          a,
          a.type,
          a.memoizedProps.value
        );
        break;
      case 13:
        var m = a.memoizedState;
        if (m !== null)
          return m.dehydrated !== null ? (tl(a), a.flags |= 128, null) : (d & a.child.childLanes) !== 0 ? $0(r, a, d) : (tl(a), r = Ii(
            r,
            a,
            d
          ), r !== null ? r.sibling : null);
        tl(a);
        break;
      case 19:
        var C = (r.flags & 128) !== 0;
        if (m = (d & a.childLanes) !== 0, m || (ch(
          r,
          a,
          d,
          !1
        ), m = (d & a.childLanes) !== 0), C) {
          if (m)
            return pu(
              r,
              a,
              d
            );
          a.flags |= 128;
        }
        if (C = a.memoizedState, C !== null && (C.rendering = null, C.tail = null, C.lastEffect = null), Tt($i, $i.current), m) break;
        return null;
      case 22:
      case 23:
        return a.lanes = 0, Y0(r, a, d);
      case 24:
        rc(a, Li, r.memoizedState.cache);
    }
    return Ii(r, a, d);
  }
  function lh(r, a, d) {
    if (r !== null)
      if (r.memoizedProps !== a.pendingProps)
        pr = !0;
      else {
        if (!Xp(r, d) && (a.flags & 128) === 0)
          return pr = !1, Tv(
            r,
            a,
            d
          );
        pr = (r.flags & 131072) !== 0;
      }
    else
      pr = !1, On && (a.flags & 1048576) !== 0 && _p(a, $d, a.index);
    switch (a.lanes = 0, a.tag) {
      case 16:
        t: {
          r = a.pendingProps;
          var m = a.elementType, C = m._init;
          if (m = C(m._payload), a.type = m, typeof m == "function")
            fl(m) ? (r = fu(m, r), a.tag = 1, a = W0(
              null,
              a,
              m,
              r,
              d
            )) : (a.tag = 0, a = qp(
              null,
              a,
              m,
              r,
              d
            ));
          else {
            if (m != null) {
              if (C = m.$$typeof, C === _) {
                a.tag = 11, a = Lp(
                  null,
                  a,
                  m,
                  r,
                  d
                );
                break t;
              } else if (C === O) {
                a.tag = 14, a = Vp(
                  null,
                  a,
                  m,
                  r,
                  d
                );
                break t;
              }
            }
            throw a = j(m) || m, Error(i(306, a, ""));
          }
        }
        return a;
      case 0:
        return qp(
          r,
          a,
          a.type,
          a.pendingProps,
          d
        );
      case 1:
        return m = a.type, C = fu(
          m,
          a.pendingProps
        ), W0(
          r,
          a,
          m,
          C,
          d
        );
      case 3:
        t: {
          if (Ut(
            a,
            a.stateNode.containerInfo
          ), r === null) throw Error(i(387));
          var B = a.pendingProps;
          C = a.memoizedState, m = C.element, mf(r, a), Ls(a, B, null, d);
          var $ = a.memoizedState;
          if (B = $.cache, rc(a, Li, B), B !== C.cache && ff(
            a,
            [Li],
            d,
            !0
          ), Kr(), B = $.element, C.isDehydrated)
            if (C = {
              element: B,
              isDehydrated: !1,
              cache: $.cache
            }, a.updateQueue.baseState = C, a.memoizedState = C, a.flags & 256) {
              a = Gp(
                r,
                a,
                B,
                d
              );
              break t;
            } else if (B !== m) {
              m = Ta(
                Error(i(424)),
                a
              ), fo(m), a = Gp(
                r,
                a,
                B,
                d
              );
              break t;
            } else
              for (wr = vl(
                a.stateNode.containerInfo.firstChild
              ), Gr = a, On = !0, ss = null, os = !0, d = Jo(
                a,
                null,
                B,
                d
              ), a.child = d; d; )
                d.flags = d.flags & -3 | 4096, d = d.sibling;
          else {
            if (td(), B === m) {
              a = Ii(
                r,
                a,
                d
              );
              break t;
            }
            mr(r, a, B, d);
          }
          a = a.child;
        }
        return a;
      case 26:
        return ld(r, a), r === null ? (d = hS(
          a.type,
          null,
          a.pendingProps,
          null
        )) ? a.memoizedState = d : On || (d = a.type, r = a.pendingProps, m = iy(
          ie.current
        ).createElement(d), m[Pi] = a, m[rn] = r, fa(m, d, r), Pn(m), a.stateNode = m) : a.memoizedState = hS(
          a.type,
          r.memoizedProps,
          a.pendingProps,
          r.memoizedState
        ), null;
      case 27:
        return re(a), r === null && On && (m = a.stateNode = cS(
          a.type,
          a.pendingProps,
          ie.current
        ), Gr = a, os = !0, wr = vl(
          m.firstChild
        )), m = a.pendingProps.children, r !== null || On ? mr(
          r,
          a,
          m,
          d
        ) : a.child = Zo(
          a,
          null,
          m,
          d
        ), ld(r, a), a.child;
      case 5:
        return r === null && On && ((C = m = wr) && (m = SC(
          m,
          a.type,
          a.pendingProps,
          os
        ), m !== null ? (a.stateNode = m, Gr = a, wr = vl(
          m.firstChild
        ), os = !1, C = !0) : C = !1), C || au(a)), re(a), C = a.type, B = a.pendingProps, $ = r !== null ? r.memoizedProps : null, m = B.children, Bv(C, B) ? m = null : $ !== null && Bv(C, $) && (a.flags |= 32), a.memoizedState !== null && (C = wp(
          r,
          a,
          vv,
          null,
          null,
          d
        ), am._currentValue = C), ld(r, a), mr(r, a, m, d), a.child;
      case 6:
        return r === null && On && ((r = d = wr) && (d = xC(
          d,
          a.pendingProps,
          os
        ), d !== null ? (a.stateNode = d, Gr = a, wr = null, r = !0) : r = !1), r || au(a)), null;
      case 13:
        return $0(r, a, d);
      case 4:
        return Ut(
          a,
          a.stateNode.containerInfo
        ), m = a.pendingProps, r === null ? a.child = Zo(
          a,
          null,
          m,
          d
        ) : mr(
          r,
          a,
          m,
          d
        ), a.child;
      case 11:
        return Lp(
          r,
          a,
          a.type,
          a.pendingProps,
          d
        );
      case 7:
        return mr(
          r,
          a,
          a.pendingProps,
          d
        ), a.child;
      case 8:
        return mr(
          r,
          a,
          a.pendingProps.children,
          d
        ), a.child;
      case 12:
        return mr(
          r,
          a,
          a.pendingProps.children,
          d
        ), a.child;
      case 10:
        return m = a.pendingProps, rc(a, a.type, m.value), mr(
          r,
          a,
          m.children,
          d
        ), a.child;
      case 9:
        return C = a.type._context, m = a.pendingProps.children, mu(a), C = Hr(C), m = m(C), a.flags |= 1, mr(r, a, m, d), a.child;
      case 14:
        return Vp(
          r,
          a,
          a.type,
          a.pendingProps,
          d
        );
      case 15:
        return Ip(
          r,
          a,
          a.type,
          a.pendingProps,
          d
        );
      case 19:
        return pu(r, a, d);
      case 22:
        return Y0(r, a, d);
      case 24:
        return mu(a), m = Hr(Li), r === null ? (C = rh(), C === null && (C = Wn, B = Tp(), C.pooledCache = B, B.refCount++, B !== null && (C.pooledCacheLanes |= d), C = B), a.memoizedState = {
          parent: m,
          cache: C
        }, la(a), rc(a, Li, C)) : ((r.lanes & d) !== 0 && (mf(r, a), Ls(a, null, null, d), Kr()), C = r.memoizedState, B = a.memoizedState, C.parent !== m ? (C = { parent: m, cache: m }, a.memoizedState = C, a.lanes === 0 && (a.memoizedState = a.updateQueue.baseState = C), rc(a, Li, m)) : (m = B.cache, rc(a, Li, m), m !== C.cache && ff(
          a,
          [Li],
          d,
          !0
        ))), mr(
          r,
          a,
          a.pendingProps.children,
          d
        ), a.child;
      case 29:
        throw a.pendingProps;
    }
    throw Error(i(156, a.tag));
  }
  var cd = lt(null), bo = null, js = null;
  function rc(r, a, d) {
    Tt(cd, a._currentValue), a._currentValue = d;
  }
  function ol(r) {
    r._currentValue = cd.current, ft(cd);
  }
  function Ga(r, a, d) {
    for (; r !== null; ) {
      var m = r.alternate;
      if ((r.childLanes & a) !== a ? (r.childLanes |= a, m !== null && (m.childLanes |= a)) : m !== null && (m.childLanes & a) !== a && (m.childLanes |= a), r === d) break;
      r = r.return;
    }
  }
  function ff(r, a, d, m) {
    var C = r.child;
    for (C !== null && (C.return = r); C !== null; ) {
      var B = C.dependencies;
      if (B !== null) {
        var $ = C.child;
        B = B.firstContext;
        t: for (; B !== null; ) {
          var at = B;
          B = C;
          for (var pt = 0; pt < a.length; pt++)
            if (at.context === a[pt]) {
              B.lanes |= d, at = B.alternate, at !== null && (at.lanes |= d), Ga(
                B.return,
                d,
                r
              ), m || ($ = null);
              break t;
            }
          B = at.next;
        }
      } else if (C.tag === 18) {
        if ($ = C.return, $ === null) throw Error(i(341));
        $.lanes |= d, B = $.alternate, B !== null && (B.lanes |= d), Ga($, d, r), $ = null;
      } else $ = C.child;
      if ($ !== null) $.return = C;
      else
        for ($ = C; $ !== null; ) {
          if ($ === r) {
            $ = null;
            break;
          }
          if (C = $.sibling, C !== null) {
            C.return = $.return, $ = C;
            break;
          }
          $ = $.return;
        }
      C = $;
    }
  }
  function ch(r, a, d, m) {
    r = null;
    for (var C = a, B = !1; C !== null; ) {
      if (!B) {
        if ((C.flags & 524288) !== 0) B = !0;
        else if ((C.flags & 262144) !== 0) break;
      }
      if (C.tag === 10) {
        var $ = C.alternate;
        if ($ === null) throw Error(i(387));
        if ($ = $.memoizedProps, $ !== null) {
          var at = C.type;
          zr(C.pendingProps.value, $.value) || (r !== null ? r.push(at) : r = [at]);
        }
      } else if (C === ce.current) {
        if ($ = C.alternate, $ === null) throw Error(i(387));
        $.memoizedState.memoizedState !== C.memoizedState.memoizedState && (r !== null ? r.push(am) : r = [am]);
      }
      C = C.return;
    }
    r !== null && ff(
      a,
      r,
      d,
      m
    ), a.flags |= 262144;
  }
  function ud(r) {
    for (r = r.firstContext; r !== null; ) {
      if (!zr(
        r.context._currentValue,
        r.memoizedValue
      ))
        return !0;
      r = r.next;
    }
    return !1;
  }
  function mu(r) {
    bo = r, js = null, r = r.dependencies, r !== null && (r.firstContext = null);
  }
  function Hr(r) {
    return dd(bo, r);
  }
  function pf(r, a) {
    return bo === null && mu(r), dd(r, a);
  }
  function dd(r, a) {
    var d = a._currentValue;
    if (a = { context: a, memoizedValue: d, next: null }, js === null) {
      if (r === null) throw Error(i(308));
      js = a, r.dependencies = { lanes: 0, firstContext: a }, r.flags |= 524288;
    } else js = js.next = a;
    return d;
  }
  var Zi = !1;
  function la(r) {
    r.updateQueue = {
      baseState: r.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, lanes: 0, hiddenCallbacks: null },
      callbacks: null
    };
  }
  function mf(r, a) {
    r = r.updateQueue, a.updateQueue === r && (a.updateQueue = {
      baseState: r.baseState,
      firstBaseUpdate: r.firstBaseUpdate,
      lastBaseUpdate: r.lastBaseUpdate,
      shared: r.shared,
      callbacks: null
    });
  }
  function Ha(r) {
    return { lane: r, tag: 0, payload: null, callback: null, next: null };
  }
  function Ka(r, a, d) {
    var m = r.updateQueue;
    if (m === null) return null;
    if (m = m.shared, (tn & 2) !== 0) {
      var C = m.pending;
      return C === null ? a.next = a : (a.next = C.next, C.next = a), m.pending = a, a = ji(r), uo(r, null, d), a;
    }
    return Ge(r, m, a, d), ji(r);
  }
  function ac(r, a, d) {
    if (a = a.updateQueue, a !== null && (a = a.shared, (d & 4194176) !== 0)) {
      var m = a.lanes;
      m &= r.pendingLanes, d |= m, a.lanes = d, Ci(r, d);
    }
  }
  function hd(r, a) {
    var d = r.updateQueue, m = r.alternate;
    if (m !== null && (m = m.updateQueue, d === m)) {
      var C = null, B = null;
      if (d = d.firstBaseUpdate, d !== null) {
        do {
          var $ = {
            lane: d.lane,
            tag: d.tag,
            payload: d.payload,
            callback: null,
            next: null
          };
          B === null ? C = B = $ : B = B.next = $, d = d.next;
        } while (d !== null);
        B === null ? C = B = a : B = B.next = a;
      } else C = B = a;
      d = {
        baseState: m.baseState,
        firstBaseUpdate: C,
        lastBaseUpdate: B,
        shared: m.shared,
        callbacks: m.callbacks
      }, r.updateQueue = d;
      return;
    }
    r = d.lastBaseUpdate, r === null ? d.firstBaseUpdate = a : r.next = a, d.lastBaseUpdate = a;
  }
  var Ea = !1;
  function Kr() {
    if (Ea) {
      var r = $l;
      if (r !== null) throw r;
    }
  }
  function Ls(r, a, d, m) {
    Ea = !1;
    var C = r.updateQueue;
    Zi = !1;
    var B = C.firstBaseUpdate, $ = C.lastBaseUpdate, at = C.shared.pending;
    if (at !== null) {
      C.shared.pending = null;
      var pt = at, Mt = pt.next;
      pt.next = null, $ === null ? B = Mt : $.next = Mt, $ = pt;
      var Zt = r.alternate;
      Zt !== null && (Zt = Zt.updateQueue, at = Zt.lastBaseUpdate, at !== $ && (at === null ? Zt.firstBaseUpdate = Mt : at.next = Mt, Zt.lastBaseUpdate = pt));
    }
    if (B !== null) {
      var he = C.baseState;
      $ = 0, Zt = Mt = pt = null, at = B;
      do {
        var qt = at.lane & -536870913, $t = qt !== at.lane;
        if ($t ? (Ie & qt) === qt : (m & qt) === qt) {
          qt !== 0 && qt === lu && (Ea = !0), Zt !== null && (Zt = Zt.next = {
            lane: 0,
            tag: at.tag,
            payload: at.payload,
            callback: null,
            next: null
          });
          t: {
            var Pe = r, sn = at;
            qt = a;
            var nr = d;
            switch (sn.tag) {
              case 1:
                if (Pe = sn.payload, typeof Pe == "function") {
                  he = Pe.call(nr, he, qt);
                  break t;
                }
                he = Pe;
                break t;
              case 3:
                Pe.flags = Pe.flags & -65537 | 128;
              case 0:
                if (Pe = sn.payload, qt = typeof Pe == "function" ? Pe.call(nr, he, qt) : Pe, qt == null) break t;
                he = D({}, he, qt);
                break t;
              case 2:
                Zi = !0;
            }
          }
          qt = at.callback, qt !== null && (r.flags |= 64, $t && (r.flags |= 8192), $t = C.callbacks, $t === null ? C.callbacks = [qt] : $t.push(qt));
        } else
          $t = {
            lane: qt,
            tag: at.tag,
            payload: at.payload,
            callback: at.callback,
            next: null
          }, Zt === null ? (Mt = Zt = $t, pt = he) : Zt = Zt.next = $t, $ |= qt;
        if (at = at.next, at === null) {
          if (at = C.shared.pending, at === null)
            break;
          $t = at, at = $t.next, $t.next = null, C.lastBaseUpdate = $t, C.shared.pending = null;
        }
      } while (!0);
      Zt === null && (pt = he), C.baseState = pt, C.firstBaseUpdate = Mt, C.lastBaseUpdate = Zt, B === null && (C.shared.lanes = 0), Gs |= $, r.lanes = $, r.memoizedState = he;
    }
  }
  function _o(r, a) {
    if (typeof r != "function")
      throw Error(i(191, r));
    r.call(a);
  }
  function So(r, a) {
    var d = r.callbacks;
    if (d !== null)
      for (r.callbacks = null, r = 0; r < d.length; r++)
        _o(d[r], a);
  }
  function Fi(r, a) {
    try {
      var d = a.updateQueue, m = d !== null ? d.lastEffect : null;
      if (m !== null) {
        var C = m.next;
        d = C;
        do {
          if ((d.tag & r) === r) {
            m = void 0;
            var B = d.create, $ = d.inst;
            m = B(), $.destroy = m;
          }
          d = d.next;
        } while (d !== C);
      }
    } catch (at) {
      ge(a, a.return, at);
    }
  }
  function ls(r, a, d) {
    try {
      var m = a.updateQueue, C = m !== null ? m.lastEffect : null;
      if (C !== null) {
        var B = C.next;
        m = B;
        do {
          if ((m.tag & r) === r) {
            var $ = m.inst, at = $.destroy;
            if (at !== void 0) {
              $.destroy = void 0, C = a;
              var pt = d;
              try {
                at();
              } catch (Mt) {
                ge(
                  C,
                  pt,
                  Mt
                );
              }
            }
          }
          m = m.next;
        } while (m !== B);
      }
    } catch (Mt) {
      ge(a, a.return, Mt);
    }
  }
  function ll(r) {
    var a = r.updateQueue;
    if (a !== null) {
      var d = r.stateNode;
      try {
        So(a, d);
      } catch (m) {
        ge(r, r.return, m);
      }
    }
  }
  function uh(r, a, d) {
    d.props = fu(
      r.type,
      r.memoizedProps
    ), d.state = r.memoizedState;
    try {
      d.componentWillUnmount();
    } catch (m) {
      ge(r, a, m);
    }
  }
  function qi(r, a) {
    try {
      var d = r.ref;
      if (d !== null) {
        var m = r.stateNode;
        switch (r.tag) {
          case 26:
          case 27:
          case 5:
            var C = m;
            break;
          default:
            C = m;
        }
        typeof d == "function" ? r.refCleanup = d(C) : d.current = C;
      }
    } catch (B) {
      ge(r, a, B);
    }
  }
  function Xn(r, a) {
    var d = r.ref, m = r.refCleanup;
    if (d !== null)
      if (typeof m == "function")
        try {
          m();
        } catch (C) {
          ge(r, a, C);
        } finally {
          r.refCleanup = null, r = r.alternate, r != null && (r.refCleanup = null);
        }
      else if (typeof d == "function")
        try {
          d(null);
        } catch (C) {
          ge(r, a, C);
        }
      else d.current = null;
  }
  function Nn(r) {
    var a = r.type, d = r.memoizedProps, m = r.stateNode;
    try {
      t: switch (a) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          d.autoFocus && m.focus();
          break t;
        case "img":
          d.src ? m.src = d.src : d.srcSet && (m.srcset = d.srcSet);
      }
    } catch (C) {
      ge(r, r.return, C);
    }
  }
  function cs(r, a, d) {
    try {
      var m = r.stateNode;
      gC(m, r.type, d, a), m[rn] = a;
    } catch (C) {
      ge(r, r.return, C);
    }
  }
  function Vs(r) {
    return r.tag === 5 || r.tag === 3 || r.tag === 26 || r.tag === 27 || r.tag === 4;
  }
  function dh(r) {
    t: for (; ; ) {
      for (; r.sibling === null; ) {
        if (r.return === null || Vs(r.return)) return null;
        r = r.return;
      }
      for (r.sibling.return = r.return, r = r.sibling; r.tag !== 5 && r.tag !== 6 && r.tag !== 27 && r.tag !== 18; ) {
        if (r.flags & 2 || r.child === null || r.tag === 4) continue t;
        r.child.return = r, r = r.child;
      }
      if (!(r.flags & 2)) return r.stateNode;
    }
  }
  function Aa(r, a, d) {
    var m = r.tag;
    if (m === 5 || m === 6)
      r = r.stateNode, a ? d.nodeType === 8 ? d.parentNode.insertBefore(r, a) : d.insertBefore(r, a) : (d.nodeType === 8 ? (a = d.parentNode, a.insertBefore(r, d)) : (a = d, a.appendChild(r)), d = d._reactRootContainer, d != null || a.onclick !== null || (a.onclick = ny));
    else if (m !== 4 && m !== 27 && (r = r.child, r !== null))
      for (Aa(r, a, d), r = r.sibling; r !== null; )
        Aa(r, a, d), r = r.sibling;
  }
  function cl(r, a, d) {
    var m = r.tag;
    if (m === 5 || m === 6)
      r = r.stateNode, a ? d.insertBefore(r, a) : d.appendChild(r);
    else if (m !== 4 && m !== 27 && (r = r.child, r !== null))
      for (cl(r, a, d), r = r.sibling; r !== null; )
        cl(r, a, d), r = r.sibling;
  }
  var Is = !1, di = !1, sc = !1, gf = typeof WeakSet == "function" ? WeakSet : Set, Gi = null, yf = !1;
  function fd(r, a) {
    if (r = r.containerInfo, kv = cy, r = Z(r), et(r)) {
      if ("selectionStart" in r)
        var d = {
          start: r.selectionStart,
          end: r.selectionEnd
        };
      else
        t: {
          d = (d = r.ownerDocument) && d.defaultView || window;
          var m = d.getSelection && d.getSelection();
          if (m && m.rangeCount !== 0) {
            d = m.anchorNode;
            var C = m.anchorOffset, B = m.focusNode;
            m = m.focusOffset;
            try {
              d.nodeType, B.nodeType;
            } catch {
              d = null;
              break t;
            }
            var $ = 0, at = -1, pt = -1, Mt = 0, Zt = 0, he = r, qt = null;
            e: for (; ; ) {
              for (var $t; he !== d || C !== 0 && he.nodeType !== 3 || (at = $ + C), he !== B || m !== 0 && he.nodeType !== 3 || (pt = $ + m), he.nodeType === 3 && ($ += he.nodeValue.length), ($t = he.firstChild) !== null; )
                qt = he, he = $t;
              for (; ; ) {
                if (he === r) break e;
                if (qt === d && ++Mt === C && (at = $), qt === B && ++Zt === m && (pt = $), ($t = he.nextSibling) !== null) break;
                he = qt, qt = he.parentNode;
              }
              he = $t;
            }
            d = at === -1 || pt === -1 ? null : { start: at, end: pt };
          } else d = null;
        }
      d = d || { start: 0, end: 0 };
    } else d = null;
    for (Dv = { focusedElem: r, selectionRange: d }, cy = !1, Gi = a; Gi !== null; )
      if (a = Gi, r = a.child, (a.subtreeFlags & 1028) !== 0 && r !== null)
        r.return = a, Gi = r;
      else
        for (; Gi !== null; ) {
          switch (a = Gi, B = a.alternate, r = a.flags, a.tag) {
            case 0:
              break;
            case 11:
            case 15:
              break;
            case 1:
              if ((r & 1024) !== 0 && B !== null) {
                r = void 0, d = a, C = B.memoizedProps, B = B.memoizedState, m = d.stateNode;
                try {
                  var Pe = fu(
                    d.type,
                    C,
                    d.elementType === d.type
                  );
                  r = m.getSnapshotBeforeUpdate(
                    Pe,
                    B
                  ), m.__reactInternalSnapshotBeforeUpdate = r;
                } catch (sn) {
                  ge(
                    d,
                    d.return,
                    sn
                  );
                }
              }
              break;
            case 3:
              if ((r & 1024) !== 0) {
                if (r = a.stateNode.containerInfo, d = r.nodeType, d === 9)
                  Uv(r);
                else if (d === 1)
                  switch (r.nodeName) {
                    case "HEAD":
                    case "HTML":
                    case "BODY":
                      Uv(r);
                      break;
                    default:
                      r.textContent = "";
                  }
              }
              break;
            case 5:
            case 26:
            case 27:
            case 6:
            case 4:
            case 17:
              break;
            default:
              if ((r & 1024) !== 0) throw Error(i(163));
          }
          if (r = a.sibling, r !== null) {
            r.return = a.return, Gi = r;
            break;
          }
          Gi = a.return;
        }
    return Pe = yf, yf = !1, Pe;
  }
  function pd(r, a, d) {
    var m = d.flags;
    switch (d.tag) {
      case 0:
      case 11:
      case 15:
        xo(r, d), m & 4 && Fi(5, d);
        break;
      case 1:
        if (xo(r, d), m & 4)
          if (r = d.stateNode, a === null)
            try {
              r.componentDidMount();
            } catch (at) {
              ge(d, d.return, at);
            }
          else {
            var C = fu(
              d.type,
              a.memoizedProps
            );
            a = a.memoizedState;
            try {
              r.componentDidUpdate(
                C,
                a,
                r.__reactInternalSnapshotBeforeUpdate
              );
            } catch (at) {
              ge(
                d,
                d.return,
                at
              );
            }
          }
        m & 64 && ll(d), m & 512 && qi(d, d.return);
        break;
      case 3:
        if (xo(r, d), m & 64 && (m = d.updateQueue, m !== null)) {
          if (r = null, d.child !== null)
            switch (d.child.tag) {
              case 27:
              case 5:
                r = d.child.stateNode;
                break;
              case 1:
                r = d.child.stateNode;
            }
          try {
            So(m, r);
          } catch (at) {
            ge(d, d.return, at);
          }
        }
        break;
      case 26:
        xo(r, d), m & 512 && qi(d, d.return);
        break;
      case 27:
      case 5:
        xo(r, d), a === null && m & 4 && Nn(d), m & 512 && qi(d, d.return);
        break;
      case 12:
        xo(r, d);
        break;
      case 13:
        xo(r, d), m & 4 && Q0(r, d);
        break;
      case 22:
        if (C = d.memoizedState !== null || Is, !C) {
          a = a !== null && a.memoizedState !== null || di;
          var B = Is, $ = di;
          Is = C, (di = a) && !$ ? qs(
            r,
            d,
            (d.subtreeFlags & 8772) !== 0
          ) : xo(r, d), Is = B, di = $;
        }
        m & 512 && (d.memoizedProps.mode === "manual" ? qi(d, d.return) : Xn(d, d.return));
        break;
      default:
        xo(r, d);
    }
  }
  function vf(r) {
    var a = r.alternate;
    a !== null && (r.alternate = null, vf(a)), r.child = null, r.deletions = null, r.sibling = null, r.tag === 5 && (a = r.stateNode, a !== null && Ua(a)), r.stateNode = null, r.return = null, r.dependencies = null, r.memoizedProps = null, r.memoizedState = null, r.pendingProps = null, r.stateNode = null, r.updateQueue = null;
  }
  var hi = null, Ar = !1;
  function Yr(r, a, d) {
    for (d = d.child; d !== null; )
      bf(r, a, d), d = d.sibling;
  }
  function bf(r, a, d) {
    if (Me && typeof Me.onCommitFiberUnmount == "function")
      try {
        Me.onCommitFiberUnmount(fe, d);
      } catch {
      }
    switch (d.tag) {
      case 26:
        di || Xn(d, a), Yr(
          r,
          a,
          d
        ), d.memoizedState ? d.memoizedState.count-- : d.stateNode && (d = d.stateNode, d.parentNode.removeChild(d));
        break;
      case 27:
        di || Xn(d, a);
        var m = hi, C = Ar;
        for (hi = d.stateNode, Yr(
          r,
          a,
          d
        ), d = d.stateNode, a = d.attributes; a.length; )
          d.removeAttributeNode(a[0]);
        Ua(d), hi = m, Ar = C;
        break;
      case 5:
        di || Xn(d, a);
      case 6:
        C = hi;
        var B = Ar;
        if (hi = null, Yr(
          r,
          a,
          d
        ), hi = C, Ar = B, hi !== null)
          if (Ar)
            try {
              r = hi, m = d.stateNode, r.nodeType === 8 ? r.parentNode.removeChild(m) : r.removeChild(m);
            } catch ($) {
              ge(
                d,
                a,
                $
              );
            }
          else
            try {
              hi.removeChild(d.stateNode);
            } catch ($) {
              ge(
                d,
                a,
                $
              );
            }
        break;
      case 18:
        hi !== null && (Ar ? (a = hi, d = d.stateNode, a.nodeType === 8 ? Pv(
          a.parentNode,
          d
        ) : a.nodeType === 1 && Pv(a, d), cm(a)) : Pv(hi, d.stateNode));
        break;
      case 4:
        m = hi, C = Ar, hi = d.stateNode.containerInfo, Ar = !0, Yr(
          r,
          a,
          d
        ), hi = m, Ar = C;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        di || ls(2, d, a), di || ls(4, d, a), Yr(
          r,
          a,
          d
        );
        break;
      case 1:
        di || (Xn(d, a), m = d.stateNode, typeof m.componentWillUnmount == "function" && uh(
          d,
          a,
          m
        )), Yr(
          r,
          a,
          d
        );
        break;
      case 21:
        Yr(
          r,
          a,
          d
        );
        break;
      case 22:
        di || Xn(d, a), di = (m = di) || d.memoizedState !== null, Yr(
          r,
          a,
          d
        ), di = m;
        break;
      default:
        Yr(
          r,
          a,
          d
        );
    }
  }
  function Q0(r, a) {
    if (a.memoizedState === null && (r = a.alternate, r !== null && (r = r.memoizedState, r !== null && (r = r.dehydrated, r !== null))))
      try {
        cm(r);
      } catch (d) {
        ge(a, a.return, d);
      }
  }
  function hh(r) {
    switch (r.tag) {
      case 13:
      case 19:
        var a = r.stateNode;
        return a === null && (a = r.stateNode = new gf()), a;
      case 22:
        return r = r.stateNode, a = r._retryCache, a === null && (a = r._retryCache = new gf()), a;
      default:
        throw Error(i(435, r.tag));
    }
  }
  function fh(r, a) {
    var d = hh(r);
    a.forEach(function(m) {
      var C = Vt.bind(null, r, m);
      d.has(m) || (d.add(m), m.then(C, C));
    });
  }
  function ca(r, a) {
    var d = a.deletions;
    if (d !== null)
      for (var m = 0; m < d.length; m++) {
        var C = d[m], B = r, $ = a, at = $;
        t: for (; at !== null; ) {
          switch (at.tag) {
            case 27:
            case 5:
              hi = at.stateNode, Ar = !1;
              break t;
            case 3:
              hi = at.stateNode.containerInfo, Ar = !0;
              break t;
            case 4:
              hi = at.stateNode.containerInfo, Ar = !0;
              break t;
          }
          at = at.return;
        }
        if (hi === null) throw Error(i(160));
        bf(B, $, C), hi = null, Ar = !1, B = C.alternate, B !== null && (B.return = null), C.return = null;
      }
    if (a.subtreeFlags & 13878)
      for (a = a.child; a !== null; )
        gu(a, r), a = a.sibling;
  }
  var Xr = null;
  function gu(r, a) {
    var d = r.alternate, m = r.flags;
    switch (r.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        ca(a, r), Wr(r), m & 4 && (ls(3, r, r.return), Fi(3, r), ls(5, r, r.return));
        break;
      case 1:
        ca(a, r), Wr(r), m & 512 && (di || d === null || Xn(d, d.return)), m & 64 && Is && (r = r.updateQueue, r !== null && (m = r.callbacks, m !== null && (d = r.shared.hiddenCallbacks, r.shared.hiddenCallbacks = d === null ? m : d.concat(m))));
        break;
      case 26:
        var C = Xr;
        if (ca(a, r), Wr(r), m & 512 && (di || d === null || Xn(d, d.return)), m & 4) {
          var B = d !== null ? d.memoizedState : null;
          if (m = r.memoizedState, d === null)
            if (m === null)
              if (r.stateNode === null) {
                t: {
                  m = r.type, d = r.memoizedProps, C = C.ownerDocument || C;
                  e: switch (m) {
                    case "title":
                      B = C.getElementsByTagName("title")[0], (!B || B[eo] || B[Pi] || B.namespaceURI === "http://www.w3.org/2000/svg" || B.hasAttribute("itemprop")) && (B = C.createElement(m), C.head.insertBefore(
                        B,
                        C.querySelector("head > title")
                      )), fa(B, m, d), B[Pi] = r, Pn(B), m = B;
                      break t;
                    case "link":
                      var $ = mS(
                        "link",
                        "href",
                        C
                      ).get(m + (d.href || ""));
                      if ($) {
                        for (var at = 0; at < $.length; at++)
                          if (B = $[at], B.getAttribute("href") === (d.href == null ? null : d.href) && B.getAttribute("rel") === (d.rel == null ? null : d.rel) && B.getAttribute("title") === (d.title == null ? null : d.title) && B.getAttribute("crossorigin") === (d.crossOrigin == null ? null : d.crossOrigin)) {
                            $.splice(at, 1);
                            break e;
                          }
                      }
                      B = C.createElement(m), fa(B, m, d), C.head.appendChild(B);
                      break;
                    case "meta":
                      if ($ = mS(
                        "meta",
                        "content",
                        C
                      ).get(m + (d.content || ""))) {
                        for (at = 0; at < $.length; at++)
                          if (B = $[at], B.getAttribute("content") === (d.content == null ? null : "" + d.content) && B.getAttribute("name") === (d.name == null ? null : d.name) && B.getAttribute("property") === (d.property == null ? null : d.property) && B.getAttribute("http-equiv") === (d.httpEquiv == null ? null : d.httpEquiv) && B.getAttribute("charset") === (d.charSet == null ? null : d.charSet)) {
                            $.splice(at, 1);
                            break e;
                          }
                      }
                      B = C.createElement(m), fa(B, m, d), C.head.appendChild(B);
                      break;
                    default:
                      throw Error(i(468, m));
                  }
                  B[Pi] = r, Pn(B), m = B;
                }
                r.stateNode = m;
              } else
                gS(
                  C,
                  r.type,
                  r.stateNode
                );
            else
              r.stateNode = pS(
                C,
                m,
                r.memoizedProps
              );
          else
            B !== m ? (B === null ? d.stateNode !== null && (d = d.stateNode, d.parentNode.removeChild(d)) : B.count--, m === null ? gS(
              C,
              r.type,
              r.stateNode
            ) : pS(
              C,
              m,
              r.memoizedProps
            )) : m === null && r.stateNode !== null && cs(
              r,
              r.memoizedProps,
              d.memoizedProps
            );
        }
        break;
      case 27:
        if (m & 4 && r.alternate === null) {
          C = r.stateNode, B = r.memoizedProps;
          try {
            for (var pt = C.firstChild; pt; ) {
              var Mt = pt.nextSibling, Zt = pt.nodeName;
              pt[eo] || Zt === "HEAD" || Zt === "BODY" || Zt === "SCRIPT" || Zt === "STYLE" || Zt === "LINK" && pt.rel.toLowerCase() === "stylesheet" || C.removeChild(pt), pt = Mt;
            }
            for (var he = r.type, qt = C.attributes; qt.length; )
              C.removeAttributeNode(qt[0]);
            fa(C, he, B), C[Pi] = r, C[rn] = B;
          } catch (Pe) {
            ge(r, r.return, Pe);
          }
        }
      case 5:
        if (ca(a, r), Wr(r), m & 512 && (di || d === null || Xn(d, d.return)), r.flags & 32) {
          C = r.stateNode;
          try {
            cn(C, "");
          } catch (Pe) {
            ge(r, r.return, Pe);
          }
        }
        m & 4 && r.stateNode != null && (C = r.memoizedProps, cs(
          r,
          C,
          d !== null ? d.memoizedProps : C
        )), m & 1024 && (sc = !0);
        break;
      case 6:
        if (ca(a, r), Wr(r), m & 4) {
          if (r.stateNode === null)
            throw Error(i(162));
          m = r.memoizedProps, d = r.stateNode;
          try {
            d.nodeValue = m;
          } catch (Pe) {
            ge(r, r.return, Pe);
          }
        }
        break;
      case 3:
        if (sy = null, C = Xr, Xr = ry(a.containerInfo), ca(a, r), Xr = C, Wr(r), m & 4 && d !== null && d.memoizedState.isDehydrated)
          try {
            cm(a.containerInfo);
          } catch (Pe) {
            ge(r, r.return, Pe);
          }
        sc && (sc = !1, oc(r));
        break;
      case 4:
        m = Xr, Xr = ry(
          r.stateNode.containerInfo
        ), ca(a, r), Wr(r), Xr = m;
        break;
      case 12:
        ca(a, r), Wr(r);
        break;
      case 13:
        ca(a, r), Wr(r), r.child.flags & 8192 && r.memoizedState !== null != (d !== null && d.memoizedState !== null) && (dn = De()), m & 4 && (m = r.updateQueue, m !== null && (r.updateQueue = null, fh(r, m)));
        break;
      case 22:
        if (m & 512 && (di || d === null || Xn(d, d.return)), pt = r.memoizedState !== null, Mt = d !== null && d.memoizedState !== null, Zt = Is, he = di, Is = Zt || pt, di = he || Mt, ca(a, r), di = he, Is = Zt, Wr(r), a = r.stateNode, a._current = r, a._visibility &= -3, a._visibility |= a._pendingVisibility & 2, m & 8192 && (a._visibility = pt ? a._visibility & -2 : a._visibility | 1, pt && (a = Is || di, d === null || Mt || a || Fs(r)), r.memoizedProps === null || r.memoizedProps.mode !== "manual"))
          t: for (d = null, a = r; ; ) {
            if (a.tag === 5 || a.tag === 26 || a.tag === 27) {
              if (d === null) {
                Mt = d = a;
                try {
                  if (C = Mt.stateNode, pt)
                    B = C.style, typeof B.setProperty == "function" ? B.setProperty(
                      "display",
                      "none",
                      "important"
                    ) : B.display = "none";
                  else {
                    $ = Mt.stateNode, at = Mt.memoizedProps.style;
                    var $t = at != null && at.hasOwnProperty("display") ? at.display : null;
                    $.style.display = $t == null || typeof $t == "boolean" ? "" : ("" + $t).trim();
                  }
                } catch (Pe) {
                  ge(Mt, Mt.return, Pe);
                }
              }
            } else if (a.tag === 6) {
              if (d === null) {
                Mt = a;
                try {
                  Mt.stateNode.nodeValue = pt ? "" : Mt.memoizedProps;
                } catch (Pe) {
                  ge(Mt, Mt.return, Pe);
                }
              }
            } else if ((a.tag !== 22 && a.tag !== 23 || a.memoizedState === null || a === r) && a.child !== null) {
              a.child.return = a, a = a.child;
              continue;
            }
            if (a === r) break t;
            for (; a.sibling === null; ) {
              if (a.return === null || a.return === r) break t;
              d === a && (d = null), a = a.return;
            }
            d === a && (d = null), a.sibling.return = a.return, a = a.sibling;
          }
        m & 4 && (m = r.updateQueue, m !== null && (d = m.retryQueue, d !== null && (m.retryQueue = null, fh(r, d))));
        break;
      case 19:
        ca(a, r), Wr(r), m & 4 && (m = r.updateQueue, m !== null && (r.updateQueue = null, fh(r, m)));
        break;
      case 21:
        break;
      default:
        ca(a, r), Wr(r);
    }
  }
  function Wr(r) {
    var a = r.flags;
    if (a & 2) {
      try {
        if (r.tag !== 27) {
          t: {
            for (var d = r.return; d !== null; ) {
              if (Vs(d)) {
                var m = d;
                break t;
              }
              d = d.return;
            }
            throw Error(i(160));
          }
          switch (m.tag) {
            case 27:
              var C = m.stateNode, B = dh(r);
              cl(r, B, C);
              break;
            case 5:
              var $ = m.stateNode;
              m.flags & 32 && (cn($, ""), m.flags &= -33);
              var at = dh(r);
              cl(r, at, $);
              break;
            case 3:
            case 4:
              var pt = m.stateNode.containerInfo, Mt = dh(r);
              Aa(
                r,
                Mt,
                pt
              );
              break;
            default:
              throw Error(i(161));
          }
        }
      } catch (Zt) {
        ge(r, r.return, Zt);
      }
      r.flags &= -3;
    }
    a & 4096 && (r.flags &= -4097);
  }
  function oc(r) {
    if (r.subtreeFlags & 1024)
      for (r = r.child; r !== null; ) {
        var a = r;
        oc(a), a.tag === 5 && a.flags & 1024 && a.stateNode.reset(), r = r.sibling;
      }
  }
  function xo(r, a) {
    if (a.subtreeFlags & 8772)
      for (a = a.child; a !== null; )
        pd(r, a.alternate, a), a = a.sibling;
  }
  function Fs(r) {
    for (r = r.child; r !== null; ) {
      var a = r;
      switch (a.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          ls(4, a, a.return), Fs(a);
          break;
        case 1:
          Xn(a, a.return);
          var d = a.stateNode;
          typeof d.componentWillUnmount == "function" && uh(
            a,
            a.return,
            d
          ), Fs(a);
          break;
        case 26:
        case 27:
        case 5:
          Xn(a, a.return), Fs(a);
          break;
        case 22:
          Xn(a, a.return), a.memoizedState === null && Fs(a);
          break;
        default:
          Fs(a);
      }
      r = r.sibling;
    }
  }
  function qs(r, a, d) {
    for (d = d && (a.subtreeFlags & 8772) !== 0, a = a.child; a !== null; ) {
      var m = a.alternate, C = r, B = a, $ = B.flags;
      switch (B.tag) {
        case 0:
        case 11:
        case 15:
          qs(
            C,
            B,
            d
          ), Fi(4, B);
          break;
        case 1:
          if (qs(
            C,
            B,
            d
          ), m = B, C = m.stateNode, typeof C.componentDidMount == "function")
            try {
              C.componentDidMount();
            } catch (Mt) {
              ge(m, m.return, Mt);
            }
          if (m = B, C = m.updateQueue, C !== null) {
            var at = m.stateNode;
            try {
              var pt = C.shared.hiddenCallbacks;
              if (pt !== null)
                for (C.shared.hiddenCallbacks = null, C = 0; C < pt.length; C++)
                  _o(pt[C], at);
            } catch (Mt) {
              ge(m, m.return, Mt);
            }
          }
          d && $ & 64 && ll(B), qi(B, B.return);
          break;
        case 26:
        case 27:
        case 5:
          qs(
            C,
            B,
            d
          ), d && m === null && $ & 4 && Nn(B), qi(B, B.return);
          break;
        case 12:
          qs(
            C,
            B,
            d
          );
          break;
        case 13:
          qs(
            C,
            B,
            d
          ), d && $ & 4 && Q0(C, B);
          break;
        case 22:
          B.memoizedState === null && qs(
            C,
            B,
            d
          ), qi(B, B.return);
          break;
        default:
          qs(
            C,
            B,
            d
          );
      }
      a = a.sibling;
    }
  }
  function Ma(r, a) {
    var d = null;
    r !== null && r.memoizedState !== null && r.memoizedState.cachePool !== null && (d = r.memoizedState.cachePool.pool), r = null, a.memoizedState !== null && a.memoizedState.cachePool !== null && (r = a.memoizedState.cachePool.pool), r !== d && (r != null && r.refCount++, d != null && Xl(d));
  }
  function us(r, a) {
    r = null, a.alternate !== null && (r = a.alternate.memoizedState.cache), a = a.memoizedState.cache, a !== r && (a.refCount++, r != null && Xl(r));
  }
  function oi(r, a, d, m) {
    if (a.subtreeFlags & 10256)
      for (a = a.child; a !== null; )
        ul(
          r,
          a,
          d,
          m
        ), a = a.sibling;
  }
  function ul(r, a, d, m) {
    var C = a.flags;
    switch (a.tag) {
      case 0:
      case 11:
      case 15:
        oi(
          r,
          a,
          d,
          m
        ), C & 2048 && Fi(9, a);
        break;
      case 3:
        oi(
          r,
          a,
          d,
          m
        ), C & 2048 && (r = null, a.alternate !== null && (r = a.alternate.memoizedState.cache), a = a.memoizedState.cache, a !== r && (a.refCount++, r != null && Xl(r)));
        break;
      case 12:
        if (C & 2048) {
          oi(
            r,
            a,
            d,
            m
          ), r = a.stateNode;
          try {
            var B = a.memoizedProps, $ = B.id, at = B.onPostCommit;
            typeof at == "function" && at(
              $,
              a.alternate === null ? "mount" : "update",
              r.passiveEffectDuration,
              -0
            );
          } catch (pt) {
            ge(a, a.return, pt);
          }
        } else
          oi(
            r,
            a,
            d,
            m
          );
        break;
      case 23:
        break;
      case 22:
        B = a.stateNode, a.memoizedState !== null ? B._visibility & 4 ? oi(
          r,
          a,
          d,
          m
        ) : Dn(r, a) : B._visibility & 4 ? oi(
          r,
          a,
          d,
          m
        ) : (B._visibility |= 4, Je(
          r,
          a,
          d,
          m,
          (a.subtreeFlags & 10256) !== 0
        )), C & 2048 && Ma(
          a.alternate,
          a
        );
        break;
      case 24:
        oi(
          r,
          a,
          d,
          m
        ), C & 2048 && us(a.alternate, a);
        break;
      default:
        oi(
          r,
          a,
          d,
          m
        );
    }
  }
  function Je(r, a, d, m, C) {
    for (C = C && (a.subtreeFlags & 10256) !== 0, a = a.child; a !== null; ) {
      var B = r, $ = a, at = d, pt = m, Mt = $.flags;
      switch ($.tag) {
        case 0:
        case 11:
        case 15:
          Je(
            B,
            $,
            at,
            pt,
            C
          ), Fi(8, $);
          break;
        case 23:
          break;
        case 22:
          var Zt = $.stateNode;
          $.memoizedState !== null ? Zt._visibility & 4 ? Je(
            B,
            $,
            at,
            pt,
            C
          ) : Dn(
            B,
            $
          ) : (Zt._visibility |= 4, Je(
            B,
            $,
            at,
            pt,
            C
          )), C && Mt & 2048 && Ma(
            $.alternate,
            $
          );
          break;
        case 24:
          Je(
            B,
            $,
            at,
            pt,
            C
          ), C && Mt & 2048 && us($.alternate, $);
          break;
        default:
          Je(
            B,
            $,
            at,
            pt,
            C
          );
      }
      a = a.sibling;
    }
  }
  function Dn(r, a) {
    if (a.subtreeFlags & 10256)
      for (a = a.child; a !== null; ) {
        var d = r, m = a, C = m.flags;
        switch (m.tag) {
          case 22:
            Dn(d, m), C & 2048 && Ma(
              m.alternate,
              m
            );
            break;
          case 24:
            Dn(d, m), C & 2048 && us(m.alternate, m);
            break;
          default:
            Dn(d, m);
        }
        a = a.sibling;
      }
  }
  var bi = 8192;
  function dl(r) {
    if (r.subtreeFlags & bi)
      for (r = r.child; r !== null; )
        yu(r), r = r.sibling;
  }
  function yu(r) {
    switch (r.tag) {
      case 26:
        dl(r), r.flags & bi && r.memoizedState !== null && zC(
          Xr,
          r.memoizedState,
          r.memoizedProps
        );
        break;
      case 5:
        dl(r);
        break;
      case 3:
      case 4:
        var a = Xr;
        Xr = ry(r.stateNode.containerInfo), dl(r), Xr = a;
        break;
      case 22:
        r.memoizedState === null && (a = r.alternate, a !== null && a.memoizedState !== null ? (a = bi, bi = 16777216, dl(r), bi = a) : dl(r));
        break;
      default:
        dl(r);
    }
  }
  function lc(r) {
    var a = r.alternate;
    if (a !== null && (r = a.child, r !== null)) {
      a.child = null;
      do
        a = r.sibling, r.sibling = null, r = a;
      while (r !== null);
    }
  }
  function cc(r) {
    var a = r.deletions;
    if ((r.flags & 16) !== 0) {
      if (a !== null)
        for (var d = 0; d < a.length; d++) {
          var m = a[d];
          Gi = m, Z0(
            m,
            r
          );
        }
      lc(r);
    }
    if (r.subtreeFlags & 10256)
      for (r = r.child; r !== null; )
        md(r), r = r.sibling;
  }
  function md(r) {
    switch (r.tag) {
      case 0:
      case 11:
      case 15:
        cc(r), r.flags & 2048 && ls(9, r, r.return);
        break;
      case 3:
        cc(r);
        break;
      case 12:
        cc(r);
        break;
      case 22:
        var a = r.stateNode;
        r.memoizedState !== null && a._visibility & 4 && (r.return === null || r.return.tag !== 13) ? (a._visibility &= -5, hl(r)) : cc(r);
        break;
      default:
        cc(r);
    }
  }
  function hl(r) {
    var a = r.deletions;
    if ((r.flags & 16) !== 0) {
      if (a !== null)
        for (var d = 0; d < a.length; d++) {
          var m = a[d];
          Gi = m, Z0(
            m,
            r
          );
        }
      lc(r);
    }
    for (r = r.child; r !== null; ) {
      switch (a = r, a.tag) {
        case 0:
        case 11:
        case 15:
          ls(8, a, a.return), hl(a);
          break;
        case 22:
          d = a.stateNode, d._visibility & 4 && (d._visibility &= -5, hl(a));
          break;
        default:
          hl(a);
      }
      r = r.sibling;
    }
  }
  function Z0(r, a) {
    for (; Gi !== null; ) {
      var d = Gi;
      switch (d.tag) {
        case 0:
        case 11:
        case 15:
          ls(8, d, a);
          break;
        case 23:
        case 22:
          if (d.memoizedState !== null && d.memoizedState.cachePool !== null) {
            var m = d.memoizedState.cachePool.pool;
            m != null && m.refCount++;
          }
          break;
        case 24:
          Xl(d.memoizedState.cache);
      }
      if (m = d.child, m !== null) m.return = d, Gi = m;
      else
        t: for (d = r; Gi !== null; ) {
          m = Gi;
          var C = m.sibling, B = m.return;
          if (vf(m), m === d) {
            Gi = null;
            break t;
          }
          if (C !== null) {
            C.return = B, Gi = C;
            break t;
          }
          Gi = B;
        }
    }
  }
  function Wp(r, a, d, m) {
    this.tag = r, this.key = d, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = a, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = m, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function Hi(r, a, d, m) {
    return new Wp(r, a, d, m);
  }
  function fl(r) {
    return r = r.prototype, !(!r || !r.isReactComponent);
  }
  function ua(r, a) {
    var d = r.alternate;
    return d === null ? (d = Hi(
      r.tag,
      a,
      r.key,
      r.mode
    ), d.elementType = r.elementType, d.type = r.type, d.stateNode = r.stateNode, d.alternate = r, r.alternate = d) : (d.pendingProps = a, d.type = r.type, d.flags = 0, d.subtreeFlags = 0, d.deletions = null), d.flags = r.flags & 31457280, d.childLanes = r.childLanes, d.lanes = r.lanes, d.child = r.child, d.memoizedProps = r.memoizedProps, d.memoizedState = r.memoizedState, d.updateQueue = r.updateQueue, a = r.dependencies, d.dependencies = a === null ? null : { lanes: a.lanes, firstContext: a.firstContext }, d.sibling = r.sibling, d.index = r.index, d.ref = r.ref, d.refCleanup = r.refCleanup, d;
  }
  function uc(r, a) {
    r.flags &= 31457282;
    var d = r.alternate;
    return d === null ? (r.childLanes = 0, r.lanes = a, r.child = null, r.subtreeFlags = 0, r.memoizedProps = null, r.memoizedState = null, r.updateQueue = null, r.dependencies = null, r.stateNode = null) : (r.childLanes = d.childLanes, r.lanes = d.lanes, r.child = d.child, r.subtreeFlags = 0, r.deletions = null, r.memoizedProps = d.memoizedProps, r.memoizedState = d.memoizedState, r.updateQueue = d.updateQueue, r.type = d.type, a = d.dependencies, r.dependencies = a === null ? null : {
      lanes: a.lanes,
      firstContext: a.firstContext
    }), r;
  }
  function gd(r, a, d, m, C, B) {
    var $ = 0;
    if (m = r, typeof r == "function") fl(r) && ($ = 1);
    else if (typeof r == "string")
      $ = DC(
        r,
        d,
        Bt.current
      ) ? 26 : r === "html" || r === "head" || r === "body" ? 27 : 5;
    else
      t: switch (r) {
        case f:
          return dc(d.children, C, B, a);
        case p:
          $ = 8, C |= 24;
          break;
        case g:
          return r = Hi(12, d, a, C | 2), r.elementType = g, r.lanes = B, r;
        case T:
          return r = Hi(13, d, a, C), r.elementType = T, r.lanes = B, r;
        case A:
          return r = Hi(19, d, a, C), r.elementType = A, r.lanes = B, r;
        case E:
          return $p(d, C, B, a);
        default:
          if (typeof r == "object" && r !== null)
            switch (r.$$typeof) {
              case v:
              case b:
                $ = 10;
                break t;
              case x:
                $ = 9;
                break t;
              case _:
                $ = 11;
                break t;
              case O:
                $ = 14;
                break t;
              case M:
                $ = 16, m = null;
                break t;
            }
          $ = 29, d = Error(
            i(130, r === null ? "null" : typeof r, "")
          ), m = null;
      }
    return a = Hi($, d, a, C), a.elementType = r, a.type = m, a.lanes = B, a;
  }
  function dc(r, a, d, m) {
    return r = Hi(7, r, m, a), r.lanes = d, r;
  }
  function $p(r, a, d, m) {
    r = Hi(22, r, m, a), r.elementType = E, r.lanes = d;
    var C = {
      _visibility: 1,
      _pendingVisibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null,
      _current: null,
      detach: function() {
        var B = C._current;
        if (B === null) throw Error(i(456));
        if ((C._pendingVisibility & 2) === 0) {
          var $ = ai(B, 2);
          $ !== null && (C._pendingVisibility |= 2, er($, B, 2));
        }
      },
      attach: function() {
        var B = C._current;
        if (B === null) throw Error(i(456));
        if ((C._pendingVisibility & 2) !== 0) {
          var $ = ai(B, 2);
          $ !== null && (C._pendingVisibility &= -3, er($, B, 2));
        }
      }
    };
    return r.stateNode = C, r;
  }
  function Ji(r, a, d) {
    return r = Hi(6, r, null, a), r.lanes = d, r;
  }
  function ph(r, a, d) {
    return a = Hi(
      4,
      r.children !== null ? r.children : [],
      r.key,
      a
    ), a.lanes = d, a.stateNode = {
      containerInfo: r.containerInfo,
      pendingChildren: null,
      implementation: r.implementation
    }, a;
  }
  function ds(r) {
    r.flags |= 4;
  }
  function hc(r, a) {
    if (a.type !== "stylesheet" || (a.state.loading & 4) !== 0)
      r.flags &= -16777217;
    else if (r.flags |= 16777216, !yS(a)) {
      if (a = Ca.current, a !== null && ((Ie & 4194176) === Ie ? po !== null : (Ie & 62914560) !== Ie && (Ie & 536870912) === 0 || a !== po))
        throw ed = Wh, Sp;
      r.flags |= 8192;
    }
  }
  function hs(r, a) {
    a !== null && (r.flags |= 4), r.flags & 16384 && (a = r.tag !== 22 ? gi() : 536870912, r.lanes |= a, Co |= a);
  }
  function mh(r, a) {
    if (!On)
      switch (r.tailMode) {
        case "hidden":
          a = r.tail;
          for (var d = null; a !== null; )
            a.alternate !== null && (d = a), a = a.sibling;
          d === null ? r.tail = null : d.sibling = null;
          break;
        case "collapsed":
          d = r.tail;
          for (var m = null; d !== null; )
            d.alternate !== null && (m = d), d = d.sibling;
          m === null ? a || r.tail === null ? r.tail = null : r.tail.sibling = null : m.sibling = null;
      }
  }
  function Ei(r) {
    var a = r.alternate !== null && r.alternate.child === r.child, d = 0, m = 0;
    if (a)
      for (var C = r.child; C !== null; )
        d |= C.lanes | C.childLanes, m |= C.subtreeFlags & 31457280, m |= C.flags & 31457280, C.return = r, C = C.sibling;
    else
      for (C = r.child; C !== null; )
        d |= C.lanes | C.childLanes, m |= C.subtreeFlags, m |= C.flags, C.return = r, C = C.sibling;
    return r.subtreeFlags |= m, r.childLanes = d, a;
  }
  function Cv(r, a, d) {
    var m = a.pendingProps;
    switch (ql(a), a.tag) {
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return Ei(a), null;
      case 1:
        return Ei(a), null;
      case 3:
        return d = a.stateNode, m = null, r !== null && (m = r.memoizedState.cache), a.memoizedState.cache !== m && (a.flags |= 2048), ol(Li), se(), d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null), (r === null || r.child === null) && (Ju(a) ? ds(a) : r === null || r.memoizedState.isDehydrated && (a.flags & 256) === 0 || (a.flags |= 1024, ss !== null && (gs(ss), ss = null))), Ei(a), null;
      case 26:
        return d = a.memoizedState, r === null ? (ds(a), d !== null ? (Ei(a), hc(a, d)) : (Ei(a), a.flags &= -16777217)) : d ? d !== r.memoizedState ? (ds(a), Ei(a), hc(a, d)) : (Ei(a), a.flags &= -16777217) : (r.memoizedProps !== m && ds(a), Ei(a), a.flags &= -16777217), null;
      case 27:
        ue(a), d = ie.current;
        var C = a.type;
        if (r !== null && a.stateNode != null)
          r.memoizedProps !== m && ds(a);
        else {
          if (!m) {
            if (a.stateNode === null)
              throw Error(i(166));
            return Ei(a), null;
          }
          r = Bt.current, Ju(a) ? s0(a) : (r = cS(C, m, d), a.stateNode = r, ds(a));
        }
        return Ei(a), null;
      case 5:
        if (ue(a), d = a.type, r !== null && a.stateNode != null)
          r.memoizedProps !== m && ds(a);
        else {
          if (!m) {
            if (a.stateNode === null)
              throw Error(i(166));
            return Ei(a), null;
          }
          if (r = Bt.current, Ju(a))
            s0(a);
          else {
            switch (C = iy(
              ie.current
            ), r) {
              case 1:
                r = C.createElementNS(
                  "http://www.w3.org/2000/svg",
                  d
                );
                break;
              case 2:
                r = C.createElementNS(
                  "http://www.w3.org/1998/Math/MathML",
                  d
                );
                break;
              default:
                switch (d) {
                  case "svg":
                    r = C.createElementNS(
                      "http://www.w3.org/2000/svg",
                      d
                    );
                    break;
                  case "math":
                    r = C.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      d
                    );
                    break;
                  case "script":
                    r = C.createElement("div"), r.innerHTML = "<script><\/script>", r = r.removeChild(r.firstChild);
                    break;
                  case "select":
                    r = typeof m.is == "string" ? C.createElement("select", { is: m.is }) : C.createElement("select"), m.multiple ? r.multiple = !0 : m.size && (r.size = m.size);
                    break;
                  default:
                    r = typeof m.is == "string" ? C.createElement(d, { is: m.is }) : C.createElement(d);
                }
            }
            r[Pi] = a, r[rn] = m;
            t: for (C = a.child; C !== null; ) {
              if (C.tag === 5 || C.tag === 6)
                r.appendChild(C.stateNode);
              else if (C.tag !== 4 && C.tag !== 27 && C.child !== null) {
                C.child.return = C, C = C.child;
                continue;
              }
              if (C === a) break t;
              for (; C.sibling === null; ) {
                if (C.return === null || C.return === a)
                  break t;
                C = C.return;
              }
              C.sibling.return = C.return, C = C.sibling;
            }
            a.stateNode = r;
            t: switch (fa(r, d, m), d) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                r = !!m.autoFocus;
                break t;
              case "img":
                r = !0;
                break t;
              default:
                r = !1;
            }
            r && ds(a);
          }
        }
        return Ei(a), a.flags &= -16777217, null;
      case 6:
        if (r && a.stateNode != null)
          r.memoizedProps !== m && ds(a);
        else {
          if (typeof m != "string" && a.stateNode === null)
            throw Error(i(166));
          if (r = ie.current, Ju(a)) {
            if (r = a.stateNode, d = a.memoizedProps, m = null, C = Gr, C !== null)
              switch (C.tag) {
                case 27:
                case 5:
                  m = C.memoizedProps;
              }
            r[Pi] = a, r = !!(r.nodeValue === d || m !== null && m.suppressHydrationWarning === !0 || iS(r.nodeValue, d)), r || au(a);
          } else
            r = iy(r).createTextNode(
              m
            ), r[Pi] = a, a.stateNode = r;
        }
        return Ei(a), null;
      case 13:
        if (m = a.memoizedState, r === null || r.memoizedState !== null && r.memoizedState.dehydrated !== null) {
          if (C = Ju(a), m !== null && m.dehydrated !== null) {
            if (r === null) {
              if (!C) throw Error(i(318));
              if (C = a.memoizedState, C = C !== null ? C.dehydrated : null, !C) throw Error(i(317));
              C[Pi] = a;
            } else
              td(), (a.flags & 128) === 0 && (a.memoizedState = null), a.flags |= 4;
            Ei(a), C = !1;
          } else
            ss !== null && (gs(ss), ss = null), C = !0;
          if (!C)
            return a.flags & 256 ? (mo(a), a) : (mo(a), null);
        }
        if (mo(a), (a.flags & 128) !== 0)
          return a.lanes = d, a;
        if (d = m !== null, r = r !== null && r.memoizedState !== null, d) {
          m = a.child, C = null, m.alternate !== null && m.alternate.memoizedState !== null && m.alternate.memoizedState.cachePool !== null && (C = m.alternate.memoizedState.cachePool.pool);
          var B = null;
          m.memoizedState !== null && m.memoizedState.cachePool !== null && (B = m.memoizedState.cachePool.pool), B !== C && (m.flags |= 2048);
        }
        return d !== r && d && (a.child.flags |= 8192), hs(a, a.updateQueue), Ei(a), null;
      case 4:
        return se(), r === null && Rv(a.stateNode.containerInfo), Ei(a), null;
      case 10:
        return ol(a.type), Ei(a), null;
      case 19:
        if (ft($i), C = a.memoizedState, C === null) return Ei(a), null;
        if (m = (a.flags & 128) !== 0, B = C.rendering, B === null)
          if (m) mh(C, !1);
          else {
            if (fi !== 0 || r !== null && (r.flags & 128) !== 0)
              for (r = a.child; r !== null; ) {
                if (B = nd(r), B !== null) {
                  for (a.flags |= 128, mh(C, !1), r = B.updateQueue, a.updateQueue = r, hs(a, r), a.subtreeFlags = 0, r = d, d = a.child; d !== null; )
                    uc(d, r), d = d.sibling;
                  return Tt(
                    $i,
                    $i.current & 1 | 2
                  ), a.child;
                }
                r = r.sibling;
              }
            C.tail !== null && De() > vn && (a.flags |= 128, m = !0, mh(C, !1), a.lanes = 4194304);
          }
        else {
          if (!m)
            if (r = nd(B), r !== null) {
              if (a.flags |= 128, m = !0, r = r.updateQueue, a.updateQueue = r, hs(a, r), mh(C, !0), C.tail === null && C.tailMode === "hidden" && !B.alternate && !On)
                return Ei(a), null;
            } else
              2 * De() - C.renderingStartTime > vn && d !== 536870912 && (a.flags |= 128, m = !0, mh(C, !1), a.lanes = 4194304);
          C.isBackwards ? (B.sibling = a.child, a.child = B) : (r = C.last, r !== null ? r.sibling = B : a.child = B, C.last = B);
        }
        return C.tail !== null ? (a = C.tail, C.rendering = a, C.tail = a.sibling, C.renderingStartTime = De(), a.sibling = null, r = $i.current, Tt($i, m ? r & 1 | 2 : r & 1), a) : (Ei(a), null);
      case 22:
      case 23:
        return mo(a), ih(), m = a.memoizedState !== null, r !== null ? r.memoizedState !== null !== m && (a.flags |= 8192) : m && (a.flags |= 8192), m ? (d & 536870912) !== 0 && (a.flags & 128) === 0 && (Ei(a), a.subtreeFlags & 6 && (a.flags |= 8192)) : Ei(a), d = a.updateQueue, d !== null && hs(a, d.retryQueue), d = null, r !== null && r.memoizedState !== null && r.memoizedState.cachePool !== null && (d = r.memoizedState.cachePool.pool), m = null, a.memoizedState !== null && a.memoizedState.cachePool !== null && (m = a.memoizedState.cachePool.pool), m !== d && (a.flags |= 2048), r !== null && ft(nl), null;
      case 24:
        return d = null, r !== null && (d = r.memoizedState.cache), a.memoizedState.cache !== d && (a.flags |= 2048), ol(Li), Ei(a), null;
      case 25:
        return null;
    }
    throw Error(i(156, a.tag));
  }
  function ki(r, a) {
    switch (ql(a), a.tag) {
      case 1:
        return r = a.flags, r & 65536 ? (a.flags = r & -65537 | 128, a) : null;
      case 3:
        return ol(Li), se(), r = a.flags, (r & 65536) !== 0 && (r & 128) === 0 ? (a.flags = r & -65537 | 128, a) : null;
      case 26:
      case 27:
      case 5:
        return ue(a), null;
      case 13:
        if (mo(a), r = a.memoizedState, r !== null && r.dehydrated !== null) {
          if (a.alternate === null)
            throw Error(i(340));
          td();
        }
        return r = a.flags, r & 65536 ? (a.flags = r & -65537 | 128, a) : null;
      case 19:
        return ft($i), null;
      case 4:
        return se(), null;
      case 10:
        return ol(a.type), null;
      case 22:
      case 23:
        return mo(a), ih(), r !== null && ft(nl), r = a.flags, r & 65536 ? (a.flags = r & -65537 | 128, a) : null;
      case 24:
        return ol(Li), null;
      case 25:
        return null;
      default:
        return null;
    }
  }
  function Qp(r, a) {
    switch (ql(a), a.tag) {
      case 3:
        ol(Li), se();
        break;
      case 26:
      case 27:
      case 5:
        ue(a);
        break;
      case 4:
        se();
        break;
      case 13:
        mo(a);
        break;
      case 19:
        ft($i);
        break;
      case 10:
        ol(a.type);
        break;
      case 22:
      case 23:
        mo(a), ih(), r !== null && ft(nl);
        break;
      case 24:
        ol(Li);
    }
  }
  var vu = {
    getCacheForType: function(r) {
      var a = Hr(Li), d = a.data.get(r);
      return d === void 0 && (d = r(), a.data.set(r, d)), d;
    }
  }, pl = typeof WeakMap == "function" ? WeakMap : Map, tn = 0, Wn = null, pn = null, Ie = 0, Jn = 0, Bn = null, Ki = !1, $r = !1, fc = !1, ml = 0, fi = 0, Gs = 0, To = 0, yd = 0, da = 0, Co = 0, gh = null, yn = null, $n = !1, dn = 0, vn = 1 / 0, Gn = null, tr = null, fs = !1, ps = null, bu = 0, Hs = 0, _i = null, ms = 0, gl = null;
  function ha() {
    if ((tn & 2) !== 0 && Ie !== 0)
      return Ie & -Ie;
    if (V.T !== null) {
      var r = lu;
      return r !== 0 ? r : wv();
    }
    return wl();
  }
  function Ya() {
    da === 0 && (da = (Ie & 536870912) === 0 || On ? Ke() : 536870912);
    var r = Ca.current;
    return r !== null && (r.flags |= 32), da;
  }
  function er(r, a, d) {
    (r === Wn && Jn === 2 || r.cancelPendingCommit !== null) && (yl(r, 0), Xa(
      r,
      Ie,
      da,
      !1
    )), to(r, d), ((tn & 2) === 0 || r !== Wn) && (r === Wn && ((tn & 2) === 0 && (To |= d), fi === 4 && Xa(
      r,
      Ie,
      da,
      !1
    )), ti(r));
  }
  function vd(r, a, d) {
    if ((tn & 6) !== 0) throw Error(i(327));
    var m = !d && (a & 60) === 0 && (a & r.expiredLanes) === 0 || Wi(r, a), C = m ? l(r, a) : Su(r, a, !0), B = m;
    do {
      if (C === 0) {
        $r && !m && Xa(r, a, 0, !1);
        break;
      } else if (C === 6)
        Xa(
          r,
          a,
          0,
          !Ki
        );
      else {
        if (d = r.current.alternate, B && !Zp(d)) {
          C = Su(r, a, !1), B = !1;
          continue;
        }
        if (C === 2) {
          if (B = a, r.errorRecoveryDisabledLanes & B)
            var $ = 0;
          else
            $ = r.pendingLanes & -536870913, $ = $ !== 0 ? $ : $ & 536870912 ? 536870912 : 0;
          if ($ !== 0) {
            a = $;
            t: {
              var at = r;
              C = gh;
              var pt = at.current.memoizedState.isDehydrated;
              if (pt && (yl(at, $).flags |= 256), $ = Su(
                at,
                $,
                !1
              ), $ !== 2) {
                if (fc && !pt) {
                  at.errorRecoveryDisabledLanes |= B, To |= B, C = 4;
                  break t;
                }
                B = yn, yn = C, B !== null && gs(B);
              }
              C = $;
            }
            if (B = !1, C !== 2) continue;
          }
        }
        if (C === 1) {
          yl(r, 0), Xa(r, a, 0, !0);
          break;
        }
        t: {
          switch (m = r, C) {
            case 0:
            case 1:
              throw Error(i(345));
            case 4:
              if ((a & 4194176) === a) {
                Xa(
                  m,
                  a,
                  da,
                  !Ki
                );
                break t;
              }
              break;
            case 2:
              yn = null;
              break;
            case 3:
            case 5:
              break;
            default:
              throw Error(i(329));
          }
          if (m.finishedWork = d, m.finishedLanes = a, (a & 62914560) === a && (B = dn + 300 - De(), 10 < B)) {
            if (Xa(
              m,
              a,
              da,
              !Ki
            ), Vr(m, 0) !== 0) break t;
            m.timeoutHandle = sS(
              _f.bind(
                null,
                m,
                d,
                yn,
                Gn,
                $n,
                a,
                da,
                To,
                Co,
                Ki,
                2,
                -0,
                0
              ),
              B
            );
            break t;
          }
          _f(
            m,
            d,
            yn,
            Gn,
            $n,
            a,
            da,
            To,
            Co,
            Ki,
            0,
            -0,
            0
          );
        }
      }
      break;
    } while (!0);
    ti(r);
  }
  function gs(r) {
    yn === null ? yn = r : yn.push.apply(
      yn,
      r
    );
  }
  function _f(r, a, d, m, C, B, $, at, pt, Mt, Zt, he, qt) {
    var $t = a.subtreeFlags;
    if (($t & 8192 || ($t & 16785408) === 16785408) && (rm = { stylesheets: null, count: 0, unsuspend: BC }, yu(a), a = PC(), a !== null)) {
      r.cancelPendingCommit = a(
        yt.bind(
          null,
          r,
          d,
          m,
          C,
          $,
          at,
          pt,
          1,
          he,
          qt
        )
      ), Xa(r, B, $, !Mt);
      return;
    }
    yt(
      r,
      d,
      m,
      C,
      $,
      at,
      pt,
      Zt,
      he,
      qt
    );
  }
  function Zp(r) {
    for (var a = r; ; ) {
      var d = a.tag;
      if ((d === 0 || d === 11 || d === 15) && a.flags & 16384 && (d = a.updateQueue, d !== null && (d = d.stores, d !== null)))
        for (var m = 0; m < d.length; m++) {
          var C = d[m], B = C.getSnapshot;
          C = C.value;
          try {
            if (!zr(B(), C)) return !1;
          } catch {
            return !1;
          }
        }
      if (d = a.child, a.subtreeFlags & 16384 && d !== null)
        d.return = a, a = d;
      else {
        if (a === r) break;
        for (; a.sibling === null; ) {
          if (a.return === null || a.return === r) return !0;
          a = a.return;
        }
        a.sibling.return = a.return, a = a.sibling;
      }
    }
    return !0;
  }
  function Xa(r, a, d, m) {
    a &= ~yd, a &= ~To, r.suspendedLanes |= a, r.pingedLanes &= ~a, m && (r.warmLanes |= a), m = r.expirationTimes;
    for (var C = a; 0 < C; ) {
      var B = 31 - Ve(C), $ = 1 << B;
      m[B] = -1, C &= ~$;
    }
    d !== 0 && Fn(r, d, a);
  }
  function _u() {
    return (tn & 6) === 0 ? (xn(0), !1) : !0;
  }
  function wo() {
    if (pn !== null) {
      if (Jn === 0)
        var r = pn.return;
      else
        r = pn, js = bo = null, Jh(r), Kl = null, th = 0, r = pn;
      for (; r !== null; )
        Qp(r.alternate, r), r = r.return;
      pn = null;
    }
  }
  function yl(r, a) {
    r.finishedWork = null, r.finishedLanes = 0;
    var d = r.timeoutHandle;
    d !== -1 && (r.timeoutHandle = -1, vC(d)), d = r.cancelPendingCommit, d !== null && (r.cancelPendingCommit = null, d()), wo(), Wn = r, pn = d = ua(r.current, null), Ie = a, Jn = 0, Bn = null, Ki = !1, $r = Wi(r, a), fc = !1, Co = da = yd = To = Gs = fi = 0, yn = gh = null, $n = !1, (a & 8) !== 0 && (a |= a & 32);
    var m = r.entangledLanes;
    if (m !== 0)
      for (r = r.entanglements, m &= a; 0 < m; ) {
        var C = 31 - Ve(m), B = 1 << C;
        a |= r[C], m &= ~B;
      }
    return ml = a, fr(), d;
  }
  function pc(r, a) {
    un = null, V.H = vo, a === Gl ? (a = Ln(), Jn = 3) : a === Sp ? (a = Ln(), Jn = 4) : Jn = a === qa ? 8 : a !== null && typeof a == "object" && typeof a.then == "function" ? 6 : 1, Bn = a, pn === null && (fi = 1, cf(
      r,
      Ta(a, r.current)
    ));
  }
  function bd() {
    var r = V.H;
    return V.H = vo, r === null ? vo : r;
  }
  function Sf() {
    var r = V.A;
    return V.A = vu, r;
  }
  function yh() {
    fi = 4, Ki || (Ie & 4194176) !== Ie && Ca.current !== null || ($r = !0), (Gs & 134217727) === 0 && (To & 134217727) === 0 || Wn === null || Xa(
      Wn,
      Ie,
      da,
      !1
    );
  }
  function Su(r, a, d) {
    var m = tn;
    tn |= 2;
    var C = bd(), B = Sf();
    (Wn !== r || Ie !== a) && (Gn = null, yl(r, a)), a = !1;
    var $ = fi;
    t: do
      try {
        if (Jn !== 0 && pn !== null) {
          var at = pn, pt = Bn;
          switch (Jn) {
            case 8:
              wo(), $ = 6;
              break t;
            case 3:
            case 2:
            case 6:
              Ca.current === null && (a = !0);
              var Mt = Jn;
              if (Jn = 0, Bn = null, z(r, at, pt, Mt), d && $r) {
                $ = 0;
                break t;
              }
              break;
            default:
              Mt = Jn, Jn = 0, Bn = null, z(r, at, pt, Mt);
          }
        }
        Jp(), $ = fi;
        break;
      } catch (Zt) {
        pc(r, Zt);
      }
    while (!0);
    return a && r.shellSuspendCounter++, js = bo = null, tn = m, V.H = C, V.A = B, pn === null && (Wn = null, Ie = 0, fr()), $;
  }
  function Jp() {
    for (; pn !== null; ) y(pn);
  }
  function l(r, a) {
    var d = tn;
    tn |= 2;
    var m = bd(), C = Sf();
    Wn !== r || Ie !== a ? (Gn = null, vn = De() + 500, yl(r, a)) : $r = Wi(
      r,
      a
    );
    t: do
      try {
        if (Jn !== 0 && pn !== null) {
          a = pn;
          var B = Bn;
          e: switch (Jn) {
            case 1:
              Jn = 0, Bn = null, z(r, a, B, 1);
              break;
            case 2:
              if (l0(B)) {
                Jn = 0, Bn = null, w(a);
                break;
              }
              a = function() {
                Jn === 2 && Wn === r && (Jn = 7), ti(r);
              }, B.then(a, a);
              break t;
            case 3:
              Jn = 7;
              break t;
            case 4:
              Jn = 5;
              break t;
            case 7:
              l0(B) ? (Jn = 0, Bn = null, w(a)) : (Jn = 0, Bn = null, z(r, a, B, 7));
              break;
            case 5:
              var $ = null;
              switch (pn.tag) {
                case 26:
                  $ = pn.memoizedState;
                case 5:
                case 27:
                  var at = pn;
                  if (!$ || yS($)) {
                    Jn = 0, Bn = null;
                    var pt = at.sibling;
                    if (pt !== null) pn = pt;
                    else {
                      var Mt = at.return;
                      Mt !== null ? (pn = Mt, F(Mt)) : pn = null;
                    }
                    break e;
                  }
              }
              Jn = 0, Bn = null, z(r, a, B, 5);
              break;
            case 6:
              Jn = 0, Bn = null, z(r, a, B, 6);
              break;
            case 8:
              wo(), fi = 6;
              break t;
            default:
              throw Error(i(462));
          }
        }
        c();
        break;
      } catch (Zt) {
        pc(r, Zt);
      }
    while (!0);
    return js = bo = null, V.H = m, V.A = C, tn = d, pn !== null ? 0 : (Wn = null, Ie = 0, fr(), fi);
  }
  function c() {
    for (; pn !== null && !oe(); )
      y(pn);
  }
  function y(r) {
    var a = lh(r.alternate, r, ml);
    r.memoizedProps = r.pendingProps, a === null ? F(r) : pn = a;
  }
  function w(r) {
    var a = r, d = a.alternate;
    switch (a.tag) {
      case 15:
      case 0:
        a = X0(
          d,
          a,
          a.pendingProps,
          a.type,
          void 0,
          Ie
        );
        break;
      case 11:
        a = X0(
          d,
          a,
          a.pendingProps,
          a.type.render,
          a.ref,
          Ie
        );
        break;
      case 5:
        Jh(a);
      default:
        Qp(d, a), a = pn = uc(a, ml), a = lh(d, a, ml);
    }
    r.memoizedProps = r.pendingProps, a === null ? F(r) : pn = a;
  }
  function z(r, a, d, m) {
    js = bo = null, Jh(a), Kl = null, th = 0;
    var C = a.return;
    try {
      if (xv(
        r,
        C,
        a,
        d,
        Ie
      )) {
        fi = 1, cf(
          r,
          Ta(d, r.current)
        ), pn = null;
        return;
      }
    } catch (B) {
      if (C !== null) throw pn = C, B;
      fi = 1, cf(
        r,
        Ta(d, r.current)
      ), pn = null;
      return;
    }
    a.flags & 32768 ? (On || m === 1 ? r = !0 : $r || (Ie & 536870912) !== 0 ? r = !1 : (Ki = r = !0, (m === 2 || m === 3 || m === 6) && (m = Ca.current, m !== null && m.tag === 13 && (m.flags |= 16384))), st(a, r)) : F(a);
  }
  function F(r) {
    var a = r;
    do {
      if ((a.flags & 32768) !== 0) {
        st(
          a,
          Ki
        );
        return;
      }
      r = a.return;
      var d = Cv(
        a.alternate,
        a,
        ml
      );
      if (d !== null) {
        pn = d;
        return;
      }
      if (a = a.sibling, a !== null) {
        pn = a;
        return;
      }
      pn = a = r;
    } while (a !== null);
    fi === 0 && (fi = 5);
  }
  function st(r, a) {
    do {
      var d = ki(r.alternate, r);
      if (d !== null) {
        d.flags &= 32767, pn = d;
        return;
      }
      if (d = r.return, d !== null && (d.flags |= 32768, d.subtreeFlags = 0, d.deletions = null), !a && (r = r.sibling, r !== null)) {
        pn = r;
        return;
      }
      pn = r = d;
    } while (r !== null);
    fi = 6, pn = null;
  }
  function yt(r, a, d, m, C, B, $, at, pt, Mt) {
    var Zt = V.T, he = dt.p;
    try {
      dt.p = 2, V.T = null, Pt(
        r,
        a,
        d,
        m,
        he,
        C,
        B,
        $,
        at,
        pt,
        Mt
      );
    } finally {
      V.T = Zt, dt.p = he;
    }
  }
  function Pt(r, a, d, m, C, B, $, at) {
    do
      ye();
    while (ps !== null);
    if ((tn & 6) !== 0) throw Error(i(327));
    var pt = r.finishedWork;
    if (m = r.finishedLanes, pt === null) return null;
    if (r.finishedWork = null, r.finishedLanes = 0, pt === r.current) throw Error(i(177));
    r.callbackNode = null, r.callbackPriority = 0, r.cancelPendingCommit = null;
    var Mt = pt.lanes | pt.childLanes;
    if (Mt |= Ye, zc(
      r,
      m,
      Mt,
      B,
      $,
      at
    ), r === Wn && (pn = Wn = null, Ie = 0), (pt.subtreeFlags & 10256) === 0 && (pt.flags & 10256) === 0 || fs || (fs = !0, Hs = Mt, _i = d, kt(Ht, function() {
      return ye(), null;
    })), d = (pt.flags & 15990) !== 0, (pt.subtreeFlags & 15990) !== 0 || d ? (d = V.T, V.T = null, B = dt.p, dt.p = 2, $ = tn, tn |= 4, fd(r, pt), gu(pt, r), ut(Dv, r.containerInfo), cy = !!kv, Dv = kv = null, r.current = pt, pd(r, pt.alternate, pt), Le(), tn = $, dt.p = B, V.T = d) : r.current = pt, fs ? (fs = !1, ps = r, bu = m) : Qt(r, Mt), Mt = r.pendingLanes, Mt === 0 && (tr = null), Te(pt.stateNode), ti(r), a !== null)
      for (C = r.onRecoverableError, pt = 0; pt < a.length; pt++)
        Mt = a[pt], C(Mt.value, {
          componentStack: Mt.stack
        });
    return (bu & 3) !== 0 && ye(), Mt = r.pendingLanes, (m & 4194218) !== 0 && (Mt & 42) !== 0 ? r === gl ? ms++ : (ms = 0, gl = r) : ms = 0, xn(0), null;
  }
  function Qt(r, a) {
    (r.pooledCacheLanes &= a) === 0 && (a = r.pooledCache, a != null && (r.pooledCache = null, Xl(a)));
  }
  function ye() {
    if (ps !== null) {
      var r = ps, a = Hs;
      Hs = 0;
      var d = Es(bu), m = V.T, C = dt.p;
      try {
        if (dt.p = 32 > d ? 32 : d, V.T = null, ps === null)
          var B = !1;
        else {
          d = _i, _i = null;
          var $ = ps, at = bu;
          if (ps = null, bu = 0, (tn & 6) !== 0)
            throw Error(i(331));
          var pt = tn;
          if (tn |= 4, md($.current), ul($, $.current, at, d), tn = pt, xn(0, !1), Me && typeof Me.onPostCommitFiberRoot == "function")
            try {
              Me.onPostCommitFiberRoot(fe, $);
            } catch {
            }
          B = !0;
        }
        return B;
      } finally {
        dt.p = C, V.T = m, Qt(r, a);
      }
    }
    return !1;
  }
  function Oe(r, a, d) {
    a = Ta(d, a), a = Up(r.stateNode, a, 2), r = Ka(r, a, 2), r !== null && (to(r, 2), ti(r));
  }
  function ge(r, a, d) {
    if (r.tag === 3)
      Oe(r, r, d);
    else
      for (; a !== null; ) {
        if (a.tag === 3) {
          Oe(
            a,
            r,
            d
          );
          break;
        } else if (a.tag === 1) {
          var m = a.stateNode;
          if (typeof a.type.getDerivedStateFromError == "function" || typeof m.componentDidCatch == "function" && (tr === null || !tr.has(m))) {
            r = Ta(d, r), d = jp(2), m = Ka(a, d, 2), m !== null && (K0(
              d,
              m,
              a,
              r
            ), to(m, 2), ti(m));
            break;
          }
        }
        a = a.return;
      }
  }
  function en(r, a, d) {
    var m = r.pingCache;
    if (m === null) {
      m = r.pingCache = new pl();
      var C = /* @__PURE__ */ new Set();
      m.set(a, C);
    } else
      C = m.get(a), C === void 0 && (C = /* @__PURE__ */ new Set(), m.set(a, C));
    C.has(d) || (fc = !0, C.add(d), r = ys.bind(null, r, a, d), a.then(r, r));
  }
  function ys(r, a, d) {
    var m = r.pingCache;
    m !== null && m.delete(a), r.pingedLanes |= r.suspendedLanes & d, r.warmLanes &= ~d, Wn === r && (Ie & d) === d && (fi === 4 || fi === 3 && (Ie & 62914560) === Ie && 300 > De() - dn ? (tn & 2) === 0 && yl(r, 0) : yd |= d, Co === Ie && (Co = 0)), ti(r);
  }
  function _d(r, a) {
    a === 0 && (a = gi()), r = ai(r, a), r !== null && (to(r, a), ti(r));
  }
  function xu(r) {
    var a = r.memoizedState, d = 0;
    a !== null && (d = a.retryLane), _d(r, d);
  }
  function Vt(r, a) {
    var d = 0;
    switch (r.tag) {
      case 13:
        var m = r.stateNode, C = r.memoizedState;
        C !== null && (d = C.retryLane);
        break;
      case 19:
        m = r.stateNode;
        break;
      case 22:
        m = r.stateNode._retryCache;
        break;
      default:
        throw Error(i(314));
    }
    m !== null && m.delete(a), _d(r, d);
  }
  function kt(r, a) {
    return ve(r, a);
  }
  var Gt = null, me = null, ze = !1, Qn = !1, He = !1, mn = 0;
  function ti(r) {
    r !== me && r.next === null && (me === null ? Gt = me = r : me = me.next = r), Qn = !0, ze || (ze = !0, cC(mc));
  }
  function xn(r, a) {
    if (!He && Qn) {
      He = !0;
      do
        for (var d = !1, m = Gt; m !== null; ) {
          if (r !== 0) {
            var C = m.pendingLanes;
            if (C === 0) var B = 0;
            else {
              var $ = m.suspendedLanes, at = m.pingedLanes;
              B = (1 << 31 - Ve(42 | r) + 1) - 1, B &= C & ~($ & ~at), B = B & 201326677 ? B & 201326677 | 1 : B ? B | 2 : 0;
            }
            B !== 0 && (d = !0, $_(m, B));
          } else
            B = Ie, B = Vr(
              m,
              m === Wn ? B : 0
            ), (B & 3) === 0 || Wi(m, B) || (d = !0, $_(m, B));
          m = m.next;
        }
      while (d);
      He = !1;
    }
  }
  function mc() {
    Qn = ze = !1;
    var r = 0;
    mn !== 0 && (yC() && (r = mn), mn = 0);
    for (var a = De(), d = null, m = Gt; m !== null; ) {
      var C = m.next, B = J0(m, a);
      B === 0 ? (m.next = null, d === null ? Gt = C : d.next = C, C === null && (me = d)) : (d = m, (r !== 0 || (B & 3) !== 0) && (Qn = !0)), m = C;
    }
    xn(r);
  }
  function J0(r, a) {
    for (var d = r.suspendedLanes, m = r.pingedLanes, C = r.expirationTimes, B = r.pendingLanes & -62914561; 0 < B; ) {
      var $ = 31 - Ve(B), at = 1 << $, pt = C[$];
      pt === -1 ? ((at & d) === 0 || (at & m) !== 0) && (C[$] = Sr(at, a)) : pt <= a && (r.expiredLanes |= at), B &= ~at;
    }
    if (a = Wn, d = Ie, d = Vr(
      r,
      r === a ? d : 0
    ), m = r.callbackNode, d === 0 || r === a && Jn === 2 || r.cancelPendingCommit !== null)
      return m !== null && m !== null && Re(m), r.callbackNode = null, r.callbackPriority = 0;
    if ((d & 3) === 0 || Wi(r, d)) {
      if (a = d & -d, a === r.callbackPriority) return a;
      switch (m !== null && Re(m), Es(d)) {
        case 2:
        case 8:
          d = It;
          break;
        case 32:
          d = Ht;
          break;
        case 268435456:
          d = Yt;
          break;
        default:
          d = Ht;
      }
      return m = W_.bind(null, r), d = ve(d, m), r.callbackPriority = a, r.callbackNode = d, a;
    }
    return m !== null && m !== null && Re(m), r.callbackPriority = 2, r.callbackNode = null, 2;
  }
  function W_(r, a) {
    var d = r.callbackNode;
    if (ye() && r.callbackNode !== d)
      return null;
    var m = Ie;
    return m = Vr(
      r,
      r === Wn ? m : 0
    ), m === 0 ? null : (vd(r, m, a), J0(r, De()), r.callbackNode != null && r.callbackNode === d ? W_.bind(null, r) : null);
  }
  function $_(r, a) {
    if (ye()) return null;
    vd(r, a, !0);
  }
  function cC(r) {
    bC(function() {
      (tn & 6) !== 0 ? ve(te, r) : r();
    });
  }
  function wv() {
    return mn === 0 && (mn = Ke()), mn;
  }
  function Q_(r) {
    return r == null || typeof r == "symbol" || typeof r == "boolean" ? null : typeof r == "function" ? r : Sa("" + r);
  }
  function Z_(r, a) {
    var d = a.ownerDocument.createElement("input");
    return d.name = a.name, d.value = a.value, r.id && d.setAttribute("form", r.id), a.parentNode.insertBefore(d, a), r = new FormData(r), d.parentNode.removeChild(d), r;
  }
  function uC(r, a, d, m, C) {
    if (a === "submit" && d && d.stateNode === C) {
      var B = Q_(
        (C[rn] || null).action
      ), $ = m.submitter;
      $ && (a = (a = $[rn] || null) ? Q_(a.formAction) : $.getAttribute("formAction"), a !== null && (B = a, $ = null));
      var at = new Dl(
        "action",
        "action",
        null,
        m,
        C
      );
      r.push({
        event: at,
        listeners: [
          {
            instance: null,
            listener: function() {
              if (m.defaultPrevented) {
                if (mn !== 0) {
                  var pt = $ ? Z_(C, $) : new FormData(C);
                  kp(
                    d,
                    {
                      pending: !0,
                      data: pt,
                      method: C.method,
                      action: B
                    },
                    null,
                    pt
                  );
                }
              } else
                typeof B == "function" && (at.preventDefault(), pt = $ ? Z_(C, $) : new FormData(C), kp(
                  d,
                  {
                    pending: !0,
                    data: pt,
                    method: C.method,
                    action: B
                  },
                  B,
                  pt
                ));
            },
            currentTarget: C
          }
        ]
      });
    }
  }
  for (var Ev = 0; Ev < be.length; Ev++) {
    var Av = be[Ev], dC = Av.toLowerCase(), hC = Av[0].toUpperCase() + Av.slice(1);
    Ee(
      dC,
      "on" + hC
    );
  }
  Ee(Ft, "onAnimationEnd"), Ee(Lt, "onAnimationIteration"), Ee(Xt, "onAnimationStart"), Ee("dblclick", "onDoubleClick"), Ee("focusin", "onFocus"), Ee("focusout", "onBlur"), Ee(de, "onTransitionRun"), Ee(Se, "onTransitionStart"), Ee(pe, "onTransitionCancel"), Ee(_e, "onTransitionEnd"), es("onMouseEnter", ["mouseout", "mouseover"]), es("onMouseLeave", ["mouseout", "mouseover"]), es("onPointerEnter", ["pointerout", "pointerover"]), es("onPointerLeave", ["pointerout", "pointerover"]), na(
    "onChange",
    "change click focusin focusout input keydown keyup selectionchange".split(" ")
  ), na(
    "onSelect",
    "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
      " "
    )
  ), na("onBeforeInput", [
    "compositionend",
    "keypress",
    "textInput",
    "paste"
  ]), na(
    "onCompositionEnd",
    "compositionend focusout keydown keypress keyup mousedown".split(" ")
  ), na(
    "onCompositionStart",
    "compositionstart focusout keydown keypress keyup mousedown".split(" ")
  ), na(
    "onCompositionUpdate",
    "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
  );
  var tm = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
    " "
  ), fC = new Set(
    "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(tm)
  );
  function J_(r, a) {
    a = (a & 4) !== 0;
    for (var d = 0; d < r.length; d++) {
      var m = r[d], C = m.event;
      m = m.listeners;
      t: {
        var B = void 0;
        if (a)
          for (var $ = m.length - 1; 0 <= $; $--) {
            var at = m[$], pt = at.instance, Mt = at.currentTarget;
            if (at = at.listener, pt !== B && C.isPropagationStopped())
              break t;
            B = at, C.currentTarget = Mt;
            try {
              B(C);
            } catch (Zt) {
              lf(Zt);
            }
            C.currentTarget = null, B = pt;
          }
        else
          for ($ = 0; $ < m.length; $++) {
            if (at = m[$], pt = at.instance, Mt = at.currentTarget, at = at.listener, pt !== B && C.isPropagationStopped())
              break t;
            B = at, C.currentTarget = Mt;
            try {
              B(C);
            } catch (Zt) {
              lf(Zt);
            }
            C.currentTarget = null, B = pt;
          }
      }
    }
  }
  function kn(r, a) {
    var d = a[ba];
    d === void 0 && (d = a[ba] = /* @__PURE__ */ new Set());
    var m = r + "__bubble";
    d.has(m) || (tS(a, r, 2, !1), d.add(m));
  }
  function Mv(r, a, d) {
    var m = 0;
    a && (m |= 4), tS(
      d,
      r,
      m,
      a
    );
  }
  var ty = "_reactListening" + Math.random().toString(36).slice(2);
  function Rv(r) {
    if (!r[ty]) {
      r[ty] = !0, Uc.forEach(function(d) {
        d !== "selectionchange" && (fC.has(d) || Mv(d, !1, r), Mv(d, !0, r));
      });
      var a = r.nodeType === 9 ? r : r.ownerDocument;
      a === null || a[ty] || (a[ty] = !0, Mv("selectionchange", !1, a));
    }
  }
  function tS(r, a, d, m) {
    switch (TS(a)) {
      case 2:
        var C = LC;
        break;
      case 8:
        C = VC;
        break;
      default:
        C = Fv;
    }
    d = C.bind(
      null,
      a,
      d,
      r
    ), C = void 0, !Gc || a !== "touchstart" && a !== "touchmove" && a !== "wheel" || (C = !0), m ? C !== void 0 ? r.addEventListener(a, d, {
      capture: !0,
      passive: C
    }) : r.addEventListener(a, d, !0) : C !== void 0 ? r.addEventListener(a, d, {
      passive: C
    }) : r.addEventListener(a, d, !1);
  }
  function Ov(r, a, d, m, C) {
    var B = m;
    if ((a & 1) === 0 && (a & 2) === 0 && m !== null)
      t: for (; ; ) {
        if (m === null) return;
        var $ = m.tag;
        if ($ === 3 || $ === 4) {
          var at = m.stateNode.containerInfo;
          if (at === C || at.nodeType === 8 && at.parentNode === C)
            break;
          if ($ === 4)
            for ($ = m.return; $ !== null; ) {
              var pt = $.tag;
              if ((pt === 3 || pt === 4) && (pt = $.stateNode.containerInfo, pt === C || pt.nodeType === 8 && pt.parentNode === C))
                return;
              $ = $.return;
            }
          for (; at !== null; ) {
            if ($ = ts(at), $ === null) return;
            if (pt = $.tag, pt === 5 || pt === 6 || pt === 26 || pt === 27) {
              m = B = $;
              continue t;
            }
            at = at.parentNode;
          }
        }
        m = m.return;
      }
    qc(function() {
      var Mt = B, Zt = Nl(d), he = [];
      t: {
        var qt = we.get(r);
        if (qt !== void 0) {
          var $t = Dl, Pe = r;
          switch (r) {
            case "keypress":
              if (is(d) === 0) break t;
            case "keydown":
            case "keyup":
              $t = jl;
              break;
            case "focusin":
              Pe = "focus", $t = Io;
              break;
            case "focusout":
              Pe = "blur", $t = Io;
              break;
            case "beforeblur":
            case "afterblur":
              $t = Io;
              break;
            case "click":
              if (d.button === 2) break t;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              $t = Yc;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              $t = Hh;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              $t = Zc;
              break;
            case Ft:
            case Lt:
            case Xt:
              $t = Kd;
              break;
            case _e:
              $t = Va;
              break;
            case "scroll":
            case "scrollend":
              $t = Kc;
              break;
            case "wheel":
              $t = $u;
              break;
            case "copy":
            case "cut":
            case "paste":
              $t = Wc;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              $t = $c;
              break;
            case "toggle":
            case "beforetoggle":
              $t = Ns;
          }
          var sn = (a & 4) !== 0, nr = !sn && (r === "scroll" || r === "scrollend"), zt = sn ? qt !== null ? qt + "Capture" : null : qt;
          sn = [];
          for (var Ct = Mt, jt; Ct !== null; ) {
            var ee = Ct;
            if (jt = ee.stateNode, ee = ee.tag, ee !== 5 && ee !== 26 && ee !== 27 || jt === null || zt === null || (ee = ra(Ct, zt), ee != null && sn.push(
              em(Ct, ee, jt)
            )), nr) break;
            Ct = Ct.return;
          }
          0 < sn.length && (qt = new $t(
            qt,
            Pe,
            null,
            d,
            Zt
          ), he.push({ event: qt, listeners: sn }));
        }
      }
      if ((a & 7) === 0) {
        t: {
          if (qt = r === "mouseover" || r === "pointerover", $t = r === "mouseout" || r === "pointerout", qt && d !== Fc && (Pe = d.relatedTarget || d.fromElement) && (ts(Pe) || Pe[ea]))
            break t;
          if (($t || qt) && (qt = Zt.window === Zt ? Zt : (qt = Zt.ownerDocument) ? qt.defaultView || qt.parentWindow : window, $t ? (Pe = d.relatedTarget || d.toElement, $t = Mt, Pe = Pe ? ts(Pe) : null, Pe !== null && (nr = it(Pe), sn = Pe.tag, Pe !== nr || sn !== 5 && sn !== 27 && sn !== 6) && (Pe = null)) : ($t = null, Pe = Mt), $t !== Pe)) {
            if (sn = Yc, ee = "onMouseLeave", zt = "onMouseEnter", Ct = "mouse", (r === "pointerout" || r === "pointerover") && (sn = $c, ee = "onPointerLeave", zt = "onPointerEnter", Ct = "pointer"), nr = $t == null ? qt : $e($t), jt = Pe == null ? qt : $e(Pe), qt = new sn(
              ee,
              Ct + "leave",
              $t,
              d,
              Zt
            ), qt.target = nr, qt.relatedTarget = jt, ee = null, ts(Zt) === Mt && (sn = new sn(
              zt,
              Ct + "enter",
              Pe,
              d,
              Zt
            ), sn.target = jt, sn.relatedTarget = nr, ee = sn), nr = ee, $t && Pe)
              e: {
                for (sn = $t, zt = Pe, Ct = 0, jt = sn; jt; jt = xf(jt))
                  Ct++;
                for (jt = 0, ee = zt; ee; ee = xf(ee))
                  jt++;
                for (; 0 < Ct - jt; )
                  sn = xf(sn), Ct--;
                for (; 0 < jt - Ct; )
                  zt = xf(zt), jt--;
                for (; Ct--; ) {
                  if (sn === zt || zt !== null && sn === zt.alternate)
                    break e;
                  sn = xf(sn), zt = xf(zt);
                }
                sn = null;
              }
            else sn = null;
            $t !== null && eS(
              he,
              qt,
              $t,
              sn,
              !1
            ), Pe !== null && nr !== null && eS(
              he,
              nr,
              Pe,
              sn,
              !0
            );
          }
        }
        t: {
          if (qt = Mt ? $e(Mt) : window, $t = qt.nodeName && qt.nodeName.toLowerCase(), $t === "select" || $t === "input" && qt.type === "file")
            var ke = Xo;
          else if (nu(qt))
            if (xa)
              ke = aa;
            else {
              ke = co;
              var Tn = Xh;
            }
          else
            $t = qt.nodeName, !$t || $t.toLowerCase() !== "input" || qt.type !== "checkbox" && qt.type !== "radio" ? Mt && cr(Mt.elementType) && (ke = Xo) : ke = Wo;
          if (ke && (ke = ke(r, Mt))) {
            Br(
              he,
              ke,
              d,
              Zt
            );
            break t;
          }
          Tn && Tn(r, qt, Mt), r === "focusout" && Mt && qt.type === "number" && Mt.memoizedProps.value != null && Lc(qt, "number", qt.value);
        }
        switch (Tn = Mt ? $e(Mt) : window, r) {
          case "focusin":
            (nu(Tn) || Tn.contentEditable === "true") && (bt = Tn, St = Mt, At = null);
            break;
          case "focusout":
            At = St = bt = null;
            break;
          case "mousedown":
            gt = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            gt = !1, Rt(he, d, Zt);
            break;
          case "selectionchange":
            if (mt) break;
          case "keydown":
          case "keyup":
            Rt(he, d, Zt);
        }
        var je;
        if (Go)
          t: {
            switch (r) {
              case "compositionstart":
                var We = "onCompositionStart";
                break t;
              case "compositionend":
                We = "onCompositionEnd";
                break t;
              case "compositionupdate":
                We = "onCompositionUpdate";
                break t;
            }
            We = void 0;
          }
        else
          Ds ? Ll(r, d) && (We = "onCompositionEnd") : r === "keydown" && d.keyCode === 229 && (We = "onCompositionStart");
        We && (Ho && d.locale !== "ko" && (Ds || We !== "onCompositionStart" ? We === "onCompositionEnd" && Ds && (je = Lo()) : (ja = Zt, Hu = "value" in ja ? ja.value : ja.textContent, Ds = !0)), Tn = ey(Mt, We), 0 < Tn.length && (We = new Ul(
          We,
          r,
          null,
          d,
          Zt
        ), he.push({ event: We, listeners: Tn }), je ? We.data = je : (je = Xd(d), je !== null && (We.data = je)))), (je = tu ? Vl(r, d) : Wd(r, d)) && (We = ey(Mt, "onBeforeInput"), 0 < We.length && (Tn = new Ul(
          "onBeforeInput",
          "beforeinput",
          null,
          d,
          Zt
        ), he.push({
          event: Tn,
          listeners: We
        }), Tn.data = je)), uC(
          he,
          r,
          Mt,
          d,
          Zt
        );
      }
      J_(he, a);
    });
  }
  function em(r, a, d) {
    return {
      instance: r,
      listener: a,
      currentTarget: d
    };
  }
  function ey(r, a) {
    for (var d = a + "Capture", m = []; r !== null; ) {
      var C = r, B = C.stateNode;
      C = C.tag, C !== 5 && C !== 26 && C !== 27 || B === null || (C = ra(r, d), C != null && m.unshift(
        em(r, C, B)
      ), C = ra(r, a), C != null && m.push(
        em(r, C, B)
      )), r = r.return;
    }
    return m;
  }
  function xf(r) {
    if (r === null) return null;
    do
      r = r.return;
    while (r && r.tag !== 5 && r.tag !== 27);
    return r || null;
  }
  function eS(r, a, d, m, C) {
    for (var B = a._reactName, $ = []; d !== null && d !== m; ) {
      var at = d, pt = at.alternate, Mt = at.stateNode;
      if (at = at.tag, pt !== null && pt === m) break;
      at !== 5 && at !== 26 && at !== 27 || Mt === null || (pt = Mt, C ? (Mt = ra(d, B), Mt != null && $.unshift(
        em(d, Mt, pt)
      )) : C || (Mt = ra(d, B), Mt != null && $.push(
        em(d, Mt, pt)
      ))), d = d.return;
    }
    $.length !== 0 && r.push({ event: a, listeners: $ });
  }
  var pC = /\r\n?/g, mC = /\u0000|\uFFFD/g;
  function nS(r) {
    return (typeof r == "string" ? r : "" + r).replace(pC, `
`).replace(mC, "");
  }
  function iS(r, a) {
    return a = nS(a), nS(r) === a;
  }
  function ny() {
  }
  function li(r, a, d, m, C, B) {
    switch (d) {
      case "children":
        typeof m == "string" ? a === "body" || a === "textarea" && m === "" || cn(r, m) : (typeof m == "number" || typeof m == "bigint") && a !== "body" && cn(r, "" + m);
        break;
      case "className":
        Al(r, "class", m);
        break;
      case "tabIndex":
        Al(r, "tabindex", m);
        break;
      case "dir":
      case "role":
      case "viewBox":
      case "width":
      case "height":
        Al(r, d, m);
        break;
      case "style":
        Hd(r, m, B);
        break;
      case "data":
        if (a !== "object") {
          Al(r, "data", m);
          break;
        }
      case "src":
      case "href":
        if (m === "" && (a !== "a" || d !== "href")) {
          r.removeAttribute(d);
          break;
        }
        if (m == null || typeof m == "function" || typeof m == "symbol" || typeof m == "boolean") {
          r.removeAttribute(d);
          break;
        }
        m = Sa("" + m), r.setAttribute(d, m);
        break;
      case "action":
      case "formAction":
        if (typeof m == "function") {
          r.setAttribute(
            d,
            "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
          );
          break;
        } else
          typeof B == "function" && (d === "formAction" ? (a !== "input" && li(r, a, "name", C.name, C, null), li(
            r,
            a,
            "formEncType",
            C.formEncType,
            C,
            null
          ), li(
            r,
            a,
            "formMethod",
            C.formMethod,
            C,
            null
          ), li(
            r,
            a,
            "formTarget",
            C.formTarget,
            C,
            null
          )) : (li(r, a, "encType", C.encType, C, null), li(r, a, "method", C.method, C, null), li(r, a, "target", C.target, C, null)));
        if (m == null || typeof m == "symbol" || typeof m == "boolean") {
          r.removeAttribute(d);
          break;
        }
        m = Sa("" + m), r.setAttribute(d, m);
        break;
      case "onClick":
        m != null && (r.onclick = ny);
        break;
      case "onScroll":
        m != null && kn("scroll", r);
        break;
      case "onScrollEnd":
        m != null && kn("scrollend", r);
        break;
      case "dangerouslySetInnerHTML":
        if (m != null) {
          if (typeof m != "object" || !("__html" in m))
            throw Error(i(61));
          if (d = m.__html, d != null) {
            if (C.children != null) throw Error(i(60));
            r.innerHTML = d;
          }
        }
        break;
      case "multiple":
        r.multiple = m && typeof m != "function" && typeof m != "symbol";
        break;
      case "muted":
        r.muted = m && typeof m != "function" && typeof m != "symbol";
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "ref":
        break;
      case "autoFocus":
        break;
      case "xlinkHref":
        if (m == null || typeof m == "function" || typeof m == "boolean" || typeof m == "symbol") {
          r.removeAttribute("xlink:href");
          break;
        }
        d = Sa("" + m), r.setAttributeNS(
          "http://www.w3.org/1999/xlink",
          "xlink:href",
          d
        );
        break;
      case "contentEditable":
      case "spellCheck":
      case "draggable":
      case "value":
      case "autoReverse":
      case "externalResourcesRequired":
      case "focusable":
      case "preserveAlpha":
        m != null && typeof m != "function" && typeof m != "symbol" ? r.setAttribute(d, "" + m) : r.removeAttribute(d);
        break;
      case "inert":
      case "allowFullScreen":
      case "async":
      case "autoPlay":
      case "controls":
      case "default":
      case "defer":
      case "disabled":
      case "disablePictureInPicture":
      case "disableRemotePlayback":
      case "formNoValidate":
      case "hidden":
      case "loop":
      case "noModule":
      case "noValidate":
      case "open":
      case "playsInline":
      case "readOnly":
      case "required":
      case "reversed":
      case "scoped":
      case "seamless":
      case "itemScope":
        m && typeof m != "function" && typeof m != "symbol" ? r.setAttribute(d, "") : r.removeAttribute(d);
        break;
      case "capture":
      case "download":
        m === !0 ? r.setAttribute(d, "") : m !== !1 && m != null && typeof m != "function" && typeof m != "symbol" ? r.setAttribute(d, m) : r.removeAttribute(d);
        break;
      case "cols":
      case "rows":
      case "size":
      case "span":
        m != null && typeof m != "function" && typeof m != "symbol" && !isNaN(m) && 1 <= m ? r.setAttribute(d, m) : r.removeAttribute(d);
        break;
      case "rowSpan":
      case "start":
        m == null || typeof m == "function" || typeof m == "symbol" || isNaN(m) ? r.removeAttribute(d) : r.setAttribute(d, m);
        break;
      case "popover":
        kn("beforetoggle", r), kn("toggle", r), ln(r, "popover", m);
        break;
      case "xlinkActuate":
        _a(
          r,
          "http://www.w3.org/1999/xlink",
          "xlink:actuate",
          m
        );
        break;
      case "xlinkArcrole":
        _a(
          r,
          "http://www.w3.org/1999/xlink",
          "xlink:arcrole",
          m
        );
        break;
      case "xlinkRole":
        _a(
          r,
          "http://www.w3.org/1999/xlink",
          "xlink:role",
          m
        );
        break;
      case "xlinkShow":
        _a(
          r,
          "http://www.w3.org/1999/xlink",
          "xlink:show",
          m
        );
        break;
      case "xlinkTitle":
        _a(
          r,
          "http://www.w3.org/1999/xlink",
          "xlink:title",
          m
        );
        break;
      case "xlinkType":
        _a(
          r,
          "http://www.w3.org/1999/xlink",
          "xlink:type",
          m
        );
        break;
      case "xmlBase":
        _a(
          r,
          "http://www.w3.org/XML/1998/namespace",
          "xml:base",
          m
        );
        break;
      case "xmlLang":
        _a(
          r,
          "http://www.w3.org/XML/1998/namespace",
          "xml:lang",
          m
        );
        break;
      case "xmlSpace":
        _a(
          r,
          "http://www.w3.org/XML/1998/namespace",
          "xml:space",
          m
        );
        break;
      case "is":
        ln(r, "is", m);
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        (!(2 < d.length) || d[0] !== "o" && d[0] !== "O" || d[1] !== "n" && d[1] !== "N") && (d = jo.get(d) || d, ln(r, d, m));
    }
  }
  function Nv(r, a, d, m, C, B) {
    switch (d) {
      case "style":
        Hd(r, m, B);
        break;
      case "dangerouslySetInnerHTML":
        if (m != null) {
          if (typeof m != "object" || !("__html" in m))
            throw Error(i(61));
          if (d = m.__html, d != null) {
            if (C.children != null) throw Error(i(60));
            r.innerHTML = d;
          }
        }
        break;
      case "children":
        typeof m == "string" ? cn(r, m) : (typeof m == "number" || typeof m == "bigint") && cn(r, "" + m);
        break;
      case "onScroll":
        m != null && kn("scroll", r);
        break;
      case "onScrollEnd":
        m != null && kn("scrollend", r);
        break;
      case "onClick":
        m != null && (r.onclick = ny);
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "innerHTML":
      case "ref":
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        if (!kr.hasOwnProperty(d))
          t: {
            if (d[0] === "o" && d[1] === "n" && (C = d.endsWith("Capture"), a = d.slice(2, C ? d.length - 7 : void 0), B = r[rn] || null, B = B != null ? B[d] : null, typeof B == "function" && r.removeEventListener(a, B, C), typeof m == "function")) {
              typeof B != "function" && B !== null && (d in r ? r[d] = null : r.hasAttribute(d) && r.removeAttribute(d)), r.addEventListener(a, m, C);
              break t;
            }
            d in r ? r[d] = m : m === !0 ? r.setAttribute(d, "") : ln(r, d, m);
          }
    }
  }
  function fa(r, a, d) {
    switch (a) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "img":
        kn("error", r), kn("load", r);
        var m = !1, C = !1, B;
        for (B in d)
          if (d.hasOwnProperty(B)) {
            var $ = d[B];
            if ($ != null)
              switch (B) {
                case "src":
                  m = !0;
                  break;
                case "srcSet":
                  C = !0;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(i(137, a));
                default:
                  li(r, a, B, $, d, null);
              }
          }
        C && li(r, a, "srcSet", d.srcSet, d, null), m && li(r, a, "src", d.src, d, null);
        return;
      case "input":
        kn("invalid", r);
        var at = B = $ = C = null, pt = null, Mt = null;
        for (m in d)
          if (d.hasOwnProperty(m)) {
            var Zt = d[m];
            if (Zt != null)
              switch (m) {
                case "name":
                  C = Zt;
                  break;
                case "type":
                  $ = Zt;
                  break;
                case "checked":
                  pt = Zt;
                  break;
                case "defaultChecked":
                  Mt = Zt;
                  break;
                case "value":
                  B = Zt;
                  break;
                case "defaultValue":
                  at = Zt;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (Zt != null)
                    throw Error(i(137, a));
                  break;
                default:
                  li(r, a, m, Zt, d, null);
              }
          }
        Rl(
          r,
          B,
          at,
          pt,
          Mt,
          $,
          C,
          !1
        ), Ms(r);
        return;
      case "select":
        kn("invalid", r), m = $ = B = null;
        for (C in d)
          if (d.hasOwnProperty(C) && (at = d[C], at != null))
            switch (C) {
              case "value":
                B = at;
                break;
              case "defaultValue":
                $ = at;
                break;
              case "multiple":
                m = at;
              default:
                li(r, a, C, at, d, null);
            }
        a = B, d = $, r.multiple = !!m, a != null ? ns(r, !!m, a, !1) : d != null && ns(r, !!m, d, !0);
        return;
      case "textarea":
        kn("invalid", r), B = C = m = null;
        for ($ in d)
          if (d.hasOwnProperty($) && (at = d[$], at != null))
            switch ($) {
              case "value":
                m = at;
                break;
              case "defaultValue":
                C = at;
                break;
              case "children":
                B = at;
                break;
              case "dangerouslySetInnerHTML":
                if (at != null) throw Error(i(91));
                break;
              default:
                li(r, a, $, at, d, null);
            }
        Uo(r, m, C, B), Ms(r);
        return;
      case "option":
        for (pt in d)
          if (d.hasOwnProperty(pt) && (m = d[pt], m != null))
            switch (pt) {
              case "selected":
                r.selected = m && typeof m != "function" && typeof m != "symbol";
                break;
              default:
                li(r, a, pt, m, d, null);
            }
        return;
      case "dialog":
        kn("cancel", r), kn("close", r);
        break;
      case "iframe":
      case "object":
        kn("load", r);
        break;
      case "video":
      case "audio":
        for (m = 0; m < tm.length; m++)
          kn(tm[m], r);
        break;
      case "image":
        kn("error", r), kn("load", r);
        break;
      case "details":
        kn("toggle", r);
        break;
      case "embed":
      case "source":
      case "link":
        kn("error", r), kn("load", r);
      case "area":
      case "base":
      case "br":
      case "col":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "track":
      case "wbr":
      case "menuitem":
        for (Mt in d)
          if (d.hasOwnProperty(Mt) && (m = d[Mt], m != null))
            switch (Mt) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(i(137, a));
              default:
                li(r, a, Mt, m, d, null);
            }
        return;
      default:
        if (cr(a)) {
          for (Zt in d)
            d.hasOwnProperty(Zt) && (m = d[Zt], m !== void 0 && Nv(
              r,
              a,
              Zt,
              m,
              d,
              void 0
            ));
          return;
        }
    }
    for (at in d)
      d.hasOwnProperty(at) && (m = d[at], m != null && li(r, a, at, m, d, null));
  }
  function gC(r, a, d, m) {
    switch (a) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "input":
        var C = null, B = null, $ = null, at = null, pt = null, Mt = null, Zt = null;
        for ($t in d) {
          var he = d[$t];
          if (d.hasOwnProperty($t) && he != null)
            switch ($t) {
              case "checked":
                break;
              case "value":
                break;
              case "defaultValue":
                pt = he;
              default:
                m.hasOwnProperty($t) || li(r, a, $t, null, m, he);
            }
        }
        for (var qt in m) {
          var $t = m[qt];
          if (he = d[qt], m.hasOwnProperty(qt) && ($t != null || he != null))
            switch (qt) {
              case "type":
                B = $t;
                break;
              case "name":
                C = $t;
                break;
              case "checked":
                Mt = $t;
                break;
              case "defaultChecked":
                Zt = $t;
                break;
              case "value":
                $ = $t;
                break;
              case "defaultValue":
                at = $t;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if ($t != null)
                  throw Error(i(137, a));
                break;
              default:
                $t !== he && li(
                  r,
                  a,
                  qt,
                  $t,
                  m,
                  he
                );
            }
        }
        jc(
          r,
          $,
          at,
          pt,
          Mt,
          Zt,
          B,
          C
        );
        return;
      case "select":
        $t = $ = at = qt = null;
        for (B in d)
          if (pt = d[B], d.hasOwnProperty(B) && pt != null)
            switch (B) {
              case "value":
                break;
              case "multiple":
                $t = pt;
              default:
                m.hasOwnProperty(B) || li(
                  r,
                  a,
                  B,
                  null,
                  m,
                  pt
                );
            }
        for (C in m)
          if (B = m[C], pt = d[C], m.hasOwnProperty(C) && (B != null || pt != null))
            switch (C) {
              case "value":
                qt = B;
                break;
              case "defaultValue":
                at = B;
                break;
              case "multiple":
                $ = B;
              default:
                B !== pt && li(
                  r,
                  a,
                  C,
                  B,
                  m,
                  pt
                );
            }
        a = at, d = $, m = $t, qt != null ? ns(r, !!d, qt, !1) : !!m != !!d && (a != null ? ns(r, !!d, a, !0) : ns(r, !!d, d ? [] : "", !1));
        return;
      case "textarea":
        $t = qt = null;
        for (at in d)
          if (C = d[at], d.hasOwnProperty(at) && C != null && !m.hasOwnProperty(at))
            switch (at) {
              case "value":
                break;
              case "children":
                break;
              default:
                li(r, a, at, null, m, C);
            }
        for ($ in m)
          if (C = m[$], B = d[$], m.hasOwnProperty($) && (C != null || B != null))
            switch ($) {
              case "value":
                qt = C;
                break;
              case "defaultValue":
                $t = C;
                break;
              case "children":
                break;
              case "dangerouslySetInnerHTML":
                if (C != null) throw Error(i(91));
                break;
              default:
                C !== B && li(r, a, $, C, m, B);
            }
        Gu(r, qt, $t);
        return;
      case "option":
        for (var Pe in d)
          if (qt = d[Pe], d.hasOwnProperty(Pe) && qt != null && !m.hasOwnProperty(Pe))
            switch (Pe) {
              case "selected":
                r.selected = !1;
                break;
              default:
                li(
                  r,
                  a,
                  Pe,
                  null,
                  m,
                  qt
                );
            }
        for (pt in m)
          if (qt = m[pt], $t = d[pt], m.hasOwnProperty(pt) && qt !== $t && (qt != null || $t != null))
            switch (pt) {
              case "selected":
                r.selected = qt && typeof qt != "function" && typeof qt != "symbol";
                break;
              default:
                li(
                  r,
                  a,
                  pt,
                  qt,
                  m,
                  $t
                );
            }
        return;
      case "img":
      case "link":
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
      case "menuitem":
        for (var sn in d)
          qt = d[sn], d.hasOwnProperty(sn) && qt != null && !m.hasOwnProperty(sn) && li(r, a, sn, null, m, qt);
        for (Mt in m)
          if (qt = m[Mt], $t = d[Mt], m.hasOwnProperty(Mt) && qt !== $t && (qt != null || $t != null))
            switch (Mt) {
              case "children":
              case "dangerouslySetInnerHTML":
                if (qt != null)
                  throw Error(i(137, a));
                break;
              default:
                li(
                  r,
                  a,
                  Mt,
                  qt,
                  m,
                  $t
                );
            }
        return;
      default:
        if (cr(a)) {
          for (var nr in d)
            qt = d[nr], d.hasOwnProperty(nr) && qt !== void 0 && !m.hasOwnProperty(nr) && Nv(
              r,
              a,
              nr,
              void 0,
              m,
              qt
            );
          for (Zt in m)
            qt = m[Zt], $t = d[Zt], !m.hasOwnProperty(Zt) || qt === $t || qt === void 0 && $t === void 0 || Nv(
              r,
              a,
              Zt,
              qt,
              m,
              $t
            );
          return;
        }
    }
    for (var zt in d)
      qt = d[zt], d.hasOwnProperty(zt) && qt != null && !m.hasOwnProperty(zt) && li(r, a, zt, null, m, qt);
    for (he in m)
      qt = m[he], $t = d[he], !m.hasOwnProperty(he) || qt === $t || qt == null && $t == null || li(r, a, he, qt, m, $t);
  }
  var kv = null, Dv = null;
  function iy(r) {
    return r.nodeType === 9 ? r : r.ownerDocument;
  }
  function rS(r) {
    switch (r) {
      case "http://www.w3.org/2000/svg":
        return 1;
      case "http://www.w3.org/1998/Math/MathML":
        return 2;
      default:
        return 0;
    }
  }
  function aS(r, a) {
    if (r === 0)
      switch (a) {
        case "svg":
          return 1;
        case "math":
          return 2;
        default:
          return 0;
      }
    return r === 1 && a === "foreignObject" ? 0 : r;
  }
  function Bv(r, a) {
    return r === "textarea" || r === "noscript" || typeof a.children == "string" || typeof a.children == "number" || typeof a.children == "bigint" || typeof a.dangerouslySetInnerHTML == "object" && a.dangerouslySetInnerHTML !== null && a.dangerouslySetInnerHTML.__html != null;
  }
  var zv = null;
  function yC() {
    var r = window.event;
    return r && r.type === "popstate" ? r === zv ? !1 : (zv = r, !0) : (zv = null, !1);
  }
  var sS = typeof setTimeout == "function" ? setTimeout : void 0, vC = typeof clearTimeout == "function" ? clearTimeout : void 0, oS = typeof Promise == "function" ? Promise : void 0, bC = typeof queueMicrotask == "function" ? queueMicrotask : typeof oS < "u" ? function(r) {
    return oS.resolve(null).then(r).catch(_C);
  } : sS;
  function _C(r) {
    setTimeout(function() {
      throw r;
    });
  }
  function Pv(r, a) {
    var d = a, m = 0;
    do {
      var C = d.nextSibling;
      if (r.removeChild(d), C && C.nodeType === 8)
        if (d = C.data, d === "/$") {
          if (m === 0) {
            r.removeChild(C), cm(a);
            return;
          }
          m--;
        } else d !== "$" && d !== "$?" && d !== "$!" || m++;
      d = C;
    } while (d);
    cm(a);
  }
  function Uv(r) {
    var a = r.firstChild;
    for (a && a.nodeType === 10 && (a = a.nextSibling); a; ) {
      var d = a;
      switch (a = a.nextSibling, d.nodeName) {
        case "HTML":
        case "HEAD":
        case "BODY":
          Uv(d), Ua(d);
          continue;
        case "SCRIPT":
        case "STYLE":
          continue;
        case "LINK":
          if (d.rel.toLowerCase() === "stylesheet") continue;
      }
      r.removeChild(d);
    }
  }
  function SC(r, a, d, m) {
    for (; r.nodeType === 1; ) {
      var C = d;
      if (r.nodeName.toLowerCase() !== a.toLowerCase()) {
        if (!m && (r.nodeName !== "INPUT" || r.type !== "hidden"))
          break;
      } else if (m) {
        if (!r[eo])
          switch (a) {
            case "meta":
              if (!r.hasAttribute("itemprop")) break;
              return r;
            case "link":
              if (B = r.getAttribute("rel"), B === "stylesheet" && r.hasAttribute("data-precedence"))
                break;
              if (B !== C.rel || r.getAttribute("href") !== (C.href == null ? null : C.href) || r.getAttribute("crossorigin") !== (C.crossOrigin == null ? null : C.crossOrigin) || r.getAttribute("title") !== (C.title == null ? null : C.title))
                break;
              return r;
            case "style":
              if (r.hasAttribute("data-precedence")) break;
              return r;
            case "script":
              if (B = r.getAttribute("src"), (B !== (C.src == null ? null : C.src) || r.getAttribute("type") !== (C.type == null ? null : C.type) || r.getAttribute("crossorigin") !== (C.crossOrigin == null ? null : C.crossOrigin)) && B && r.hasAttribute("async") && !r.hasAttribute("itemprop"))
                break;
              return r;
            default:
              return r;
          }
      } else if (a === "input" && r.type === "hidden") {
        var B = C.name == null ? null : "" + C.name;
        if (C.type === "hidden" && r.getAttribute("name") === B)
          return r;
      } else return r;
      if (r = vl(r.nextSibling), r === null) break;
    }
    return null;
  }
  function xC(r, a, d) {
    if (a === "") return null;
    for (; r.nodeType !== 3; )
      if ((r.nodeType !== 1 || r.nodeName !== "INPUT" || r.type !== "hidden") && !d || (r = vl(r.nextSibling), r === null)) return null;
    return r;
  }
  function vl(r) {
    for (; r != null; r = r.nextSibling) {
      var a = r.nodeType;
      if (a === 1 || a === 3) break;
      if (a === 8) {
        if (a = r.data, a === "$" || a === "$!" || a === "$?" || a === "F!" || a === "F")
          break;
        if (a === "/$") return null;
      }
    }
    return r;
  }
  function lS(r) {
    r = r.previousSibling;
    for (var a = 0; r; ) {
      if (r.nodeType === 8) {
        var d = r.data;
        if (d === "$" || d === "$!" || d === "$?") {
          if (a === 0) return r;
          a--;
        } else d === "/$" && a++;
      }
      r = r.previousSibling;
    }
    return null;
  }
  function cS(r, a, d) {
    switch (a = iy(d), r) {
      case "html":
        if (r = a.documentElement, !r) throw Error(i(452));
        return r;
      case "head":
        if (r = a.head, !r) throw Error(i(453));
        return r;
      case "body":
        if (r = a.body, !r) throw Error(i(454));
        return r;
      default:
        throw Error(i(451));
    }
  }
  var Eo = /* @__PURE__ */ new Map(), uS = /* @__PURE__ */ new Set();
  function ry(r) {
    return typeof r.getRootNode == "function" ? r.getRootNode() : r.ownerDocument;
  }
  var Tu = dt.d;
  dt.d = {
    f: TC,
    r: CC,
    D: wC,
    C: EC,
    L: AC,
    m: MC,
    X: OC,
    S: RC,
    M: NC
  };
  function TC() {
    var r = Tu.f(), a = _u();
    return r || a;
  }
  function CC(r) {
    var a = wi(r);
    a !== null && a.tag === 5 && a.type === "form" ? B0(a) : Tu.r(r);
  }
  var Tf = typeof document > "u" ? null : document;
  function dS(r, a, d) {
    var m = Tf;
    if (m && typeof a == "string" && a) {
      var C = Tr(a);
      C = 'link[rel="' + r + '"][href="' + C + '"]', typeof d == "string" && (C += '[crossorigin="' + d + '"]'), uS.has(C) || (uS.add(C), r = { rel: r, crossOrigin: d, href: a }, m.querySelector(C) === null && (a = m.createElement("link"), fa(a, "link", r), Pn(a), m.head.appendChild(a)));
    }
  }
  function wC(r) {
    Tu.D(r), dS("dns-prefetch", r, null);
  }
  function EC(r, a) {
    Tu.C(r, a), dS("preconnect", r, a);
  }
  function AC(r, a, d) {
    Tu.L(r, a, d);
    var m = Tf;
    if (m && r && a) {
      var C = 'link[rel="preload"][as="' + Tr(a) + '"]';
      a === "image" && d && d.imageSrcSet ? (C += '[imagesrcset="' + Tr(
        d.imageSrcSet
      ) + '"]', typeof d.imageSizes == "string" && (C += '[imagesizes="' + Tr(
        d.imageSizes
      ) + '"]')) : C += '[href="' + Tr(r) + '"]';
      var B = C;
      switch (a) {
        case "style":
          B = Cf(r);
          break;
        case "script":
          B = wf(r);
      }
      Eo.has(B) || (r = D(
        {
          rel: "preload",
          href: a === "image" && d && d.imageSrcSet ? void 0 : r,
          as: a
        },
        d
      ), Eo.set(B, r), m.querySelector(C) !== null || a === "style" && m.querySelector(nm(B)) || a === "script" && m.querySelector(im(B)) || (a = m.createElement("link"), fa(a, "link", r), Pn(a), m.head.appendChild(a)));
    }
  }
  function MC(r, a) {
    Tu.m(r, a);
    var d = Tf;
    if (d && r) {
      var m = a && typeof a.as == "string" ? a.as : "script", C = 'link[rel="modulepreload"][as="' + Tr(m) + '"][href="' + Tr(r) + '"]', B = C;
      switch (m) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          B = wf(r);
      }
      if (!Eo.has(B) && (r = D({ rel: "modulepreload", href: r }, a), Eo.set(B, r), d.querySelector(C) === null)) {
        switch (m) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            if (d.querySelector(im(B)))
              return;
        }
        m = d.createElement("link"), fa(m, "link", r), Pn(m), d.head.appendChild(m);
      }
    }
  }
  function RC(r, a, d) {
    Tu.S(r, a, d);
    var m = Tf;
    if (m && r) {
      var C = xr(m).hoistableStyles, B = Cf(r);
      a = a || "default";
      var $ = C.get(B);
      if (!$) {
        var at = { loading: 0, preload: null };
        if ($ = m.querySelector(
          nm(B)
        ))
          at.loading = 5;
        else {
          r = D(
            { rel: "stylesheet", href: r, "data-precedence": a },
            d
          ), (d = Eo.get(B)) && jv(r, d);
          var pt = $ = m.createElement("link");
          Pn(pt), fa(pt, "link", r), pt._p = new Promise(function(Mt, Zt) {
            pt.onload = Mt, pt.onerror = Zt;
          }), pt.addEventListener("load", function() {
            at.loading |= 1;
          }), pt.addEventListener("error", function() {
            at.loading |= 2;
          }), at.loading |= 4, ay($, a, m);
        }
        $ = {
          type: "stylesheet",
          instance: $,
          count: 1,
          state: at
        }, C.set(B, $);
      }
    }
  }
  function OC(r, a) {
    Tu.X(r, a);
    var d = Tf;
    if (d && r) {
      var m = xr(d).hoistableScripts, C = wf(r), B = m.get(C);
      B || (B = d.querySelector(im(C)), B || (r = D({ src: r, async: !0 }, a), (a = Eo.get(C)) && Lv(r, a), B = d.createElement("script"), Pn(B), fa(B, "link", r), d.head.appendChild(B)), B = {
        type: "script",
        instance: B,
        count: 1,
        state: null
      }, m.set(C, B));
    }
  }
  function NC(r, a) {
    Tu.M(r, a);
    var d = Tf;
    if (d && r) {
      var m = xr(d).hoistableScripts, C = wf(r), B = m.get(C);
      B || (B = d.querySelector(im(C)), B || (r = D({ src: r, async: !0, type: "module" }, a), (a = Eo.get(C)) && Lv(r, a), B = d.createElement("script"), Pn(B), fa(B, "link", r), d.head.appendChild(B)), B = {
        type: "script",
        instance: B,
        count: 1,
        state: null
      }, m.set(C, B));
    }
  }
  function hS(r, a, d, m) {
    var C = (C = ie.current) ? ry(C) : null;
    if (!C) throw Error(i(446));
    switch (r) {
      case "meta":
      case "title":
        return null;
      case "style":
        return typeof d.precedence == "string" && typeof d.href == "string" ? (a = Cf(d.href), d = xr(
          C
        ).hoistableStyles, m = d.get(a), m || (m = {
          type: "style",
          instance: null,
          count: 0,
          state: null
        }, d.set(a, m)), m) : { type: "void", instance: null, count: 0, state: null };
      case "link":
        if (d.rel === "stylesheet" && typeof d.href == "string" && typeof d.precedence == "string") {
          r = Cf(d.href);
          var B = xr(
            C
          ).hoistableStyles, $ = B.get(r);
          if ($ || (C = C.ownerDocument || C, $ = {
            type: "stylesheet",
            instance: null,
            count: 0,
            state: { loading: 0, preload: null }
          }, B.set(r, $), (B = C.querySelector(
            nm(r)
          )) && !B._p && ($.instance = B, $.state.loading = 5), Eo.has(r) || (d = {
            rel: "preload",
            as: "style",
            href: d.href,
            crossOrigin: d.crossOrigin,
            integrity: d.integrity,
            media: d.media,
            hrefLang: d.hrefLang,
            referrerPolicy: d.referrerPolicy
          }, Eo.set(r, d), B || kC(
            C,
            r,
            d,
            $.state
          ))), a && m === null)
            throw Error(i(528, ""));
          return $;
        }
        if (a && m !== null)
          throw Error(i(529, ""));
        return null;
      case "script":
        return a = d.async, d = d.src, typeof d == "string" && a && typeof a != "function" && typeof a != "symbol" ? (a = wf(d), d = xr(
          C
        ).hoistableScripts, m = d.get(a), m || (m = {
          type: "script",
          instance: null,
          count: 0,
          state: null
        }, d.set(a, m)), m) : { type: "void", instance: null, count: 0, state: null };
      default:
        throw Error(i(444, r));
    }
  }
  function Cf(r) {
    return 'href="' + Tr(r) + '"';
  }
  function nm(r) {
    return 'link[rel="stylesheet"][' + r + "]";
  }
  function fS(r) {
    return D({}, r, {
      "data-precedence": r.precedence,
      precedence: null
    });
  }
  function kC(r, a, d, m) {
    r.querySelector('link[rel="preload"][as="style"][' + a + "]") ? m.loading = 1 : (a = r.createElement("link"), m.preload = a, a.addEventListener("load", function() {
      return m.loading |= 1;
    }), a.addEventListener("error", function() {
      return m.loading |= 2;
    }), fa(a, "link", d), Pn(a), r.head.appendChild(a));
  }
  function wf(r) {
    return '[src="' + Tr(r) + '"]';
  }
  function im(r) {
    return "script[async]" + r;
  }
  function pS(r, a, d) {
    if (a.count++, a.instance === null)
      switch (a.type) {
        case "style":
          var m = r.querySelector(
            'style[data-href~="' + Tr(d.href) + '"]'
          );
          if (m)
            return a.instance = m, Pn(m), m;
          var C = D({}, d, {
            "data-href": d.href,
            "data-precedence": d.precedence,
            href: null,
            precedence: null
          });
          return m = (r.ownerDocument || r).createElement(
            "style"
          ), Pn(m), fa(m, "style", C), ay(m, d.precedence, r), a.instance = m;
        case "stylesheet":
          C = Cf(d.href);
          var B = r.querySelector(
            nm(C)
          );
          if (B)
            return a.state.loading |= 4, a.instance = B, Pn(B), B;
          m = fS(d), (C = Eo.get(C)) && jv(m, C), B = (r.ownerDocument || r).createElement("link"), Pn(B);
          var $ = B;
          return $._p = new Promise(function(at, pt) {
            $.onload = at, $.onerror = pt;
          }), fa(B, "link", m), a.state.loading |= 4, ay(B, d.precedence, r), a.instance = B;
        case "script":
          return B = wf(d.src), (C = r.querySelector(
            im(B)
          )) ? (a.instance = C, Pn(C), C) : (m = d, (C = Eo.get(B)) && (m = D({}, d), Lv(m, C)), r = r.ownerDocument || r, C = r.createElement("script"), Pn(C), fa(C, "link", m), r.head.appendChild(C), a.instance = C);
        case "void":
          return null;
        default:
          throw Error(i(443, a.type));
      }
    else
      a.type === "stylesheet" && (a.state.loading & 4) === 0 && (m = a.instance, a.state.loading |= 4, ay(m, d.precedence, r));
    return a.instance;
  }
  function ay(r, a, d) {
    for (var m = d.querySelectorAll(
      'link[rel="stylesheet"][data-precedence],style[data-precedence]'
    ), C = m.length ? m[m.length - 1] : null, B = C, $ = 0; $ < m.length; $++) {
      var at = m[$];
      if (at.dataset.precedence === a) B = at;
      else if (B !== C) break;
    }
    B ? B.parentNode.insertBefore(r, B.nextSibling) : (a = d.nodeType === 9 ? d.head : d, a.insertBefore(r, a.firstChild));
  }
  function jv(r, a) {
    r.crossOrigin == null && (r.crossOrigin = a.crossOrigin), r.referrerPolicy == null && (r.referrerPolicy = a.referrerPolicy), r.title == null && (r.title = a.title);
  }
  function Lv(r, a) {
    r.crossOrigin == null && (r.crossOrigin = a.crossOrigin), r.referrerPolicy == null && (r.referrerPolicy = a.referrerPolicy), r.integrity == null && (r.integrity = a.integrity);
  }
  var sy = null;
  function mS(r, a, d) {
    if (sy === null) {
      var m = /* @__PURE__ */ new Map(), C = sy = /* @__PURE__ */ new Map();
      C.set(d, m);
    } else
      C = sy, m = C.get(d), m || (m = /* @__PURE__ */ new Map(), C.set(d, m));
    if (m.has(r)) return m;
    for (m.set(r, null), d = d.getElementsByTagName(r), C = 0; C < d.length; C++) {
      var B = d[C];
      if (!(B[eo] || B[Pi] || r === "link" && B.getAttribute("rel") === "stylesheet") && B.namespaceURI !== "http://www.w3.org/2000/svg") {
        var $ = B.getAttribute(a) || "";
        $ = r + $;
        var at = m.get($);
        at ? at.push(B) : m.set($, [B]);
      }
    }
    return m;
  }
  function gS(r, a, d) {
    r = r.ownerDocument || r, r.head.insertBefore(
      d,
      a === "title" ? r.querySelector("head > title") : null
    );
  }
  function DC(r, a, d) {
    if (d === 1 || a.itemProp != null) return !1;
    switch (r) {
      case "meta":
      case "title":
        return !0;
      case "style":
        if (typeof a.precedence != "string" || typeof a.href != "string" || a.href === "")
          break;
        return !0;
      case "link":
        if (typeof a.rel != "string" || typeof a.href != "string" || a.href === "" || a.onLoad || a.onError)
          break;
        switch (a.rel) {
          case "stylesheet":
            return r = a.disabled, typeof a.precedence == "string" && r == null;
          default:
            return !0;
        }
      case "script":
        if (a.async && typeof a.async != "function" && typeof a.async != "symbol" && !a.onLoad && !a.onError && a.src && typeof a.src == "string")
          return !0;
    }
    return !1;
  }
  function yS(r) {
    return !(r.type === "stylesheet" && (r.state.loading & 3) === 0);
  }
  var rm = null;
  function BC() {
  }
  function zC(r, a, d) {
    if (rm === null) throw Error(i(475));
    var m = rm;
    if (a.type === "stylesheet" && (typeof d.media != "string" || matchMedia(d.media).matches !== !1) && (a.state.loading & 4) === 0) {
      if (a.instance === null) {
        var C = Cf(d.href), B = r.querySelector(
          nm(C)
        );
        if (B) {
          r = B._p, r !== null && typeof r == "object" && typeof r.then == "function" && (m.count++, m = oy.bind(m), r.then(m, m)), a.state.loading |= 4, a.instance = B, Pn(B);
          return;
        }
        B = r.ownerDocument || r, d = fS(d), (C = Eo.get(C)) && jv(d, C), B = B.createElement("link"), Pn(B);
        var $ = B;
        $._p = new Promise(function(at, pt) {
          $.onload = at, $.onerror = pt;
        }), fa(B, "link", d), a.instance = B;
      }
      m.stylesheets === null && (m.stylesheets = /* @__PURE__ */ new Map()), m.stylesheets.set(a, r), (r = a.state.preload) && (a.state.loading & 3) === 0 && (m.count++, a = oy.bind(m), r.addEventListener("load", a), r.addEventListener("error", a));
    }
  }
  function PC() {
    if (rm === null) throw Error(i(475));
    var r = rm;
    return r.stylesheets && r.count === 0 && Vv(r, r.stylesheets), 0 < r.count ? function(a) {
      var d = setTimeout(function() {
        if (r.stylesheets && Vv(r, r.stylesheets), r.unsuspend) {
          var m = r.unsuspend;
          r.unsuspend = null, m();
        }
      }, 6e4);
      return r.unsuspend = a, function() {
        r.unsuspend = null, clearTimeout(d);
      };
    } : null;
  }
  function oy() {
    if (this.count--, this.count === 0) {
      if (this.stylesheets) Vv(this, this.stylesheets);
      else if (this.unsuspend) {
        var r = this.unsuspend;
        this.unsuspend = null, r();
      }
    }
  }
  var ly = null;
  function Vv(r, a) {
    r.stylesheets = null, r.unsuspend !== null && (r.count++, ly = /* @__PURE__ */ new Map(), a.forEach(UC, r), ly = null, oy.call(r));
  }
  function UC(r, a) {
    if (!(a.state.loading & 4)) {
      var d = ly.get(r);
      if (d) var m = d.get(null);
      else {
        d = /* @__PURE__ */ new Map(), ly.set(r, d);
        for (var C = r.querySelectorAll(
          "link[data-precedence],style[data-precedence]"
        ), B = 0; B < C.length; B++) {
          var $ = C[B];
          ($.nodeName === "LINK" || $.getAttribute("media") !== "not all") && (d.set($.dataset.precedence, $), m = $);
        }
        m && d.set(null, m);
      }
      C = a.instance, $ = C.getAttribute("data-precedence"), B = d.get($) || m, B === m && d.set(null, C), d.set($, C), this.count++, m = oy.bind(this), C.addEventListener("load", m), C.addEventListener("error", m), B ? B.parentNode.insertBefore(C, B.nextSibling) : (r = r.nodeType === 9 ? r.head : r, r.insertBefore(C, r.firstChild)), a.state.loading |= 4;
    }
  }
  var am = {
    $$typeof: b,
    Provider: null,
    Consumer: null,
    _currentValue: ht,
    _currentValue2: ht,
    _threadCount: 0
  };
  function jC(r, a, d, m, C, B, $, at) {
    this.tag = 1, this.containerInfo = r, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = va(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.finishedLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = va(0), this.hiddenUpdates = va(null), this.identifierPrefix = m, this.onUncaughtError = C, this.onCaughtError = B, this.onRecoverableError = $, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = at, this.incompleteTransitions = /* @__PURE__ */ new Map();
  }
  function vS(r, a, d, m, C, B, $, at, pt, Mt, Zt, he) {
    return r = new jC(
      r,
      a,
      d,
      $,
      at,
      pt,
      Mt,
      he
    ), a = 1, B === !0 && (a |= 24), B = Hi(3, null, null, a), r.current = B, B.stateNode = r, a = Tp(), a.refCount++, r.pooledCache = a, a.refCount++, B.memoizedState = {
      element: m,
      isDehydrated: d,
      cache: a
    }, la(B), r;
  }
  function bS(r) {
    return r ? (r = Fr, r) : Fr;
  }
  function _S(r, a, d, m, C, B) {
    C = bS(C), m.context === null ? m.context = C : m.pendingContext = C, m = Ha(a), m.payload = { element: d }, B = B === void 0 ? null : B, B !== null && (m.callback = B), d = Ka(r, m, a), d !== null && (er(d, r, a), ac(d, r, a));
  }
  function SS(r, a) {
    if (r = r.memoizedState, r !== null && r.dehydrated !== null) {
      var d = r.retryLane;
      r.retryLane = d !== 0 && d < a ? d : a;
    }
  }
  function Iv(r, a) {
    SS(r, a), (r = r.alternate) && SS(r, a);
  }
  function xS(r) {
    if (r.tag === 13) {
      var a = ai(r, 67108864);
      a !== null && er(a, r, 67108864), Iv(r, 67108864);
    }
  }
  var cy = !0;
  function LC(r, a, d, m) {
    var C = V.T;
    V.T = null;
    var B = dt.p;
    try {
      dt.p = 2, Fv(r, a, d, m);
    } finally {
      dt.p = B, V.T = C;
    }
  }
  function VC(r, a, d, m) {
    var C = V.T;
    V.T = null;
    var B = dt.p;
    try {
      dt.p = 8, Fv(r, a, d, m);
    } finally {
      dt.p = B, V.T = C;
    }
  }
  function Fv(r, a, d, m) {
    if (cy) {
      var C = qv(m);
      if (C === null)
        Ov(
          r,
          a,
          m,
          uy,
          d
        ), CS(r, m);
      else if (FC(
        C,
        r,
        a,
        d,
        m
      ))
        m.stopPropagation();
      else if (CS(r, m), a & 4 && -1 < IC.indexOf(r)) {
        for (; C !== null; ) {
          var B = wi(C);
          if (B !== null)
            switch (B.tag) {
              case 3:
                if (B = B.stateNode, B.current.memoizedState.isDehydrated) {
                  var $ = Ze(B.pendingLanes);
                  if ($ !== 0) {
                    var at = B;
                    for (at.pendingLanes |= 2, at.entangledLanes |= 2; $; ) {
                      var pt = 1 << 31 - Ve($);
                      at.entanglements[1] |= pt, $ &= ~pt;
                    }
                    ti(B), (tn & 6) === 0 && (vn = De() + 500, xn(0));
                  }
                }
                break;
              case 13:
                at = ai(B, 2), at !== null && er(at, B, 2), _u(), Iv(B, 2);
            }
          if (B = qv(m), B === null && Ov(
            r,
            a,
            m,
            uy,
            d
          ), B === C) break;
          C = B;
        }
        C !== null && m.stopPropagation();
      } else
        Ov(
          r,
          a,
          m,
          null,
          d
        );
    }
  }
  function qv(r) {
    return r = Nl(r), Gv(r);
  }
  var uy = null;
  function Gv(r) {
    if (uy = null, r = ts(r), r !== null) {
      var a = it(r);
      if (a === null) r = null;
      else {
        var d = a.tag;
        if (d === 13) {
          if (r = nt(a), r !== null) return r;
          r = null;
        } else if (d === 3) {
          if (a.stateNode.current.memoizedState.isDehydrated)
            return a.tag === 3 ? a.stateNode.containerInfo : null;
          r = null;
        } else a !== r && (r = null);
      }
    }
    return uy = r, null;
  }
  function TS(r) {
    switch (r) {
      case "beforetoggle":
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "toggle":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 2;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 8;
      case "message":
        switch (Kt()) {
          case te:
            return 2;
          case It:
            return 8;
          case Ht:
          case Jt:
            return 32;
          case Yt:
            return 268435456;
          default:
            return 32;
        }
      default:
        return 32;
    }
  }
  var Hv = !1, Sd = null, xd = null, Td = null, sm = /* @__PURE__ */ new Map(), om = /* @__PURE__ */ new Map(), Cd = [], IC = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
    " "
  );
  function CS(r, a) {
    switch (r) {
      case "focusin":
      case "focusout":
        Sd = null;
        break;
      case "dragenter":
      case "dragleave":
        xd = null;
        break;
      case "mouseover":
      case "mouseout":
        Td = null;
        break;
      case "pointerover":
      case "pointerout":
        sm.delete(a.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        om.delete(a.pointerId);
    }
  }
  function lm(r, a, d, m, C, B) {
    return r === null || r.nativeEvent !== B ? (r = {
      blockedOn: a,
      domEventName: d,
      eventSystemFlags: m,
      nativeEvent: B,
      targetContainers: [C]
    }, a !== null && (a = wi(a), a !== null && xS(a)), r) : (r.eventSystemFlags |= m, a = r.targetContainers, C !== null && a.indexOf(C) === -1 && a.push(C), r);
  }
  function FC(r, a, d, m, C) {
    switch (a) {
      case "focusin":
        return Sd = lm(
          Sd,
          r,
          a,
          d,
          m,
          C
        ), !0;
      case "dragenter":
        return xd = lm(
          xd,
          r,
          a,
          d,
          m,
          C
        ), !0;
      case "mouseover":
        return Td = lm(
          Td,
          r,
          a,
          d,
          m,
          C
        ), !0;
      case "pointerover":
        var B = C.pointerId;
        return sm.set(
          B,
          lm(
            sm.get(B) || null,
            r,
            a,
            d,
            m,
            C
          )
        ), !0;
      case "gotpointercapture":
        return B = C.pointerId, om.set(
          B,
          lm(
            om.get(B) || null,
            r,
            a,
            d,
            m,
            C
          )
        ), !0;
    }
    return !1;
  }
  function wS(r) {
    var a = ts(r.target);
    if (a !== null) {
      var d = it(a);
      if (d !== null) {
        if (a = d.tag, a === 13) {
          if (a = nt(d), a !== null) {
            r.blockedOn = a, Pa(r.priority, function() {
              if (d.tag === 13) {
                var m = ha(), C = ai(d, m);
                C !== null && er(C, d, m), Iv(d, m);
              }
            });
            return;
          }
        } else if (a === 3 && d.stateNode.current.memoizedState.isDehydrated) {
          r.blockedOn = d.tag === 3 ? d.stateNode.containerInfo : null;
          return;
        }
      }
    }
    r.blockedOn = null;
  }
  function dy(r) {
    if (r.blockedOn !== null) return !1;
    for (var a = r.targetContainers; 0 < a.length; ) {
      var d = qv(r.nativeEvent);
      if (d === null) {
        d = r.nativeEvent;
        var m = new d.constructor(
          d.type,
          d
        );
        Fc = m, d.target.dispatchEvent(m), Fc = null;
      } else
        return a = wi(d), a !== null && xS(a), r.blockedOn = d, !1;
      a.shift();
    }
    return !0;
  }
  function ES(r, a, d) {
    dy(r) && d.delete(a);
  }
  function qC() {
    Hv = !1, Sd !== null && dy(Sd) && (Sd = null), xd !== null && dy(xd) && (xd = null), Td !== null && dy(Td) && (Td = null), sm.forEach(ES), om.forEach(ES);
  }
  function hy(r, a) {
    r.blockedOn === a && (r.blockedOn = null, Hv || (Hv = !0, e.unstable_scheduleCallback(
      e.unstable_NormalPriority,
      qC
    )));
  }
  var fy = null;
  function AS(r) {
    fy !== r && (fy = r, e.unstable_scheduleCallback(
      e.unstable_NormalPriority,
      function() {
        fy === r && (fy = null);
        for (var a = 0; a < r.length; a += 3) {
          var d = r[a], m = r[a + 1], C = r[a + 2];
          if (typeof m != "function") {
            if (Gv(m || d) === null)
              continue;
            break;
          }
          var B = wi(d);
          B !== null && (r.splice(a, 3), a -= 3, kp(
            B,
            {
              pending: !0,
              data: C,
              method: d.method,
              action: m
            },
            m,
            C
          ));
        }
      }
    ));
  }
  function cm(r) {
    function a(pt) {
      return hy(pt, r);
    }
    Sd !== null && hy(Sd, r), xd !== null && hy(xd, r), Td !== null && hy(Td, r), sm.forEach(a), om.forEach(a);
    for (var d = 0; d < Cd.length; d++) {
      var m = Cd[d];
      m.blockedOn === r && (m.blockedOn = null);
    }
    for (; 0 < Cd.length && (d = Cd[0], d.blockedOn === null); )
      wS(d), d.blockedOn === null && Cd.shift();
    if (d = (r.ownerDocument || r).$$reactFormReplay, d != null)
      for (m = 0; m < d.length; m += 3) {
        var C = d[m], B = d[m + 1], $ = C[rn] || null;
        if (typeof B == "function")
          $ || AS(d);
        else if ($) {
          var at = null;
          if (B && B.hasAttribute("formAction")) {
            if (C = B, $ = B[rn] || null)
              at = $.formAction;
            else if (Gv(C) !== null) continue;
          } else at = $.action;
          typeof at == "function" ? d[m + 1] = at : (d.splice(m, 3), m -= 3), AS(d);
        }
      }
  }
  function Kv(r) {
    this._internalRoot = r;
  }
  py.prototype.render = Kv.prototype.render = function(r) {
    var a = this._internalRoot;
    if (a === null) throw Error(i(409));
    var d = a.current, m = ha();
    _S(d, m, r, a, null, null);
  }, py.prototype.unmount = Kv.prototype.unmount = function() {
    var r = this._internalRoot;
    if (r !== null) {
      this._internalRoot = null;
      var a = r.containerInfo;
      r.tag === 0 && ye(), _S(r.current, 2, null, r, null, null), _u(), a[ea] = null;
    }
  };
  function py(r) {
    this._internalRoot = r;
  }
  py.prototype.unstable_scheduleHydration = function(r) {
    if (r) {
      var a = wl();
      r = { blockedOn: null, target: r, priority: a };
      for (var d = 0; d < Cd.length && a !== 0 && a < Cd[d].priority; d++) ;
      Cd.splice(d, 0, r), d === 0 && wS(r);
    }
  };
  var MS = t.version;
  if (MS !== "19.0.0")
    throw Error(
      i(
        527,
        MS,
        "19.0.0"
      )
    );
  dt.findDOMNode = function(r) {
    var a = r._reactInternals;
    if (a === void 0)
      throw typeof r.render == "function" ? Error(i(188)) : (r = Object.keys(r).join(","), Error(i(268, r)));
    return r = rt(a), r = r !== null ? vt(r) : null, r = r === null ? null : r.stateNode, r;
  };
  var GC = {
    bundleType: 0,
    version: "19.0.0",
    rendererPackageName: "react-dom",
    currentDispatcherRef: V,
    findFiberByHostInstance: ts,
    reconcilerVersion: "19.0.0"
  };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var my = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!my.isDisabled && my.supportsFiber)
      try {
        fe = my.inject(
          GC
        ), Me = my;
      } catch {
      }
  }
  return dm.createRoot = function(r, a) {
    if (!s(r)) throw Error(i(299));
    var d = !1, m = "", C = F0, B = q0, $ = G0, at = null;
    return a != null && (a.unstable_strictMode === !0 && (d = !0), a.identifierPrefix !== void 0 && (m = a.identifierPrefix), a.onUncaughtError !== void 0 && (C = a.onUncaughtError), a.onCaughtError !== void 0 && (B = a.onCaughtError), a.onRecoverableError !== void 0 && ($ = a.onRecoverableError), a.unstable_transitionCallbacks !== void 0 && (at = a.unstable_transitionCallbacks)), a = vS(
      r,
      1,
      !1,
      null,
      null,
      d,
      m,
      C,
      B,
      $,
      at,
      null
    ), r[ea] = a.current, Rv(
      r.nodeType === 8 ? r.parentNode : r
    ), new Kv(a);
  }, dm.hydrateRoot = function(r, a, d) {
    if (!s(r)) throw Error(i(299));
    var m = !1, C = "", B = F0, $ = q0, at = G0, pt = null, Mt = null;
    return d != null && (d.unstable_strictMode === !0 && (m = !0), d.identifierPrefix !== void 0 && (C = d.identifierPrefix), d.onUncaughtError !== void 0 && (B = d.onUncaughtError), d.onCaughtError !== void 0 && ($ = d.onCaughtError), d.onRecoverableError !== void 0 && (at = d.onRecoverableError), d.unstable_transitionCallbacks !== void 0 && (pt = d.unstable_transitionCallbacks), d.formState !== void 0 && (Mt = d.formState)), a = vS(
      r,
      1,
      !0,
      a,
      d ?? null,
      m,
      C,
      B,
      $,
      at,
      pt,
      Mt
    ), a.context = bS(null), d = a.current, m = ha(), C = Ha(m), C.callback = null, Ka(d, C, m), a.current.lanes = m, to(a, m), ti(a), r[ea] = a.current, Rv(r), new py(a);
  }, dm.version = "19.0.0", dm;
}
var jS;
function n8() {
  if (jS) return Wv.exports;
  jS = 1;
  function e() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (t) {
        console.error(t);
      }
  }
  return e(), Wv.exports = e8(), Wv.exports;
}
var i8 = n8();
const d3 = /* @__PURE__ */ lp(i8);
function Bu(e, ...t) {
  const n = new URL(`https://mui.com/production-error/?code=${e}`);
  return t.forEach((i) => n.searchParams.append("args[]", i)), `Minified MUI error #${e}; visit ${n} for the full message.`;
}
const Tc = "$$material";
function Wy() {
  return Wy = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n) ({}).hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, Wy.apply(null, arguments);
}
function r8(e) {
  if (e.sheet)
    return e.sheet;
  for (var t = 0; t < document.styleSheets.length; t++)
    if (document.styleSheets[t].ownerNode === e)
      return document.styleSheets[t];
}
function a8(e) {
  var t = document.createElement("style");
  return t.setAttribute("data-emotion", e.key), e.nonce !== void 0 && t.setAttribute("nonce", e.nonce), t.appendChild(document.createTextNode("")), t.setAttribute("data-s", ""), t;
}
var s8 = /* @__PURE__ */ function() {
  function e(n) {
    var i = this;
    this._insertTag = function(s) {
      var o;
      i.tags.length === 0 ? i.insertionPoint ? o = i.insertionPoint.nextSibling : i.prepend ? o = i.container.firstChild : o = i.before : o = i.tags[i.tags.length - 1].nextSibling, i.container.insertBefore(s, o), i.tags.push(s);
    }, this.isSpeedy = n.speedy === void 0 ? !0 : n.speedy, this.tags = [], this.ctr = 0, this.nonce = n.nonce, this.key = n.key, this.container = n.container, this.prepend = n.prepend, this.insertionPoint = n.insertionPoint, this.before = null;
  }
  var t = e.prototype;
  return t.hydrate = function(i) {
    i.forEach(this._insertTag);
  }, t.insert = function(i) {
    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(a8(this));
    var s = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var o = r8(s);
      try {
        o.insertRule(i, o.cssRules.length);
      } catch {
      }
    } else
      s.appendChild(document.createTextNode(i));
    this.ctr++;
  }, t.flush = function() {
    this.tags.forEach(function(i) {
      var s;
      return (s = i.parentNode) == null ? void 0 : s.removeChild(i);
    }), this.tags = [], this.ctr = 0;
  }, e;
}(), Oa = "-ms-", $y = "-moz-", Hn = "-webkit-", h3 = "comm", _2 = "rule", S2 = "decl", o8 = "@import", f3 = "@keyframes", l8 = "@layer", c8 = Math.abs, w1 = String.fromCharCode, u8 = Object.assign;
function d8(e, t) {
  return ma(e, 0) ^ 45 ? (((t << 2 ^ ma(e, 0)) << 2 ^ ma(e, 1)) << 2 ^ ma(e, 2)) << 2 ^ ma(e, 3) : 0;
}
function p3(e) {
  return e.trim();
}
function h8(e, t) {
  return (e = t.exec(e)) ? e[0] : e;
}
function Kn(e, t, n) {
  return e.replace(t, n);
}
function jb(e, t) {
  return e.indexOf(t);
}
function ma(e, t) {
  return e.charCodeAt(t) | 0;
}
function Tg(e, t, n) {
  return e.slice(t, n);
}
function bc(e) {
  return e.length;
}
function x2(e) {
  return e.length;
}
function gy(e, t) {
  return t.push(e), e;
}
function f8(e, t) {
  return e.map(t).join("");
}
var E1 = 1, Kf = 1, m3 = 0, Cs = 0, Rr = 0, cp = "";
function A1(e, t, n, i, s, o, u) {
  return { value: e, root: t, parent: n, type: i, props: s, children: o, line: E1, column: Kf, length: u, return: "" };
}
function hm(e, t) {
  return u8(A1("", null, null, "", null, null, 0), e, { length: -e.length }, t);
}
function p8() {
  return Rr;
}
function m8() {
  return Rr = Cs > 0 ? ma(cp, --Cs) : 0, Kf--, Rr === 10 && (Kf = 1, E1--), Rr;
}
function Ws() {
  return Rr = Cs < m3 ? ma(cp, Cs++) : 0, Kf++, Rr === 10 && (Kf = 1, E1++), Rr;
}
function Cc() {
  return ma(cp, Cs);
}
function Vy() {
  return Cs;
}
function Pg(e, t) {
  return Tg(cp, e, t);
}
function Cg(e) {
  switch (e) {
    // \0 \t \n \r \s whitespace token
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    // ! + , / > @ ~ isolate token
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    // ; { } breakpoint token
    case 59:
    case 123:
    case 125:
      return 4;
    // : accompanied token
    case 58:
      return 3;
    // " ' ( [ opening delimit token
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    // ) ] closing delimit token
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function g3(e) {
  return E1 = Kf = 1, m3 = bc(cp = e), Cs = 0, [];
}
function y3(e) {
  return cp = "", e;
}
function Iy(e) {
  return p3(Pg(Cs - 1, Lb(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function g8(e) {
  for (; (Rr = Cc()) && Rr < 33; )
    Ws();
  return Cg(e) > 2 || Cg(Rr) > 3 ? "" : " ";
}
function y8(e, t) {
  for (; --t && Ws() && !(Rr < 48 || Rr > 102 || Rr > 57 && Rr < 65 || Rr > 70 && Rr < 97); )
    ;
  return Pg(e, Vy() + (t < 6 && Cc() == 32 && Ws() == 32));
}
function Lb(e) {
  for (; Ws(); )
    switch (Rr) {
      // ] ) " '
      case e:
        return Cs;
      // " '
      case 34:
      case 39:
        e !== 34 && e !== 39 && Lb(Rr);
        break;
      // (
      case 40:
        e === 41 && Lb(e);
        break;
      // \
      case 92:
        Ws();
        break;
    }
  return Cs;
}
function v8(e, t) {
  for (; Ws() && e + Rr !== 57; )
    if (e + Rr === 84 && Cc() === 47)
      break;
  return "/*" + Pg(t, Cs - 1) + "*" + w1(e === 47 ? e : Ws());
}
function b8(e) {
  for (; !Cg(Cc()); )
    Ws();
  return Pg(e, Cs);
}
function _8(e) {
  return y3(Fy("", null, null, null, [""], e = g3(e), 0, [0], e));
}
function Fy(e, t, n, i, s, o, u, h, f) {
  for (var p = 0, g = 0, v = u, x = 0, b = 0, _ = 0, T = 1, A = 1, O = 1, M = 0, E = "", R = s, N = o, U = i, q = E; A; )
    switch (_ = M, M = Ws()) {
      // (
      case 40:
        if (_ != 108 && ma(q, v - 1) == 58) {
          jb(q += Kn(Iy(M), "&", "&\f"), "&\f") != -1 && (O = -1);
          break;
        }
      // " ' [
      case 34:
      case 39:
      case 91:
        q += Iy(M);
        break;
      // \t \n \r \s
      case 9:
      case 10:
      case 13:
      case 32:
        q += g8(_);
        break;
      // \
      case 92:
        q += y8(Vy() - 1, 7);
        continue;
      // /
      case 47:
        switch (Cc()) {
          case 42:
          case 47:
            gy(S8(v8(Ws(), Vy()), t, n), f);
            break;
          default:
            q += "/";
        }
        break;
      // {
      case 123 * T:
        h[p++] = bc(q) * O;
      // } ; \0
      case 125 * T:
      case 59:
      case 0:
        switch (M) {
          // \0 }
          case 0:
          case 125:
            A = 0;
          // ;
          case 59 + g:
            O == -1 && (q = Kn(q, /\f/g, "")), b > 0 && bc(q) - v && gy(b > 32 ? VS(q + ";", i, n, v - 1) : VS(Kn(q, " ", "") + ";", i, n, v - 2), f);
            break;
          // @ ;
          case 59:
            q += ";";
          // { rule/at-rule
          default:
            if (gy(U = LS(q, t, n, p, g, s, h, E, R = [], N = [], v), o), M === 123)
              if (g === 0)
                Fy(q, t, U, U, R, o, v, h, N);
              else
                switch (x === 99 && ma(q, 3) === 110 ? 100 : x) {
                  // d l m s
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    Fy(e, U, U, i && gy(LS(e, U, U, 0, 0, s, h, E, s, R = [], v), N), s, N, v, h, i ? R : N);
                    break;
                  default:
                    Fy(q, U, U, U, [""], N, 0, h, N);
                }
        }
        p = g = b = 0, T = O = 1, E = q = "", v = u;
        break;
      // :
      case 58:
        v = 1 + bc(q), b = _;
      default:
        if (T < 1) {
          if (M == 123)
            --T;
          else if (M == 125 && T++ == 0 && m8() == 125)
            continue;
        }
        switch (q += w1(M), M * T) {
          // &
          case 38:
            O = g > 0 ? 1 : (q += "\f", -1);
            break;
          // ,
          case 44:
            h[p++] = (bc(q) - 1) * O, O = 1;
            break;
          // @
          case 64:
            Cc() === 45 && (q += Iy(Ws())), x = Cc(), g = v = bc(E = q += b8(Vy())), M++;
            break;
          // -
          case 45:
            _ === 45 && bc(q) == 2 && (T = 0);
        }
    }
  return o;
}
function LS(e, t, n, i, s, o, u, h, f, p, g) {
  for (var v = s - 1, x = s === 0 ? o : [""], b = x2(x), _ = 0, T = 0, A = 0; _ < i; ++_)
    for (var O = 0, M = Tg(e, v + 1, v = c8(T = u[_])), E = e; O < b; ++O)
      (E = p3(T > 0 ? x[O] + " " + M : Kn(M, /&\f/g, x[O]))) && (f[A++] = E);
  return A1(e, t, n, s === 0 ? _2 : h, f, p, g);
}
function S8(e, t, n) {
  return A1(e, t, n, h3, w1(p8()), Tg(e, 2, -2), 0);
}
function VS(e, t, n, i) {
  return A1(e, t, n, S2, Tg(e, 0, i), Tg(e, i + 1, -1), i);
}
function Ff(e, t) {
  for (var n = "", i = x2(e), s = 0; s < i; s++)
    n += t(e[s], s, e, t) || "";
  return n;
}
function x8(e, t, n, i) {
  switch (e.type) {
    case l8:
      if (e.children.length) break;
    case o8:
    case S2:
      return e.return = e.return || e.value;
    case h3:
      return "";
    case f3:
      return e.return = e.value + "{" + Ff(e.children, i) + "}";
    case _2:
      e.value = e.props.join(",");
  }
  return bc(n = Ff(e.children, i)) ? e.return = e.value + "{" + n + "}" : "";
}
function T8(e) {
  var t = x2(e);
  return function(n, i, s, o) {
    for (var u = "", h = 0; h < t; h++)
      u += e[h](n, i, s, o) || "";
    return u;
  };
}
function C8(e) {
  return function(t) {
    t.root || (t = t.return) && e(t);
  };
}
function v3(e) {
  var t = /* @__PURE__ */ Object.create(null);
  return function(n) {
    return t[n] === void 0 && (t[n] = e(n)), t[n];
  };
}
var w8 = function(t, n, i) {
  for (var s = 0, o = 0; s = o, o = Cc(), s === 38 && o === 12 && (n[i] = 1), !Cg(o); )
    Ws();
  return Pg(t, Cs);
}, E8 = function(t, n) {
  var i = -1, s = 44;
  do
    switch (Cg(s)) {
      case 0:
        s === 38 && Cc() === 12 && (n[i] = 1), t[i] += w8(Cs - 1, n, i);
        break;
      case 2:
        t[i] += Iy(s);
        break;
      case 4:
        if (s === 44) {
          t[++i] = Cc() === 58 ? "&\f" : "", n[i] = t[i].length;
          break;
        }
      // fallthrough
      default:
        t[i] += w1(s);
    }
  while (s = Ws());
  return t;
}, A8 = function(t, n) {
  return y3(E8(g3(t), n));
}, IS = /* @__PURE__ */ new WeakMap(), M8 = function(t) {
  if (!(t.type !== "rule" || !t.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  t.length < 1)) {
    for (var n = t.value, i = t.parent, s = t.column === i.column && t.line === i.line; i.type !== "rule"; )
      if (i = i.parent, !i) return;
    if (!(t.props.length === 1 && n.charCodeAt(0) !== 58 && !IS.get(i)) && !s) {
      IS.set(t, !0);
      for (var o = [], u = A8(n, o), h = i.props, f = 0, p = 0; f < u.length; f++)
        for (var g = 0; g < h.length; g++, p++)
          t.props[p] = o[f] ? u[f].replace(/&\f/g, h[g]) : h[g] + " " + u[f];
    }
  }
}, R8 = function(t) {
  if (t.type === "decl") {
    var n = t.value;
    // charcode for l
    n.charCodeAt(0) === 108 && // charcode for b
    n.charCodeAt(2) === 98 && (t.return = "", t.value = "");
  }
};
function b3(e, t) {
  switch (d8(e, t)) {
    // color-adjust
    case 5103:
      return Hn + "print-" + e + e;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return Hn + e + e;
    // appearance, user-select, transform, hyphens, text-size-adjust
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return Hn + e + $y + e + Oa + e + e;
    // flex, flex-direction
    case 6828:
    case 4268:
      return Hn + e + Oa + e + e;
    // order
    case 6165:
      return Hn + e + Oa + "flex-" + e + e;
    // align-items
    case 5187:
      return Hn + e + Kn(e, /(\w+).+(:[^]+)/, Hn + "box-$1$2" + Oa + "flex-$1$2") + e;
    // align-self
    case 5443:
      return Hn + e + Oa + "flex-item-" + Kn(e, /flex-|-self/, "") + e;
    // align-content
    case 4675:
      return Hn + e + Oa + "flex-line-pack" + Kn(e, /align-content|flex-|-self/, "") + e;
    // flex-shrink
    case 5548:
      return Hn + e + Oa + Kn(e, "shrink", "negative") + e;
    // flex-basis
    case 5292:
      return Hn + e + Oa + Kn(e, "basis", "preferred-size") + e;
    // flex-grow
    case 6060:
      return Hn + "box-" + Kn(e, "-grow", "") + Hn + e + Oa + Kn(e, "grow", "positive") + e;
    // transition
    case 4554:
      return Hn + Kn(e, /([^-])(transform)/g, "$1" + Hn + "$2") + e;
    // cursor
    case 6187:
      return Kn(Kn(Kn(e, /(zoom-|grab)/, Hn + "$1"), /(image-set)/, Hn + "$1"), e, "") + e;
    // background, background-image
    case 5495:
    case 3959:
      return Kn(e, /(image-set\([^]*)/, Hn + "$1$`$1");
    // justify-content
    case 4968:
      return Kn(Kn(e, /(.+:)(flex-)?(.*)/, Hn + "box-pack:$3" + Oa + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + Hn + e + e;
    // (margin|padding)-inline-(start|end)
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return Kn(e, /(.+)-inline(.+)/, Hn + "$1$2") + e;
    // (min|max)?(width|height|inline-size|block-size)
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (bc(e) - 1 - t > 6) switch (ma(e, t + 1)) {
        // (m)ax-content, (m)in-content
        case 109:
          if (ma(e, t + 4) !== 45) break;
        // (f)ill-available, (f)it-content
        case 102:
          return Kn(e, /(.+:)(.+)-([^]+)/, "$1" + Hn + "$2-$3$1" + $y + (ma(e, t + 3) == 108 ? "$3" : "$2-$3")) + e;
        // (s)tretch
        case 115:
          return ~jb(e, "stretch") ? b3(Kn(e, "stretch", "fill-available"), t) + e : e;
      }
      break;
    // position: sticky
    case 4949:
      if (ma(e, t + 1) !== 115) break;
    // display: (flex|inline-flex)
    case 6444:
      switch (ma(e, bc(e) - 3 - (~jb(e, "!important") && 10))) {
        // stic(k)y
        case 107:
          return Kn(e, ":", ":" + Hn) + e;
        // (inline-)?fl(e)x
        case 101:
          return Kn(e, /(.+:)([^;!]+)(;|!.+)?/, "$1" + Hn + (ma(e, 14) === 45 ? "inline-" : "") + "box$3$1" + Hn + "$2$3$1" + Oa + "$2box$3") + e;
      }
      break;
    // writing-mode
    case 5936:
      switch (ma(e, t + 11)) {
        // vertical-l(r)
        case 114:
          return Hn + e + Oa + Kn(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
        // vertical-r(l)
        case 108:
          return Hn + e + Oa + Kn(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
        // horizontal(-)tb
        case 45:
          return Hn + e + Oa + Kn(e, /[svh]\w+-[tblr]{2}/, "lr") + e;
      }
      return Hn + e + Oa + e + e;
  }
  return e;
}
var O8 = function(t, n, i, s) {
  if (t.length > -1 && !t.return) switch (t.type) {
    case S2:
      t.return = b3(t.value, t.length);
      break;
    case f3:
      return Ff([hm(t, {
        value: Kn(t.value, "@", "@" + Hn)
      })], s);
    case _2:
      if (t.length) return f8(t.props, function(o) {
        switch (h8(o, /(::plac\w+|:read-\w+)/)) {
          // :read-(only|write)
          case ":read-only":
          case ":read-write":
            return Ff([hm(t, {
              props: [Kn(o, /:(read-\w+)/, ":" + $y + "$1")]
            })], s);
          // :placeholder
          case "::placeholder":
            return Ff([hm(t, {
              props: [Kn(o, /:(plac\w+)/, ":" + Hn + "input-$1")]
            }), hm(t, {
              props: [Kn(o, /:(plac\w+)/, ":" + $y + "$1")]
            }), hm(t, {
              props: [Kn(o, /:(plac\w+)/, Oa + "input-$1")]
            })], s);
        }
        return "";
      });
  }
}, N8 = [O8], k8 = function(t) {
  var n = t.key;
  if (n === "css") {
    var i = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(i, function(T) {
      var A = T.getAttribute("data-emotion");
      A.indexOf(" ") !== -1 && (document.head.appendChild(T), T.setAttribute("data-s", ""));
    });
  }
  var s = t.stylisPlugins || N8, o = {}, u, h = [];
  u = t.container || document.head, Array.prototype.forEach.call(
    // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll('style[data-emotion^="' + n + ' "]'),
    function(T) {
      for (var A = T.getAttribute("data-emotion").split(" "), O = 1; O < A.length; O++)
        o[A[O]] = !0;
      h.push(T);
    }
  );
  var f, p = [M8, R8];
  {
    var g, v = [x8, C8(function(T) {
      g.insert(T);
    })], x = T8(p.concat(s, v)), b = function(A) {
      return Ff(_8(A), x);
    };
    f = function(A, O, M, E) {
      g = M, b(A ? A + "{" + O.styles + "}" : O.styles), E && (_.inserted[O.name] = !0);
    };
  }
  var _ = {
    key: n,
    sheet: new s8({
      key: n,
      container: u,
      nonce: t.nonce,
      speedy: t.speedy,
      prepend: t.prepend,
      insertionPoint: t.insertionPoint
    }),
    nonce: t.nonce,
    inserted: o,
    registered: {},
    insert: f
  };
  return _.sheet.hydrate(h), _;
}, Jv = { exports: {} }, Zn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var FS;
function D8() {
  if (FS) return Zn;
  FS = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, i = e ? Symbol.for("react.fragment") : 60107, s = e ? Symbol.for("react.strict_mode") : 60108, o = e ? Symbol.for("react.profiler") : 60114, u = e ? Symbol.for("react.provider") : 60109, h = e ? Symbol.for("react.context") : 60110, f = e ? Symbol.for("react.async_mode") : 60111, p = e ? Symbol.for("react.concurrent_mode") : 60111, g = e ? Symbol.for("react.forward_ref") : 60112, v = e ? Symbol.for("react.suspense") : 60113, x = e ? Symbol.for("react.suspense_list") : 60120, b = e ? Symbol.for("react.memo") : 60115, _ = e ? Symbol.for("react.lazy") : 60116, T = e ? Symbol.for("react.block") : 60121, A = e ? Symbol.for("react.fundamental") : 60117, O = e ? Symbol.for("react.responder") : 60118, M = e ? Symbol.for("react.scope") : 60119;
  function E(N) {
    if (typeof N == "object" && N !== null) {
      var U = N.$$typeof;
      switch (U) {
        case t:
          switch (N = N.type, N) {
            case f:
            case p:
            case i:
            case o:
            case s:
            case v:
              return N;
            default:
              switch (N = N && N.$$typeof, N) {
                case h:
                case g:
                case _:
                case b:
                case u:
                  return N;
                default:
                  return U;
              }
          }
        case n:
          return U;
      }
    }
  }
  function R(N) {
    return E(N) === p;
  }
  return Zn.AsyncMode = f, Zn.ConcurrentMode = p, Zn.ContextConsumer = h, Zn.ContextProvider = u, Zn.Element = t, Zn.ForwardRef = g, Zn.Fragment = i, Zn.Lazy = _, Zn.Memo = b, Zn.Portal = n, Zn.Profiler = o, Zn.StrictMode = s, Zn.Suspense = v, Zn.isAsyncMode = function(N) {
    return R(N) || E(N) === f;
  }, Zn.isConcurrentMode = R, Zn.isContextConsumer = function(N) {
    return E(N) === h;
  }, Zn.isContextProvider = function(N) {
    return E(N) === u;
  }, Zn.isElement = function(N) {
    return typeof N == "object" && N !== null && N.$$typeof === t;
  }, Zn.isForwardRef = function(N) {
    return E(N) === g;
  }, Zn.isFragment = function(N) {
    return E(N) === i;
  }, Zn.isLazy = function(N) {
    return E(N) === _;
  }, Zn.isMemo = function(N) {
    return E(N) === b;
  }, Zn.isPortal = function(N) {
    return E(N) === n;
  }, Zn.isProfiler = function(N) {
    return E(N) === o;
  }, Zn.isStrictMode = function(N) {
    return E(N) === s;
  }, Zn.isSuspense = function(N) {
    return E(N) === v;
  }, Zn.isValidElementType = function(N) {
    return typeof N == "string" || typeof N == "function" || N === i || N === p || N === o || N === s || N === v || N === x || typeof N == "object" && N !== null && (N.$$typeof === _ || N.$$typeof === b || N.$$typeof === u || N.$$typeof === h || N.$$typeof === g || N.$$typeof === A || N.$$typeof === O || N.$$typeof === M || N.$$typeof === T);
  }, Zn.typeOf = E, Zn;
}
var qS;
function B8() {
  return qS || (qS = 1, Jv.exports = D8()), Jv.exports;
}
var tb, GS;
function z8() {
  if (GS) return tb;
  GS = 1;
  var e = B8(), t = {
    childContextTypes: !0,
    contextType: !0,
    contextTypes: !0,
    defaultProps: !0,
    displayName: !0,
    getDefaultProps: !0,
    getDerivedStateFromError: !0,
    getDerivedStateFromProps: !0,
    mixins: !0,
    propTypes: !0,
    type: !0
  }, n = {
    name: !0,
    length: !0,
    prototype: !0,
    caller: !0,
    callee: !0,
    arguments: !0,
    arity: !0
  }, i = {
    $$typeof: !0,
    render: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0
  }, s = {
    $$typeof: !0,
    compare: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0,
    type: !0
  }, o = {};
  o[e.ForwardRef] = i, o[e.Memo] = s;
  function u(_) {
    return e.isMemo(_) ? s : o[_.$$typeof] || t;
  }
  var h = Object.defineProperty, f = Object.getOwnPropertyNames, p = Object.getOwnPropertySymbols, g = Object.getOwnPropertyDescriptor, v = Object.getPrototypeOf, x = Object.prototype;
  function b(_, T, A) {
    if (typeof T != "string") {
      if (x) {
        var O = v(T);
        O && O !== x && b(_, O, A);
      }
      var M = f(T);
      p && (M = M.concat(p(T)));
      for (var E = u(_), R = u(T), N = 0; N < M.length; ++N) {
        var U = M[N];
        if (!n[U] && !(A && A[U]) && !(R && R[U]) && !(E && E[U])) {
          var q = g(T, U);
          try {
            h(_, U, q);
          } catch {
          }
        }
      }
    }
    return _;
  }
  return tb = b, tb;
}
z8();
var P8 = !0;
function _3(e, t, n) {
  var i = "";
  return n.split(" ").forEach(function(s) {
    e[s] !== void 0 ? t.push(e[s] + ";") : s && (i += s + " ");
  }), i;
}
var T2 = function(t, n, i) {
  var s = t.key + "-" + n.name;
  // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  (i === !1 || // we need to always store it if we're in compat mode and
  // in node since emotion-server relies on whether a style is in
  // the registered cache to know whether a style is global or not
  // also, note that this check will be dead code eliminated in the browser
  P8 === !1) && t.registered[s] === void 0 && (t.registered[s] = n.styles);
}, C2 = function(t, n, i) {
  T2(t, n, i);
  var s = t.key + "-" + n.name;
  if (t.inserted[n.name] === void 0) {
    var o = n;
    do
      t.insert(n === o ? "." + s : "", o, t.sheet, !0), o = o.next;
    while (o !== void 0);
  }
};
function U8(e) {
  for (var t = 0, n, i = 0, s = e.length; s >= 4; ++i, s -= 4)
    n = e.charCodeAt(i) & 255 | (e.charCodeAt(++i) & 255) << 8 | (e.charCodeAt(++i) & 255) << 16 | (e.charCodeAt(++i) & 255) << 24, n = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= /* k >>> r: */
    n >>> 24, t = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  switch (s) {
    case 3:
      t ^= (e.charCodeAt(i + 2) & 255) << 16;
    case 2:
      t ^= (e.charCodeAt(i + 1) & 255) << 8;
    case 1:
      t ^= e.charCodeAt(i) & 255, t = /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  }
  return t ^= t >>> 13, t = /* Math.imul(h, m): */
  (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
}
var j8 = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, L8 = /[A-Z]|^ms/g, V8 = /_EMO_([^_]+?)_([^]*?)_EMO_/g, S3 = function(t) {
  return t.charCodeAt(1) === 45;
}, HS = function(t) {
  return t != null && typeof t != "boolean";
}, eb = /* @__PURE__ */ v3(function(e) {
  return S3(e) ? e : e.replace(L8, "-$&").toLowerCase();
}), KS = function(t, n) {
  switch (t) {
    case "animation":
    case "animationName":
      if (typeof n == "string")
        return n.replace(V8, function(i, s, o) {
          return _c = {
            name: s,
            styles: o,
            next: _c
          }, s;
        });
  }
  return j8[t] !== 1 && !S3(t) && typeof n == "number" && n !== 0 ? n + "px" : n;
};
function wg(e, t, n) {
  if (n == null)
    return "";
  var i = n;
  if (i.__emotion_styles !== void 0)
    return i;
  switch (typeof n) {
    case "boolean":
      return "";
    case "object": {
      var s = n;
      if (s.anim === 1)
        return _c = {
          name: s.name,
          styles: s.styles,
          next: _c
        }, s.name;
      var o = n;
      if (o.styles !== void 0) {
        var u = o.next;
        if (u !== void 0)
          for (; u !== void 0; )
            _c = {
              name: u.name,
              styles: u.styles,
              next: _c
            }, u = u.next;
        var h = o.styles + ";";
        return h;
      }
      return I8(e, t, n);
    }
    case "function": {
      if (e !== void 0) {
        var f = _c, p = n(e);
        return _c = f, wg(e, t, p);
      }
      break;
    }
  }
  var g = n;
  if (t == null)
    return g;
  var v = t[g];
  return v !== void 0 ? v : g;
}
function I8(e, t, n) {
  var i = "";
  if (Array.isArray(n))
    for (var s = 0; s < n.length; s++)
      i += wg(e, t, n[s]) + ";";
  else
    for (var o in n) {
      var u = n[o];
      if (typeof u != "object") {
        var h = u;
        t != null && t[h] !== void 0 ? i += o + "{" + t[h] + "}" : HS(h) && (i += eb(o) + ":" + KS(o, h) + ";");
      } else if (Array.isArray(u) && typeof u[0] == "string" && (t == null || t[u[0]] === void 0))
        for (var f = 0; f < u.length; f++)
          HS(u[f]) && (i += eb(o) + ":" + KS(o, u[f]) + ";");
      else {
        var p = wg(e, t, u);
        switch (o) {
          case "animation":
          case "animationName": {
            i += eb(o) + ":" + p + ";";
            break;
          }
          default:
            i += o + "{" + p + "}";
        }
      }
    }
  return i;
}
var YS = /label:\s*([^\s;{]+)\s*(;|$)/g, _c;
function Ug(e, t, n) {
  if (e.length === 1 && typeof e[0] == "object" && e[0] !== null && e[0].styles !== void 0)
    return e[0];
  var i = !0, s = "";
  _c = void 0;
  var o = e[0];
  if (o == null || o.raw === void 0)
    i = !1, s += wg(n, t, o);
  else {
    var u = o;
    s += u[0];
  }
  for (var h = 1; h < e.length; h++)
    if (s += wg(n, t, e[h]), i) {
      var f = o;
      s += f[h];
    }
  YS.lastIndex = 0;
  for (var p = "", g; (g = YS.exec(s)) !== null; )
    p += "-" + g[1];
  var v = U8(s) + p;
  return {
    name: v,
    styles: s,
    next: _c
  };
}
var F8 = function(t) {
  return t();
}, x3 = Ub.useInsertionEffect ? Ub.useInsertionEffect : !1, T3 = x3 || F8, XS = x3 || tt.useLayoutEffect, C3 = /* @__PURE__ */ tt.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement < "u" ? /* @__PURE__ */ k8({
    key: "css"
  }) : null
);
C3.Provider;
var w2 = function(t) {
  return /* @__PURE__ */ tt.forwardRef(function(n, i) {
    var s = tt.useContext(C3);
    return t(n, s, i);
  });
}, jg = /* @__PURE__ */ tt.createContext({}), E2 = {}.hasOwnProperty, Vb = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", q8 = function(t, n) {
  var i = {};
  for (var s in n)
    E2.call(n, s) && (i[s] = n[s]);
  return i[Vb] = t, i;
}, G8 = function(t) {
  var n = t.cache, i = t.serialized, s = t.isStringTag;
  return T2(n, i, s), T3(function() {
    return C2(n, i, s);
  }), null;
}, H8 = /* @__PURE__ */ w2(function(e, t, n) {
  var i = e.css;
  typeof i == "string" && t.registered[i] !== void 0 && (i = t.registered[i]);
  var s = e[Vb], o = [i], u = "";
  typeof e.className == "string" ? u = _3(t.registered, o, e.className) : e.className != null && (u = e.className + " ");
  var h = Ug(o, void 0, tt.useContext(jg));
  u += t.key + "-" + h.name;
  var f = {};
  for (var p in e)
    E2.call(e, p) && p !== "css" && p !== Vb && (f[p] = e[p]);
  return f.className = u, n && (f.ref = n), /* @__PURE__ */ tt.createElement(tt.Fragment, null, /* @__PURE__ */ tt.createElement(G8, {
    cache: t,
    serialized: h,
    isStringTag: typeof s == "string"
  }), /* @__PURE__ */ tt.createElement(s, f));
}), K8 = H8, WS = function(t, n) {
  var i = arguments;
  if (n == null || !E2.call(n, "css"))
    return tt.createElement.apply(void 0, i);
  var s = i.length, o = new Array(s);
  o[0] = K8, o[1] = q8(t, n);
  for (var u = 2; u < s; u++)
    o[u] = i[u];
  return tt.createElement.apply(null, o);
};
(function(e) {
  var t;
  t || (t = e.JSX || (e.JSX = {}));
})(WS || (WS = {}));
var Y8 = /* @__PURE__ */ w2(function(e, t) {
  var n = e.styles, i = Ug([n], void 0, tt.useContext(jg)), s = tt.useRef();
  return XS(function() {
    var o = t.key + "-global", u = new t.sheet.constructor({
      key: o,
      nonce: t.sheet.nonce,
      container: t.sheet.container,
      speedy: t.sheet.isSpeedy
    }), h = !1, f = document.querySelector('style[data-emotion="' + o + " " + i.name + '"]');
    return t.sheet.tags.length && (u.before = t.sheet.tags[0]), f !== null && (h = !0, f.setAttribute("data-emotion", o), u.hydrate([f])), s.current = [u, h], function() {
      u.flush();
    };
  }, [t]), XS(function() {
    var o = s.current, u = o[0], h = o[1];
    if (h) {
      o[1] = !1;
      return;
    }
    if (i.next !== void 0 && C2(t, i.next, !0), u.tags.length) {
      var f = u.tags[u.tags.length - 1].nextElementSibling;
      u.before = f, u.flush();
    }
    t.insert("", i, u, !1);
  }, [t, i.name]), null;
});
function A2() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return Ug(t);
}
function Lg() {
  var e = A2.apply(void 0, arguments), t = "animation-" + e.name;
  return {
    name: t,
    styles: "@keyframes " + t + "{" + e.styles + "}",
    anim: 1,
    toString: function() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
}
var X8 = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, W8 = /* @__PURE__ */ v3(
  function(e) {
    return X8.test(e) || e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) < 91;
  }
  /* Z+1 */
), $8 = W8, Q8 = function(t) {
  return t !== "theme";
}, $S = function(t) {
  return typeof t == "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  t.charCodeAt(0) > 96 ? $8 : Q8;
}, QS = function(t, n, i) {
  var s;
  if (n) {
    var o = n.shouldForwardProp;
    s = t.__emotion_forwardProp && o ? function(u) {
      return t.__emotion_forwardProp(u) && o(u);
    } : o;
  }
  return typeof s != "function" && i && (s = t.__emotion_forwardProp), s;
}, Z8 = function(t) {
  var n = t.cache, i = t.serialized, s = t.isStringTag;
  return T2(n, i, s), T3(function() {
    return C2(n, i, s);
  }), null;
}, J8 = function e(t, n) {
  var i = t.__emotion_real === t, s = i && t.__emotion_base || t, o, u;
  n !== void 0 && (o = n.label, u = n.target);
  var h = QS(t, n, i), f = h || $S(s), p = !f("as");
  return function() {
    var g = arguments, v = i && t.__emotion_styles !== void 0 ? t.__emotion_styles.slice(0) : [];
    if (o !== void 0 && v.push("label:" + o + ";"), g[0] == null || g[0].raw === void 0)
      v.push.apply(v, g);
    else {
      var x = g[0];
      v.push(x[0]);
      for (var b = g.length, _ = 1; _ < b; _++)
        v.push(g[_], x[_]);
    }
    var T = w2(function(A, O, M) {
      var E = p && A.as || s, R = "", N = [], U = A;
      if (A.theme == null) {
        U = {};
        for (var q in A)
          U[q] = A[q];
        U.theme = tt.useContext(jg);
      }
      typeof A.className == "string" ? R = _3(O.registered, N, A.className) : A.className != null && (R = A.className + " ");
      var j = Ug(v.concat(N), O.registered, U);
      R += O.key + "-" + j.name, u !== void 0 && (R += " " + u);
      var V = p && h === void 0 ? $S(E) : f, D = {};
      for (var G in A)
        p && G === "as" || V(G) && (D[G] = A[G]);
      return D.className = R, M && (D.ref = M), /* @__PURE__ */ tt.createElement(tt.Fragment, null, /* @__PURE__ */ tt.createElement(Z8, {
        cache: O,
        serialized: j,
        isStringTag: typeof E == "string"
      }), /* @__PURE__ */ tt.createElement(E, D));
    });
    return T.displayName = o !== void 0 ? o : "Styled(" + (typeof s == "string" ? s : s.displayName || s.name || "Component") + ")", T.defaultProps = t.defaultProps, T.__emotion_real = T, T.__emotion_base = s, T.__emotion_styles = v, T.__emotion_forwardProp = h, Object.defineProperty(T, "toString", {
      value: function() {
        return "." + u;
      }
    }), T.withComponent = function(A, O) {
      var M = e(A, Wy({}, n, O, {
        shouldForwardProp: QS(T, O, !0)
      }));
      return M.apply(void 0, v);
    }, T;
  };
}, tw = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
], Ib = J8.bind(null);
tw.forEach(function(e) {
  Ib[e] = Ib(e);
});
function ew(e) {
  return e == null || Object.keys(e).length === 0;
}
function w3(e) {
  const {
    styles: t,
    defaultTheme: n = {}
  } = e, i = typeof t == "function" ? (s) => t(ew(s) ? n : s) : t;
  return /* @__PURE__ */ J.jsx(Y8, {
    styles: i
  });
}
/**
 * @mui/styled-engine v6.4.8
 *
 * @license MIT
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
function E3(e, t) {
  return Ib(e, t);
}
function nw(e, t) {
  Array.isArray(e.__emotion_styles) && (e.__emotion_styles = t(e.__emotion_styles));
}
const ZS = [];
function JS(e) {
  return ZS[0] = e, Ug(ZS);
}
var nb = { exports: {} }, ci = {};
/**
 * @license React
 * react-is.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var t5;
function iw() {
  if (t5) return ci;
  t5 = 1;
  var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), o = Symbol.for("react.consumer"), u = Symbol.for("react.context"), h = Symbol.for("react.forward_ref"), f = Symbol.for("react.suspense"), p = Symbol.for("react.suspense_list"), g = Symbol.for("react.memo"), v = Symbol.for("react.lazy"), x = Symbol.for("react.offscreen"), b = Symbol.for("react.client.reference");
  function _(T) {
    if (typeof T == "object" && T !== null) {
      var A = T.$$typeof;
      switch (A) {
        case e:
          switch (T = T.type, T) {
            case n:
            case s:
            case i:
            case f:
            case p:
              return T;
            default:
              switch (T = T && T.$$typeof, T) {
                case u:
                case h:
                case v:
                case g:
                  return T;
                case o:
                  return T;
                default:
                  return A;
              }
          }
        case t:
          return A;
      }
    }
  }
  return ci.ContextConsumer = o, ci.ContextProvider = u, ci.Element = e, ci.ForwardRef = h, ci.Fragment = n, ci.Lazy = v, ci.Memo = g, ci.Portal = t, ci.Profiler = s, ci.StrictMode = i, ci.Suspense = f, ci.SuspenseList = p, ci.isContextConsumer = function(T) {
    return _(T) === o;
  }, ci.isContextProvider = function(T) {
    return _(T) === u;
  }, ci.isElement = function(T) {
    return typeof T == "object" && T !== null && T.$$typeof === e;
  }, ci.isForwardRef = function(T) {
    return _(T) === h;
  }, ci.isFragment = function(T) {
    return _(T) === n;
  }, ci.isLazy = function(T) {
    return _(T) === v;
  }, ci.isMemo = function(T) {
    return _(T) === g;
  }, ci.isPortal = function(T) {
    return _(T) === t;
  }, ci.isProfiler = function(T) {
    return _(T) === s;
  }, ci.isStrictMode = function(T) {
    return _(T) === i;
  }, ci.isSuspense = function(T) {
    return _(T) === f;
  }, ci.isSuspenseList = function(T) {
    return _(T) === p;
  }, ci.isValidElementType = function(T) {
    return typeof T == "string" || typeof T == "function" || T === n || T === s || T === i || T === f || T === p || T === x || typeof T == "object" && T !== null && (T.$$typeof === v || T.$$typeof === g || T.$$typeof === u || T.$$typeof === o || T.$$typeof === h || T.$$typeof === b || T.getModuleId !== void 0);
  }, ci.typeOf = _, ci;
}
var e5;
function rw() {
  return e5 || (e5 = 1, nb.exports = /* @__PURE__ */ iw()), nb.exports;
}
var A3 = /* @__PURE__ */ rw();
function xc(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function M3(e) {
  if (/* @__PURE__ */ tt.isValidElement(e) || A3.isValidElementType(e) || !xc(e))
    return e;
  const t = {};
  return Object.keys(e).forEach((n) => {
    t[n] = M3(e[n]);
  }), t;
}
function Na(e, t, n = {
  clone: !0
}) {
  const i = n.clone ? {
    ...e
  } : e;
  return xc(e) && xc(t) && Object.keys(t).forEach((s) => {
    /* @__PURE__ */ tt.isValidElement(t[s]) || A3.isValidElementType(t[s]) ? i[s] = t[s] : xc(t[s]) && // Avoid prototype pollution
    Object.prototype.hasOwnProperty.call(e, s) && xc(e[s]) ? i[s] = Na(e[s], t[s], n) : n.clone ? i[s] = xc(t[s]) ? M3(t[s]) : t[s] : i[s] = t[s];
  }), i;
}
const aw = (e) => {
  const t = Object.keys(e).map((n) => ({
    key: n,
    val: e[n]
  })) || [];
  return t.sort((n, i) => n.val - i.val), t.reduce((n, i) => ({
    ...n,
    [i.key]: i.val
  }), {});
};
function sw(e) {
  const {
    // The breakpoint **start** at this value.
    // For instance with the first breakpoint xs: [xs, sm).
    values: t = {
      xs: 0,
      // phone
      sm: 600,
      // tablet
      md: 900,
      // small laptop
      lg: 1200,
      // desktop
      xl: 1536
      // large screen
    },
    unit: n = "px",
    step: i = 5,
    ...s
  } = e, o = aw(t), u = Object.keys(o);
  function h(x) {
    return `@media (min-width:${typeof t[x] == "number" ? t[x] : x}${n})`;
  }
  function f(x) {
    return `@media (max-width:${(typeof t[x] == "number" ? t[x] : x) - i / 100}${n})`;
  }
  function p(x, b) {
    const _ = u.indexOf(b);
    return `@media (min-width:${typeof t[x] == "number" ? t[x] : x}${n}) and (max-width:${(_ !== -1 && typeof t[u[_]] == "number" ? t[u[_]] : b) - i / 100}${n})`;
  }
  function g(x) {
    return u.indexOf(x) + 1 < u.length ? p(x, u[u.indexOf(x) + 1]) : h(x);
  }
  function v(x) {
    const b = u.indexOf(x);
    return b === 0 ? h(u[1]) : b === u.length - 1 ? f(u[b]) : p(x, u[u.indexOf(x) + 1]).replace("@media", "@media not all and");
  }
  return {
    keys: u,
    values: o,
    up: h,
    down: f,
    between: p,
    only: g,
    not: v,
    unit: n,
    ...s
  };
}
function ow(e, t) {
  if (!e.containerQueries)
    return t;
  const n = Object.keys(t).filter((i) => i.startsWith("@container")).sort((i, s) => {
    var u, h;
    const o = /min-width:\s*([0-9.]+)/;
    return +(((u = i.match(o)) == null ? void 0 : u[1]) || 0) - +(((h = s.match(o)) == null ? void 0 : h[1]) || 0);
  });
  return n.length ? n.reduce((i, s) => {
    const o = t[s];
    return delete i[s], i[s] = o, i;
  }, {
    ...t
  }) : t;
}
function lw(e, t) {
  return t === "@" || t.startsWith("@") && (e.some((n) => t.startsWith(`@${n}`)) || !!t.match(/^@\d/));
}
function cw(e, t) {
  const n = t.match(/^@([^/]+)?\/?(.+)?$/);
  if (!n)
    return null;
  const [, i, s] = n, o = Number.isNaN(+i) ? i || 0 : +i;
  return e.containerQueries(s).up(o);
}
function uw(e) {
  const t = (o, u) => o.replace("@media", u ? `@container ${u}` : "@container");
  function n(o, u) {
    o.up = (...h) => t(e.breakpoints.up(...h), u), o.down = (...h) => t(e.breakpoints.down(...h), u), o.between = (...h) => t(e.breakpoints.between(...h), u), o.only = (...h) => t(e.breakpoints.only(...h), u), o.not = (...h) => {
      const f = t(e.breakpoints.not(...h), u);
      return f.includes("not all and") ? f.replace("not all and ", "").replace("min-width:", "width<").replace("max-width:", "width>").replace("and", "or") : f;
    };
  }
  const i = {}, s = (o) => (n(i, o), i);
  return n(s), {
    ...e,
    containerQueries: s
  };
}
const dw = {
  borderRadius: 4
};
function yg(e, t) {
  return t ? Na(e, t, {
    clone: !1
    // No need to clone deep, it's way faster.
  }) : e;
}
const M1 = {
  xs: 0,
  // phone
  sm: 600,
  // tablet
  md: 900,
  // small laptop
  lg: 1200,
  // desktop
  xl: 1536
  // large screen
}, n5 = {
  // Sorted ASC by size. That's important.
  // It can't be configured as it's used statically for propTypes.
  keys: ["xs", "sm", "md", "lg", "xl"],
  up: (e) => `@media (min-width:${M1[e]}px)`
}, hw = {
  containerQueries: (e) => ({
    up: (t) => {
      let n = typeof t == "number" ? t : M1[t] || t;
      return typeof n == "number" && (n = `${n}px`), e ? `@container ${e} (min-width:${n})` : `@container (min-width:${n})`;
    }
  })
};
function zu(e, t, n) {
  const i = e.theme || {};
  if (Array.isArray(t)) {
    const o = i.breakpoints || n5;
    return t.reduce((u, h, f) => (u[o.up(o.keys[f])] = n(t[f]), u), {});
  }
  if (typeof t == "object") {
    const o = i.breakpoints || n5;
    return Object.keys(t).reduce((u, h) => {
      if (lw(o.keys, h)) {
        const f = cw(i.containerQueries ? i : hw, h);
        f && (u[f] = n(t[h], h));
      } else if (Object.keys(o.values || M1).includes(h)) {
        const f = o.up(h);
        u[f] = n(t[h], h);
      } else {
        const f = h;
        u[f] = t[f];
      }
      return u;
    }, {});
  }
  return n(t);
}
function fw(e = {}) {
  var n;
  return ((n = e.keys) == null ? void 0 : n.reduce((i, s) => {
    const o = e.up(s);
    return i[o] = {}, i;
  }, {})) || {};
}
function pw(e, t) {
  return e.reduce((n, i) => {
    const s = n[i];
    return (!s || Object.keys(s).length === 0) && delete n[i], n;
  }, t);
}
function Ue(e) {
  if (typeof e != "string")
    throw new Error(Bu(7));
  return e.charAt(0).toUpperCase() + e.slice(1);
}
function R1(e, t, n = !0) {
  if (!t || typeof t != "string")
    return null;
  if (e && e.vars && n) {
    const i = `vars.${t}`.split(".").reduce((s, o) => s && s[o] ? s[o] : null, e);
    if (i != null)
      return i;
  }
  return t.split(".").reduce((i, s) => i && i[s] != null ? i[s] : null, e);
}
function Qy(e, t, n, i = n) {
  let s;
  return typeof e == "function" ? s = e(n) : Array.isArray(e) ? s = e[n] || i : s = R1(e, n) || i, t && (s = t(s, i, e)), s;
}
function yr(e) {
  const {
    prop: t,
    cssProperty: n = e.prop,
    themeKey: i,
    transform: s
  } = e, o = (u) => {
    if (u[t] == null)
      return null;
    const h = u[t], f = u.theme, p = R1(f, i) || {};
    return zu(u, h, (v) => {
      let x = Qy(p, s, v);
      return v === x && typeof v == "string" && (x = Qy(p, s, `${t}${v === "default" ? "" : Ue(v)}`, v)), n === !1 ? x : {
        [n]: x
      };
    });
  };
  return o.propTypes = {}, o.filterProps = [t], o;
}
function mw(e) {
  const t = {};
  return (n) => (t[n] === void 0 && (t[n] = e(n)), t[n]);
}
const gw = {
  m: "margin",
  p: "padding"
}, yw = {
  t: "Top",
  r: "Right",
  b: "Bottom",
  l: "Left",
  x: ["Left", "Right"],
  y: ["Top", "Bottom"]
}, i5 = {
  marginX: "mx",
  marginY: "my",
  paddingX: "px",
  paddingY: "py"
}, vw = mw((e) => {
  if (e.length > 2)
    if (i5[e])
      e = i5[e];
    else
      return [e];
  const [t, n] = e.split(""), i = gw[t], s = yw[n] || "";
  return Array.isArray(s) ? s.map((o) => i + o) : [i + s];
}), M2 = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"], R2 = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
[...M2, ...R2];
function Vg(e, t, n, i) {
  const s = R1(e, t, !0) ?? n;
  return typeof s == "number" || typeof s == "string" ? (o) => typeof o == "string" ? o : typeof s == "string" ? `calc(${o} * ${s})` : s * o : Array.isArray(s) ? (o) => {
    if (typeof o == "string")
      return o;
    const u = Math.abs(o), h = s[u];
    return o >= 0 ? h : typeof h == "number" ? -h : `-${h}`;
  } : typeof s == "function" ? s : () => {
  };
}
function O2(e) {
  return Vg(e, "spacing", 8);
}
function Ig(e, t) {
  return typeof t == "string" || t == null ? t : e(t);
}
function bw(e, t) {
  return (n) => e.reduce((i, s) => (i[s] = Ig(t, n), i), {});
}
function _w(e, t, n, i) {
  if (!t.includes(n))
    return null;
  const s = vw(n), o = bw(s, i), u = e[n];
  return zu(e, u, o);
}
function R3(e, t) {
  const n = O2(e.theme);
  return Object.keys(e).map((i) => _w(e, t, i, n)).reduce(yg, {});
}
function ir(e) {
  return R3(e, M2);
}
ir.propTypes = {};
ir.filterProps = M2;
function rr(e) {
  return R3(e, R2);
}
rr.propTypes = {};
rr.filterProps = R2;
function O3(e = 8, t = O2({
  spacing: e
})) {
  if (e.mui)
    return e;
  const n = (...i) => (i.length === 0 ? [1] : i).map((o) => {
    const u = t(o);
    return typeof u == "number" ? `${u}px` : u;
  }).join(" ");
  return n.mui = !0, n;
}
function O1(...e) {
  const t = e.reduce((i, s) => (s.filterProps.forEach((o) => {
    i[o] = s;
  }), i), {}), n = (i) => Object.keys(i).reduce((s, o) => t[o] ? yg(s, t[o](i)) : s, {});
  return n.propTypes = {}, n.filterProps = e.reduce((i, s) => i.concat(s.filterProps), []), n;
}
function Mo(e) {
  return typeof e != "number" ? e : `${e}px solid`;
}
function zo(e, t) {
  return yr({
    prop: e,
    themeKey: "borders",
    transform: t
  });
}
const Sw = zo("border", Mo), xw = zo("borderTop", Mo), Tw = zo("borderRight", Mo), Cw = zo("borderBottom", Mo), ww = zo("borderLeft", Mo), Ew = zo("borderColor"), Aw = zo("borderTopColor"), Mw = zo("borderRightColor"), Rw = zo("borderBottomColor"), Ow = zo("borderLeftColor"), Nw = zo("outline", Mo), kw = zo("outlineColor"), N1 = (e) => {
  if (e.borderRadius !== void 0 && e.borderRadius !== null) {
    const t = Vg(e.theme, "shape.borderRadius", 4), n = (i) => ({
      borderRadius: Ig(t, i)
    });
    return zu(e, e.borderRadius, n);
  }
  return null;
};
N1.propTypes = {};
N1.filterProps = ["borderRadius"];
O1(Sw, xw, Tw, Cw, ww, Ew, Aw, Mw, Rw, Ow, N1, Nw, kw);
const k1 = (e) => {
  if (e.gap !== void 0 && e.gap !== null) {
    const t = Vg(e.theme, "spacing", 8), n = (i) => ({
      gap: Ig(t, i)
    });
    return zu(e, e.gap, n);
  }
  return null;
};
k1.propTypes = {};
k1.filterProps = ["gap"];
const D1 = (e) => {
  if (e.columnGap !== void 0 && e.columnGap !== null) {
    const t = Vg(e.theme, "spacing", 8), n = (i) => ({
      columnGap: Ig(t, i)
    });
    return zu(e, e.columnGap, n);
  }
  return null;
};
D1.propTypes = {};
D1.filterProps = ["columnGap"];
const B1 = (e) => {
  if (e.rowGap !== void 0 && e.rowGap !== null) {
    const t = Vg(e.theme, "spacing", 8), n = (i) => ({
      rowGap: Ig(t, i)
    });
    return zu(e, e.rowGap, n);
  }
  return null;
};
B1.propTypes = {};
B1.filterProps = ["rowGap"];
const Dw = yr({
  prop: "gridColumn"
}), Bw = yr({
  prop: "gridRow"
}), zw = yr({
  prop: "gridAutoFlow"
}), Pw = yr({
  prop: "gridAutoColumns"
}), Uw = yr({
  prop: "gridAutoRows"
}), jw = yr({
  prop: "gridTemplateColumns"
}), Lw = yr({
  prop: "gridTemplateRows"
}), Vw = yr({
  prop: "gridTemplateAreas"
}), Iw = yr({
  prop: "gridArea"
});
O1(k1, D1, B1, Dw, Bw, zw, Pw, Uw, jw, Lw, Vw, Iw);
function qf(e, t) {
  return t === "grey" ? t : e;
}
const Fw = yr({
  prop: "color",
  themeKey: "palette",
  transform: qf
}), qw = yr({
  prop: "bgcolor",
  cssProperty: "backgroundColor",
  themeKey: "palette",
  transform: qf
}), Gw = yr({
  prop: "backgroundColor",
  themeKey: "palette",
  transform: qf
});
O1(Fw, qw, Gw);
function Xs(e) {
  return e <= 1 && e !== 0 ? `${e * 100}%` : e;
}
const Hw = yr({
  prop: "width",
  transform: Xs
}), N2 = (e) => {
  if (e.maxWidth !== void 0 && e.maxWidth !== null) {
    const t = (n) => {
      var s, o, u, h, f;
      const i = ((u = (o = (s = e.theme) == null ? void 0 : s.breakpoints) == null ? void 0 : o.values) == null ? void 0 : u[n]) || M1[n];
      return i ? ((f = (h = e.theme) == null ? void 0 : h.breakpoints) == null ? void 0 : f.unit) !== "px" ? {
        maxWidth: `${i}${e.theme.breakpoints.unit}`
      } : {
        maxWidth: i
      } : {
        maxWidth: Xs(n)
      };
    };
    return zu(e, e.maxWidth, t);
  }
  return null;
};
N2.filterProps = ["maxWidth"];
const Kw = yr({
  prop: "minWidth",
  transform: Xs
}), Yw = yr({
  prop: "height",
  transform: Xs
}), Xw = yr({
  prop: "maxHeight",
  transform: Xs
}), Ww = yr({
  prop: "minHeight",
  transform: Xs
});
yr({
  prop: "size",
  cssProperty: "width",
  transform: Xs
});
yr({
  prop: "size",
  cssProperty: "height",
  transform: Xs
});
const $w = yr({
  prop: "boxSizing"
});
O1(Hw, N2, Kw, Yw, Xw, Ww, $w);
const Fg = {
  // borders
  border: {
    themeKey: "borders",
    transform: Mo
  },
  borderTop: {
    themeKey: "borders",
    transform: Mo
  },
  borderRight: {
    themeKey: "borders",
    transform: Mo
  },
  borderBottom: {
    themeKey: "borders",
    transform: Mo
  },
  borderLeft: {
    themeKey: "borders",
    transform: Mo
  },
  borderColor: {
    themeKey: "palette"
  },
  borderTopColor: {
    themeKey: "palette"
  },
  borderRightColor: {
    themeKey: "palette"
  },
  borderBottomColor: {
    themeKey: "palette"
  },
  borderLeftColor: {
    themeKey: "palette"
  },
  outline: {
    themeKey: "borders",
    transform: Mo
  },
  outlineColor: {
    themeKey: "palette"
  },
  borderRadius: {
    themeKey: "shape.borderRadius",
    style: N1
  },
  // palette
  color: {
    themeKey: "palette",
    transform: qf
  },
  bgcolor: {
    themeKey: "palette",
    cssProperty: "backgroundColor",
    transform: qf
  },
  backgroundColor: {
    themeKey: "palette",
    transform: qf
  },
  // spacing
  p: {
    style: rr
  },
  pt: {
    style: rr
  },
  pr: {
    style: rr
  },
  pb: {
    style: rr
  },
  pl: {
    style: rr
  },
  px: {
    style: rr
  },
  py: {
    style: rr
  },
  padding: {
    style: rr
  },
  paddingTop: {
    style: rr
  },
  paddingRight: {
    style: rr
  },
  paddingBottom: {
    style: rr
  },
  paddingLeft: {
    style: rr
  },
  paddingX: {
    style: rr
  },
  paddingY: {
    style: rr
  },
  paddingInline: {
    style: rr
  },
  paddingInlineStart: {
    style: rr
  },
  paddingInlineEnd: {
    style: rr
  },
  paddingBlock: {
    style: rr
  },
  paddingBlockStart: {
    style: rr
  },
  paddingBlockEnd: {
    style: rr
  },
  m: {
    style: ir
  },
  mt: {
    style: ir
  },
  mr: {
    style: ir
  },
  mb: {
    style: ir
  },
  ml: {
    style: ir
  },
  mx: {
    style: ir
  },
  my: {
    style: ir
  },
  margin: {
    style: ir
  },
  marginTop: {
    style: ir
  },
  marginRight: {
    style: ir
  },
  marginBottom: {
    style: ir
  },
  marginLeft: {
    style: ir
  },
  marginX: {
    style: ir
  },
  marginY: {
    style: ir
  },
  marginInline: {
    style: ir
  },
  marginInlineStart: {
    style: ir
  },
  marginInlineEnd: {
    style: ir
  },
  marginBlock: {
    style: ir
  },
  marginBlockStart: {
    style: ir
  },
  marginBlockEnd: {
    style: ir
  },
  // display
  displayPrint: {
    cssProperty: !1,
    transform: (e) => ({
      "@media print": {
        display: e
      }
    })
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  // flexbox
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  // grid
  gap: {
    style: k1
  },
  rowGap: {
    style: B1
  },
  columnGap: {
    style: D1
  },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  // positions
  position: {},
  zIndex: {
    themeKey: "zIndex"
  },
  top: {},
  right: {},
  bottom: {},
  left: {},
  // shadows
  boxShadow: {
    themeKey: "shadows"
  },
  // sizing
  width: {
    transform: Xs
  },
  maxWidth: {
    style: N2
  },
  minWidth: {
    transform: Xs
  },
  height: {
    transform: Xs
  },
  maxHeight: {
    transform: Xs
  },
  minHeight: {
    transform: Xs
  },
  boxSizing: {},
  // typography
  font: {
    themeKey: "font"
  },
  fontFamily: {
    themeKey: "typography"
  },
  fontSize: {
    themeKey: "typography"
  },
  fontStyle: {
    themeKey: "typography"
  },
  fontWeight: {
    themeKey: "typography"
  },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: {
    cssProperty: !1,
    themeKey: "typography"
  }
};
function Qw(...e) {
  const t = e.reduce((i, s) => i.concat(Object.keys(s)), []), n = new Set(t);
  return e.every((i) => n.size === Object.keys(i).length);
}
function Zw(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function Jw() {
  function e(n, i, s, o) {
    const u = {
      [n]: i,
      theme: s
    }, h = o[n];
    if (!h)
      return {
        [n]: i
      };
    const {
      cssProperty: f = n,
      themeKey: p,
      transform: g,
      style: v
    } = h;
    if (i == null)
      return null;
    if (p === "typography" && i === "inherit")
      return {
        [n]: i
      };
    const x = R1(s, p) || {};
    return v ? v(u) : zu(u, i, (_) => {
      let T = Qy(x, g, _);
      return _ === T && typeof _ == "string" && (T = Qy(x, g, `${n}${_ === "default" ? "" : Ue(_)}`, _)), f === !1 ? T : {
        [f]: T
      };
    });
  }
  function t(n) {
    const {
      sx: i,
      theme: s = {}
    } = n || {};
    if (!i)
      return null;
    const o = s.unstable_sxConfig ?? Fg;
    function u(h) {
      let f = h;
      if (typeof h == "function")
        f = h(s);
      else if (typeof h != "object")
        return h;
      if (!f)
        return null;
      const p = fw(s.breakpoints), g = Object.keys(p);
      let v = p;
      return Object.keys(f).forEach((x) => {
        const b = Zw(f[x], s);
        if (b != null)
          if (typeof b == "object")
            if (o[x])
              v = yg(v, e(x, b, s, o));
            else {
              const _ = zu({
                theme: s
              }, b, (T) => ({
                [x]: T
              }));
              Qw(_, b) ? v[x] = t({
                sx: b,
                theme: s
              }) : v = yg(v, _);
            }
          else
            v = yg(v, e(x, b, s, o));
      }), ow(s, pw(g, v));
    }
    return Array.isArray(i) ? i.map(u) : u(i);
  }
  return t;
}
const zd = Jw();
zd.filterProps = ["sx"];
function tE(e, t) {
  var i;
  const n = this;
  if (n.vars) {
    if (!((i = n.colorSchemes) != null && i[e]) || typeof n.getColorSchemeSelector != "function")
      return {};
    let s = n.getColorSchemeSelector(e);
    return s === "&" ? t : ((s.includes("data-") || s.includes(".")) && (s = `*:where(${s.replace(/\s*&$/, "")}) &`), {
      [s]: t
    });
  }
  return n.palette.mode === e ? t : {};
}
function k2(e = {}, ...t) {
  const {
    breakpoints: n = {},
    palette: i = {},
    spacing: s,
    shape: o = {},
    ...u
  } = e, h = sw(n), f = O3(s);
  let p = Na({
    breakpoints: h,
    direction: "ltr",
    components: {},
    // Inject component definitions.
    palette: {
      mode: "light",
      ...i
    },
    spacing: f,
    shape: {
      ...dw,
      ...o
    }
  }, u);
  return p = uw(p), p.applyStyles = tE, p = t.reduce((g, v) => Na(g, v), p), p.unstable_sxConfig = {
    ...Fg,
    ...u == null ? void 0 : u.unstable_sxConfig
  }, p.unstable_sx = function(v) {
    return zd({
      sx: v,
      theme: this
    });
  }, p;
}
function eE(e) {
  return Object.keys(e).length === 0;
}
function N3(e = null) {
  const t = tt.useContext(jg);
  return !t || eE(t) ? e : t;
}
const nE = k2();
function D2(e = nE) {
  return N3(e);
}
function iE({
  styles: e,
  themeId: t,
  defaultTheme: n = {}
}) {
  const i = D2(n), s = typeof e == "function" ? e(t && i[t] || i) : e;
  return /* @__PURE__ */ J.jsx(w3, {
    styles: s
  });
}
const rE = (e) => {
  var i;
  const t = {
    systemProps: {},
    otherProps: {}
  }, n = ((i = e == null ? void 0 : e.theme) == null ? void 0 : i.unstable_sxConfig) ?? Fg;
  return Object.keys(e).forEach((s) => {
    n[s] ? t.systemProps[s] = e[s] : t.otherProps[s] = e[s];
  }), t;
};
function k3(e) {
  const {
    sx: t,
    ...n
  } = e, {
    systemProps: i,
    otherProps: s
  } = rE(n);
  let o;
  return Array.isArray(t) ? o = [i, ...t] : typeof t == "function" ? o = (...u) => {
    const h = t(...u);
    return xc(h) ? {
      ...i,
      ...h
    } : i;
  } : o = {
    ...i,
    ...t
  }, {
    ...s,
    sx: o
  };
}
const r5 = (e) => e, aE = () => {
  let e = r5;
  return {
    configure(t) {
      e = t;
    },
    generate(t) {
      return e(t);
    },
    reset() {
      e = r5;
    }
  };
}, D3 = aE();
function B3(e) {
  var t, n, i = "";
  if (typeof e == "string" || typeof e == "number") i += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var s = e.length;
    for (t = 0; t < s; t++) e[t] && (n = B3(e[t])) && (i && (i += " "), i += n);
  } else for (n in e) e[n] && (i && (i += " "), i += n);
  return i;
}
function Fe() {
  for (var e, t, n = 0, i = "", s = arguments.length; n < s; n++) (e = arguments[n]) && (t = B3(e)) && (i && (i += " "), i += t);
  return i;
}
function sE(e = {}) {
  const {
    themeId: t,
    defaultTheme: n,
    defaultClassName: i = "MuiBox-root",
    generateClassName: s
  } = e, o = E3("div", {
    shouldForwardProp: (h) => h !== "theme" && h !== "sx" && h !== "as"
  })(zd);
  return /* @__PURE__ */ tt.forwardRef(function(f, p) {
    const g = D2(n), {
      className: v,
      component: x = "div",
      ...b
    } = k3(f);
    return /* @__PURE__ */ J.jsx(o, {
      as: x,
      ref: p,
      className: Fe(v, s ? s(i) : i),
      theme: t && g[t] || g,
      ...b
    });
  });
}
const oE = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  open: "open",
  readOnly: "readOnly",
  required: "required",
  selected: "selected"
};
function Un(e, t, n = "Mui") {
  const i = oE[t];
  return i ? `${n}-${i}` : `${D3.generate(e)}-${t}`;
}
function zn(e, t, n = "Mui") {
  const i = {};
  return t.forEach((s) => {
    i[s] = Un(e, s, n);
  }), i;
}
function z3(e) {
  const {
    variants: t,
    ...n
  } = e, i = {
    variants: t,
    style: JS(n),
    isProcessed: !0
  };
  return i.style === n || t && t.forEach((s) => {
    typeof s.style != "function" && (s.style = JS(s.style));
  }), i;
}
const lE = k2();
function ib(e) {
  return e !== "ownerState" && e !== "theme" && e !== "sx" && e !== "as";
}
function cE(e) {
  return e ? (t, n) => n[e] : null;
}
function uE(e, t, n) {
  e.theme = fE(e.theme) ? n : e.theme[t] || e.theme;
}
function qy(e, t) {
  const n = typeof t == "function" ? t(e) : t;
  if (Array.isArray(n))
    return n.flatMap((i) => qy(e, i));
  if (Array.isArray(n == null ? void 0 : n.variants)) {
    let i;
    if (n.isProcessed)
      i = n.style;
    else {
      const {
        variants: s,
        ...o
      } = n;
      i = o;
    }
    return P3(e, n.variants, [i]);
  }
  return n != null && n.isProcessed ? n.style : n;
}
function P3(e, t, n = []) {
  var s;
  let i;
  t: for (let o = 0; o < t.length; o += 1) {
    const u = t[o];
    if (typeof u.props == "function") {
      if (i ?? (i = {
        ...e,
        ...e.ownerState,
        ownerState: e.ownerState
      }), !u.props(i))
        continue;
    } else
      for (const h in u.props)
        if (e[h] !== u.props[h] && ((s = e.ownerState) == null ? void 0 : s[h]) !== u.props[h])
          continue t;
    typeof u.style == "function" ? (i ?? (i = {
      ...e,
      ...e.ownerState,
      ownerState: e.ownerState
    }), n.push(u.style(i))) : n.push(u.style);
  }
  return n;
}
function dE(e = {}) {
  const {
    themeId: t,
    defaultTheme: n = lE,
    rootShouldForwardProp: i = ib,
    slotShouldForwardProp: s = ib
  } = e;
  function o(h) {
    uE(h, t, n);
  }
  return (h, f = {}) => {
    nw(h, (N) => N.filter((U) => U !== zd));
    const {
      name: p,
      slot: g,
      skipVariantsResolver: v,
      skipSx: x,
      // TODO v6: remove `lowercaseFirstLetter()` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      overridesResolver: b = cE(mE(g)),
      ..._
    } = f, T = v !== void 0 ? v : (
      // TODO v6: remove `Root` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      g && g !== "Root" && g !== "root" || !1
    ), A = x || !1;
    let O = ib;
    g === "Root" || g === "root" ? O = i : g ? O = s : pE(h) && (O = void 0);
    const M = E3(h, {
      shouldForwardProp: O,
      label: hE(),
      ..._
    }), E = (N) => {
      if (typeof N == "function" && N.__emotion_real !== N)
        return function(q) {
          return qy(q, N);
        };
      if (xc(N)) {
        const U = z3(N);
        return U.variants ? function(j) {
          return qy(j, U);
        } : U.style;
      }
      return N;
    }, R = (...N) => {
      const U = [], q = N.map(E), j = [];
      if (U.push(o), p && b && j.push(function(W) {
        var K, Q;
        const H = (Q = (K = W.theme.components) == null ? void 0 : K[p]) == null ? void 0 : Q.styleOverrides;
        if (!H)
          return null;
        const I = {};
        for (const it in H)
          I[it] = qy(W, H[it]);
        return b(W, I);
      }), p && !T && j.push(function(W) {
        var I, K;
        const P = W.theme, H = (K = (I = P == null ? void 0 : P.components) == null ? void 0 : I[p]) == null ? void 0 : K.variants;
        return H ? P3(W, H) : null;
      }), A || j.push(zd), Array.isArray(q[0])) {
        const G = q.shift(), W = new Array(U.length).fill(""), P = new Array(j.length).fill("");
        let H;
        H = [...W, ...G, ...P], H.raw = [...W, ...G.raw, ...P], U.unshift(H);
      }
      const V = [...U, ...q, ...j], D = M(...V);
      return h.muiName && (D.muiName = h.muiName), D;
    };
    return M.withConfig && (R.withConfig = M.withConfig), R;
  };
}
function hE(e, t) {
  return void 0;
}
function fE(e) {
  for (const t in e)
    return !1;
  return !0;
}
function pE(e) {
  return typeof e == "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  e.charCodeAt(0) > 96;
}
function mE(e) {
  return e && e.charAt(0).toLowerCase() + e.slice(1);
}
function Eg(e, t) {
  const n = {
    ...t
  };
  for (const i in e)
    if (Object.prototype.hasOwnProperty.call(e, i)) {
      const s = i;
      if (s === "components" || s === "slots")
        n[s] = {
          ...e[s],
          ...n[s]
        };
      else if (s === "componentsProps" || s === "slotProps") {
        const o = e[s], u = t[s];
        if (!u)
          n[s] = o || {};
        else if (!o)
          n[s] = u;
        else {
          n[s] = {
            ...u
          };
          for (const h in o)
            if (Object.prototype.hasOwnProperty.call(o, h)) {
              const f = h;
              n[s][f] = Eg(o[f], u[f]);
            }
        }
      } else n[s] === void 0 && (n[s] = e[s]);
    }
  return n;
}
const ko = typeof window < "u" ? tt.useLayoutEffect : tt.useEffect;
function Bf(e, t = Number.MIN_SAFE_INTEGER, n = Number.MAX_SAFE_INTEGER) {
  return Math.max(t, Math.min(e, n));
}
function B2(e, t = 0, n = 1) {
  return Bf(e, t, n);
}
function gE(e) {
  e = e.slice(1);
  const t = new RegExp(`.{1,${e.length >= 6 ? 2 : 1}}`, "g");
  let n = e.match(t);
  return n && n[0].length === 1 && (n = n.map((i) => i + i)), n ? `rgb${n.length === 4 ? "a" : ""}(${n.map((i, s) => s < 3 ? parseInt(i, 16) : Math.round(parseInt(i, 16) / 255 * 1e3) / 1e3).join(", ")})` : "";
}
function Pd(e) {
  if (e.type)
    return e;
  if (e.charAt(0) === "#")
    return Pd(gE(e));
  const t = e.indexOf("("), n = e.substring(0, t);
  if (!["rgb", "rgba", "hsl", "hsla", "color"].includes(n))
    throw new Error(Bu(9, e));
  let i = e.substring(t + 1, e.length - 1), s;
  if (n === "color") {
    if (i = i.split(" "), s = i.shift(), i.length === 4 && i[3].charAt(0) === "/" && (i[3] = i[3].slice(1)), !["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].includes(s))
      throw new Error(Bu(10, s));
  } else
    i = i.split(",");
  return i = i.map((o) => parseFloat(o)), {
    type: n,
    values: i,
    colorSpace: s
  };
}
const yE = (e) => {
  const t = Pd(e);
  return t.values.slice(0, 3).map((n, i) => t.type.includes("hsl") && i !== 0 ? `${n}%` : n).join(" ");
}, fg = (e, t) => {
  try {
    return yE(e);
  } catch {
    return e;
  }
};
function z1(e) {
  const {
    type: t,
    colorSpace: n
  } = e;
  let {
    values: i
  } = e;
  return t.includes("rgb") ? i = i.map((s, o) => o < 3 ? parseInt(s, 10) : s) : t.includes("hsl") && (i[1] = `${i[1]}%`, i[2] = `${i[2]}%`), t.includes("color") ? i = `${n} ${i.join(" ")}` : i = `${i.join(", ")}`, `${t}(${i})`;
}
function U3(e) {
  e = Pd(e);
  const {
    values: t
  } = e, n = t[0], i = t[1] / 100, s = t[2] / 100, o = i * Math.min(s, 1 - s), u = (p, g = (p + n / 30) % 12) => s - o * Math.max(Math.min(g - 3, 9 - g, 1), -1);
  let h = "rgb";
  const f = [Math.round(u(0) * 255), Math.round(u(8) * 255), Math.round(u(4) * 255)];
  return e.type === "hsla" && (h += "a", f.push(t[3])), z1({
    type: h,
    values: f
  });
}
function Fb(e) {
  e = Pd(e);
  let t = e.type === "hsl" || e.type === "hsla" ? Pd(U3(e)).values : e.values;
  return t = t.map((n) => (e.type !== "color" && (n /= 255), n <= 0.03928 ? n / 12.92 : ((n + 0.055) / 1.055) ** 2.4)), Number((0.2126 * t[0] + 0.7152 * t[1] + 0.0722 * t[2]).toFixed(3));
}
function vE(e, t) {
  const n = Fb(e), i = Fb(t);
  return (Math.max(n, i) + 0.05) / (Math.min(n, i) + 0.05);
}
function xi(e, t) {
  return e = Pd(e), t = B2(t), (e.type === "rgb" || e.type === "hsl") && (e.type += "a"), e.type === "color" ? e.values[3] = `/${t}` : e.values[3] = t, z1(e);
}
function yy(e, t, n) {
  try {
    return xi(e, t);
  } catch {
    return e;
  }
}
function Ag(e, t) {
  if (e = Pd(e), t = B2(t), e.type.includes("hsl"))
    e.values[2] *= 1 - t;
  else if (e.type.includes("rgb") || e.type.includes("color"))
    for (let n = 0; n < 3; n += 1)
      e.values[n] *= 1 - t;
  return z1(e);
}
function pi(e, t, n) {
  try {
    return Ag(e, t);
  } catch {
    return e;
  }
}
function Mg(e, t) {
  if (e = Pd(e), t = B2(t), e.type.includes("hsl"))
    e.values[2] += (100 - e.values[2]) * t;
  else if (e.type.includes("rgb"))
    for (let n = 0; n < 3; n += 1)
      e.values[n] += (255 - e.values[n]) * t;
  else if (e.type.includes("color"))
    for (let n = 0; n < 3; n += 1)
      e.values[n] += (1 - e.values[n]) * t;
  return z1(e);
}
function mi(e, t, n) {
  try {
    return Mg(e, t);
  } catch {
    return e;
  }
}
function bE(e, t = 0.15) {
  return Fb(e) > 0.5 ? Ag(e, t) : Mg(e, t);
}
function vy(e, t, n) {
  try {
    return bE(e, t);
  } catch {
    return e;
  }
}
function a5(...e) {
  return e.reduce((t, n) => n == null ? t : function(...s) {
    t.apply(this, s), n.apply(this, s);
  }, () => {
  });
}
function j3(e, t = 166) {
  let n;
  function i(...s) {
    const o = () => {
      e.apply(this, s);
    };
    clearTimeout(n), n = setTimeout(o, t);
  }
  return i.clear = () => {
    clearTimeout(n);
  }, i;
}
function rb(e, t) {
  var n, i, s;
  return /* @__PURE__ */ tt.isValidElement(e) && t.indexOf(
    // For server components `muiName` is avaialble in element.type._payload.value.muiName
    // relevant info - https://github.com/facebook/react/blob/2807d781a08db8e9873687fccc25c0f12b4fb3d4/packages/react/src/ReactLazy.js#L45
    // eslint-disable-next-line no-underscore-dangle
    e.type.muiName ?? ((s = (i = (n = e.type) == null ? void 0 : n._payload) == null ? void 0 : i.value) == null ? void 0 : s.muiName)
  ) !== -1;
}
function ga(e) {
  return e && e.ownerDocument || document;
}
function Pu(e) {
  return ga(e).defaultView || window;
}
function qb(e, t) {
  typeof e == "function" ? e(t) : e && (e.current = t);
}
let s5 = 0;
function _E(e) {
  const [t, n] = tt.useState(e), i = e || t;
  return tt.useEffect(() => {
    t == null && (s5 += 1, n(`mui-${s5}`));
  }, [t]), i;
}
const SE = {
  ...Ub
}, o5 = SE.useId;
function qg(e) {
  if (o5 !== void 0) {
    const t = o5();
    return e ?? t;
  }
  return _E(e);
}
function Zy({
  controlled: e,
  default: t,
  name: n,
  state: i = "value"
}) {
  const {
    current: s
  } = tt.useRef(e !== void 0), [o, u] = tt.useState(t), h = s ? e : o, f = tt.useCallback((p) => {
    s || u(p);
  }, []);
  return [h, f];
}
function Oo(e) {
  const t = tt.useRef(e);
  return ko(() => {
    t.current = e;
  }), tt.useRef((...n) => (
    // @ts-expect-error hide `this`
    (0, t.current)(...n)
  )).current;
}
function jr(...e) {
  return tt.useMemo(() => e.every((t) => t == null) ? null : (t) => {
    e.forEach((n) => {
      qb(n, t);
    });
  }, e);
}
const l5 = {};
function L3(e, t) {
  const n = tt.useRef(l5);
  return n.current === l5 && (n.current = e(t)), n;
}
const xE = [];
function TE(e) {
  tt.useEffect(e, xE);
}
class P1 {
  constructor() {
    Qe(this, "currentId", null);
    Qe(this, "clear", () => {
      this.currentId !== null && (clearTimeout(this.currentId), this.currentId = null);
    });
    Qe(this, "disposeEffect", () => this.clear);
  }
  static create() {
    return new P1();
  }
  /**
   * Executes `fn` after `delay`, clearing any previously scheduled call.
   */
  start(t, n) {
    this.clear(), this.currentId = setTimeout(() => {
      this.currentId = null, n();
    }, t);
  }
}
function jf() {
  const e = L3(P1.create).current;
  return TE(e.disposeEffect), e;
}
function Yf(e) {
  try {
    return e.matches(":focus-visible");
  } catch {
  }
  return !1;
}
function V3(e = window) {
  const t = e.document.documentElement.clientWidth;
  return e.innerWidth - t;
}
function CE(e) {
  return tt.Children.toArray(e).filter((t) => /* @__PURE__ */ tt.isValidElement(t));
}
const wE = {
  border: 0,
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "absolute",
  whiteSpace: "nowrap",
  width: "1px"
};
function jn(e, t, n = void 0) {
  const i = {};
  for (const s in e) {
    const o = e[s];
    let u = "", h = !0;
    for (let f = 0; f < o.length; f += 1) {
      const p = o[f];
      p && (u += (h === !0 ? "" : " ") + t(p), h = !1, n && n[p] && (u += " " + n[p]));
    }
    i[s] = u;
  }
  return i;
}
function EE(e) {
  return typeof e == "string";
}
function I3(e, t, n) {
  return e === void 0 || EE(e) ? t : {
    ...t,
    ownerState: {
      ...t.ownerState,
      ...n
    }
  };
}
function vg(e, t = []) {
  if (e === void 0)
    return {};
  const n = {};
  return Object.keys(e).filter((i) => i.match(/^on[A-Z]/) && typeof e[i] == "function" && !t.includes(i)).forEach((i) => {
    n[i] = e[i];
  }), n;
}
function c5(e) {
  if (e === void 0)
    return {};
  const t = {};
  return Object.keys(e).filter((n) => !(n.match(/^on[A-Z]/) && typeof e[n] == "function")).forEach((n) => {
    t[n] = e[n];
  }), t;
}
function F3(e) {
  const {
    getSlotProps: t,
    additionalProps: n,
    externalSlotProps: i,
    externalForwardedProps: s,
    className: o
  } = e;
  if (!t) {
    const b = Fe(n == null ? void 0 : n.className, o, s == null ? void 0 : s.className, i == null ? void 0 : i.className), _ = {
      ...n == null ? void 0 : n.style,
      ...s == null ? void 0 : s.style,
      ...i == null ? void 0 : i.style
    }, T = {
      ...n,
      ...s,
      ...i
    };
    return b.length > 0 && (T.className = b), Object.keys(_).length > 0 && (T.style = _), {
      props: T,
      internalRef: void 0
    };
  }
  const u = vg({
    ...s,
    ...i
  }), h = c5(i), f = c5(s), p = t(u), g = Fe(p == null ? void 0 : p.className, n == null ? void 0 : n.className, o, s == null ? void 0 : s.className, i == null ? void 0 : i.className), v = {
    ...p == null ? void 0 : p.style,
    ...n == null ? void 0 : n.style,
    ...s == null ? void 0 : s.style,
    ...i == null ? void 0 : i.style
  }, x = {
    ...p,
    ...n,
    ...f,
    ...h
  };
  return g.length > 0 && (x.className = g), Object.keys(v).length > 0 && (x.style = v), {
    props: x,
    internalRef: p.ref
  };
}
function q3(e, t, n) {
  return typeof e == "function" ? e(t, n) : e;
}
function vc(e) {
  var v;
  const {
    elementType: t,
    externalSlotProps: n,
    ownerState: i,
    skipResolvingSlotProps: s = !1,
    ...o
  } = e, u = s ? {} : q3(n, i), {
    props: h,
    internalRef: f
  } = F3({
    ...o,
    externalSlotProps: u
  }), p = jr(f, u == null ? void 0 : u.ref, (v = e.additionalProps) == null ? void 0 : v.ref);
  return I3(t, {
    ...h,
    ref: p
  }, i);
}
function up(e) {
  var t;
  return parseInt(tt.version, 10) >= 19 ? ((t = e == null ? void 0 : e.props) == null ? void 0 : t.ref) || null : (e == null ? void 0 : e.ref) || null;
}
const G3 = /* @__PURE__ */ tt.createContext(null);
function z2() {
  return tt.useContext(G3);
}
const AE = typeof Symbol == "function" && Symbol.for, ME = AE ? Symbol.for("mui.nested") : "__THEME_NESTED__";
function RE(e, t) {
  return typeof t == "function" ? t(e) : {
    ...e,
    ...t
  };
}
function OE(e) {
  const {
    children: t,
    theme: n
  } = e, i = z2(), s = tt.useMemo(() => {
    const o = i === null ? {
      ...n
    } : RE(i, n);
    return o != null && (o[ME] = i !== null), o;
  }, [n, i]);
  return /* @__PURE__ */ J.jsx(G3.Provider, {
    value: s,
    children: t
  });
}
const H3 = /* @__PURE__ */ tt.createContext();
function NE({
  value: e,
  ...t
}) {
  return /* @__PURE__ */ J.jsx(H3.Provider, {
    value: e ?? !0,
    ...t
  });
}
const U1 = () => tt.useContext(H3) ?? !1, K3 = /* @__PURE__ */ tt.createContext(void 0);
function kE({
  value: e,
  children: t
}) {
  return /* @__PURE__ */ J.jsx(K3.Provider, {
    value: e,
    children: t
  });
}
function DE(e) {
  const {
    theme: t,
    name: n,
    props: i
  } = e;
  if (!t || !t.components || !t.components[n])
    return i;
  const s = t.components[n];
  return s.defaultProps ? Eg(s.defaultProps, i) : !s.styleOverrides && !s.variants ? Eg(s, i) : i;
}
function BE({
  props: e,
  name: t
}) {
  const n = tt.useContext(K3);
  return DE({
    props: e,
    name: t,
    theme: {
      components: n
    }
  });
}
const u5 = {};
function d5(e, t, n, i = !1) {
  return tt.useMemo(() => {
    const s = e && t[e] || t;
    if (typeof n == "function") {
      const o = n(s), u = e ? {
        ...t,
        [e]: o
      } : o;
      return i ? () => u : u;
    }
    return e ? {
      ...t,
      [e]: n
    } : {
      ...t,
      ...n
    };
  }, [e, t, n, i]);
}
function Y3(e) {
  const {
    children: t,
    theme: n,
    themeId: i
  } = e, s = N3(u5), o = z2() || u5, u = d5(i, s, n), h = d5(i, o, n, !0), f = (i ? u[i] : u).direction === "rtl";
  return /* @__PURE__ */ J.jsx(OE, {
    theme: h,
    children: /* @__PURE__ */ J.jsx(jg.Provider, {
      value: u,
      children: /* @__PURE__ */ J.jsx(NE, {
        value: f,
        children: /* @__PURE__ */ J.jsx(kE, {
          value: i ? u[i].components : u.components,
          children: t
        })
      })
    })
  });
}
const h5 = {
  theme: void 0
};
function zE(e) {
  let t, n;
  return function(s) {
    let o = t;
    return (o === void 0 || s.theme !== n) && (h5.theme = s.theme, o = z3(e(h5)), t = o, n = s.theme), o;
  };
}
const P2 = "mode", U2 = "color-scheme", PE = "data-color-scheme";
function UE(e) {
  const {
    defaultMode: t = "system",
    defaultLightColorScheme: n = "light",
    defaultDarkColorScheme: i = "dark",
    modeStorageKey: s = P2,
    colorSchemeStorageKey: o = U2,
    attribute: u = PE,
    colorSchemeNode: h = "document.documentElement",
    nonce: f
  } = e || {};
  let p = "", g = u;
  if (u === "class" && (g = ".%s"), u === "data" && (g = "[data-%s]"), g.startsWith(".")) {
    const x = g.substring(1);
    p += `${h}.classList.remove('${x}'.replace('%s', light), '${x}'.replace('%s', dark));
      ${h}.classList.add('${x}'.replace('%s', colorScheme));`;
  }
  const v = g.match(/\[([^\]]+)\]/);
  if (v) {
    const [x, b] = v[1].split("=");
    b || (p += `${h}.removeAttribute('${x}'.replace('%s', light));
      ${h}.removeAttribute('${x}'.replace('%s', dark));`), p += `
      ${h}.setAttribute('${x}'.replace('%s', colorScheme), ${b ? `${b}.replace('%s', colorScheme)` : '""'});`;
  } else
    p += `${h}.setAttribute('${g}', colorScheme);`;
  return /* @__PURE__ */ J.jsx("script", {
    suppressHydrationWarning: !0,
    nonce: typeof window > "u" ? f : "",
    dangerouslySetInnerHTML: {
      __html: `(function() {
try {
  let colorScheme = '';
  const mode = localStorage.getItem('${s}') || '${t}';
  const dark = localStorage.getItem('${o}-dark') || '${i}';
  const light = localStorage.getItem('${o}-light') || '${n}';
  if (mode === 'system') {
    // handle system mode
    const mql = window.matchMedia('(prefers-color-scheme: dark)');
    if (mql.matches) {
      colorScheme = dark
    } else {
      colorScheme = light
    }
  }
  if (mode === 'light') {
    colorScheme = light;
  }
  if (mode === 'dark') {
    colorScheme = dark;
  }
  if (colorScheme) {
    ${p}
  }
} catch(e){}})();`
    }
  }, "mui-color-scheme-init");
}
function jE() {
}
const LE = ({
  key: e,
  storageWindow: t
}) => (!t && typeof window < "u" && (t = window), {
  get(n) {
    if (typeof window > "u")
      return;
    if (!t)
      return n;
    let i;
    try {
      i = t.localStorage.getItem(e);
    } catch {
    }
    return i || n;
  },
  set: (n) => {
    if (t)
      try {
        t.localStorage.setItem(e, n);
      } catch {
      }
  },
  subscribe: (n) => {
    if (!t)
      return jE;
    const i = (s) => {
      const o = s.newValue;
      s.key === e && n(o);
    };
    return t.addEventListener("storage", i), () => {
      t.removeEventListener("storage", i);
    };
  }
});
function ab() {
}
function f5(e) {
  if (typeof window < "u" && typeof window.matchMedia == "function" && e === "system")
    return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
}
function X3(e, t) {
  if (e.mode === "light" || e.mode === "system" && e.systemMode === "light")
    return t("light");
  if (e.mode === "dark" || e.mode === "system" && e.systemMode === "dark")
    return t("dark");
}
function VE(e) {
  return X3(e, (t) => {
    if (t === "light")
      return e.lightColorScheme;
    if (t === "dark")
      return e.darkColorScheme;
  });
}
function IE(e) {
  const {
    defaultMode: t = "light",
    defaultLightColorScheme: n,
    defaultDarkColorScheme: i,
    supportedColorSchemes: s = [],
    modeStorageKey: o = P2,
    colorSchemeStorageKey: u = U2,
    storageWindow: h = typeof window > "u" ? void 0 : window,
    storageManager: f = LE,
    noSsr: p = !1
  } = e, g = s.join(","), v = s.length > 1, x = tt.useMemo(() => f == null ? void 0 : f({
    key: o,
    storageWindow: h
  }), [f, o, h]), b = tt.useMemo(() => f == null ? void 0 : f({
    key: `${u}-light`,
    storageWindow: h
  }), [f, u, h]), _ = tt.useMemo(() => f == null ? void 0 : f({
    key: `${u}-dark`,
    storageWindow: h
  }), [f, u, h]), [T, A] = tt.useState(() => {
    const j = (x == null ? void 0 : x.get(t)) || t, V = (b == null ? void 0 : b.get(n)) || n, D = (_ == null ? void 0 : _.get(i)) || i;
    return {
      mode: j,
      systemMode: f5(j),
      lightColorScheme: V,
      darkColorScheme: D
    };
  }), [O, M] = tt.useState(p || !v);
  tt.useEffect(() => {
    M(!0);
  }, []);
  const E = VE(T), R = tt.useCallback((j) => {
    A((V) => {
      if (j === V.mode)
        return V;
      const D = j ?? t;
      return x == null || x.set(D), {
        ...V,
        mode: D,
        systemMode: f5(D)
      };
    });
  }, [x, t]), N = tt.useCallback((j) => {
    j ? typeof j == "string" ? j && !g.includes(j) ? console.error(`\`${j}\` does not exist in \`theme.colorSchemes\`.`) : A((V) => {
      const D = {
        ...V
      };
      return X3(V, (G) => {
        G === "light" && (b == null || b.set(j), D.lightColorScheme = j), G === "dark" && (_ == null || _.set(j), D.darkColorScheme = j);
      }), D;
    }) : A((V) => {
      const D = {
        ...V
      }, G = j.light === null ? n : j.light, W = j.dark === null ? i : j.dark;
      return G && (g.includes(G) ? (D.lightColorScheme = G, b == null || b.set(G)) : console.error(`\`${G}\` does not exist in \`theme.colorSchemes\`.`)), W && (g.includes(W) ? (D.darkColorScheme = W, _ == null || _.set(W)) : console.error(`\`${W}\` does not exist in \`theme.colorSchemes\`.`)), D;
    }) : A((V) => (b == null || b.set(n), _ == null || _.set(i), {
      ...V,
      lightColorScheme: n,
      darkColorScheme: i
    }));
  }, [g, b, _, n, i]), U = tt.useCallback((j) => {
    T.mode === "system" && A((V) => {
      const D = j != null && j.matches ? "dark" : "light";
      return V.systemMode === D ? V : {
        ...V,
        systemMode: D
      };
    });
  }, [T.mode]), q = tt.useRef(U);
  return q.current = U, tt.useEffect(() => {
    if (typeof window.matchMedia != "function" || !v)
      return;
    const j = (...D) => q.current(...D), V = window.matchMedia("(prefers-color-scheme: dark)");
    return V.addListener(j), j(V), () => {
      V.removeListener(j);
    };
  }, [v]), tt.useEffect(() => {
    if (v) {
      const j = (x == null ? void 0 : x.subscribe((G) => {
        (!G || ["light", "dark", "system"].includes(G)) && R(G || t);
      })) || ab, V = (b == null ? void 0 : b.subscribe((G) => {
        (!G || g.match(G)) && N({
          light: G
        });
      })) || ab, D = (_ == null ? void 0 : _.subscribe((G) => {
        (!G || g.match(G)) && N({
          dark: G
        });
      })) || ab;
      return () => {
        j(), V(), D();
      };
    }
  }, [N, R, g, t, h, v, x, b, _]), {
    ...T,
    mode: O ? T.mode : void 0,
    systemMode: O ? T.systemMode : void 0,
    colorScheme: O ? E : void 0,
    setMode: R,
    setColorScheme: N
  };
}
const FE = "*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}";
function qE(e) {
  const {
    themeId: t,
    /**
     * This `theme` object needs to follow a certain structure to
     * be used correctly by the finel `CssVarsProvider`. It should have a
     * `colorSchemes` key with the light and dark (and any other) palette.
     * It should also ideally have a vars object created using `prepareCssVars`.
     */
    theme: n = {},
    modeStorageKey: i = P2,
    colorSchemeStorageKey: s = U2,
    disableTransitionOnChange: o = !1,
    defaultColorScheme: u,
    resolveTheme: h
  } = e, f = {
    allColorSchemes: [],
    colorScheme: void 0,
    darkColorScheme: void 0,
    lightColorScheme: void 0,
    mode: void 0,
    setColorScheme: () => {
    },
    setMode: () => {
    },
    systemMode: void 0
  }, p = /* @__PURE__ */ tt.createContext(void 0), g = () => tt.useContext(p) || f, v = {}, x = {};
  function b(O) {
    var De, Kt, te, It;
    const {
      children: M,
      theme: E,
      modeStorageKey: R = i,
      colorSchemeStorageKey: N = s,
      disableTransitionOnChange: U = o,
      storageManager: q,
      storageWindow: j = typeof window > "u" ? void 0 : window,
      documentNode: V = typeof document > "u" ? void 0 : document,
      colorSchemeNode: D = typeof document > "u" ? void 0 : document.documentElement,
      disableNestedContext: G = !1,
      disableStyleSheetGeneration: W = !1,
      defaultMode: P = "system",
      noSsr: H
    } = O, I = tt.useRef(!1), K = z2(), Q = tt.useContext(p), it = !!Q && !G, nt = tt.useMemo(() => E || (typeof n == "function" ? n() : n), [E]), X = nt[t], rt = X || nt, {
      colorSchemes: vt = v,
      components: ct = x,
      cssVarPrefix: dt
    } = rt, ht = Object.keys(vt).filter((Ht) => !!vt[Ht]).join(","), Et = tt.useMemo(() => ht.split(","), [ht]), ot = typeof u == "string" ? u : u.light, lt = typeof u == "string" ? u : u.dark, ft = vt[ot] && vt[lt] ? P : ((Kt = (De = vt[rt.defaultColorScheme]) == null ? void 0 : De.palette) == null ? void 0 : Kt.mode) || ((te = rt.palette) == null ? void 0 : te.mode), {
      mode: Tt,
      setMode: Bt,
      systemMode: Ot,
      lightColorScheme: ie,
      darkColorScheme: ce,
      colorScheme: Ut,
      setColorScheme: se
    } = IE({
      supportedColorSchemes: Et,
      defaultLightColorScheme: ot,
      defaultDarkColorScheme: lt,
      modeStorageKey: R,
      colorSchemeStorageKey: N,
      defaultMode: ft,
      storageManager: q,
      storageWindow: j,
      noSsr: H
    });
    let re = Tt, ue = Ut;
    it && (re = Q.mode, ue = Q.colorScheme);
    const Ae = tt.useMemo(() => {
      var ae;
      const Ht = ue || rt.defaultColorScheme, Jt = ((ae = rt.generateThemeVars) == null ? void 0 : ae.call(rt)) || rt.vars, Yt = {
        ...rt,
        components: ct,
        colorSchemes: vt,
        cssVarPrefix: dt,
        vars: Jt
      };
      if (typeof Yt.generateSpacing == "function" && (Yt.spacing = Yt.generateSpacing()), Ht) {
        const le = vt[Ht];
        le && typeof le == "object" && Object.keys(le).forEach((fe) => {
          le[fe] && typeof le[fe] == "object" ? Yt[fe] = {
            ...Yt[fe],
            ...le[fe]
          } : Yt[fe] = le[fe];
        });
      }
      return h ? h(Yt) : Yt;
    }, [rt, ue, ct, vt, dt]), ve = rt.colorSchemeSelector;
    ko(() => {
      if (ue && D && ve && ve !== "media") {
        const Ht = ve;
        let Jt = ve;
        if (Ht === "class" && (Jt = ".%s"), Ht === "data" && (Jt = "[data-%s]"), Ht != null && Ht.startsWith("data-") && !Ht.includes("%s") && (Jt = `[${Ht}="%s"]`), Jt.startsWith("."))
          D.classList.remove(...Et.map((Yt) => Jt.substring(1).replace("%s", Yt))), D.classList.add(Jt.substring(1).replace("%s", ue));
        else {
          const Yt = Jt.replace("%s", ue).match(/\[([^\]]+)\]/);
          if (Yt) {
            const [ae, le] = Yt[1].split("=");
            le || Et.forEach((fe) => {
              D.removeAttribute(ae.replace(ue, fe));
            }), D.setAttribute(ae, le ? le.replace(/"|'/g, "") : "");
          } else
            D.setAttribute(Jt, ue);
        }
      }
    }, [ue, ve, D, Et]), tt.useEffect(() => {
      let Ht;
      if (U && I.current && V) {
        const Jt = V.createElement("style");
        Jt.appendChild(V.createTextNode(FE)), V.head.appendChild(Jt), window.getComputedStyle(V.body), Ht = setTimeout(() => {
          V.head.removeChild(Jt);
        }, 1);
      }
      return () => {
        clearTimeout(Ht);
      };
    }, [ue, U, V]), tt.useEffect(() => (I.current = !0, () => {
      I.current = !1;
    }), []);
    const Re = tt.useMemo(() => ({
      allColorSchemes: Et,
      colorScheme: ue,
      darkColorScheme: ce,
      lightColorScheme: ie,
      mode: re,
      setColorScheme: se,
      setMode: Bt,
      systemMode: Ot
    }), [Et, ue, ce, ie, re, se, Bt, Ot, Ae.colorSchemeSelector]);
    let oe = !0;
    (W || rt.cssVariables === !1 || it && (K == null ? void 0 : K.cssVarPrefix) === dt) && (oe = !1);
    const Le = /* @__PURE__ */ J.jsxs(tt.Fragment, {
      children: [/* @__PURE__ */ J.jsx(Y3, {
        themeId: X ? t : void 0,
        theme: Ae,
        children: M
      }), oe && /* @__PURE__ */ J.jsx(w3, {
        styles: ((It = Ae.generateStyleSheets) == null ? void 0 : It.call(Ae)) || []
      })]
    });
    return it ? Le : /* @__PURE__ */ J.jsx(p.Provider, {
      value: Re,
      children: Le
    });
  }
  const _ = typeof u == "string" ? u : u.light, T = typeof u == "string" ? u : u.dark;
  return {
    CssVarsProvider: b,
    useColorScheme: g,
    getInitColorSchemeScript: (O) => UE({
      colorSchemeStorageKey: s,
      defaultLightColorScheme: _,
      defaultDarkColorScheme: T,
      modeStorageKey: i,
      ...O
    })
  };
}
function GE(e = "") {
  function t(...i) {
    if (!i.length)
      return "";
    const s = i[0];
    return typeof s == "string" && !s.match(/(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/) ? `, var(--${e ? `${e}-` : ""}${s}${t(...i.slice(1))})` : `, ${s}`;
  }
  return (i, ...s) => `var(--${e ? `${e}-` : ""}${i}${t(...s)})`;
}
const p5 = (e, t, n, i = []) => {
  let s = e;
  t.forEach((o, u) => {
    u === t.length - 1 ? Array.isArray(s) ? s[Number(o)] = n : s && typeof s == "object" && (s[o] = n) : s && typeof s == "object" && (s[o] || (s[o] = i.includes(o) ? [] : {}), s = s[o]);
  });
}, HE = (e, t, n) => {
  function i(s, o = [], u = []) {
    Object.entries(s).forEach(([h, f]) => {
      (!n || n && !n([...o, h])) && f != null && (typeof f == "object" && Object.keys(f).length > 0 ? i(f, [...o, h], Array.isArray(f) ? [...u, h] : u) : t([...o, h], f, u));
    });
  }
  i(e);
}, KE = (e, t) => typeof t == "number" ? ["lineHeight", "fontWeight", "opacity", "zIndex"].some((i) => e.includes(i)) || e[e.length - 1].toLowerCase().includes("opacity") ? t : `${t}px` : t;
function sb(e, t) {
  const {
    prefix: n,
    shouldSkipGeneratingVar: i
  } = t || {}, s = {}, o = {}, u = {};
  return HE(
    e,
    (h, f, p) => {
      if ((typeof f == "string" || typeof f == "number") && (!i || !i(h, f))) {
        const g = `--${n ? `${n}-` : ""}${h.join("-")}`, v = KE(h, f);
        Object.assign(s, {
          [g]: v
        }), p5(o, h, `var(${g})`, p), p5(u, h, `var(${g}, ${v})`, p);
      }
    },
    (h) => h[0] === "vars"
    // skip 'vars/*' paths
  ), {
    css: s,
    vars: o,
    varsWithDefaults: u
  };
}
function YE(e, t = {}) {
  const {
    getSelector: n = A,
    disableCssColorScheme: i,
    colorSchemeSelector: s
  } = t, {
    colorSchemes: o = {},
    components: u,
    defaultColorScheme: h = "light",
    ...f
  } = e, {
    vars: p,
    css: g,
    varsWithDefaults: v
  } = sb(f, t);
  let x = v;
  const b = {}, {
    [h]: _,
    ...T
  } = o;
  if (Object.entries(T || {}).forEach(([E, R]) => {
    const {
      vars: N,
      css: U,
      varsWithDefaults: q
    } = sb(R, t);
    x = Na(x, q), b[E] = {
      css: U,
      vars: N
    };
  }), _) {
    const {
      css: E,
      vars: R,
      varsWithDefaults: N
    } = sb(_, t);
    x = Na(x, N), b[h] = {
      css: E,
      vars: R
    };
  }
  function A(E, R) {
    var U, q;
    let N = s;
    if (s === "class" && (N = ".%s"), s === "data" && (N = "[data-%s]"), s != null && s.startsWith("data-") && !s.includes("%s") && (N = `[${s}="%s"]`), E) {
      if (N === "media")
        return e.defaultColorScheme === E ? ":root" : {
          [`@media (prefers-color-scheme: ${((q = (U = o[E]) == null ? void 0 : U.palette) == null ? void 0 : q.mode) || E})`]: {
            ":root": R
          }
        };
      if (N)
        return e.defaultColorScheme === E ? `:root, ${N.replace("%s", String(E))}` : N.replace("%s", String(E));
    }
    return ":root";
  }
  return {
    vars: x,
    generateThemeVars: () => {
      let E = {
        ...p
      };
      return Object.entries(b).forEach(([, {
        vars: R
      }]) => {
        E = Na(E, R);
      }), E;
    },
    generateStyleSheets: () => {
      var j, V;
      const E = [], R = e.defaultColorScheme || "light";
      function N(D, G) {
        Object.keys(G).length && E.push(typeof D == "string" ? {
          [D]: {
            ...G
          }
        } : D);
      }
      N(n(void 0, {
        ...g
      }), g);
      const {
        [R]: U,
        ...q
      } = b;
      if (U) {
        const {
          css: D
        } = U, G = (V = (j = o[R]) == null ? void 0 : j.palette) == null ? void 0 : V.mode, W = !i && G ? {
          colorScheme: G,
          ...D
        } : {
          ...D
        };
        N(n(R, {
          ...W
        }), W);
      }
      return Object.entries(q).forEach(([D, {
        css: G
      }]) => {
        var H, I;
        const W = (I = (H = o[D]) == null ? void 0 : H.palette) == null ? void 0 : I.mode, P = !i && W ? {
          colorScheme: W,
          ...G
        } : {
          ...G
        };
        N(n(D, {
          ...P
        }), P);
      }), E;
    }
  };
}
function XE(e) {
  return function(n) {
    return e === "media" ? `@media (prefers-color-scheme: ${n})` : e ? e.startsWith("data-") && !e.includes("%s") ? `[${e}="${n}"] &` : e === "class" ? `.${n} &` : e === "data" ? `[data-${n}] &` : `${e.replace("%s", n)} &` : "&";
  };
}
const Rg = {
  black: "#000",
  white: "#fff"
}, WE = {
  50: "#fafafa",
  100: "#f5f5f5",
  200: "#eeeeee",
  300: "#e0e0e0",
  400: "#bdbdbd",
  500: "#9e9e9e",
  600: "#757575",
  700: "#616161",
  800: "#424242",
  900: "#212121",
  A100: "#f5f5f5",
  A200: "#eeeeee",
  A400: "#bdbdbd",
  A700: "#616161"
}, Ef = {
  50: "#f3e5f5",
  200: "#ce93d8",
  300: "#ba68c8",
  400: "#ab47bc",
  500: "#9c27b0",
  700: "#7b1fa2"
}, Af = {
  300: "#e57373",
  400: "#ef5350",
  500: "#f44336",
  700: "#d32f2f",
  800: "#c62828"
}, fm = {
  300: "#ffb74d",
  400: "#ffa726",
  500: "#ff9800",
  700: "#f57c00",
  900: "#e65100"
}, Mf = {
  50: "#e3f2fd",
  200: "#90caf9",
  400: "#42a5f5",
  700: "#1976d2",
  800: "#1565c0"
}, Rf = {
  300: "#4fc3f7",
  400: "#29b6f6",
  500: "#03a9f4",
  700: "#0288d1",
  900: "#01579b"
}, Of = {
  300: "#81c784",
  400: "#66bb6a",
  500: "#4caf50",
  700: "#388e3c",
  800: "#2e7d32",
  900: "#1b5e20"
};
function W3() {
  return {
    // The colors used to style the text.
    text: {
      // The most important text.
      primary: "rgba(0, 0, 0, 0.87)",
      // Secondary text.
      secondary: "rgba(0, 0, 0, 0.6)",
      // Disabled text have even lower visual prominence.
      disabled: "rgba(0, 0, 0, 0.38)"
    },
    // The color used to divide different elements.
    divider: "rgba(0, 0, 0, 0.12)",
    // The background colors used to style the surfaces.
    // Consistency between these values is important.
    background: {
      paper: Rg.white,
      default: Rg.white
    },
    // The colors used to style the action elements.
    action: {
      // The color of an active action like an icon button.
      active: "rgba(0, 0, 0, 0.54)",
      // The color of an hovered action.
      hover: "rgba(0, 0, 0, 0.04)",
      hoverOpacity: 0.04,
      // The color of a selected action.
      selected: "rgba(0, 0, 0, 0.08)",
      selectedOpacity: 0.08,
      // The color of a disabled action.
      disabled: "rgba(0, 0, 0, 0.26)",
      // The background color of a disabled action.
      disabledBackground: "rgba(0, 0, 0, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(0, 0, 0, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.12
    }
  };
}
const $E = W3();
function $3() {
  return {
    text: {
      primary: Rg.white,
      secondary: "rgba(255, 255, 255, 0.7)",
      disabled: "rgba(255, 255, 255, 0.5)",
      icon: "rgba(255, 255, 255, 0.5)"
    },
    divider: "rgba(255, 255, 255, 0.12)",
    background: {
      paper: "#121212",
      default: "#121212"
    },
    action: {
      active: Rg.white,
      hover: "rgba(255, 255, 255, 0.08)",
      hoverOpacity: 0.08,
      selected: "rgba(255, 255, 255, 0.16)",
      selectedOpacity: 0.16,
      disabled: "rgba(255, 255, 255, 0.3)",
      disabledBackground: "rgba(255, 255, 255, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(255, 255, 255, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.24
    }
  };
}
const m5 = $3();
function g5(e, t, n, i) {
  const s = i.light || i, o = i.dark || i * 1.5;
  e[t] || (e.hasOwnProperty(n) ? e[t] = e[n] : t === "light" ? e.light = Mg(e.main, s) : t === "dark" && (e.dark = Ag(e.main, o)));
}
function QE(e = "light") {
  return e === "dark" ? {
    main: Mf[200],
    light: Mf[50],
    dark: Mf[400]
  } : {
    main: Mf[700],
    light: Mf[400],
    dark: Mf[800]
  };
}
function ZE(e = "light") {
  return e === "dark" ? {
    main: Ef[200],
    light: Ef[50],
    dark: Ef[400]
  } : {
    main: Ef[500],
    light: Ef[300],
    dark: Ef[700]
  };
}
function JE(e = "light") {
  return e === "dark" ? {
    main: Af[500],
    light: Af[300],
    dark: Af[700]
  } : {
    main: Af[700],
    light: Af[400],
    dark: Af[800]
  };
}
function t9(e = "light") {
  return e === "dark" ? {
    main: Rf[400],
    light: Rf[300],
    dark: Rf[700]
  } : {
    main: Rf[700],
    light: Rf[500],
    dark: Rf[900]
  };
}
function e9(e = "light") {
  return e === "dark" ? {
    main: Of[400],
    light: Of[300],
    dark: Of[700]
  } : {
    main: Of[800],
    light: Of[500],
    dark: Of[900]
  };
}
function n9(e = "light") {
  return e === "dark" ? {
    main: fm[400],
    light: fm[300],
    dark: fm[700]
  } : {
    main: "#ed6c02",
    // closest to orange[800] that pass 3:1.
    light: fm[500],
    dark: fm[900]
  };
}
function j2(e) {
  const {
    mode: t = "light",
    contrastThreshold: n = 3,
    tonalOffset: i = 0.2,
    ...s
  } = e, o = e.primary || QE(t), u = e.secondary || ZE(t), h = e.error || JE(t), f = e.info || t9(t), p = e.success || e9(t), g = e.warning || n9(t);
  function v(T) {
    return vE(T, m5.text.primary) >= n ? m5.text.primary : $E.text.primary;
  }
  const x = ({
    color: T,
    name: A,
    mainShade: O = 500,
    lightShade: M = 300,
    darkShade: E = 700
  }) => {
    if (T = {
      ...T
    }, !T.main && T[O] && (T.main = T[O]), !T.hasOwnProperty("main"))
      throw new Error(Bu(11, A ? ` (${A})` : "", O));
    if (typeof T.main != "string")
      throw new Error(Bu(12, A ? ` (${A})` : "", JSON.stringify(T.main)));
    return g5(T, "light", M, i), g5(T, "dark", E, i), T.contrastText || (T.contrastText = v(T.main)), T;
  };
  let b;
  return t === "light" ? b = W3() : t === "dark" && (b = $3()), Na({
    // A collection of common colors.
    common: {
      ...Rg
    },
    // prevent mutable object.
    // The palette mode, can be light or dark.
    mode: t,
    // The colors used to represent primary interface elements for a user.
    primary: x({
      color: o,
      name: "primary"
    }),
    // The colors used to represent secondary interface elements for a user.
    secondary: x({
      color: u,
      name: "secondary",
      mainShade: "A400",
      lightShade: "A200",
      darkShade: "A700"
    }),
    // The colors used to represent interface elements that the user should be made aware of.
    error: x({
      color: h,
      name: "error"
    }),
    // The colors used to represent potentially dangerous actions or important messages.
    warning: x({
      color: g,
      name: "warning"
    }),
    // The colors used to present information to the user that is neutral and not necessarily important.
    info: x({
      color: f,
      name: "info"
    }),
    // The colors used to indicate the successful completion of an action that user triggered.
    success: x({
      color: p,
      name: "success"
    }),
    // The grey colors.
    grey: WE,
    // Used by `getContrastText()` to maximize the contrast between
    // the background and the text.
    contrastThreshold: n,
    // Takes a background color and returns the text color that maximizes the contrast.
    getContrastText: v,
    // Generate a rich color object.
    augmentColor: x,
    // Used by the functions below to shift a color's luminance by approximately
    // two indexes within its tonal palette.
    // E.g., shift from Red 500 to Red 300 or Red 700.
    tonalOffset: i,
    // The light and dark mode object.
    ...b
  }, s);
}
function i9(e) {
  const t = {};
  return Object.entries(e).forEach((i) => {
    const [s, o] = i;
    typeof o == "object" && (t[s] = `${o.fontStyle ? `${o.fontStyle} ` : ""}${o.fontVariant ? `${o.fontVariant} ` : ""}${o.fontWeight ? `${o.fontWeight} ` : ""}${o.fontStretch ? `${o.fontStretch} ` : ""}${o.fontSize || ""}${o.lineHeight ? `/${o.lineHeight} ` : ""}${o.fontFamily || ""}`);
  }), t;
}
function r9(e, t) {
  return {
    toolbar: {
      minHeight: 56,
      [e.up("xs")]: {
        "@media (orientation: landscape)": {
          minHeight: 48
        }
      },
      [e.up("sm")]: {
        minHeight: 64
      }
    },
    ...t
  };
}
function a9(e) {
  return Math.round(e * 1e5) / 1e5;
}
const y5 = {
  textTransform: "uppercase"
}, v5 = '"Roboto", "Helvetica", "Arial", sans-serif';
function Q3(e, t) {
  const {
    fontFamily: n = v5,
    // The default font size of the Material Specification.
    fontSize: i = 14,
    // px
    fontWeightLight: s = 300,
    fontWeightRegular: o = 400,
    fontWeightMedium: u = 500,
    fontWeightBold: h = 700,
    // Tell MUI what's the font-size on the html element.
    // 16px is the default font-size used by browsers.
    htmlFontSize: f = 16,
    // Apply the CSS properties to all the variants.
    allVariants: p,
    pxToRem: g,
    ...v
  } = typeof t == "function" ? t(e) : t, x = i / 14, b = g || ((A) => `${A / f * x}rem`), _ = (A, O, M, E, R) => ({
    fontFamily: n,
    fontWeight: A,
    fontSize: b(O),
    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
    lineHeight: M,
    // The letter spacing was designed for the Roboto font-family. Using the same letter-spacing
    // across font-families can cause issues with the kerning.
    ...n === v5 ? {
      letterSpacing: `${a9(E / O)}em`
    } : {},
    ...R,
    ...p
  }), T = {
    h1: _(s, 96, 1.167, -1.5),
    h2: _(s, 60, 1.2, -0.5),
    h3: _(o, 48, 1.167, 0),
    h4: _(o, 34, 1.235, 0.25),
    h5: _(o, 24, 1.334, 0),
    h6: _(u, 20, 1.6, 0.15),
    subtitle1: _(o, 16, 1.75, 0.15),
    subtitle2: _(u, 14, 1.57, 0.1),
    body1: _(o, 16, 1.5, 0.15),
    body2: _(o, 14, 1.43, 0.15),
    button: _(u, 14, 1.75, 0.4, y5),
    caption: _(o, 12, 1.66, 0.4),
    overline: _(o, 12, 2.66, 1, y5),
    // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
    inherit: {
      fontFamily: "inherit",
      fontWeight: "inherit",
      fontSize: "inherit",
      lineHeight: "inherit",
      letterSpacing: "inherit"
    }
  };
  return Na({
    htmlFontSize: f,
    pxToRem: b,
    fontFamily: n,
    fontSize: i,
    fontWeightLight: s,
    fontWeightRegular: o,
    fontWeightMedium: u,
    fontWeightBold: h,
    ...T
  }, v, {
    clone: !1
    // No need to clone deep
  });
}
const s9 = 0.2, o9 = 0.14, l9 = 0.12;
function Di(...e) {
  return [`${e[0]}px ${e[1]}px ${e[2]}px ${e[3]}px rgba(0,0,0,${s9})`, `${e[4]}px ${e[5]}px ${e[6]}px ${e[7]}px rgba(0,0,0,${o9})`, `${e[8]}px ${e[9]}px ${e[10]}px ${e[11]}px rgba(0,0,0,${l9})`].join(",");
}
const c9 = ["none", Di(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), Di(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), Di(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), Di(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), Di(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), Di(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), Di(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), Di(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), Di(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), Di(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), Di(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), Di(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), Di(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), Di(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), Di(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), Di(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), Di(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), Di(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), Di(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), Di(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), Di(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), Di(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), Di(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), Di(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)], u9 = {
  // This is the most common easing curve.
  easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: "cubic-bezier(0.4, 0, 1, 1)",
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
}, d9 = {
  shortest: 150,
  shorter: 200,
  short: 250,
  // most basic recommended timing
  standard: 300,
  // this is to be used in complex animations
  complex: 375,
  // recommended when something is entering screen
  enteringScreen: 225,
  // recommended when something is leaving screen
  leavingScreen: 195
};
function b5(e) {
  return `${Math.round(e)}ms`;
}
function h9(e) {
  if (!e)
    return 0;
  const t = e / 36;
  return Math.min(Math.round((4 + 15 * t ** 0.25 + t / 5) * 10), 3e3);
}
function f9(e) {
  const t = {
    ...u9,
    ...e.easing
  }, n = {
    ...d9,
    ...e.duration
  };
  return {
    getAutoHeightDuration: h9,
    create: (s = ["all"], o = {}) => {
      const {
        duration: u = n.standard,
        easing: h = t.easeInOut,
        delay: f = 0,
        ...p
      } = o;
      return (Array.isArray(s) ? s : [s]).map((g) => `${g} ${typeof u == "string" ? u : b5(u)} ${h} ${typeof f == "string" ? f : b5(f)}`).join(",");
    },
    ...e,
    easing: t,
    duration: n
  };
}
const p9 = {
  mobileStepper: 1e3,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
};
function m9(e) {
  return xc(e) || typeof e > "u" || typeof e == "string" || typeof e == "boolean" || typeof e == "number" || Array.isArray(e);
}
function Z3(e = {}) {
  const t = {
    ...e
  };
  function n(i) {
    const s = Object.entries(i);
    for (let o = 0; o < s.length; o++) {
      const [u, h] = s[o];
      !m9(h) || u.startsWith("unstable_") ? delete i[u] : xc(h) && (i[u] = {
        ...h
      }, n(i[u]));
    }
  }
  return n(t), `import { unstable_createBreakpoints as createBreakpoints, createTransitions } from '@mui/material/styles';

const theme = ${JSON.stringify(t, null, 2)};

theme.breakpoints = createBreakpoints(theme.breakpoints || {});
theme.transitions = createTransitions(theme.transitions || {});

export default theme;`;
}
function Gb(e = {}, ...t) {
  const {
    breakpoints: n,
    mixins: i = {},
    spacing: s,
    palette: o = {},
    transitions: u = {},
    typography: h = {},
    shape: f,
    ...p
  } = e;
  if (e.vars && // The error should throw only for the root theme creation because user is not allowed to use a custom node `vars`.
  // `generateThemeVars` is the closest identifier for checking that the `options` is a result of `createTheme` with CSS variables so that user can create new theme for nested ThemeProvider.
  e.generateThemeVars === void 0)
    throw new Error(Bu(20));
  const g = j2(o), v = k2(e);
  let x = Na(v, {
    mixins: r9(v.breakpoints, i),
    palette: g,
    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
    shadows: c9.slice(),
    typography: Q3(g, h),
    transitions: f9(u),
    zIndex: {
      ...p9
    }
  });
  return x = Na(x, p), x = t.reduce((b, _) => Na(b, _), x), x.unstable_sxConfig = {
    ...Fg,
    ...p == null ? void 0 : p.unstable_sxConfig
  }, x.unstable_sx = function(_) {
    return zd({
      sx: _,
      theme: this
    });
  }, x.toRuntimeSource = Z3, x;
}
function Hb(e) {
  let t;
  return e < 1 ? t = 5.11916 * e ** 2 : t = 4.5 * Math.log(e + 1) + 2, Math.round(t * 10) / 1e3;
}
const g9 = [...Array(25)].map((e, t) => {
  if (t === 0)
    return "none";
  const n = Hb(t);
  return `linear-gradient(rgba(255 255 255 / ${n}), rgba(255 255 255 / ${n}))`;
});
function J3(e) {
  return {
    inputPlaceholder: e === "dark" ? 0.5 : 0.42,
    inputUnderline: e === "dark" ? 0.7 : 0.42,
    switchTrackDisabled: e === "dark" ? 0.2 : 0.12,
    switchTrack: e === "dark" ? 0.3 : 0.38
  };
}
function tT(e) {
  return e === "dark" ? g9 : [];
}
function y9(e) {
  const {
    palette: t = {
      mode: "light"
    },
    // need to cast to avoid module augmentation test
    opacity: n,
    overlays: i,
    ...s
  } = e, o = j2(t);
  return {
    palette: o,
    opacity: {
      ...J3(o.mode),
      ...n
    },
    overlays: i || tT(o.mode),
    ...s
  };
}
function v9(e) {
  var t;
  return !!e[0].match(/(cssVarPrefix|colorSchemeSelector|rootSelector|typography|mixins|breakpoints|direction|transitions)/) || !!e[0].match(/sxConfig$/) || // ends with sxConfig
  e[0] === "palette" && !!((t = e[1]) != null && t.match(/(mode|contrastThreshold|tonalOffset)/));
}
const b9 = (e) => [...[...Array(25)].map((t, n) => `--${e ? `${e}-` : ""}overlays-${n}`), `--${e ? `${e}-` : ""}palette-AppBar-darkBg`, `--${e ? `${e}-` : ""}palette-AppBar-darkColor`], _9 = (e) => (t, n) => {
  const i = e.rootSelector || ":root", s = e.colorSchemeSelector;
  let o = s;
  if (s === "class" && (o = ".%s"), s === "data" && (o = "[data-%s]"), s != null && s.startsWith("data-") && !s.includes("%s") && (o = `[${s}="%s"]`), e.defaultColorScheme === t) {
    if (t === "dark") {
      const u = {};
      return b9(e.cssVarPrefix).forEach((h) => {
        u[h] = n[h], delete n[h];
      }), o === "media" ? {
        [i]: n,
        "@media (prefers-color-scheme: dark)": {
          [i]: u
        }
      } : o ? {
        [o.replace("%s", t)]: u,
        [`${i}, ${o.replace("%s", t)}`]: n
      } : {
        [i]: {
          ...n,
          ...u
        }
      };
    }
    if (o && o !== "media")
      return `${i}, ${o.replace("%s", String(t))}`;
  } else if (t) {
    if (o === "media")
      return {
        [`@media (prefers-color-scheme: ${String(t)})`]: {
          [i]: n
        }
      };
    if (o)
      return o.replace("%s", String(t));
  }
  return i;
};
function S9(e, t) {
  t.forEach((n) => {
    e[n] || (e[n] = {});
  });
}
function Wt(e, t, n) {
  !e[t] && n && (e[t] = n);
}
function pg(e) {
  return typeof e != "string" || !e.startsWith("hsl") ? e : U3(e);
}
function Cu(e, t) {
  `${t}Channel` in e || (e[`${t}Channel`] = fg(pg(e[t])));
}
function x9(e) {
  return typeof e == "number" ? `${e}px` : typeof e == "string" || typeof e == "function" || Array.isArray(e) ? e : "8px";
}
const gc = (e) => {
  try {
    return e();
  } catch {
  }
}, T9 = (e = "mui") => GE(e);
function ob(e, t, n, i) {
  if (!t)
    return;
  t = t === !0 ? {} : t;
  const s = i === "dark" ? "dark" : "light";
  if (!n) {
    e[i] = y9({
      ...t,
      palette: {
        mode: s,
        ...t == null ? void 0 : t.palette
      }
    });
    return;
  }
  const {
    palette: o,
    ...u
  } = Gb({
    ...n,
    palette: {
      mode: s,
      ...t == null ? void 0 : t.palette
    }
  });
  return e[i] = {
    ...t,
    palette: o,
    opacity: {
      ...J3(s),
      ...t == null ? void 0 : t.opacity
    },
    overlays: (t == null ? void 0 : t.overlays) || tT(s)
  }, u;
}
function C9(e = {}, ...t) {
  const {
    colorSchemes: n = {
      light: !0
    },
    defaultColorScheme: i,
    disableCssColorScheme: s = !1,
    cssVarPrefix: o = "mui",
    shouldSkipGeneratingVar: u = v9,
    colorSchemeSelector: h = n.light && n.dark ? "media" : void 0,
    rootSelector: f = ":root",
    ...p
  } = e, g = Object.keys(n)[0], v = i || (n.light && g !== "light" ? "light" : g), x = T9(o), {
    [v]: b,
    light: _,
    dark: T,
    ...A
  } = n, O = {
    ...A
  };
  let M = b;
  if ((v === "dark" && !("dark" in n) || v === "light" && !("light" in n)) && (M = !0), !M)
    throw new Error(Bu(21, v));
  const E = ob(O, M, p, v);
  _ && !O.light && ob(O, _, void 0, "light"), T && !O.dark && ob(O, T, void 0, "dark");
  let R = {
    defaultColorScheme: v,
    ...E,
    cssVarPrefix: o,
    colorSchemeSelector: h,
    rootSelector: f,
    getCssVar: x,
    colorSchemes: O,
    font: {
      ...i9(E.typography),
      ...E.font
    },
    spacing: x9(p.spacing)
  };
  Object.keys(R.colorSchemes).forEach((V) => {
    const D = R.colorSchemes[V].palette, G = (W) => {
      const P = W.split("-"), H = P[1], I = P[2];
      return x(W, D[H][I]);
    };
    if (D.mode === "light" && (Wt(D.common, "background", "#fff"), Wt(D.common, "onBackground", "#000")), D.mode === "dark" && (Wt(D.common, "background", "#000"), Wt(D.common, "onBackground", "#fff")), S9(D, ["Alert", "AppBar", "Avatar", "Button", "Chip", "FilledInput", "LinearProgress", "Skeleton", "Slider", "SnackbarContent", "SpeedDialAction", "StepConnector", "StepContent", "Switch", "TableCell", "Tooltip"]), D.mode === "light") {
      Wt(D.Alert, "errorColor", pi(D.error.light, 0.6)), Wt(D.Alert, "infoColor", pi(D.info.light, 0.6)), Wt(D.Alert, "successColor", pi(D.success.light, 0.6)), Wt(D.Alert, "warningColor", pi(D.warning.light, 0.6)), Wt(D.Alert, "errorFilledBg", G("palette-error-main")), Wt(D.Alert, "infoFilledBg", G("palette-info-main")), Wt(D.Alert, "successFilledBg", G("palette-success-main")), Wt(D.Alert, "warningFilledBg", G("palette-warning-main")), Wt(D.Alert, "errorFilledColor", gc(() => D.getContrastText(D.error.main))), Wt(D.Alert, "infoFilledColor", gc(() => D.getContrastText(D.info.main))), Wt(D.Alert, "successFilledColor", gc(() => D.getContrastText(D.success.main))), Wt(D.Alert, "warningFilledColor", gc(() => D.getContrastText(D.warning.main))), Wt(D.Alert, "errorStandardBg", mi(D.error.light, 0.9)), Wt(D.Alert, "infoStandardBg", mi(D.info.light, 0.9)), Wt(D.Alert, "successStandardBg", mi(D.success.light, 0.9)), Wt(D.Alert, "warningStandardBg", mi(D.warning.light, 0.9)), Wt(D.Alert, "errorIconColor", G("palette-error-main")), Wt(D.Alert, "infoIconColor", G("palette-info-main")), Wt(D.Alert, "successIconColor", G("palette-success-main")), Wt(D.Alert, "warningIconColor", G("palette-warning-main")), Wt(D.AppBar, "defaultBg", G("palette-grey-100")), Wt(D.Avatar, "defaultBg", G("palette-grey-400")), Wt(D.Button, "inheritContainedBg", G("palette-grey-300")), Wt(D.Button, "inheritContainedHoverBg", G("palette-grey-A100")), Wt(D.Chip, "defaultBorder", G("palette-grey-400")), Wt(D.Chip, "defaultAvatarColor", G("palette-grey-700")), Wt(D.Chip, "defaultIconColor", G("palette-grey-700")), Wt(D.FilledInput, "bg", "rgba(0, 0, 0, 0.06)"), Wt(D.FilledInput, "hoverBg", "rgba(0, 0, 0, 0.09)"), Wt(D.FilledInput, "disabledBg", "rgba(0, 0, 0, 0.12)"), Wt(D.LinearProgress, "primaryBg", mi(D.primary.main, 0.62)), Wt(D.LinearProgress, "secondaryBg", mi(D.secondary.main, 0.62)), Wt(D.LinearProgress, "errorBg", mi(D.error.main, 0.62)), Wt(D.LinearProgress, "infoBg", mi(D.info.main, 0.62)), Wt(D.LinearProgress, "successBg", mi(D.success.main, 0.62)), Wt(D.LinearProgress, "warningBg", mi(D.warning.main, 0.62)), Wt(D.Skeleton, "bg", `rgba(${G("palette-text-primaryChannel")} / 0.11)`), Wt(D.Slider, "primaryTrack", mi(D.primary.main, 0.62)), Wt(D.Slider, "secondaryTrack", mi(D.secondary.main, 0.62)), Wt(D.Slider, "errorTrack", mi(D.error.main, 0.62)), Wt(D.Slider, "infoTrack", mi(D.info.main, 0.62)), Wt(D.Slider, "successTrack", mi(D.success.main, 0.62)), Wt(D.Slider, "warningTrack", mi(D.warning.main, 0.62));
      const W = vy(D.background.default, 0.8);
      Wt(D.SnackbarContent, "bg", W), Wt(D.SnackbarContent, "color", gc(() => D.getContrastText(W))), Wt(D.SpeedDialAction, "fabHoverBg", vy(D.background.paper, 0.15)), Wt(D.StepConnector, "border", G("palette-grey-400")), Wt(D.StepContent, "border", G("palette-grey-400")), Wt(D.Switch, "defaultColor", G("palette-common-white")), Wt(D.Switch, "defaultDisabledColor", G("palette-grey-100")), Wt(D.Switch, "primaryDisabledColor", mi(D.primary.main, 0.62)), Wt(D.Switch, "secondaryDisabledColor", mi(D.secondary.main, 0.62)), Wt(D.Switch, "errorDisabledColor", mi(D.error.main, 0.62)), Wt(D.Switch, "infoDisabledColor", mi(D.info.main, 0.62)), Wt(D.Switch, "successDisabledColor", mi(D.success.main, 0.62)), Wt(D.Switch, "warningDisabledColor", mi(D.warning.main, 0.62)), Wt(D.TableCell, "border", mi(yy(D.divider, 1), 0.88)), Wt(D.Tooltip, "bg", yy(D.grey[700], 0.92));
    }
    if (D.mode === "dark") {
      Wt(D.Alert, "errorColor", mi(D.error.light, 0.6)), Wt(D.Alert, "infoColor", mi(D.info.light, 0.6)), Wt(D.Alert, "successColor", mi(D.success.light, 0.6)), Wt(D.Alert, "warningColor", mi(D.warning.light, 0.6)), Wt(D.Alert, "errorFilledBg", G("palette-error-dark")), Wt(D.Alert, "infoFilledBg", G("palette-info-dark")), Wt(D.Alert, "successFilledBg", G("palette-success-dark")), Wt(D.Alert, "warningFilledBg", G("palette-warning-dark")), Wt(D.Alert, "errorFilledColor", gc(() => D.getContrastText(D.error.dark))), Wt(D.Alert, "infoFilledColor", gc(() => D.getContrastText(D.info.dark))), Wt(D.Alert, "successFilledColor", gc(() => D.getContrastText(D.success.dark))), Wt(D.Alert, "warningFilledColor", gc(() => D.getContrastText(D.warning.dark))), Wt(D.Alert, "errorStandardBg", pi(D.error.light, 0.9)), Wt(D.Alert, "infoStandardBg", pi(D.info.light, 0.9)), Wt(D.Alert, "successStandardBg", pi(D.success.light, 0.9)), Wt(D.Alert, "warningStandardBg", pi(D.warning.light, 0.9)), Wt(D.Alert, "errorIconColor", G("palette-error-main")), Wt(D.Alert, "infoIconColor", G("palette-info-main")), Wt(D.Alert, "successIconColor", G("palette-success-main")), Wt(D.Alert, "warningIconColor", G("palette-warning-main")), Wt(D.AppBar, "defaultBg", G("palette-grey-900")), Wt(D.AppBar, "darkBg", G("palette-background-paper")), Wt(D.AppBar, "darkColor", G("palette-text-primary")), Wt(D.Avatar, "defaultBg", G("palette-grey-600")), Wt(D.Button, "inheritContainedBg", G("palette-grey-800")), Wt(D.Button, "inheritContainedHoverBg", G("palette-grey-700")), Wt(D.Chip, "defaultBorder", G("palette-grey-700")), Wt(D.Chip, "defaultAvatarColor", G("palette-grey-300")), Wt(D.Chip, "defaultIconColor", G("palette-grey-300")), Wt(D.FilledInput, "bg", "rgba(255, 255, 255, 0.09)"), Wt(D.FilledInput, "hoverBg", "rgba(255, 255, 255, 0.13)"), Wt(D.FilledInput, "disabledBg", "rgba(255, 255, 255, 0.12)"), Wt(D.LinearProgress, "primaryBg", pi(D.primary.main, 0.5)), Wt(D.LinearProgress, "secondaryBg", pi(D.secondary.main, 0.5)), Wt(D.LinearProgress, "errorBg", pi(D.error.main, 0.5)), Wt(D.LinearProgress, "infoBg", pi(D.info.main, 0.5)), Wt(D.LinearProgress, "successBg", pi(D.success.main, 0.5)), Wt(D.LinearProgress, "warningBg", pi(D.warning.main, 0.5)), Wt(D.Skeleton, "bg", `rgba(${G("palette-text-primaryChannel")} / 0.13)`), Wt(D.Slider, "primaryTrack", pi(D.primary.main, 0.5)), Wt(D.Slider, "secondaryTrack", pi(D.secondary.main, 0.5)), Wt(D.Slider, "errorTrack", pi(D.error.main, 0.5)), Wt(D.Slider, "infoTrack", pi(D.info.main, 0.5)), Wt(D.Slider, "successTrack", pi(D.success.main, 0.5)), Wt(D.Slider, "warningTrack", pi(D.warning.main, 0.5));
      const W = vy(D.background.default, 0.98);
      Wt(D.SnackbarContent, "bg", W), Wt(D.SnackbarContent, "color", gc(() => D.getContrastText(W))), Wt(D.SpeedDialAction, "fabHoverBg", vy(D.background.paper, 0.15)), Wt(D.StepConnector, "border", G("palette-grey-600")), Wt(D.StepContent, "border", G("palette-grey-600")), Wt(D.Switch, "defaultColor", G("palette-grey-300")), Wt(D.Switch, "defaultDisabledColor", G("palette-grey-600")), Wt(D.Switch, "primaryDisabledColor", pi(D.primary.main, 0.55)), Wt(D.Switch, "secondaryDisabledColor", pi(D.secondary.main, 0.55)), Wt(D.Switch, "errorDisabledColor", pi(D.error.main, 0.55)), Wt(D.Switch, "infoDisabledColor", pi(D.info.main, 0.55)), Wt(D.Switch, "successDisabledColor", pi(D.success.main, 0.55)), Wt(D.Switch, "warningDisabledColor", pi(D.warning.main, 0.55)), Wt(D.TableCell, "border", pi(yy(D.divider, 1), 0.68)), Wt(D.Tooltip, "bg", yy(D.grey[700], 0.92));
    }
    Cu(D.background, "default"), Cu(D.background, "paper"), Cu(D.common, "background"), Cu(D.common, "onBackground"), Cu(D, "divider"), Object.keys(D).forEach((W) => {
      const P = D[W];
      W !== "tonalOffset" && P && typeof P == "object" && (P.main && Wt(D[W], "mainChannel", fg(pg(P.main))), P.light && Wt(D[W], "lightChannel", fg(pg(P.light))), P.dark && Wt(D[W], "darkChannel", fg(pg(P.dark))), P.contrastText && Wt(D[W], "contrastTextChannel", fg(pg(P.contrastText))), W === "text" && (Cu(D[W], "primary"), Cu(D[W], "secondary")), W === "action" && (P.active && Cu(D[W], "active"), P.selected && Cu(D[W], "selected")));
    });
  }), R = t.reduce((V, D) => Na(V, D), R);
  const N = {
    prefix: o,
    disableCssColorScheme: s,
    shouldSkipGeneratingVar: u,
    getSelector: _9(R)
  }, {
    vars: U,
    generateThemeVars: q,
    generateStyleSheets: j
  } = YE(R, N);
  return R.vars = U, Object.entries(R.colorSchemes[R.defaultColorScheme]).forEach(([V, D]) => {
    R[V] = D;
  }), R.generateThemeVars = q, R.generateStyleSheets = j, R.generateSpacing = function() {
    return O3(p.spacing, O2(this));
  }, R.getColorSchemeSelector = XE(h), R.spacing = R.generateSpacing(), R.shouldSkipGeneratingVar = u, R.unstable_sxConfig = {
    ...Fg,
    ...p == null ? void 0 : p.unstable_sxConfig
  }, R.unstable_sx = function(D) {
    return zd({
      sx: D,
      theme: this
    });
  }, R.toRuntimeSource = Z3, R;
}
function _5(e, t, n) {
  e.colorSchemes && n && (e.colorSchemes[t] = {
    ...n !== !0 && n,
    palette: j2({
      ...n === !0 ? {} : n.palette,
      mode: t
    })
    // cast type to skip module augmentation test
  });
}
function j1(e = {}, ...t) {
  const {
    palette: n,
    cssVariables: i = !1,
    colorSchemes: s = n ? void 0 : {
      light: !0
    },
    defaultColorScheme: o = n == null ? void 0 : n.mode,
    ...u
  } = e, h = o || "light", f = s == null ? void 0 : s[h], p = {
    ...s,
    ...n ? {
      [h]: {
        ...typeof f != "boolean" && f,
        palette: n
      }
    } : void 0
  };
  if (i === !1) {
    if (!("colorSchemes" in e))
      return Gb(e, ...t);
    let g = n;
    "palette" in e || p[h] && (p[h] !== !0 ? g = p[h].palette : h === "dark" && (g = {
      mode: "dark"
    }));
    const v = Gb({
      ...e,
      palette: g
    }, ...t);
    return v.defaultColorScheme = h, v.colorSchemes = p, v.palette.mode === "light" && (v.colorSchemes.light = {
      ...p.light !== !0 && p.light,
      palette: v.palette
    }, _5(v, "dark", p.dark)), v.palette.mode === "dark" && (v.colorSchemes.dark = {
      ...p.dark !== !0 && p.dark,
      palette: v.palette
    }, _5(v, "light", p.light)), v;
  }
  return !n && !("light" in p) && h === "light" && (p.light = !0), C9({
    ...u,
    colorSchemes: p,
    defaultColorScheme: h,
    ...typeof i != "boolean" && i
  }, ...t);
}
const L2 = j1();
function L1() {
  const e = D2(L2);
  return e[Tc] || e;
}
function V1(e) {
  return e !== "ownerState" && e !== "theme" && e !== "sx" && e !== "as";
}
const Po = (e) => V1(e) && e !== "classes", Ne = dE({
  themeId: Tc,
  defaultTheme: L2,
  rootShouldForwardProp: Po
});
function lb({
  theme: e,
  ...t
}) {
  const n = Tc in e ? e[Tc] : void 0;
  return /* @__PURE__ */ J.jsx(Y3, {
    ...t,
    themeId: n ? Tc : void 0,
    theme: n || e
  });
}
const by = {
  colorSchemeStorageKey: "mui-color-scheme",
  defaultLightColorScheme: "light",
  defaultDarkColorScheme: "dark",
  modeStorageKey: "mui-mode"
}, {
  CssVarsProvider: w9
} = qE({
  themeId: Tc,
  // @ts-ignore ignore module augmentation tests
  theme: () => j1({
    cssVariables: !0
  }),
  colorSchemeStorageKey: by.colorSchemeStorageKey,
  modeStorageKey: by.modeStorageKey,
  defaultColorScheme: {
    light: by.defaultLightColorScheme,
    dark: by.defaultDarkColorScheme
  },
  resolveTheme: (e) => {
    const t = {
      ...e,
      typography: Q3(e.palette, e.typography)
    };
    return t.unstable_sx = function(i) {
      return zd({
        sx: i,
        theme: this
      });
    }, t;
  }
}), E9 = w9;
function eT({
  theme: e,
  ...t
}) {
  if (typeof e == "function")
    return /* @__PURE__ */ J.jsx(lb, {
      theme: e,
      ...t
    });
  const n = Tc in e ? e[Tc] : e;
  return "colorSchemes" in n ? /* @__PURE__ */ J.jsx(E9, {
    theme: e,
    ...t
  }) : "vars" in n ? /* @__PURE__ */ J.jsx(lb, {
    theme: e,
    ...t
  }) : /* @__PURE__ */ J.jsx(lb, {
    theme: {
      ...e,
      vars: null
    },
    ...t
  });
}
function A9(e) {
  return /* @__PURE__ */ J.jsx(iE, {
    ...e,
    defaultTheme: L2,
    themeId: Tc
  });
}
function M9(e) {
  return function(n) {
    return (
      // Pigment CSS `globalCss` support callback with theme inside an object but `GlobalStyles` support theme as a callback value.
      /* @__PURE__ */ J.jsx(A9, {
        styles: typeof e == "function" ? (i) => e({
          theme: i,
          ...n
        }) : e
      })
    );
  };
}
function R9() {
  return k3;
}
const En = zE;
function In(e) {
  return BE(e);
}
function O9(e) {
  return Un("MuiSvgIcon", e);
}
zn("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
const N9 = (e) => {
  const {
    color: t,
    fontSize: n,
    classes: i
  } = e, s = {
    root: ["root", t !== "inherit" && `color${Ue(t)}`, `fontSize${Ue(n)}`]
  };
  return jn(s, O9, i);
}, k9 = Ne("svg", {
  name: "MuiSvgIcon",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.color !== "inherit" && t[`color${Ue(n.color)}`], t[`fontSize${Ue(n.fontSize)}`]];
  }
})(En(({
  theme: e
}) => {
  var t, n, i, s, o, u, h, f, p, g, v, x, b, _;
  return {
    userSelect: "none",
    width: "1em",
    height: "1em",
    display: "inline-block",
    flexShrink: 0,
    transition: (s = (t = e.transitions) == null ? void 0 : t.create) == null ? void 0 : s.call(t, "fill", {
      duration: (i = (n = (e.vars ?? e).transitions) == null ? void 0 : n.duration) == null ? void 0 : i.shorter
    }),
    variants: [
      {
        props: (T) => !T.hasSvgAsChild,
        style: {
          // the <svg> will define the property that has `currentColor`
          // for example heroicons uses fill="none" and stroke="currentColor"
          fill: "currentColor"
        }
      },
      {
        props: {
          fontSize: "inherit"
        },
        style: {
          fontSize: "inherit"
        }
      },
      {
        props: {
          fontSize: "small"
        },
        style: {
          fontSize: ((u = (o = e.typography) == null ? void 0 : o.pxToRem) == null ? void 0 : u.call(o, 20)) || "1.25rem"
        }
      },
      {
        props: {
          fontSize: "medium"
        },
        style: {
          fontSize: ((f = (h = e.typography) == null ? void 0 : h.pxToRem) == null ? void 0 : f.call(h, 24)) || "1.5rem"
        }
      },
      {
        props: {
          fontSize: "large"
        },
        style: {
          fontSize: ((g = (p = e.typography) == null ? void 0 : p.pxToRem) == null ? void 0 : g.call(p, 35)) || "2.1875rem"
        }
      },
      // TODO v5 deprecate color prop, v6 remove for sx
      ...Object.entries((e.vars ?? e).palette).filter(([, T]) => T && T.main).map(([T]) => {
        var A, O;
        return {
          props: {
            color: T
          },
          style: {
            color: (O = (A = (e.vars ?? e).palette) == null ? void 0 : A[T]) == null ? void 0 : O.main
          }
        };
      }),
      {
        props: {
          color: "action"
        },
        style: {
          color: (x = (v = (e.vars ?? e).palette) == null ? void 0 : v.action) == null ? void 0 : x.active
        }
      },
      {
        props: {
          color: "disabled"
        },
        style: {
          color: (_ = (b = (e.vars ?? e).palette) == null ? void 0 : b.action) == null ? void 0 : _.disabled
        }
      },
      {
        props: {
          color: "inherit"
        },
        style: {
          color: void 0
        }
      }
    ]
  };
})), Kb = /* @__PURE__ */ tt.forwardRef(function(t, n) {
  const i = In({
    props: t,
    name: "MuiSvgIcon"
  }), {
    children: s,
    className: o,
    color: u = "inherit",
    component: h = "svg",
    fontSize: f = "medium",
    htmlColor: p,
    inheritViewBox: g = !1,
    titleAccess: v,
    viewBox: x = "0 0 24 24",
    ...b
  } = i, _ = /* @__PURE__ */ tt.isValidElement(s) && s.type === "svg", T = {
    ...i,
    color: u,
    component: h,
    fontSize: f,
    instanceFontSize: t.fontSize,
    inheritViewBox: g,
    viewBox: x,
    hasSvgAsChild: _
  }, A = {};
  g || (A.viewBox = x);
  const O = N9(T);
  return /* @__PURE__ */ J.jsxs(k9, {
    as: h,
    className: Fe(O.root, o),
    focusable: "false",
    color: p,
    "aria-hidden": v ? void 0 : !0,
    role: v ? "img" : void 0,
    ref: n,
    ...A,
    ...b,
    ..._ && s.props,
    ownerState: T,
    children: [_ ? s.props.children : s, v ? /* @__PURE__ */ J.jsx("title", {
      children: v
    }) : null]
  });
});
Kb.muiName = "SvgIcon";
function Ba(e, t) {
  function n(i, s) {
    return /* @__PURE__ */ J.jsx(Kb, {
      "data-testid": `${t}Icon`,
      ref: s,
      ...i,
      children: e
    });
  }
  return n.muiName = Kb.muiName, /* @__PURE__ */ tt.memo(/* @__PURE__ */ tt.forwardRef(n));
}
function D9(e, t) {
  if (!e)
    return t;
  if (typeof e == "function" || typeof t == "function")
    return (s) => {
      const o = typeof t == "function" ? t(s) : t, u = typeof e == "function" ? e({
        ...s,
        ...o
      }) : e, h = Fe(s == null ? void 0 : s.className, o == null ? void 0 : o.className, u == null ? void 0 : u.className);
      return {
        ...o,
        ...u,
        ...!!h && {
          className: h
        },
        ...(o == null ? void 0 : o.style) && (u == null ? void 0 : u.style) && {
          style: {
            ...o.style,
            ...u.style
          }
        },
        ...(o == null ? void 0 : o.sx) && (u == null ? void 0 : u.sx) && {
          sx: [...Array.isArray(o.sx) ? o.sx : [o.sx], ...Array.isArray(u.sx) ? u.sx : [u.sx]]
        }
      };
    };
  const n = t, i = Fe(n == null ? void 0 : n.className, e == null ? void 0 : e.className);
  return {
    ...t,
    ...e,
    ...!!i && {
      className: i
    },
    ...(n == null ? void 0 : n.style) && (e == null ? void 0 : e.style) && {
      style: {
        ...n.style,
        ...e.style
      }
    },
    ...(n == null ? void 0 : n.sx) && (e == null ? void 0 : e.sx) && {
      sx: [...Array.isArray(n.sx) ? n.sx : [n.sx], ...Array.isArray(e.sx) ? e.sx : [e.sx]]
    }
  };
}
function nT(e, t) {
  if (e == null) return {};
  var n = {};
  for (var i in e) if ({}.hasOwnProperty.call(e, i)) {
    if (t.indexOf(i) !== -1) continue;
    n[i] = e[i];
  }
  return n;
}
function Yb(e, t) {
  return Yb = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
    return n.__proto__ = i, n;
  }, Yb(e, t);
}
function iT(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, Yb(e, t);
}
var rT = u3();
const _y = /* @__PURE__ */ lp(rT), S5 = {
  disabled: !1
}, Jy = an.createContext(null);
var B9 = function(t) {
  return t.scrollTop;
}, mg = "unmounted", Ch = "exited", wh = "entering", zf = "entered", Xb = "exiting", Nc = /* @__PURE__ */ function(e) {
  iT(t, e);
  function t(i, s) {
    var o;
    o = e.call(this, i, s) || this;
    var u = s, h = u && !u.isMounting ? i.enter : i.appear, f;
    return o.appearStatus = null, i.in ? h ? (f = Ch, o.appearStatus = wh) : f = zf : i.unmountOnExit || i.mountOnEnter ? f = mg : f = Ch, o.state = {
      status: f
    }, o.nextCallback = null, o;
  }
  t.getDerivedStateFromProps = function(s, o) {
    var u = s.in;
    return u && o.status === mg ? {
      status: Ch
    } : null;
  };
  var n = t.prototype;
  return n.componentDidMount = function() {
    this.updateStatus(!0, this.appearStatus);
  }, n.componentDidUpdate = function(s) {
    var o = null;
    if (s !== this.props) {
      var u = this.state.status;
      this.props.in ? u !== wh && u !== zf && (o = wh) : (u === wh || u === zf) && (o = Xb);
    }
    this.updateStatus(!1, o);
  }, n.componentWillUnmount = function() {
    this.cancelNextCallback();
  }, n.getTimeouts = function() {
    var s = this.props.timeout, o, u, h;
    return o = u = h = s, s != null && typeof s != "number" && (o = s.exit, u = s.enter, h = s.appear !== void 0 ? s.appear : u), {
      exit: o,
      enter: u,
      appear: h
    };
  }, n.updateStatus = function(s, o) {
    if (s === void 0 && (s = !1), o !== null)
      if (this.cancelNextCallback(), o === wh) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var u = this.props.nodeRef ? this.props.nodeRef.current : _y.findDOMNode(this);
          u && B9(u);
        }
        this.performEnter(s);
      } else
        this.performExit();
    else this.props.unmountOnExit && this.state.status === Ch && this.setState({
      status: mg
    });
  }, n.performEnter = function(s) {
    var o = this, u = this.props.enter, h = this.context ? this.context.isMounting : s, f = this.props.nodeRef ? [h] : [_y.findDOMNode(this), h], p = f[0], g = f[1], v = this.getTimeouts(), x = h ? v.appear : v.enter;
    if (!s && !u || S5.disabled) {
      this.safeSetState({
        status: zf
      }, function() {
        o.props.onEntered(p);
      });
      return;
    }
    this.props.onEnter(p, g), this.safeSetState({
      status: wh
    }, function() {
      o.props.onEntering(p, g), o.onTransitionEnd(x, function() {
        o.safeSetState({
          status: zf
        }, function() {
          o.props.onEntered(p, g);
        });
      });
    });
  }, n.performExit = function() {
    var s = this, o = this.props.exit, u = this.getTimeouts(), h = this.props.nodeRef ? void 0 : _y.findDOMNode(this);
    if (!o || S5.disabled) {
      this.safeSetState({
        status: Ch
      }, function() {
        s.props.onExited(h);
      });
      return;
    }
    this.props.onExit(h), this.safeSetState({
      status: Xb
    }, function() {
      s.props.onExiting(h), s.onTransitionEnd(u.exit, function() {
        s.safeSetState({
          status: Ch
        }, function() {
          s.props.onExited(h);
        });
      });
    });
  }, n.cancelNextCallback = function() {
    this.nextCallback !== null && (this.nextCallback.cancel(), this.nextCallback = null);
  }, n.safeSetState = function(s, o) {
    o = this.setNextCallback(o), this.setState(s, o);
  }, n.setNextCallback = function(s) {
    var o = this, u = !0;
    return this.nextCallback = function(h) {
      u && (u = !1, o.nextCallback = null, s(h));
    }, this.nextCallback.cancel = function() {
      u = !1;
    }, this.nextCallback;
  }, n.onTransitionEnd = function(s, o) {
    this.setNextCallback(o);
    var u = this.props.nodeRef ? this.props.nodeRef.current : _y.findDOMNode(this), h = s == null && !this.props.addEndListener;
    if (!u || h) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var f = this.props.nodeRef ? [this.nextCallback] : [u, this.nextCallback], p = f[0], g = f[1];
      this.props.addEndListener(p, g);
    }
    s != null && setTimeout(this.nextCallback, s);
  }, n.render = function() {
    var s = this.state.status;
    if (s === mg)
      return null;
    var o = this.props, u = o.children;
    o.in, o.mountOnEnter, o.unmountOnExit, o.appear, o.enter, o.exit, o.timeout, o.addEndListener, o.onEnter, o.onEntering, o.onEntered, o.onExit, o.onExiting, o.onExited, o.nodeRef;
    var h = nT(o, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      /* @__PURE__ */ an.createElement(Jy.Provider, {
        value: null
      }, typeof u == "function" ? u(s, h) : an.cloneElement(an.Children.only(u), h))
    );
  }, t;
}(an.Component);
Nc.contextType = Jy;
Nc.propTypes = {};
function Nf() {
}
Nc.defaultProps = {
  in: !1,
  mountOnEnter: !1,
  unmountOnExit: !1,
  appear: !1,
  enter: !0,
  exit: !0,
  onEnter: Nf,
  onEntering: Nf,
  onEntered: Nf,
  onExit: Nf,
  onExiting: Nf,
  onExited: Nf
};
Nc.UNMOUNTED = mg;
Nc.EXITED = Ch;
Nc.ENTERING = wh;
Nc.ENTERED = zf;
Nc.EXITING = Xb;
function z9(e) {
  if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function V2(e, t) {
  var n = function(o) {
    return t && tt.isValidElement(o) ? t(o) : o;
  }, i = /* @__PURE__ */ Object.create(null);
  return e && tt.Children.map(e, function(s) {
    return s;
  }).forEach(function(s) {
    i[s.key] = n(s);
  }), i;
}
function P9(e, t) {
  e = e || {}, t = t || {};
  function n(g) {
    return g in t ? t[g] : e[g];
  }
  var i = /* @__PURE__ */ Object.create(null), s = [];
  for (var o in e)
    o in t ? s.length && (i[o] = s, s = []) : s.push(o);
  var u, h = {};
  for (var f in t) {
    if (i[f])
      for (u = 0; u < i[f].length; u++) {
        var p = i[f][u];
        h[i[f][u]] = n(p);
      }
    h[f] = n(f);
  }
  for (u = 0; u < s.length; u++)
    h[s[u]] = n(s[u]);
  return h;
}
function Mh(e, t, n) {
  return n[t] != null ? n[t] : e.props[t];
}
function U9(e, t) {
  return V2(e.children, function(n) {
    return tt.cloneElement(n, {
      onExited: t.bind(null, n),
      in: !0,
      appear: Mh(n, "appear", e),
      enter: Mh(n, "enter", e),
      exit: Mh(n, "exit", e)
    });
  });
}
function j9(e, t, n) {
  var i = V2(e.children), s = P9(t, i);
  return Object.keys(s).forEach(function(o) {
    var u = s[o];
    if (tt.isValidElement(u)) {
      var h = o in t, f = o in i, p = t[o], g = tt.isValidElement(p) && !p.props.in;
      f && (!h || g) ? s[o] = tt.cloneElement(u, {
        onExited: n.bind(null, u),
        in: !0,
        exit: Mh(u, "exit", e),
        enter: Mh(u, "enter", e)
      }) : !f && h && !g ? s[o] = tt.cloneElement(u, {
        in: !1
      }) : f && h && tt.isValidElement(p) && (s[o] = tt.cloneElement(u, {
        onExited: n.bind(null, u),
        in: p.props.in,
        exit: Mh(u, "exit", e),
        enter: Mh(u, "enter", e)
      }));
    }
  }), s;
}
var L9 = Object.values || function(e) {
  return Object.keys(e).map(function(t) {
    return e[t];
  });
}, V9 = {
  component: "div",
  childFactory: function(t) {
    return t;
  }
}, I2 = /* @__PURE__ */ function(e) {
  iT(t, e);
  function t(i, s) {
    var o;
    o = e.call(this, i, s) || this;
    var u = o.handleExited.bind(z9(o));
    return o.state = {
      contextValue: {
        isMounting: !0
      },
      handleExited: u,
      firstRender: !0
    }, o;
  }
  var n = t.prototype;
  return n.componentDidMount = function() {
    this.mounted = !0, this.setState({
      contextValue: {
        isMounting: !1
      }
    });
  }, n.componentWillUnmount = function() {
    this.mounted = !1;
  }, t.getDerivedStateFromProps = function(s, o) {
    var u = o.children, h = o.handleExited, f = o.firstRender;
    return {
      children: f ? U9(s, h) : j9(s, u, h),
      firstRender: !1
    };
  }, n.handleExited = function(s, o) {
    var u = V2(this.props.children);
    s.key in u || (s.props.onExited && s.props.onExited(o), this.mounted && this.setState(function(h) {
      var f = Wy({}, h.children);
      return delete f[s.key], {
        children: f
      };
    }));
  }, n.render = function() {
    var s = this.props, o = s.component, u = s.childFactory, h = nT(s, ["component", "childFactory"]), f = this.state.contextValue, p = L9(this.state.children).map(u);
    return delete h.appear, delete h.enter, delete h.exit, o === null ? /* @__PURE__ */ an.createElement(Jy.Provider, {
      value: f
    }, p) : /* @__PURE__ */ an.createElement(Jy.Provider, {
      value: f
    }, /* @__PURE__ */ an.createElement(o, h, p));
  }, t;
}(an.Component);
I2.propTypes = {};
I2.defaultProps = V9;
const aT = (e) => e.scrollTop;
function t1(e, t) {
  const {
    timeout: n,
    easing: i,
    style: s = {}
  } = e;
  return {
    duration: s.transitionDuration ?? (typeof n == "number" ? n : n[t.mode] || 0),
    easing: s.transitionTimingFunction ?? (typeof i == "object" ? i[t.mode] : i),
    delay: s.transitionDelay
  };
}
function I9(e) {
  return Un("MuiPaper", e);
}
zn("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
const F9 = (e) => {
  const {
    square: t,
    elevation: n,
    variant: i,
    classes: s
  } = e, o = {
    root: ["root", i, !t && "rounded", i === "elevation" && `elevation${n}`]
  };
  return jn(o, I9, s);
}, q9 = Ne("div", {
  name: "MuiPaper",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, t[n.variant], !n.square && t.rounded, n.variant === "elevation" && t[`elevation${n.elevation}`]];
  }
})(En(({
  theme: e
}) => ({
  backgroundColor: (e.vars || e).palette.background.paper,
  color: (e.vars || e).palette.text.primary,
  transition: e.transitions.create("box-shadow"),
  variants: [{
    props: ({
      ownerState: t
    }) => !t.square,
    style: {
      borderRadius: e.shape.borderRadius
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      border: `1px solid ${(e.vars || e).palette.divider}`
    }
  }, {
    props: {
      variant: "elevation"
    },
    style: {
      boxShadow: "var(--Paper-shadow)",
      backgroundImage: "var(--Paper-overlay)"
    }
  }]
}))), G9 = /* @__PURE__ */ tt.forwardRef(function(t, n) {
  var b;
  const i = In({
    props: t,
    name: "MuiPaper"
  }), s = L1(), {
    className: o,
    component: u = "div",
    elevation: h = 1,
    square: f = !1,
    variant: p = "elevation",
    ...g
  } = i, v = {
    ...i,
    component: u,
    elevation: h,
    square: f,
    variant: p
  }, x = F9(v);
  return /* @__PURE__ */ J.jsx(q9, {
    as: u,
    ownerState: v,
    className: Fe(x.root, o),
    ref: n,
    ...g,
    style: {
      ...p === "elevation" && {
        "--Paper-shadow": (s.vars || s).shadows[h],
        ...s.vars && {
          "--Paper-overlay": (b = s.vars.overlays) == null ? void 0 : b[h]
        },
        ...!s.vars && s.palette.mode === "dark" && {
          "--Paper-overlay": `linear-gradient(${xi("#fff", Hb(h))}, ${xi("#fff", Hb(h))})`
        }
      },
      ...g.style
    }
  });
});
function gr(e, t) {
  const {
    className: n,
    elementType: i,
    ownerState: s,
    externalForwardedProps: o,
    internalForwardedProps: u,
    shouldForwardComponentProp: h = !1,
    ...f
  } = t, {
    component: p,
    slots: g = {
      [e]: void 0
    },
    slotProps: v = {
      [e]: void 0
    },
    ...x
  } = o, b = g[e] || i, _ = q3(v[e], s), {
    props: {
      component: T,
      ...A
    },
    internalRef: O
  } = F3({
    className: n,
    ...f,
    externalForwardedProps: e === "root" ? x : void 0,
    externalSlotProps: _
  }), M = jr(O, _ == null ? void 0 : _.ref, t.ref), E = e === "root" ? T || p : T, R = I3(b, {
    ...e === "root" && !p && !g[e] && u,
    ...e !== "root" && !g[e] && u,
    ...A,
    ...E && !h && {
      as: E
    },
    ...E && h && {
      component: E
    },
    ref: M
  }, s);
  return [b, R];
}
class e1 {
  constructor() {
    Qe(this, "mountEffect", () => {
      this.shouldMount && !this.didMount && this.ref.current !== null && (this.didMount = !0, this.mounted.resolve());
    });
    this.ref = {
      current: null
    }, this.mounted = null, this.didMount = !1, this.shouldMount = !1, this.setShouldMount = null;
  }
  /** React ref to the ripple instance */
  /** If the ripple component should be mounted */
  /** Promise that resolves when the ripple component is mounted */
  /** If the ripple component has been mounted */
  /** React state hook setter */
  static create() {
    return new e1();
  }
  static use() {
    const t = L3(e1.create).current, [n, i] = tt.useState(!1);
    return t.shouldMount = n, t.setShouldMount = i, tt.useEffect(t.mountEffect, [n]), t;
  }
  mount() {
    return this.mounted || (this.mounted = K9(), this.shouldMount = !0, this.setShouldMount(this.shouldMount)), this.mounted;
  }
  /* Ripple API */
  start(...t) {
    this.mount().then(() => {
      var n;
      return (n = this.ref.current) == null ? void 0 : n.start(...t);
    });
  }
  stop(...t) {
    this.mount().then(() => {
      var n;
      return (n = this.ref.current) == null ? void 0 : n.stop(...t);
    });
  }
  pulsate(...t) {
    this.mount().then(() => {
      var n;
      return (n = this.ref.current) == null ? void 0 : n.pulsate(...t);
    });
  }
}
function H9() {
  return e1.use();
}
function K9() {
  let e, t;
  const n = new Promise((i, s) => {
    e = i, t = s;
  });
  return n.resolve = e, n.reject = t, n;
}
function Y9(e) {
  const {
    className: t,
    classes: n,
    pulsate: i = !1,
    rippleX: s,
    rippleY: o,
    rippleSize: u,
    in: h,
    onExited: f,
    timeout: p
  } = e, [g, v] = tt.useState(!1), x = Fe(t, n.ripple, n.rippleVisible, i && n.ripplePulsate), b = {
    width: u,
    height: u,
    top: -(u / 2) + o,
    left: -(u / 2) + s
  }, _ = Fe(n.child, g && n.childLeaving, i && n.childPulsate);
  return !h && !g && v(!0), tt.useEffect(() => {
    if (!h && f != null) {
      const T = setTimeout(f, p);
      return () => {
        clearTimeout(T);
      };
    }
  }, [f, h, p]), /* @__PURE__ */ J.jsx("span", {
    className: x,
    style: b,
    children: /* @__PURE__ */ J.jsx("span", {
      className: _
    })
  });
}
const Ao = zn("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]), Wb = 550, X9 = 80, W9 = Lg`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`, $9 = Lg`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`, Q9 = Lg`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`, Z9 = Ne("span", {
  name: "MuiTouchRipple",
  slot: "Root"
})({
  overflow: "hidden",
  pointerEvents: "none",
  position: "absolute",
  zIndex: 0,
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  borderRadius: "inherit"
}), J9 = Ne(Y9, {
  name: "MuiTouchRipple",
  slot: "Ripple"
})`
  opacity: 0;
  position: absolute;

  &.${Ao.rippleVisible} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${W9};
    animation-duration: ${Wb}ms;
    animation-timing-function: ${({
  theme: e
}) => e.transitions.easing.easeInOut};
  }

  &.${Ao.ripplePulsate} {
    animation-duration: ${({
  theme: e
}) => e.transitions.duration.shorter}ms;
  }

  & .${Ao.child} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${Ao.childLeaving} {
    opacity: 0;
    animation-name: ${$9};
    animation-duration: ${Wb}ms;
    animation-timing-function: ${({
  theme: e
}) => e.transitions.easing.easeInOut};
  }

  & .${Ao.childPulsate} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${Q9};
    animation-duration: 2500ms;
    animation-timing-function: ${({
  theme: e
}) => e.transitions.easing.easeInOut};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`, t7 = /* @__PURE__ */ tt.forwardRef(function(t, n) {
  const i = In({
    props: t,
    name: "MuiTouchRipple"
  }), {
    center: s = !1,
    classes: o = {},
    className: u,
    ...h
  } = i, [f, p] = tt.useState([]), g = tt.useRef(0), v = tt.useRef(null);
  tt.useEffect(() => {
    v.current && (v.current(), v.current = null);
  }, [f]);
  const x = tt.useRef(!1), b = jf(), _ = tt.useRef(null), T = tt.useRef(null), A = tt.useCallback((R) => {
    const {
      pulsate: N,
      rippleX: U,
      rippleY: q,
      rippleSize: j,
      cb: V
    } = R;
    p((D) => [...D, /* @__PURE__ */ J.jsx(J9, {
      classes: {
        ripple: Fe(o.ripple, Ao.ripple),
        rippleVisible: Fe(o.rippleVisible, Ao.rippleVisible),
        ripplePulsate: Fe(o.ripplePulsate, Ao.ripplePulsate),
        child: Fe(o.child, Ao.child),
        childLeaving: Fe(o.childLeaving, Ao.childLeaving),
        childPulsate: Fe(o.childPulsate, Ao.childPulsate)
      },
      timeout: Wb,
      pulsate: N,
      rippleX: U,
      rippleY: q,
      rippleSize: j
    }, g.current)]), g.current += 1, v.current = V;
  }, [o]), O = tt.useCallback((R = {}, N = {}, U = () => {
  }) => {
    const {
      pulsate: q = !1,
      center: j = s || N.pulsate,
      fakeElement: V = !1
      // For test purposes
    } = N;
    if ((R == null ? void 0 : R.type) === "mousedown" && x.current) {
      x.current = !1;
      return;
    }
    (R == null ? void 0 : R.type) === "touchstart" && (x.current = !0);
    const D = V ? null : T.current, G = D ? D.getBoundingClientRect() : {
      width: 0,
      height: 0,
      left: 0,
      top: 0
    };
    let W, P, H;
    if (j || R === void 0 || R.clientX === 0 && R.clientY === 0 || !R.clientX && !R.touches)
      W = Math.round(G.width / 2), P = Math.round(G.height / 2);
    else {
      const {
        clientX: I,
        clientY: K
      } = R.touches && R.touches.length > 0 ? R.touches[0] : R;
      W = Math.round(I - G.left), P = Math.round(K - G.top);
    }
    if (j)
      H = Math.sqrt((2 * G.width ** 2 + G.height ** 2) / 3), H % 2 === 0 && (H += 1);
    else {
      const I = Math.max(Math.abs((D ? D.clientWidth : 0) - W), W) * 2 + 2, K = Math.max(Math.abs((D ? D.clientHeight : 0) - P), P) * 2 + 2;
      H = Math.sqrt(I ** 2 + K ** 2);
    }
    R != null && R.touches ? _.current === null && (_.current = () => {
      A({
        pulsate: q,
        rippleX: W,
        rippleY: P,
        rippleSize: H,
        cb: U
      });
    }, b.start(X9, () => {
      _.current && (_.current(), _.current = null);
    })) : A({
      pulsate: q,
      rippleX: W,
      rippleY: P,
      rippleSize: H,
      cb: U
    });
  }, [s, A, b]), M = tt.useCallback(() => {
    O({}, {
      pulsate: !0
    });
  }, [O]), E = tt.useCallback((R, N) => {
    if (b.clear(), (R == null ? void 0 : R.type) === "touchend" && _.current) {
      _.current(), _.current = null, b.start(0, () => {
        E(R, N);
      });
      return;
    }
    _.current = null, p((U) => U.length > 0 ? U.slice(1) : U), v.current = N;
  }, [b]);
  return tt.useImperativeHandle(n, () => ({
    pulsate: M,
    start: O,
    stop: E
  }), [M, O, E]), /* @__PURE__ */ J.jsx(Z9, {
    className: Fe(Ao.root, o.root, u),
    ref: T,
    ...h,
    children: /* @__PURE__ */ J.jsx(I2, {
      component: null,
      exit: !0,
      children: f
    })
  });
});
function e7(e) {
  return Un("MuiButtonBase", e);
}
const n7 = zn("MuiButtonBase", ["root", "disabled", "focusVisible"]), i7 = (e) => {
  const {
    disabled: t,
    focusVisible: n,
    focusVisibleClassName: i,
    classes: s
  } = e, u = jn({
    root: ["root", t && "disabled", n && "focusVisible"]
  }, e7, s);
  return n && i && (u.root += ` ${i}`), u;
}, r7 = Ne("button", {
  name: "MuiButtonBase",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  position: "relative",
  boxSizing: "border-box",
  WebkitTapHighlightColor: "transparent",
  backgroundColor: "transparent",
  // Reset default value
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  border: 0,
  margin: 0,
  // Remove the margin in Safari
  borderRadius: 0,
  padding: 0,
  // Remove the padding in Firefox
  cursor: "pointer",
  userSelect: "none",
  verticalAlign: "middle",
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // Reset
  textDecoration: "none",
  // So we take precedent over the style of a native <a /> element.
  color: "inherit",
  "&::-moz-focus-inner": {
    borderStyle: "none"
    // Remove Firefox dotted outline.
  },
  [`&.${n7.disabled}`]: {
    pointerEvents: "none",
    // Disable link interactions
    cursor: "default"
  },
  "@media print": {
    colorAdjust: "exact"
  }
}), I1 = /* @__PURE__ */ tt.forwardRef(function(t, n) {
  const i = In({
    props: t,
    name: "MuiButtonBase"
  }), {
    action: s,
    centerRipple: o = !1,
    children: u,
    className: h,
    component: f = "button",
    disabled: p = !1,
    disableRipple: g = !1,
    disableTouchRipple: v = !1,
    focusRipple: x = !1,
    focusVisibleClassName: b,
    LinkComponent: _ = "a",
    onBlur: T,
    onClick: A,
    onContextMenu: O,
    onDragLeave: M,
    onFocus: E,
    onFocusVisible: R,
    onKeyDown: N,
    onKeyUp: U,
    onMouseDown: q,
    onMouseLeave: j,
    onMouseUp: V,
    onTouchEnd: D,
    onTouchMove: G,
    onTouchStart: W,
    tabIndex: P = 0,
    TouchRippleProps: H,
    touchRippleRef: I,
    type: K,
    ...Q
  } = i, it = tt.useRef(null), nt = H9(), X = jr(nt.ref, I), [rt, vt] = tt.useState(!1);
  p && rt && vt(!1), tt.useImperativeHandle(s, () => ({
    focusVisible: () => {
      vt(!0), it.current.focus();
    }
  }), []);
  const ct = nt.shouldMount && !g && !p;
  tt.useEffect(() => {
    rt && x && !g && nt.pulsate();
  }, [g, x, rt, nt]);
  const dt = wu(nt, "start", q, v), ht = wu(nt, "stop", O, v), Et = wu(nt, "stop", M, v), ot = wu(nt, "stop", V, v), lt = wu(nt, "stop", (oe) => {
    rt && oe.preventDefault(), j && j(oe);
  }, v), ft = wu(nt, "start", W, v), Tt = wu(nt, "stop", D, v), Bt = wu(nt, "stop", G, v), Ot = wu(nt, "stop", (oe) => {
    Yf(oe.target) || vt(!1), T && T(oe);
  }, !1), ie = Oo((oe) => {
    it.current || (it.current = oe.currentTarget), Yf(oe.target) && (vt(!0), R && R(oe)), E && E(oe);
  }), ce = () => {
    const oe = it.current;
    return f && f !== "button" && !(oe.tagName === "A" && oe.href);
  }, Ut = Oo((oe) => {
    x && !oe.repeat && rt && oe.key === " " && nt.stop(oe, () => {
      nt.start(oe);
    }), oe.target === oe.currentTarget && ce() && oe.key === " " && oe.preventDefault(), N && N(oe), oe.target === oe.currentTarget && ce() && oe.key === "Enter" && !p && (oe.preventDefault(), A && A(oe));
  }), se = Oo((oe) => {
    x && oe.key === " " && rt && !oe.defaultPrevented && nt.stop(oe, () => {
      nt.pulsate(oe);
    }), U && U(oe), A && oe.target === oe.currentTarget && ce() && oe.key === " " && !oe.defaultPrevented && A(oe);
  });
  let re = f;
  re === "button" && (Q.href || Q.to) && (re = _);
  const ue = {};
  re === "button" ? (ue.type = K === void 0 ? "button" : K, ue.disabled = p) : (!Q.href && !Q.to && (ue.role = "button"), p && (ue["aria-disabled"] = p));
  const Ae = jr(n, it), ve = {
    ...i,
    centerRipple: o,
    component: f,
    disabled: p,
    disableRipple: g,
    disableTouchRipple: v,
    focusRipple: x,
    tabIndex: P,
    focusVisible: rt
  }, Re = i7(ve);
  return /* @__PURE__ */ J.jsxs(r7, {
    as: re,
    className: Fe(Re.root, h),
    ownerState: ve,
    onBlur: Ot,
    onClick: A,
    onContextMenu: ht,
    onFocus: ie,
    onKeyDown: Ut,
    onKeyUp: se,
    onMouseDown: dt,
    onMouseLeave: lt,
    onMouseUp: ot,
    onDragLeave: Et,
    onTouchEnd: Tt,
    onTouchMove: Bt,
    onTouchStart: ft,
    ref: Ae,
    tabIndex: p ? -1 : P,
    type: K,
    ...ue,
    ...Q,
    children: [u, ct ? /* @__PURE__ */ J.jsx(t7, {
      ref: X,
      center: o,
      ...H
    }) : null]
  });
});
function wu(e, t, n, i = !1) {
  return Oo((s) => (n && n(s), i || e[t](s), !0));
}
function a7(e) {
  return typeof e.main == "string";
}
function s7(e, t = []) {
  if (!a7(e))
    return !1;
  for (const n of t)
    if (!e.hasOwnProperty(n) || typeof e[n] != "string")
      return !1;
  return !0;
}
function Qs(e = []) {
  return ([, t]) => t && s7(t, e);
}
function o7(e) {
  return Un("MuiCircularProgress", e);
}
zn("MuiCircularProgress", ["root", "determinate", "indeterminate", "colorPrimary", "colorSecondary", "svg", "circle", "circleDeterminate", "circleIndeterminate", "circleDisableShrink"]);
const Ed = 44, $b = Lg`
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
`, Qb = Lg`
  0% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: 0;
  }

  50% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -15px;
  }

  100% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: -126px;
  }
`, l7 = typeof $b != "string" ? A2`
        animation: ${$b} 1.4s linear infinite;
      ` : null, c7 = typeof Qb != "string" ? A2`
        animation: ${Qb} 1.4s ease-in-out infinite;
      ` : null, u7 = (e) => {
  const {
    classes: t,
    variant: n,
    color: i,
    disableShrink: s
  } = e, o = {
    root: ["root", n, `color${Ue(i)}`],
    svg: ["svg"],
    circle: ["circle", `circle${Ue(n)}`, s && "circleDisableShrink"]
  };
  return jn(o, o7, t);
}, d7 = Ne("span", {
  name: "MuiCircularProgress",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, t[n.variant], t[`color${Ue(n.color)}`]];
  }
})(En(({
  theme: e
}) => ({
  display: "inline-block",
  variants: [{
    props: {
      variant: "determinate"
    },
    style: {
      transition: e.transitions.create("transform")
    }
  }, {
    props: {
      variant: "indeterminate"
    },
    style: l7 || {
      animation: `${$b} 1.4s linear infinite`
    }
  }, ...Object.entries(e.palette).filter(Qs()).map(([t]) => ({
    props: {
      color: t
    },
    style: {
      color: (e.vars || e).palette[t].main
    }
  }))]
}))), h7 = Ne("svg", {
  name: "MuiCircularProgress",
  slot: "Svg",
  overridesResolver: (e, t) => t.svg
})({
  display: "block"
  // Keeps the progress centered
}), f7 = Ne("circle", {
  name: "MuiCircularProgress",
  slot: "Circle",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.circle, t[`circle${Ue(n.variant)}`], n.disableShrink && t.circleDisableShrink];
  }
})(En(({
  theme: e
}) => ({
  stroke: "currentColor",
  variants: [{
    props: {
      variant: "determinate"
    },
    style: {
      transition: e.transitions.create("stroke-dashoffset")
    }
  }, {
    props: {
      variant: "indeterminate"
    },
    style: {
      // Some default value that looks fine waiting for the animation to kicks in.
      strokeDasharray: "80px, 200px",
      strokeDashoffset: 0
      // Add the unit to fix a Edge 16 and below bug.
    }
  }, {
    props: ({
      ownerState: t
    }) => t.variant === "indeterminate" && !t.disableShrink,
    style: c7 || {
      // At runtime for Pigment CSS, `bufferAnimation` will be null and the generated keyframe will be used.
      animation: `${Qb} 1.4s ease-in-out infinite`
    }
  }]
}))), sT = /* @__PURE__ */ tt.forwardRef(function(t, n) {
  const i = In({
    props: t,
    name: "MuiCircularProgress"
  }), {
    className: s,
    color: o = "primary",
    disableShrink: u = !1,
    size: h = 40,
    style: f,
    thickness: p = 3.6,
    value: g = 0,
    variant: v = "indeterminate",
    ...x
  } = i, b = {
    ...i,
    color: o,
    disableShrink: u,
    size: h,
    thickness: p,
    value: g,
    variant: v
  }, _ = u7(b), T = {}, A = {}, O = {};
  if (v === "determinate") {
    const M = 2 * Math.PI * ((Ed - p) / 2);
    T.strokeDasharray = M.toFixed(3), O["aria-valuenow"] = Math.round(g), T.strokeDashoffset = `${((100 - g) / 100 * M).toFixed(3)}px`, A.transform = "rotate(-90deg)";
  }
  return /* @__PURE__ */ J.jsx(d7, {
    className: Fe(_.root, s),
    style: {
      width: h,
      height: h,
      ...A,
      ...f
    },
    ownerState: b,
    ref: n,
    role: "progressbar",
    ...O,
    ...x,
    children: /* @__PURE__ */ J.jsx(h7, {
      className: _.svg,
      ownerState: b,
      viewBox: `${Ed / 2} ${Ed / 2} ${Ed} ${Ed}`,
      children: /* @__PURE__ */ J.jsx(f7, {
        className: _.circle,
        style: T,
        ownerState: b,
        cx: Ed,
        cy: Ed,
        r: (Ed - p) / 2,
        fill: "none",
        strokeWidth: p
      })
    })
  });
});
function p7(e) {
  return Un("MuiIconButton", e);
}
const x5 = zn("MuiIconButton", ["root", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "edgeStart", "edgeEnd", "sizeSmall", "sizeMedium", "sizeLarge", "loading", "loadingIndicator", "loadingWrapper"]), m7 = (e) => {
  const {
    classes: t,
    disabled: n,
    color: i,
    edge: s,
    size: o,
    loading: u
  } = e, h = {
    root: ["root", u && "loading", n && "disabled", i !== "default" && `color${Ue(i)}`, s && `edge${Ue(s)}`, `size${Ue(o)}`],
    loadingIndicator: ["loadingIndicator"],
    loadingWrapper: ["loadingWrapper"]
  };
  return jn(h, p7, t);
}, g7 = Ne(I1, {
  name: "MuiIconButton",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.loading && t.loading, n.color !== "default" && t[`color${Ue(n.color)}`], n.edge && t[`edge${Ue(n.edge)}`], t[`size${Ue(n.size)}`]];
  }
})(En(({
  theme: e
}) => ({
  textAlign: "center",
  flex: "0 0 auto",
  fontSize: e.typography.pxToRem(24),
  padding: 8,
  borderRadius: "50%",
  color: (e.vars || e).palette.action.active,
  transition: e.transitions.create("background-color", {
    duration: e.transitions.duration.shortest
  }),
  variants: [{
    props: (t) => !t.disableRipple,
    style: {
      "--IconButton-hoverBg": e.vars ? `rgba(${e.vars.palette.action.activeChannel} / ${e.vars.palette.action.hoverOpacity})` : xi(e.palette.action.active, e.palette.action.hoverOpacity),
      "&:hover": {
        backgroundColor: "var(--IconButton-hoverBg)",
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    }
  }, {
    props: {
      edge: "start"
    },
    style: {
      marginLeft: -12
    }
  }, {
    props: {
      edge: "start",
      size: "small"
    },
    style: {
      marginLeft: -3
    }
  }, {
    props: {
      edge: "end"
    },
    style: {
      marginRight: -12
    }
  }, {
    props: {
      edge: "end",
      size: "small"
    },
    style: {
      marginRight: -3
    }
  }]
})), En(({
  theme: e
}) => ({
  variants: [{
    props: {
      color: "inherit"
    },
    style: {
      color: "inherit"
    }
  }, ...Object.entries(e.palette).filter(Qs()).map(([t]) => ({
    props: {
      color: t
    },
    style: {
      color: (e.vars || e).palette[t].main
    }
  })), ...Object.entries(e.palette).filter(Qs()).map(([t]) => ({
    props: {
      color: t
    },
    style: {
      "--IconButton-hoverBg": e.vars ? `rgba(${(e.vars || e).palette[t].mainChannel} / ${e.vars.palette.action.hoverOpacity})` : xi((e.vars || e).palette[t].main, e.palette.action.hoverOpacity)
    }
  })), {
    props: {
      size: "small"
    },
    style: {
      padding: 5,
      fontSize: e.typography.pxToRem(18)
    }
  }, {
    props: {
      size: "large"
    },
    style: {
      padding: 12,
      fontSize: e.typography.pxToRem(28)
    }
  }],
  [`&.${x5.disabled}`]: {
    backgroundColor: "transparent",
    color: (e.vars || e).palette.action.disabled
  },
  [`&.${x5.loading}`]: {
    color: "transparent"
  }
}))), y7 = Ne("span", {
  name: "MuiIconButton",
  slot: "LoadingIndicator",
  overridesResolver: (e, t) => t.loadingIndicator
})(({
  theme: e
}) => ({
  display: "none",
  position: "absolute",
  visibility: "visible",
  top: "50%",
  left: "50%",
  transform: "translate(-50%, -50%)",
  color: (e.vars || e).palette.action.disabled,
  variants: [{
    props: {
      loading: !0
    },
    style: {
      display: "flex"
    }
  }]
})), Od = /* @__PURE__ */ tt.forwardRef(function(t, n) {
  const i = In({
    props: t,
    name: "MuiIconButton"
  }), {
    edge: s = !1,
    children: o,
    className: u,
    color: h = "default",
    disabled: f = !1,
    disableFocusRipple: p = !1,
    size: g = "medium",
    id: v,
    loading: x = null,
    loadingIndicator: b,
    ..._
  } = i, T = qg(v), A = b ?? /* @__PURE__ */ J.jsx(sT, {
    "aria-labelledby": T,
    color: "inherit",
    size: 16
  }), O = {
    ...i,
    edge: s,
    color: h,
    disabled: f,
    disableFocusRipple: p,
    loading: x,
    loadingIndicator: A,
    size: g
  }, M = m7(O);
  return /* @__PURE__ */ J.jsxs(g7, {
    id: x ? T : v,
    className: Fe(M.root, u),
    centerRipple: !0,
    focusRipple: !p,
    disabled: f || x,
    ref: n,
    ..._,
    ownerState: O,
    children: [typeof x == "boolean" && // use plain HTML span to minimize the runtime overhead
    /* @__PURE__ */ J.jsx("span", {
      className: M.loadingWrapper,
      style: {
        display: "contents"
      },
      children: /* @__PURE__ */ J.jsx(y7, {
        className: M.loadingIndicator,
        ownerState: O,
        children: x && A
      })
    }), o]
  });
});
function v7(e) {
  return Un("MuiTypography", e);
}
const T5 = zn("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]), b7 = {
  primary: !0,
  secondary: !0,
  error: !0,
  info: !0,
  success: !0,
  warning: !0,
  textPrimary: !0,
  textSecondary: !0,
  textDisabled: !0
}, _7 = R9(), S7 = (e) => {
  const {
    align: t,
    gutterBottom: n,
    noWrap: i,
    paragraph: s,
    variant: o,
    classes: u
  } = e, h = {
    root: ["root", o, e.align !== "inherit" && `align${Ue(t)}`, n && "gutterBottom", i && "noWrap", s && "paragraph"]
  };
  return jn(h, v7, u);
}, x7 = Ne("span", {
  name: "MuiTypography",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.variant && t[n.variant], n.align !== "inherit" && t[`align${Ue(n.align)}`], n.noWrap && t.noWrap, n.gutterBottom && t.gutterBottom, n.paragraph && t.paragraph];
  }
})(En(({
  theme: e
}) => {
  var t;
  return {
    margin: 0,
    variants: [{
      props: {
        variant: "inherit"
      },
      style: {
        // Some elements, like <button> on Chrome have default font that doesn't inherit, reset this.
        font: "inherit",
        lineHeight: "inherit",
        letterSpacing: "inherit"
      }
    }, ...Object.entries(e.typography).filter(([n, i]) => n !== "inherit" && i && typeof i == "object").map(([n, i]) => ({
      props: {
        variant: n
      },
      style: i
    })), ...Object.entries(e.palette).filter(Qs()).map(([n]) => ({
      props: {
        color: n
      },
      style: {
        color: (e.vars || e).palette[n].main
      }
    })), ...Object.entries(((t = e.palette) == null ? void 0 : t.text) || {}).filter(([, n]) => typeof n == "string").map(([n]) => ({
      props: {
        color: `text${Ue(n)}`
      },
      style: {
        color: (e.vars || e).palette.text[n]
      }
    })), {
      props: ({
        ownerState: n
      }) => n.align !== "inherit",
      style: {
        textAlign: "var(--Typography-textAlign)"
      }
    }, {
      props: ({
        ownerState: n
      }) => n.noWrap,
      style: {
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap"
      }
    }, {
      props: ({
        ownerState: n
      }) => n.gutterBottom,
      style: {
        marginBottom: "0.35em"
      }
    }, {
      props: ({
        ownerState: n
      }) => n.paragraph,
      style: {
        marginBottom: 16
      }
    }]
  };
})), C5 = {
  h1: "h1",
  h2: "h2",
  h3: "h3",
  h4: "h4",
  h5: "h5",
  h6: "h6",
  subtitle1: "h6",
  subtitle2: "h6",
  body1: "p",
  body2: "p",
  inherit: "p"
}, Wa = /* @__PURE__ */ tt.forwardRef(function(t, n) {
  const {
    color: i,
    ...s
  } = In({
    props: t,
    name: "MuiTypography"
  }), o = !b7[i], u = _7({
    ...s,
    ...o && {
      color: i
    }
  }), {
    align: h = "inherit",
    className: f,
    component: p,
    gutterBottom: g = !1,
    noWrap: v = !1,
    paragraph: x = !1,
    variant: b = "body1",
    variantMapping: _ = C5,
    ...T
  } = u, A = {
    ...u,
    align: h,
    color: i,
    className: f,
    component: p,
    gutterBottom: g,
    noWrap: v,
    paragraph: x,
    variant: b,
    variantMapping: _
  }, O = p || (x ? "p" : _[b] || C5[b]) || "span", M = S7(A);
  return /* @__PURE__ */ J.jsx(x7, {
    as: O,
    ref: n,
    className: Fe(M.root, f),
    ...T,
    ownerState: A,
    style: {
      ...h !== "inherit" && {
        "--Typography-textAlign": h
      },
      ...T.style
    }
  });
});
var Ss = "top", Do = "bottom", Bo = "right", xs = "left", F2 = "auto", Gg = [Ss, Do, Bo, xs], Xf = "start", Og = "end", T7 = "clippingParents", oT = "viewport", pm = "popper", C7 = "reference", w5 = /* @__PURE__ */ Gg.reduce(function(e, t) {
  return e.concat([t + "-" + Xf, t + "-" + Og]);
}, []), lT = /* @__PURE__ */ [].concat(Gg, [F2]).reduce(function(e, t) {
  return e.concat([t, t + "-" + Xf, t + "-" + Og]);
}, []), w7 = "beforeRead", E7 = "read", A7 = "afterRead", M7 = "beforeMain", R7 = "main", O7 = "afterMain", N7 = "beforeWrite", k7 = "write", D7 = "afterWrite", B7 = [w7, E7, A7, M7, R7, O7, N7, k7, D7];
function Mc(e) {
  return e ? (e.nodeName || "").toLowerCase() : null;
}
function Zs(e) {
  if (e == null)
    return window;
  if (e.toString() !== "[object Window]") {
    var t = e.ownerDocument;
    return t && t.defaultView || window;
  }
  return e;
}
function zh(e) {
  var t = Zs(e).Element;
  return e instanceof t || e instanceof Element;
}
function No(e) {
  var t = Zs(e).HTMLElement;
  return e instanceof t || e instanceof HTMLElement;
}
function q2(e) {
  if (typeof ShadowRoot > "u")
    return !1;
  var t = Zs(e).ShadowRoot;
  return e instanceof t || e instanceof ShadowRoot;
}
function z7(e) {
  var t = e.state;
  Object.keys(t.elements).forEach(function(n) {
    var i = t.styles[n] || {}, s = t.attributes[n] || {}, o = t.elements[n];
    !No(o) || !Mc(o) || (Object.assign(o.style, i), Object.keys(s).forEach(function(u) {
      var h = s[u];
      h === !1 ? o.removeAttribute(u) : o.setAttribute(u, h === !0 ? "" : h);
    }));
  });
}
function P7(e) {
  var t = e.state, n = {
    popper: {
      position: t.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(t.elements.popper.style, n.popper), t.styles = n, t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow), function() {
    Object.keys(t.elements).forEach(function(i) {
      var s = t.elements[i], o = t.attributes[i] || {}, u = Object.keys(t.styles.hasOwnProperty(i) ? t.styles[i] : n[i]), h = u.reduce(function(f, p) {
        return f[p] = "", f;
      }, {});
      !No(s) || !Mc(s) || (Object.assign(s.style, h), Object.keys(o).forEach(function(f) {
        s.removeAttribute(f);
      }));
    });
  };
}
const U7 = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: z7,
  effect: P7,
  requires: ["computeStyles"]
};
function wc(e) {
  return e.split("-")[0];
}
var kh = Math.max, n1 = Math.min, Wf = Math.round;
function Zb() {
  var e = navigator.userAgentData;
  return e != null && e.brands && Array.isArray(e.brands) ? e.brands.map(function(t) {
    return t.brand + "/" + t.version;
  }).join(" ") : navigator.userAgent;
}
function cT() {
  return !/^((?!chrome|android).)*safari/i.test(Zb());
}
function $f(e, t, n) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  var i = e.getBoundingClientRect(), s = 1, o = 1;
  t && No(e) && (s = e.offsetWidth > 0 && Wf(i.width) / e.offsetWidth || 1, o = e.offsetHeight > 0 && Wf(i.height) / e.offsetHeight || 1);
  var u = zh(e) ? Zs(e) : window, h = u.visualViewport, f = !cT() && n, p = (i.left + (f && h ? h.offsetLeft : 0)) / s, g = (i.top + (f && h ? h.offsetTop : 0)) / o, v = i.width / s, x = i.height / o;
  return {
    width: v,
    height: x,
    top: g,
    right: p + v,
    bottom: g + x,
    left: p,
    x: p,
    y: g
  };
}
function G2(e) {
  var t = $f(e), n = e.offsetWidth, i = e.offsetHeight;
  return Math.abs(t.width - n) <= 1 && (n = t.width), Math.abs(t.height - i) <= 1 && (i = t.height), {
    x: e.offsetLeft,
    y: e.offsetTop,
    width: n,
    height: i
  };
}
function uT(e, t) {
  var n = t.getRootNode && t.getRootNode();
  if (e.contains(t))
    return !0;
  if (n && q2(n)) {
    var i = t;
    do {
      if (i && e.isSameNode(i))
        return !0;
      i = i.parentNode || i.host;
    } while (i);
  }
  return !1;
}
function Uu(e) {
  return Zs(e).getComputedStyle(e);
}
function j7(e) {
  return ["table", "td", "th"].indexOf(Mc(e)) >= 0;
}
function Ld(e) {
  return ((zh(e) ? e.ownerDocument : (
    // $FlowFixMe[prop-missing]
    e.document
  )) || window.document).documentElement;
}
function F1(e) {
  return Mc(e) === "html" ? e : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    e.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    e.parentNode || // DOM Element detected
    (q2(e) ? e.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    Ld(e)
  );
}
function E5(e) {
  return !No(e) || // https://github.com/popperjs/popper-core/issues/837
  Uu(e).position === "fixed" ? null : e.offsetParent;
}
function L7(e) {
  var t = /firefox/i.test(Zb()), n = /Trident/i.test(Zb());
  if (n && No(e)) {
    var i = Uu(e);
    if (i.position === "fixed")
      return null;
  }
  var s = F1(e);
  for (q2(s) && (s = s.host); No(s) && ["html", "body"].indexOf(Mc(s)) < 0; ) {
    var o = Uu(s);
    if (o.transform !== "none" || o.perspective !== "none" || o.contain === "paint" || ["transform", "perspective"].indexOf(o.willChange) !== -1 || t && o.willChange === "filter" || t && o.filter && o.filter !== "none")
      return s;
    s = s.parentNode;
  }
  return null;
}
function Hg(e) {
  for (var t = Zs(e), n = E5(e); n && j7(n) && Uu(n).position === "static"; )
    n = E5(n);
  return n && (Mc(n) === "html" || Mc(n) === "body" && Uu(n).position === "static") ? t : n || L7(e) || t;
}
function H2(e) {
  return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y";
}
function bg(e, t, n) {
  return kh(e, n1(t, n));
}
function V7(e, t, n) {
  var i = bg(e, t, n);
  return i > n ? n : i;
}
function dT() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function hT(e) {
  return Object.assign({}, dT(), e);
}
function fT(e, t) {
  return t.reduce(function(n, i) {
    return n[i] = e, n;
  }, {});
}
var I7 = function(t, n) {
  return t = typeof t == "function" ? t(Object.assign({}, n.rects, {
    placement: n.placement
  })) : t, hT(typeof t != "number" ? t : fT(t, Gg));
};
function F7(e) {
  var t, n = e.state, i = e.name, s = e.options, o = n.elements.arrow, u = n.modifiersData.popperOffsets, h = wc(n.placement), f = H2(h), p = [xs, Bo].indexOf(h) >= 0, g = p ? "height" : "width";
  if (!(!o || !u)) {
    var v = I7(s.padding, n), x = G2(o), b = f === "y" ? Ss : xs, _ = f === "y" ? Do : Bo, T = n.rects.reference[g] + n.rects.reference[f] - u[f] - n.rects.popper[g], A = u[f] - n.rects.reference[f], O = Hg(o), M = O ? f === "y" ? O.clientHeight || 0 : O.clientWidth || 0 : 0, E = T / 2 - A / 2, R = v[b], N = M - x[g] - v[_], U = M / 2 - x[g] / 2 + E, q = bg(R, U, N), j = f;
    n.modifiersData[i] = (t = {}, t[j] = q, t.centerOffset = q - U, t);
  }
}
function q7(e) {
  var t = e.state, n = e.options, i = n.element, s = i === void 0 ? "[data-popper-arrow]" : i;
  s != null && (typeof s == "string" && (s = t.elements.popper.querySelector(s), !s) || uT(t.elements.popper, s) && (t.elements.arrow = s));
}
const G7 = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: F7,
  effect: q7,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function Qf(e) {
  return e.split("-")[1];
}
var H7 = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function K7(e, t) {
  var n = e.x, i = e.y, s = t.devicePixelRatio || 1;
  return {
    x: Wf(n * s) / s || 0,
    y: Wf(i * s) / s || 0
  };
}
function A5(e) {
  var t, n = e.popper, i = e.popperRect, s = e.placement, o = e.variation, u = e.offsets, h = e.position, f = e.gpuAcceleration, p = e.adaptive, g = e.roundOffsets, v = e.isFixed, x = u.x, b = x === void 0 ? 0 : x, _ = u.y, T = _ === void 0 ? 0 : _, A = typeof g == "function" ? g({
    x: b,
    y: T
  }) : {
    x: b,
    y: T
  };
  b = A.x, T = A.y;
  var O = u.hasOwnProperty("x"), M = u.hasOwnProperty("y"), E = xs, R = Ss, N = window;
  if (p) {
    var U = Hg(n), q = "clientHeight", j = "clientWidth";
    if (U === Zs(n) && (U = Ld(n), Uu(U).position !== "static" && h === "absolute" && (q = "scrollHeight", j = "scrollWidth")), U = U, s === Ss || (s === xs || s === Bo) && o === Og) {
      R = Do;
      var V = v && U === N && N.visualViewport ? N.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        U[q]
      );
      T -= V - i.height, T *= f ? 1 : -1;
    }
    if (s === xs || (s === Ss || s === Do) && o === Og) {
      E = Bo;
      var D = v && U === N && N.visualViewport ? N.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        U[j]
      );
      b -= D - i.width, b *= f ? 1 : -1;
    }
  }
  var G = Object.assign({
    position: h
  }, p && H7), W = g === !0 ? K7({
    x: b,
    y: T
  }, Zs(n)) : {
    x: b,
    y: T
  };
  if (b = W.x, T = W.y, f) {
    var P;
    return Object.assign({}, G, (P = {}, P[R] = M ? "0" : "", P[E] = O ? "0" : "", P.transform = (N.devicePixelRatio || 1) <= 1 ? "translate(" + b + "px, " + T + "px)" : "translate3d(" + b + "px, " + T + "px, 0)", P));
  }
  return Object.assign({}, G, (t = {}, t[R] = M ? T + "px" : "", t[E] = O ? b + "px" : "", t.transform = "", t));
}
function Y7(e) {
  var t = e.state, n = e.options, i = n.gpuAcceleration, s = i === void 0 ? !0 : i, o = n.adaptive, u = o === void 0 ? !0 : o, h = n.roundOffsets, f = h === void 0 ? !0 : h, p = {
    placement: wc(t.placement),
    variation: Qf(t.placement),
    popper: t.elements.popper,
    popperRect: t.rects.popper,
    gpuAcceleration: s,
    isFixed: t.options.strategy === "fixed"
  };
  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, A5(Object.assign({}, p, {
    offsets: t.modifiersData.popperOffsets,
    position: t.options.strategy,
    adaptive: u,
    roundOffsets: f
  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, A5(Object.assign({}, p, {
    offsets: t.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: f
  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-placement": t.placement
  });
}
const X7 = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: Y7,
  data: {}
};
var Sy = {
  passive: !0
};
function W7(e) {
  var t = e.state, n = e.instance, i = e.options, s = i.scroll, o = s === void 0 ? !0 : s, u = i.resize, h = u === void 0 ? !0 : u, f = Zs(t.elements.popper), p = [].concat(t.scrollParents.reference, t.scrollParents.popper);
  return o && p.forEach(function(g) {
    g.addEventListener("scroll", n.update, Sy);
  }), h && f.addEventListener("resize", n.update, Sy), function() {
    o && p.forEach(function(g) {
      g.removeEventListener("scroll", n.update, Sy);
    }), h && f.removeEventListener("resize", n.update, Sy);
  };
}
const $7 = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: W7,
  data: {}
};
var Q7 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function Gy(e) {
  return e.replace(/left|right|bottom|top/g, function(t) {
    return Q7[t];
  });
}
var Z7 = {
  start: "end",
  end: "start"
};
function M5(e) {
  return e.replace(/start|end/g, function(t) {
    return Z7[t];
  });
}
function K2(e) {
  var t = Zs(e), n = t.pageXOffset, i = t.pageYOffset;
  return {
    scrollLeft: n,
    scrollTop: i
  };
}
function Y2(e) {
  return $f(Ld(e)).left + K2(e).scrollLeft;
}
function J7(e, t) {
  var n = Zs(e), i = Ld(e), s = n.visualViewport, o = i.clientWidth, u = i.clientHeight, h = 0, f = 0;
  if (s) {
    o = s.width, u = s.height;
    var p = cT();
    (p || !p && t === "fixed") && (h = s.offsetLeft, f = s.offsetTop);
  }
  return {
    width: o,
    height: u,
    x: h + Y2(e),
    y: f
  };
}
function tA(e) {
  var t, n = Ld(e), i = K2(e), s = (t = e.ownerDocument) == null ? void 0 : t.body, o = kh(n.scrollWidth, n.clientWidth, s ? s.scrollWidth : 0, s ? s.clientWidth : 0), u = kh(n.scrollHeight, n.clientHeight, s ? s.scrollHeight : 0, s ? s.clientHeight : 0), h = -i.scrollLeft + Y2(e), f = -i.scrollTop;
  return Uu(s || n).direction === "rtl" && (h += kh(n.clientWidth, s ? s.clientWidth : 0) - o), {
    width: o,
    height: u,
    x: h,
    y: f
  };
}
function X2(e) {
  var t = Uu(e), n = t.overflow, i = t.overflowX, s = t.overflowY;
  return /auto|scroll|overlay|hidden/.test(n + s + i);
}
function pT(e) {
  return ["html", "body", "#document"].indexOf(Mc(e)) >= 0 ? e.ownerDocument.body : No(e) && X2(e) ? e : pT(F1(e));
}
function _g(e, t) {
  var n;
  t === void 0 && (t = []);
  var i = pT(e), s = i === ((n = e.ownerDocument) == null ? void 0 : n.body), o = Zs(i), u = s ? [o].concat(o.visualViewport || [], X2(i) ? i : []) : i, h = t.concat(u);
  return s ? h : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    h.concat(_g(F1(u)))
  );
}
function Jb(e) {
  return Object.assign({}, e, {
    left: e.x,
    top: e.y,
    right: e.x + e.width,
    bottom: e.y + e.height
  });
}
function eA(e, t) {
  var n = $f(e, !1, t === "fixed");
  return n.top = n.top + e.clientTop, n.left = n.left + e.clientLeft, n.bottom = n.top + e.clientHeight, n.right = n.left + e.clientWidth, n.width = e.clientWidth, n.height = e.clientHeight, n.x = n.left, n.y = n.top, n;
}
function R5(e, t, n) {
  return t === oT ? Jb(J7(e, n)) : zh(t) ? eA(t, n) : Jb(tA(Ld(e)));
}
function nA(e) {
  var t = _g(F1(e)), n = ["absolute", "fixed"].indexOf(Uu(e).position) >= 0, i = n && No(e) ? Hg(e) : e;
  return zh(i) ? t.filter(function(s) {
    return zh(s) && uT(s, i) && Mc(s) !== "body";
  }) : [];
}
function iA(e, t, n, i) {
  var s = t === "clippingParents" ? nA(e) : [].concat(t), o = [].concat(s, [n]), u = o[0], h = o.reduce(function(f, p) {
    var g = R5(e, p, i);
    return f.top = kh(g.top, f.top), f.right = n1(g.right, f.right), f.bottom = n1(g.bottom, f.bottom), f.left = kh(g.left, f.left), f;
  }, R5(e, u, i));
  return h.width = h.right - h.left, h.height = h.bottom - h.top, h.x = h.left, h.y = h.top, h;
}
function mT(e) {
  var t = e.reference, n = e.element, i = e.placement, s = i ? wc(i) : null, o = i ? Qf(i) : null, u = t.x + t.width / 2 - n.width / 2, h = t.y + t.height / 2 - n.height / 2, f;
  switch (s) {
    case Ss:
      f = {
        x: u,
        y: t.y - n.height
      };
      break;
    case Do:
      f = {
        x: u,
        y: t.y + t.height
      };
      break;
    case Bo:
      f = {
        x: t.x + t.width,
        y: h
      };
      break;
    case xs:
      f = {
        x: t.x - n.width,
        y: h
      };
      break;
    default:
      f = {
        x: t.x,
        y: t.y
      };
  }
  var p = s ? H2(s) : null;
  if (p != null) {
    var g = p === "y" ? "height" : "width";
    switch (o) {
      case Xf:
        f[p] = f[p] - (t[g] / 2 - n[g] / 2);
        break;
      case Og:
        f[p] = f[p] + (t[g] / 2 - n[g] / 2);
        break;
    }
  }
  return f;
}
function Ng(e, t) {
  t === void 0 && (t = {});
  var n = t, i = n.placement, s = i === void 0 ? e.placement : i, o = n.strategy, u = o === void 0 ? e.strategy : o, h = n.boundary, f = h === void 0 ? T7 : h, p = n.rootBoundary, g = p === void 0 ? oT : p, v = n.elementContext, x = v === void 0 ? pm : v, b = n.altBoundary, _ = b === void 0 ? !1 : b, T = n.padding, A = T === void 0 ? 0 : T, O = hT(typeof A != "number" ? A : fT(A, Gg)), M = x === pm ? C7 : pm, E = e.rects.popper, R = e.elements[_ ? M : x], N = iA(zh(R) ? R : R.contextElement || Ld(e.elements.popper), f, g, u), U = $f(e.elements.reference), q = mT({
    reference: U,
    element: E,
    placement: s
  }), j = Jb(Object.assign({}, E, q)), V = x === pm ? j : U, D = {
    top: N.top - V.top + O.top,
    bottom: V.bottom - N.bottom + O.bottom,
    left: N.left - V.left + O.left,
    right: V.right - N.right + O.right
  }, G = e.modifiersData.offset;
  if (x === pm && G) {
    var W = G[s];
    Object.keys(D).forEach(function(P) {
      var H = [Bo, Do].indexOf(P) >= 0 ? 1 : -1, I = [Ss, Do].indexOf(P) >= 0 ? "y" : "x";
      D[P] += W[I] * H;
    });
  }
  return D;
}
function rA(e, t) {
  t === void 0 && (t = {});
  var n = t, i = n.placement, s = n.boundary, o = n.rootBoundary, u = n.padding, h = n.flipVariations, f = n.allowedAutoPlacements, p = f === void 0 ? lT : f, g = Qf(i), v = g ? h ? w5 : w5.filter(function(_) {
    return Qf(_) === g;
  }) : Gg, x = v.filter(function(_) {
    return p.indexOf(_) >= 0;
  });
  x.length === 0 && (x = v);
  var b = x.reduce(function(_, T) {
    return _[T] = Ng(e, {
      placement: T,
      boundary: s,
      rootBoundary: o,
      padding: u
    })[wc(T)], _;
  }, {});
  return Object.keys(b).sort(function(_, T) {
    return b[_] - b[T];
  });
}
function aA(e) {
  if (wc(e) === F2)
    return [];
  var t = Gy(e);
  return [M5(e), t, M5(t)];
}
function sA(e) {
  var t = e.state, n = e.options, i = e.name;
  if (!t.modifiersData[i]._skip) {
    for (var s = n.mainAxis, o = s === void 0 ? !0 : s, u = n.altAxis, h = u === void 0 ? !0 : u, f = n.fallbackPlacements, p = n.padding, g = n.boundary, v = n.rootBoundary, x = n.altBoundary, b = n.flipVariations, _ = b === void 0 ? !0 : b, T = n.allowedAutoPlacements, A = t.options.placement, O = wc(A), M = O === A, E = f || (M || !_ ? [Gy(A)] : aA(A)), R = [A].concat(E).reduce(function(dt, ht) {
      return dt.concat(wc(ht) === F2 ? rA(t, {
        placement: ht,
        boundary: g,
        rootBoundary: v,
        padding: p,
        flipVariations: _,
        allowedAutoPlacements: T
      }) : ht);
    }, []), N = t.rects.reference, U = t.rects.popper, q = /* @__PURE__ */ new Map(), j = !0, V = R[0], D = 0; D < R.length; D++) {
      var G = R[D], W = wc(G), P = Qf(G) === Xf, H = [Ss, Do].indexOf(W) >= 0, I = H ? "width" : "height", K = Ng(t, {
        placement: G,
        boundary: g,
        rootBoundary: v,
        altBoundary: x,
        padding: p
      }), Q = H ? P ? Bo : xs : P ? Do : Ss;
      N[I] > U[I] && (Q = Gy(Q));
      var it = Gy(Q), nt = [];
      if (o && nt.push(K[W] <= 0), h && nt.push(K[Q] <= 0, K[it] <= 0), nt.every(function(dt) {
        return dt;
      })) {
        V = G, j = !1;
        break;
      }
      q.set(G, nt);
    }
    if (j)
      for (var X = _ ? 3 : 1, rt = function(ht) {
        var Et = R.find(function(ot) {
          var lt = q.get(ot);
          if (lt)
            return lt.slice(0, ht).every(function(ft) {
              return ft;
            });
        });
        if (Et)
          return V = Et, "break";
      }, vt = X; vt > 0; vt--) {
        var ct = rt(vt);
        if (ct === "break") break;
      }
    t.placement !== V && (t.modifiersData[i]._skip = !0, t.placement = V, t.reset = !0);
  }
}
const oA = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: sA,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function O5(e, t, n) {
  return n === void 0 && (n = {
    x: 0,
    y: 0
  }), {
    top: e.top - t.height - n.y,
    right: e.right - t.width + n.x,
    bottom: e.bottom - t.height + n.y,
    left: e.left - t.width - n.x
  };
}
function N5(e) {
  return [Ss, Bo, Do, xs].some(function(t) {
    return e[t] >= 0;
  });
}
function lA(e) {
  var t = e.state, n = e.name, i = t.rects.reference, s = t.rects.popper, o = t.modifiersData.preventOverflow, u = Ng(t, {
    elementContext: "reference"
  }), h = Ng(t, {
    altBoundary: !0
  }), f = O5(u, i), p = O5(h, s, o), g = N5(f), v = N5(p);
  t.modifiersData[n] = {
    referenceClippingOffsets: f,
    popperEscapeOffsets: p,
    isReferenceHidden: g,
    hasPopperEscaped: v
  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-reference-hidden": g,
    "data-popper-escaped": v
  });
}
const cA = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: lA
};
function uA(e, t, n) {
  var i = wc(e), s = [xs, Ss].indexOf(i) >= 0 ? -1 : 1, o = typeof n == "function" ? n(Object.assign({}, t, {
    placement: e
  })) : n, u = o[0], h = o[1];
  return u = u || 0, h = (h || 0) * s, [xs, Bo].indexOf(i) >= 0 ? {
    x: h,
    y: u
  } : {
    x: u,
    y: h
  };
}
function dA(e) {
  var t = e.state, n = e.options, i = e.name, s = n.offset, o = s === void 0 ? [0, 0] : s, u = lT.reduce(function(g, v) {
    return g[v] = uA(v, t.rects, o), g;
  }, {}), h = u[t.placement], f = h.x, p = h.y;
  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += f, t.modifiersData.popperOffsets.y += p), t.modifiersData[i] = u;
}
const hA = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: dA
};
function fA(e) {
  var t = e.state, n = e.name;
  t.modifiersData[n] = mT({
    reference: t.rects.reference,
    element: t.rects.popper,
    placement: t.placement
  });
}
const pA = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: fA,
  data: {}
};
function mA(e) {
  return e === "x" ? "y" : "x";
}
function gA(e) {
  var t = e.state, n = e.options, i = e.name, s = n.mainAxis, o = s === void 0 ? !0 : s, u = n.altAxis, h = u === void 0 ? !1 : u, f = n.boundary, p = n.rootBoundary, g = n.altBoundary, v = n.padding, x = n.tether, b = x === void 0 ? !0 : x, _ = n.tetherOffset, T = _ === void 0 ? 0 : _, A = Ng(t, {
    boundary: f,
    rootBoundary: p,
    padding: v,
    altBoundary: g
  }), O = wc(t.placement), M = Qf(t.placement), E = !M, R = H2(O), N = mA(R), U = t.modifiersData.popperOffsets, q = t.rects.reference, j = t.rects.popper, V = typeof T == "function" ? T(Object.assign({}, t.rects, {
    placement: t.placement
  })) : T, D = typeof V == "number" ? {
    mainAxis: V,
    altAxis: V
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, V), G = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, W = {
    x: 0,
    y: 0
  };
  if (U) {
    if (o) {
      var P, H = R === "y" ? Ss : xs, I = R === "y" ? Do : Bo, K = R === "y" ? "height" : "width", Q = U[R], it = Q + A[H], nt = Q - A[I], X = b ? -j[K] / 2 : 0, rt = M === Xf ? q[K] : j[K], vt = M === Xf ? -j[K] : -q[K], ct = t.elements.arrow, dt = b && ct ? G2(ct) : {
        width: 0,
        height: 0
      }, ht = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : dT(), Et = ht[H], ot = ht[I], lt = bg(0, q[K], dt[K]), ft = E ? q[K] / 2 - X - lt - Et - D.mainAxis : rt - lt - Et - D.mainAxis, Tt = E ? -q[K] / 2 + X + lt + ot + D.mainAxis : vt + lt + ot + D.mainAxis, Bt = t.elements.arrow && Hg(t.elements.arrow), Ot = Bt ? R === "y" ? Bt.clientTop || 0 : Bt.clientLeft || 0 : 0, ie = (P = G == null ? void 0 : G[R]) != null ? P : 0, ce = Q + ft - ie - Ot, Ut = Q + Tt - ie, se = bg(b ? n1(it, ce) : it, Q, b ? kh(nt, Ut) : nt);
      U[R] = se, W[R] = se - Q;
    }
    if (h) {
      var re, ue = R === "x" ? Ss : xs, Ae = R === "x" ? Do : Bo, ve = U[N], Re = N === "y" ? "height" : "width", oe = ve + A[ue], Le = ve - A[Ae], De = [Ss, xs].indexOf(O) !== -1, Kt = (re = G == null ? void 0 : G[N]) != null ? re : 0, te = De ? oe : ve - q[Re] - j[Re] - Kt + D.altAxis, It = De ? ve + q[Re] + j[Re] - Kt - D.altAxis : Le, Ht = b && De ? V7(te, ve, It) : bg(b ? te : oe, ve, b ? It : Le);
      U[N] = Ht, W[N] = Ht - ve;
    }
    t.modifiersData[i] = W;
  }
}
const yA = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: gA,
  requiresIfExists: ["offset"]
};
function vA(e) {
  return {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  };
}
function bA(e) {
  return e === Zs(e) || !No(e) ? K2(e) : vA(e);
}
function _A(e) {
  var t = e.getBoundingClientRect(), n = Wf(t.width) / e.offsetWidth || 1, i = Wf(t.height) / e.offsetHeight || 1;
  return n !== 1 || i !== 1;
}
function SA(e, t, n) {
  n === void 0 && (n = !1);
  var i = No(t), s = No(t) && _A(t), o = Ld(t), u = $f(e, s, n), h = {
    scrollLeft: 0,
    scrollTop: 0
  }, f = {
    x: 0,
    y: 0
  };
  return (i || !i && !n) && ((Mc(t) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  X2(o)) && (h = bA(t)), No(t) ? (f = $f(t, !0), f.x += t.clientLeft, f.y += t.clientTop) : o && (f.x = Y2(o))), {
    x: u.left + h.scrollLeft - f.x,
    y: u.top + h.scrollTop - f.y,
    width: u.width,
    height: u.height
  };
}
function xA(e) {
  var t = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), i = [];
  e.forEach(function(o) {
    t.set(o.name, o);
  });
  function s(o) {
    n.add(o.name);
    var u = [].concat(o.requires || [], o.requiresIfExists || []);
    u.forEach(function(h) {
      if (!n.has(h)) {
        var f = t.get(h);
        f && s(f);
      }
    }), i.push(o);
  }
  return e.forEach(function(o) {
    n.has(o.name) || s(o);
  }), i;
}
function TA(e) {
  var t = xA(e);
  return B7.reduce(function(n, i) {
    return n.concat(t.filter(function(s) {
      return s.phase === i;
    }));
  }, []);
}
function CA(e) {
  var t;
  return function() {
    return t || (t = new Promise(function(n) {
      Promise.resolve().then(function() {
        t = void 0, n(e());
      });
    })), t;
  };
}
function wA(e) {
  var t = e.reduce(function(n, i) {
    var s = n[i.name];
    return n[i.name] = s ? Object.assign({}, s, i, {
      options: Object.assign({}, s.options, i.options),
      data: Object.assign({}, s.data, i.data)
    }) : i, n;
  }, {});
  return Object.keys(t).map(function(n) {
    return t[n];
  });
}
var k5 = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function D5() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return !t.some(function(i) {
    return !(i && typeof i.getBoundingClientRect == "function");
  });
}
function EA(e) {
  e === void 0 && (e = {});
  var t = e, n = t.defaultModifiers, i = n === void 0 ? [] : n, s = t.defaultOptions, o = s === void 0 ? k5 : s;
  return function(h, f, p) {
    p === void 0 && (p = o);
    var g = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, k5, o),
      modifiersData: {},
      elements: {
        reference: h,
        popper: f
      },
      attributes: {},
      styles: {}
    }, v = [], x = !1, b = {
      state: g,
      setOptions: function(O) {
        var M = typeof O == "function" ? O(g.options) : O;
        T(), g.options = Object.assign({}, o, g.options, M), g.scrollParents = {
          reference: zh(h) ? _g(h) : h.contextElement ? _g(h.contextElement) : [],
          popper: _g(f)
        };
        var E = TA(wA([].concat(i, g.options.modifiers)));
        return g.orderedModifiers = E.filter(function(R) {
          return R.enabled;
        }), _(), b.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!x) {
          var O = g.elements, M = O.reference, E = O.popper;
          if (D5(M, E)) {
            g.rects = {
              reference: SA(M, Hg(E), g.options.strategy === "fixed"),
              popper: G2(E)
            }, g.reset = !1, g.placement = g.options.placement, g.orderedModifiers.forEach(function(D) {
              return g.modifiersData[D.name] = Object.assign({}, D.data);
            });
            for (var R = 0; R < g.orderedModifiers.length; R++) {
              if (g.reset === !0) {
                g.reset = !1, R = -1;
                continue;
              }
              var N = g.orderedModifiers[R], U = N.fn, q = N.options, j = q === void 0 ? {} : q, V = N.name;
              typeof U == "function" && (g = U({
                state: g,
                options: j,
                name: V,
                instance: b
              }) || g);
            }
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: CA(function() {
        return new Promise(function(A) {
          b.forceUpdate(), A(g);
        });
      }),
      destroy: function() {
        T(), x = !0;
      }
    };
    if (!D5(h, f))
      return b;
    b.setOptions(p).then(function(A) {
      !x && p.onFirstUpdate && p.onFirstUpdate(A);
    });
    function _() {
      g.orderedModifiers.forEach(function(A) {
        var O = A.name, M = A.options, E = M === void 0 ? {} : M, R = A.effect;
        if (typeof R == "function") {
          var N = R({
            state: g,
            name: O,
            instance: b,
            options: E
          }), U = function() {
          };
          v.push(N || U);
        }
      });
    }
    function T() {
      v.forEach(function(A) {
        return A();
      }), v = [];
    }
    return b;
  };
}
var AA = [$7, pA, X7, U7, hA, oA, yA, G7, cA], MA = /* @__PURE__ */ EA({
  defaultModifiers: AA
});
function RA(e) {
  return typeof e == "function" ? e() : e;
}
const gT = /* @__PURE__ */ tt.forwardRef(function(t, n) {
  const {
    children: i,
    container: s,
    disablePortal: o = !1
  } = t, [u, h] = tt.useState(null), f = jr(/* @__PURE__ */ tt.isValidElement(i) ? up(i) : null, n);
  if (ko(() => {
    o || h(RA(s) || document.body);
  }, [s, o]), ko(() => {
    if (u && !o)
      return qb(n, u), () => {
        qb(n, null);
      };
  }, [n, u, o]), o) {
    if (/* @__PURE__ */ tt.isValidElement(i)) {
      const p = {
        ref: f
      };
      return /* @__PURE__ */ tt.cloneElement(i, p);
    }
    return i;
  }
  return u && /* @__PURE__ */ rT.createPortal(i, u);
});
function OA(e) {
  return Un("MuiPopper", e);
}
zn("MuiPopper", ["root"]);
function NA(e, t) {
  if (t === "ltr")
    return e;
  switch (e) {
    case "bottom-end":
      return "bottom-start";
    case "bottom-start":
      return "bottom-end";
    case "top-end":
      return "top-start";
    case "top-start":
      return "top-end";
    default:
      return e;
  }
}
function t2(e) {
  return typeof e == "function" ? e() : e;
}
function kA(e) {
  return e.nodeType !== void 0;
}
const DA = (e) => {
  const {
    classes: t
  } = e;
  return jn({
    root: ["root"]
  }, OA, t);
}, BA = {}, zA = /* @__PURE__ */ tt.forwardRef(function(t, n) {
  const {
    anchorEl: i,
    children: s,
    direction: o,
    disablePortal: u,
    modifiers: h,
    open: f,
    placement: p,
    popperOptions: g,
    popperRef: v,
    slotProps: x = {},
    slots: b = {},
    TransitionProps: _,
    // @ts-ignore internal logic
    ownerState: T,
    // prevent from spreading to DOM, it can come from the parent component e.g. Select.
    ...A
  } = t, O = tt.useRef(null), M = jr(O, n), E = tt.useRef(null), R = jr(E, v), N = tt.useRef(R);
  ko(() => {
    N.current = R;
  }, [R]), tt.useImperativeHandle(v, () => E.current, []);
  const U = NA(p, o), [q, j] = tt.useState(U), [V, D] = tt.useState(t2(i));
  tt.useEffect(() => {
    E.current && E.current.forceUpdate();
  }), tt.useEffect(() => {
    i && D(t2(i));
  }, [i]), ko(() => {
    if (!V || !f)
      return;
    const I = (it) => {
      j(it.placement);
    };
    let K = [{
      name: "preventOverflow",
      options: {
        altBoundary: u
      }
    }, {
      name: "flip",
      options: {
        altBoundary: u
      }
    }, {
      name: "onUpdate",
      enabled: !0,
      phase: "afterWrite",
      fn: ({
        state: it
      }) => {
        I(it);
      }
    }];
    h != null && (K = K.concat(h)), g && g.modifiers != null && (K = K.concat(g.modifiers));
    const Q = MA(V, O.current, {
      placement: U,
      ...g,
      modifiers: K
    });
    return N.current(Q), () => {
      Q.destroy(), N.current(null);
    };
  }, [V, u, h, f, g, U]);
  const G = {
    placement: q
  };
  _ !== null && (G.TransitionProps = _);
  const W = DA(t), P = b.root ?? "div", H = vc({
    elementType: P,
    externalSlotProps: x.root,
    externalForwardedProps: A,
    additionalProps: {
      role: "tooltip",
      ref: M
    },
    ownerState: t,
    className: W.root
  });
  return /* @__PURE__ */ J.jsx(P, {
    ...H,
    children: typeof s == "function" ? s(G) : s
  });
}), PA = /* @__PURE__ */ tt.forwardRef(function(t, n) {
  const {
    anchorEl: i,
    children: s,
    container: o,
    direction: u = "ltr",
    disablePortal: h = !1,
    keepMounted: f = !1,
    modifiers: p,
    open: g,
    placement: v = "bottom",
    popperOptions: x = BA,
    popperRef: b,
    style: _,
    transition: T = !1,
    slotProps: A = {},
    slots: O = {},
    ...M
  } = t, [E, R] = tt.useState(!0), N = () => {
    R(!1);
  }, U = () => {
    R(!0);
  };
  if (!f && !g && (!T || E))
    return null;
  let q;
  if (o)
    q = o;
  else if (i) {
    const D = t2(i);
    q = D && kA(D) ? ga(D).body : ga(null).body;
  }
  const j = !g && f && (!T || E) ? "none" : void 0, V = T ? {
    in: g,
    onEnter: N,
    onExited: U
  } : void 0;
  return /* @__PURE__ */ J.jsx(gT, {
    disablePortal: h,
    container: q,
    children: /* @__PURE__ */ J.jsx(zA, {
      anchorEl: i,
      direction: u,
      disablePortal: h,
      modifiers: p,
      ref: n,
      open: T ? !E : g,
      placement: v,
      popperOptions: x,
      popperRef: b,
      slotProps: A,
      slots: O,
      ...M,
      style: {
        // Prevents scroll issue, waiting for Popper.js to add this style once initiated.
        position: "fixed",
        // Fix Popper.js display issue
        top: 0,
        left: 0,
        display: j,
        ..._
      },
      TransitionProps: V,
      children: s
    })
  });
}), UA = Ne(PA, {
  name: "MuiPopper",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({}), yT = /* @__PURE__ */ tt.forwardRef(function(t, n) {
  const i = U1(), s = In({
    props: t,
    name: "MuiPopper"
  }), {
    anchorEl: o,
    component: u,
    components: h,
    componentsProps: f,
    container: p,
    disablePortal: g,
    keepMounted: v,
    modifiers: x,
    open: b,
    placement: _,
    popperOptions: T,
    popperRef: A,
    transition: O,
    slots: M,
    slotProps: E,
    ...R
  } = s, N = (M == null ? void 0 : M.root) ?? (h == null ? void 0 : h.Root), U = {
    anchorEl: o,
    container: p,
    disablePortal: g,
    keepMounted: v,
    modifiers: x,
    open: b,
    placement: _,
    popperOptions: T,
    popperRef: A,
    transition: O,
    ...R
  };
  return /* @__PURE__ */ J.jsx(UA, {
    as: u,
    direction: i ? "rtl" : "ltr",
    slots: {
      root: N
    },
    slotProps: E ?? f,
    ...U,
    ref: n
  });
});
function xy(e) {
  return parseInt(e, 10) || 0;
}
const jA = {
  shadow: {
    // Visibility needed to hide the extra text area on iPads
    visibility: "hidden",
    // Remove from the content flow
    position: "absolute",
    // Ignore the scrollbar width
    overflow: "hidden",
    height: 0,
    top: 0,
    left: 0,
    // Create a new layer, increase the isolation of the computed values
    transform: "translateZ(0)"
  }
};
function LA(e) {
  for (const t in e)
    return !1;
  return !0;
}
function B5(e) {
  return LA(e) || e.outerHeightStyle === 0 && !e.overflowing;
}
const VA = /* @__PURE__ */ tt.forwardRef(function(t, n) {
  const {
    onChange: i,
    maxRows: s,
    minRows: o = 1,
    style: u,
    value: h,
    ...f
  } = t, {
    current: p
  } = tt.useRef(h != null), g = tt.useRef(null), v = jr(n, g), x = tt.useRef(null), b = tt.useRef(null), _ = tt.useCallback(() => {
    const E = g.current, R = b.current;
    if (!E || !R)
      return;
    const U = Pu(E).getComputedStyle(E);
    if (U.width === "0px")
      return {
        outerHeightStyle: 0,
        overflowing: !1
      };
    R.style.width = U.width, R.value = E.value || t.placeholder || "x", R.value.slice(-1) === `
` && (R.value += " ");
    const q = U.boxSizing, j = xy(U.paddingBottom) + xy(U.paddingTop), V = xy(U.borderBottomWidth) + xy(U.borderTopWidth), D = R.scrollHeight;
    R.value = "x";
    const G = R.scrollHeight;
    let W = D;
    o && (W = Math.max(Number(o) * G, W)), s && (W = Math.min(Number(s) * G, W)), W = Math.max(W, G);
    const P = W + (q === "border-box" ? j + V : 0), H = Math.abs(W - D) <= 1;
    return {
      outerHeightStyle: P,
      overflowing: H
    };
  }, [s, o, t.placeholder]), T = Oo(() => {
    const E = g.current, R = _();
    if (!E || !R || B5(R))
      return !1;
    const N = R.outerHeightStyle;
    return x.current != null && x.current !== N;
  }), A = tt.useCallback(() => {
    const E = g.current, R = _();
    if (!E || !R || B5(R))
      return;
    const N = R.outerHeightStyle;
    x.current !== N && (x.current = N, E.style.height = `${N}px`), E.style.overflow = R.overflowing ? "hidden" : "";
  }, [_]), O = tt.useRef(-1);
  ko(() => {
    const E = j3(A), R = g == null ? void 0 : g.current;
    if (!R)
      return;
    const N = Pu(R);
    N.addEventListener("resize", E);
    let U;
    return typeof ResizeObserver < "u" && (U = new ResizeObserver(() => {
      T() && (U.unobserve(R), cancelAnimationFrame(O.current), A(), O.current = requestAnimationFrame(() => {
        U.observe(R);
      }));
    }), U.observe(R)), () => {
      E.clear(), cancelAnimationFrame(O.current), N.removeEventListener("resize", E), U && U.disconnect();
    };
  }, [_, A, T]), ko(() => {
    A();
  });
  const M = (E) => {
    p || A(), i && i(E);
  };
  return /* @__PURE__ */ J.jsxs(tt.Fragment, {
    children: [/* @__PURE__ */ J.jsx("textarea", {
      value: h,
      onChange: M,
      ref: v,
      rows: o,
      style: u,
      ...f
    }), /* @__PURE__ */ J.jsx("textarea", {
      "aria-hidden": !0,
      className: t.className,
      readOnly: !0,
      ref: b,
      tabIndex: -1,
      style: {
        ...jA.shadow,
        ...u,
        paddingTop: 0,
        paddingBottom: 0
      }
    })]
  });
});
function Dh(e) {
  return typeof e == "string";
}
function dp({
  props: e,
  states: t,
  muiFormControl: n
}) {
  return t.reduce((i, s) => (i[s] = e[s], n && typeof e[s] > "u" && (i[s] = n[s]), i), {});
}
const W2 = /* @__PURE__ */ tt.createContext(void 0);
function hp() {
  return tt.useContext(W2);
}
function z5(e) {
  return e != null && !(Array.isArray(e) && e.length === 0);
}
function i1(e, t = !1) {
  return e && (z5(e.value) && e.value !== "" || t && z5(e.defaultValue) && e.defaultValue !== "");
}
function IA(e) {
  return e.startAdornment;
}
function FA(e) {
  return Un("MuiInputBase", e);
}
const Zf = zn("MuiInputBase", ["root", "formControl", "focused", "disabled", "adornedStart", "adornedEnd", "error", "sizeSmall", "multiline", "colorSecondary", "fullWidth", "hiddenLabel", "readOnly", "input", "inputSizeSmall", "inputMultiline", "inputTypeSearch", "inputAdornedStart", "inputAdornedEnd", "inputHiddenLabel"]);
var P5;
const q1 = (e, t) => {
  const {
    ownerState: n
  } = e;
  return [t.root, n.formControl && t.formControl, n.startAdornment && t.adornedStart, n.endAdornment && t.adornedEnd, n.error && t.error, n.size === "small" && t.sizeSmall, n.multiline && t.multiline, n.color && t[`color${Ue(n.color)}`], n.fullWidth && t.fullWidth, n.hiddenLabel && t.hiddenLabel];
}, G1 = (e, t) => {
  const {
    ownerState: n
  } = e;
  return [t.input, n.size === "small" && t.inputSizeSmall, n.multiline && t.inputMultiline, n.type === "search" && t.inputTypeSearch, n.startAdornment && t.inputAdornedStart, n.endAdornment && t.inputAdornedEnd, n.hiddenLabel && t.inputHiddenLabel];
}, qA = (e) => {
  const {
    classes: t,
    color: n,
    disabled: i,
    error: s,
    endAdornment: o,
    focused: u,
    formControl: h,
    fullWidth: f,
    hiddenLabel: p,
    multiline: g,
    readOnly: v,
    size: x,
    startAdornment: b,
    type: _
  } = e, T = {
    root: ["root", `color${Ue(n)}`, i && "disabled", s && "error", f && "fullWidth", u && "focused", h && "formControl", x && x !== "medium" && `size${Ue(x)}`, g && "multiline", b && "adornedStart", o && "adornedEnd", p && "hiddenLabel", v && "readOnly"],
    input: ["input", i && "disabled", _ === "search" && "inputTypeSearch", g && "inputMultiline", x === "small" && "inputSizeSmall", p && "inputHiddenLabel", b && "inputAdornedStart", o && "inputAdornedEnd", v && "readOnly"]
  };
  return jn(T, FA, t);
}, H1 = Ne("div", {
  name: "MuiInputBase",
  slot: "Root",
  overridesResolver: q1
})(En(({
  theme: e
}) => ({
  ...e.typography.body1,
  color: (e.vars || e).palette.text.primary,
  lineHeight: "1.4375em",
  // 23px
  boxSizing: "border-box",
  // Prevent padding issue with fullWidth.
  position: "relative",
  cursor: "text",
  display: "inline-flex",
  alignItems: "center",
  [`&.${Zf.disabled}`]: {
    color: (e.vars || e).palette.text.disabled,
    cursor: "default"
  },
  variants: [{
    props: ({
      ownerState: t
    }) => t.multiline,
    style: {
      padding: "4px 0 5px"
    }
  }, {
    props: ({
      ownerState: t,
      size: n
    }) => t.multiline && n === "small",
    style: {
      paddingTop: 1
    }
  }, {
    props: ({
      ownerState: t
    }) => t.fullWidth,
    style: {
      width: "100%"
    }
  }]
}))), K1 = Ne("input", {
  name: "MuiInputBase",
  slot: "Input",
  overridesResolver: G1
})(En(({
  theme: e
}) => {
  const t = e.palette.mode === "light", n = {
    color: "currentColor",
    ...e.vars ? {
      opacity: e.vars.opacity.inputPlaceholder
    } : {
      opacity: t ? 0.42 : 0.5
    },
    transition: e.transitions.create("opacity", {
      duration: e.transitions.duration.shorter
    })
  }, i = {
    opacity: "0 !important"
  }, s = e.vars ? {
    opacity: e.vars.opacity.inputPlaceholder
  } : {
    opacity: t ? 0.42 : 0.5
  };
  return {
    font: "inherit",
    letterSpacing: "inherit",
    color: "currentColor",
    padding: "4px 0 5px",
    border: 0,
    boxSizing: "content-box",
    background: "none",
    height: "1.4375em",
    // Reset 23pxthe native input line-height
    margin: 0,
    // Reset for Safari
    WebkitTapHighlightColor: "transparent",
    display: "block",
    // Make the flex item shrink with Firefox
    minWidth: 0,
    width: "100%",
    "&::-webkit-input-placeholder": n,
    "&::-moz-placeholder": n,
    // Firefox 19+
    "&::-ms-input-placeholder": n,
    // Edge
    "&:focus": {
      outline: 0
    },
    // Reset Firefox invalid required input style
    "&:invalid": {
      boxShadow: "none"
    },
    "&::-webkit-search-decoration": {
      // Remove the padding when type=search.
      WebkitAppearance: "none"
    },
    // Show and hide the placeholder logic
    [`label[data-shrink=false] + .${Zf.formControl} &`]: {
      "&::-webkit-input-placeholder": i,
      "&::-moz-placeholder": i,
      // Firefox 19+
      "&::-ms-input-placeholder": i,
      // Edge
      "&:focus::-webkit-input-placeholder": s,
      "&:focus::-moz-placeholder": s,
      // Firefox 19+
      "&:focus::-ms-input-placeholder": s
      // Edge
    },
    [`&.${Zf.disabled}`]: {
      opacity: 1,
      // Reset iOS opacity
      WebkitTextFillColor: (e.vars || e).palette.text.disabled
      // Fix opacity Safari bug
    },
    variants: [{
      props: ({
        ownerState: o
      }) => !o.disableInjectingGlobalStyles,
      style: {
        animationName: "mui-auto-fill-cancel",
        animationDuration: "10ms",
        "&:-webkit-autofill": {
          animationDuration: "5000s",
          animationName: "mui-auto-fill"
        }
      }
    }, {
      props: {
        size: "small"
      },
      style: {
        paddingTop: 1
      }
    }, {
      props: ({
        ownerState: o
      }) => o.multiline,
      style: {
        height: "auto",
        resize: "none",
        padding: 0,
        paddingTop: 0
      }
    }, {
      props: {
        type: "search"
      },
      style: {
        MozAppearance: "textfield"
        // Improve type search style.
      }
    }]
  };
})), U5 = M9({
  "@keyframes mui-auto-fill": {
    from: {
      display: "block"
    }
  },
  "@keyframes mui-auto-fill-cancel": {
    from: {
      display: "block"
    }
  }
}), $2 = /* @__PURE__ */ tt.forwardRef(function(t, n) {
  const i = In({
    props: t,
    name: "MuiInputBase"
  }), {
    "aria-describedby": s,
    autoComplete: o,
    autoFocus: u,
    className: h,
    color: f,
    components: p = {},
    componentsProps: g = {},
    defaultValue: v,
    disabled: x,
    disableInjectingGlobalStyles: b,
    endAdornment: _,
    error: T,
    fullWidth: A = !1,
    id: O,
    inputComponent: M = "input",
    inputProps: E = {},
    inputRef: R,
    margin: N,
    maxRows: U,
    minRows: q,
    multiline: j = !1,
    name: V,
    onBlur: D,
    onChange: G,
    onClick: W,
    onFocus: P,
    onKeyDown: H,
    onKeyUp: I,
    placeholder: K,
    readOnly: Q,
    renderSuffix: it,
    rows: nt,
    size: X,
    slotProps: rt = {},
    slots: vt = {},
    startAdornment: ct,
    type: dt = "text",
    value: ht,
    ...Et
  } = i, ot = E.value != null ? E.value : ht, {
    current: lt
  } = tt.useRef(ot != null), ft = tt.useRef(), Tt = tt.useCallback((ae) => {
  }, []), Bt = jr(ft, R, E.ref, Tt), [Ot, ie] = tt.useState(!1), ce = hp(), Ut = dp({
    props: i,
    muiFormControl: ce,
    states: ["color", "disabled", "error", "hiddenLabel", "size", "required", "filled"]
  });
  Ut.focused = ce ? ce.focused : Ot, tt.useEffect(() => {
    !ce && x && Ot && (ie(!1), D && D());
  }, [ce, x, Ot, D]);
  const se = ce && ce.onFilled, re = ce && ce.onEmpty, ue = tt.useCallback((ae) => {
    i1(ae) ? se && se() : re && re();
  }, [se, re]);
  ko(() => {
    lt && ue({
      value: ot
    });
  }, [ot, ue, lt]);
  const Ae = (ae) => {
    P && P(ae), E.onFocus && E.onFocus(ae), ce && ce.onFocus ? ce.onFocus(ae) : ie(!0);
  }, ve = (ae) => {
    D && D(ae), E.onBlur && E.onBlur(ae), ce && ce.onBlur ? ce.onBlur(ae) : ie(!1);
  }, Re = (ae, ...le) => {
    if (!lt) {
      const fe = ae.target || ft.current;
      if (fe == null)
        throw new Error(Bu(1));
      ue({
        value: fe.value
      });
    }
    E.onChange && E.onChange(ae, ...le), G && G(ae, ...le);
  };
  tt.useEffect(() => {
    ue(ft.current);
  }, []);
  const oe = (ae) => {
    ft.current && ae.currentTarget === ae.target && ft.current.focus(), W && W(ae);
  };
  let Le = M, De = E;
  j && Le === "input" && (nt ? De = {
    type: void 0,
    minRows: nt,
    maxRows: nt,
    ...De
  } : De = {
    type: void 0,
    maxRows: U,
    minRows: q,
    ...De
  }, Le = VA);
  const Kt = (ae) => {
    ue(ae.animationName === "mui-auto-fill-cancel" ? ft.current : {
      value: "x"
    });
  };
  tt.useEffect(() => {
    ce && ce.setAdornedStart(!!ct);
  }, [ce, ct]);
  const te = {
    ...i,
    color: Ut.color || "primary",
    disabled: Ut.disabled,
    endAdornment: _,
    error: Ut.error,
    focused: Ut.focused,
    formControl: ce,
    fullWidth: A,
    hiddenLabel: Ut.hiddenLabel,
    multiline: j,
    size: Ut.size,
    startAdornment: ct,
    type: dt
  }, It = qA(te), Ht = vt.root || p.Root || H1, Jt = rt.root || g.root || {}, Yt = vt.input || p.Input || K1;
  return De = {
    ...De,
    ...rt.input ?? g.input
  }, /* @__PURE__ */ J.jsxs(tt.Fragment, {
    children: [!b && typeof U5 == "function" && // For Emotion/Styled-components, InputGlobalStyles will be a function
    // For Pigment CSS, this has no effect because the InputGlobalStyles will be null.
    (P5 || (P5 = /* @__PURE__ */ J.jsx(U5, {}))), /* @__PURE__ */ J.jsxs(Ht, {
      ...Jt,
      ref: n,
      onClick: oe,
      ...Et,
      ...!Dh(Ht) && {
        ownerState: {
          ...te,
          ...Jt.ownerState
        }
      },
      className: Fe(It.root, Jt.className, h, Q && "MuiInputBase-readOnly"),
      children: [ct, /* @__PURE__ */ J.jsx(W2.Provider, {
        value: null,
        children: /* @__PURE__ */ J.jsx(Yt, {
          "aria-invalid": Ut.error,
          "aria-describedby": s,
          autoComplete: o,
          autoFocus: u,
          defaultValue: v,
          disabled: Ut.disabled,
          id: O,
          onAnimationStart: Kt,
          name: V,
          placeholder: K,
          readOnly: Q,
          required: Ut.required,
          rows: nt,
          value: ot,
          onKeyDown: H,
          onKeyUp: I,
          type: dt,
          ...De,
          ...!Dh(Yt) && {
            as: Le,
            ownerState: {
              ...te,
              ...De.ownerState
            }
          },
          ref: Bt,
          className: Fe(It.input, De.className, Q && "MuiInputBase-readOnly"),
          onBlur: ve,
          onChange: Re,
          onFocus: Ae
        })
      }), _, it ? it({
        ...Ut,
        startAdornment: ct
      }) : null]
    })]
  });
});
function GA(e) {
  return Un("MuiInput", e);
}
const mm = {
  ...Zf,
  ...zn("MuiInput", ["root", "underline", "input"])
};
function HA(e) {
  return Un("MuiOutlinedInput", e);
}
const yc = {
  ...Zf,
  ...zn("MuiOutlinedInput", ["root", "notchedOutline", "input"])
};
function KA(e) {
  return Un("MuiFilledInput", e);
}
const vh = {
  ...Zf,
  ...zn("MuiFilledInput", ["root", "underline", "input", "adornedStart", "adornedEnd", "sizeSmall", "multiline", "hiddenLabel"])
}, YA = Ba(/* @__PURE__ */ J.jsx("path", {
  d: "M7 10l5 5 5-5z"
}), "ArrowDropDown"), XA = {
  entering: {
    opacity: 1
  },
  entered: {
    opacity: 1
  }
}, WA = /* @__PURE__ */ tt.forwardRef(function(t, n) {
  const i = L1(), s = {
    enter: i.transitions.duration.enteringScreen,
    exit: i.transitions.duration.leavingScreen
  }, {
    addEndListener: o,
    appear: u = !0,
    children: h,
    easing: f,
    in: p,
    onEnter: g,
    onEntered: v,
    onEntering: x,
    onExit: b,
    onExited: _,
    onExiting: T,
    style: A,
    timeout: O = s,
    // eslint-disable-next-line react/prop-types
    TransitionComponent: M = Nc,
    ...E
  } = t, R = tt.useRef(null), N = jr(R, up(h), n), U = (H) => (I) => {
    if (H) {
      const K = R.current;
      I === void 0 ? H(K) : H(K, I);
    }
  }, q = U(x), j = U((H, I) => {
    aT(H);
    const K = t1({
      style: A,
      timeout: O,
      easing: f
    }, {
      mode: "enter"
    });
    H.style.webkitTransition = i.transitions.create("opacity", K), H.style.transition = i.transitions.create("opacity", K), g && g(H, I);
  }), V = U(v), D = U(T), G = U((H) => {
    const I = t1({
      style: A,
      timeout: O,
      easing: f
    }, {
      mode: "exit"
    });
    H.style.webkitTransition = i.transitions.create("opacity", I), H.style.transition = i.transitions.create("opacity", I), b && b(H);
  }), W = U(_), P = (H) => {
    o && o(R.current, H);
  };
  return /* @__PURE__ */ J.jsx(M, {
    appear: u,
    in: p,
    nodeRef: R,
    onEnter: j,
    onEntered: V,
    onEntering: q,
    onExit: G,
    onExited: W,
    onExiting: D,
    addEndListener: P,
    timeout: O,
    ...E,
    children: (H, {
      ownerState: I,
      ...K
    }) => /* @__PURE__ */ tt.cloneElement(h, {
      style: {
        opacity: 0,
        visibility: H === "exited" && !p ? "hidden" : void 0,
        ...XA[H],
        ...A,
        ...h.props.style
      },
      ref: N,
      ...K
    })
  });
});
function $A(e) {
  return Un("MuiBackdrop", e);
}
zn("MuiBackdrop", ["root", "invisible"]);
const QA = (e) => {
  const {
    classes: t,
    invisible: n
  } = e;
  return jn({
    root: ["root", n && "invisible"]
  }, $A, t);
}, ZA = Ne("div", {
  name: "MuiBackdrop",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.invisible && t.invisible];
  }
})({
  position: "fixed",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  right: 0,
  bottom: 0,
  top: 0,
  left: 0,
  backgroundColor: "rgba(0, 0, 0, 0.5)",
  WebkitTapHighlightColor: "transparent",
  variants: [{
    props: {
      invisible: !0
    },
    style: {
      backgroundColor: "transparent"
    }
  }]
}), JA = /* @__PURE__ */ tt.forwardRef(function(t, n) {
  const i = In({
    props: t,
    name: "MuiBackdrop"
  }), {
    children: s,
    className: o,
    component: u = "div",
    invisible: h = !1,
    open: f,
    components: p = {},
    componentsProps: g = {},
    slotProps: v = {},
    slots: x = {},
    TransitionComponent: b,
    transitionDuration: _,
    ...T
  } = i, A = {
    ...i,
    component: u,
    invisible: h
  }, O = QA(A), M = {
    transition: b,
    root: p.Root,
    ...x
  }, E = {
    ...g,
    ...v
  }, R = {
    slots: M,
    slotProps: E
  }, [N, U] = gr("root", {
    elementType: ZA,
    externalForwardedProps: R,
    className: Fe(O.root, o),
    ownerState: A
  }), [q, j] = gr("transition", {
    elementType: WA,
    externalForwardedProps: R,
    ownerState: A
  });
  return /* @__PURE__ */ J.jsx(q, {
    in: f,
    timeout: _,
    ...T,
    ...j,
    children: /* @__PURE__ */ J.jsx(N, {
      "aria-hidden": !0,
      ...U,
      classes: O,
      ref: n,
      children: s
    })
  });
}), tM = zn("MuiBox", ["root"]), eM = j1(), xe = sE({
  themeId: Tc,
  defaultTheme: eM,
  defaultClassName: tM.root,
  generateClassName: D3.generate
});
function nM(e) {
  return Un("MuiButton", e);
}
const bh = zn("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorSuccess", "colorError", "colorInfo", "colorWarning", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "icon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge", "loading", "loadingWrapper", "loadingIconPlaceholder", "loadingIndicator", "loadingPositionCenter", "loadingPositionStart", "loadingPositionEnd"]), iM = /* @__PURE__ */ tt.createContext({}), rM = /* @__PURE__ */ tt.createContext(void 0), aM = (e) => {
  const {
    color: t,
    disableElevation: n,
    fullWidth: i,
    size: s,
    variant: o,
    loading: u,
    loadingPosition: h,
    classes: f
  } = e, p = {
    root: ["root", u && "loading", o, `${o}${Ue(t)}`, `size${Ue(s)}`, `${o}Size${Ue(s)}`, `color${Ue(t)}`, n && "disableElevation", i && "fullWidth", u && `loadingPosition${Ue(h)}`],
    startIcon: ["icon", "startIcon", `iconSize${Ue(s)}`],
    endIcon: ["icon", "endIcon", `iconSize${Ue(s)}`],
    loadingIndicator: ["loadingIndicator"],
    loadingWrapper: ["loadingWrapper"]
  }, g = jn(p, nM, f);
  return {
    ...f,
    // forward the focused, disabled, etc. classes to the ButtonBase
    ...g
  };
}, vT = [{
  props: {
    size: "small"
  },
  style: {
    "& > *:nth-of-type(1)": {
      fontSize: 18
    }
  }
}, {
  props: {
    size: "medium"
  },
  style: {
    "& > *:nth-of-type(1)": {
      fontSize: 20
    }
  }
}, {
  props: {
    size: "large"
  },
  style: {
    "& > *:nth-of-type(1)": {
      fontSize: 22
    }
  }
}], sM = Ne(I1, {
  shouldForwardProp: (e) => Po(e) || e === "classes",
  name: "MuiButton",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, t[n.variant], t[`${n.variant}${Ue(n.color)}`], t[`size${Ue(n.size)}`], t[`${n.variant}Size${Ue(n.size)}`], n.color === "inherit" && t.colorInherit, n.disableElevation && t.disableElevation, n.fullWidth && t.fullWidth, n.loading && t.loading];
  }
})(En(({
  theme: e
}) => {
  const t = e.palette.mode === "light" ? e.palette.grey[300] : e.palette.grey[800], n = e.palette.mode === "light" ? e.palette.grey.A100 : e.palette.grey[700];
  return {
    ...e.typography.button,
    minWidth: 64,
    padding: "6px 16px",
    border: 0,
    borderRadius: (e.vars || e).shape.borderRadius,
    transition: e.transitions.create(["background-color", "box-shadow", "border-color", "color"], {
      duration: e.transitions.duration.short
    }),
    "&:hover": {
      textDecoration: "none"
    },
    [`&.${bh.disabled}`]: {
      color: (e.vars || e).palette.action.disabled
    },
    variants: [{
      props: {
        variant: "contained"
      },
      style: {
        color: "var(--variant-containedColor)",
        backgroundColor: "var(--variant-containedBg)",
        boxShadow: (e.vars || e).shadows[2],
        "&:hover": {
          boxShadow: (e.vars || e).shadows[4],
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            boxShadow: (e.vars || e).shadows[2]
          }
        },
        "&:active": {
          boxShadow: (e.vars || e).shadows[8]
        },
        [`&.${bh.focusVisible}`]: {
          boxShadow: (e.vars || e).shadows[6]
        },
        [`&.${bh.disabled}`]: {
          color: (e.vars || e).palette.action.disabled,
          boxShadow: (e.vars || e).shadows[0],
          backgroundColor: (e.vars || e).palette.action.disabledBackground
        }
      }
    }, {
      props: {
        variant: "outlined"
      },
      style: {
        padding: "5px 15px",
        border: "1px solid currentColor",
        borderColor: "var(--variant-outlinedBorder, currentColor)",
        backgroundColor: "var(--variant-outlinedBg)",
        color: "var(--variant-outlinedColor)",
        [`&.${bh.disabled}`]: {
          border: `1px solid ${(e.vars || e).palette.action.disabledBackground}`
        }
      }
    }, {
      props: {
        variant: "text"
      },
      style: {
        padding: "6px 8px",
        color: "var(--variant-textColor)",
        backgroundColor: "var(--variant-textBg)"
      }
    }, ...Object.entries(e.palette).filter(Qs()).map(([i]) => ({
      props: {
        color: i
      },
      style: {
        "--variant-textColor": (e.vars || e).palette[i].main,
        "--variant-outlinedColor": (e.vars || e).palette[i].main,
        "--variant-outlinedBorder": e.vars ? `rgba(${e.vars.palette[i].mainChannel} / 0.5)` : xi(e.palette[i].main, 0.5),
        "--variant-containedColor": (e.vars || e).palette[i].contrastText,
        "--variant-containedBg": (e.vars || e).palette[i].main,
        "@media (hover: hover)": {
          "&:hover": {
            "--variant-containedBg": (e.vars || e).palette[i].dark,
            "--variant-textBg": e.vars ? `rgba(${e.vars.palette[i].mainChannel} / ${e.vars.palette.action.hoverOpacity})` : xi(e.palette[i].main, e.palette.action.hoverOpacity),
            "--variant-outlinedBorder": (e.vars || e).palette[i].main,
            "--variant-outlinedBg": e.vars ? `rgba(${e.vars.palette[i].mainChannel} / ${e.vars.palette.action.hoverOpacity})` : xi(e.palette[i].main, e.palette.action.hoverOpacity)
          }
        }
      }
    })), {
      props: {
        color: "inherit"
      },
      style: {
        color: "inherit",
        borderColor: "currentColor",
        "--variant-containedBg": e.vars ? e.vars.palette.Button.inheritContainedBg : t,
        "@media (hover: hover)": {
          "&:hover": {
            "--variant-containedBg": e.vars ? e.vars.palette.Button.inheritContainedHoverBg : n,
            "--variant-textBg": e.vars ? `rgba(${e.vars.palette.text.primaryChannel} / ${e.vars.palette.action.hoverOpacity})` : xi(e.palette.text.primary, e.palette.action.hoverOpacity),
            "--variant-outlinedBg": e.vars ? `rgba(${e.vars.palette.text.primaryChannel} / ${e.vars.palette.action.hoverOpacity})` : xi(e.palette.text.primary, e.palette.action.hoverOpacity)
          }
        }
      }
    }, {
      props: {
        size: "small",
        variant: "text"
      },
      style: {
        padding: "4px 5px",
        fontSize: e.typography.pxToRem(13)
      }
    }, {
      props: {
        size: "large",
        variant: "text"
      },
      style: {
        padding: "8px 11px",
        fontSize: e.typography.pxToRem(15)
      }
    }, {
      props: {
        size: "small",
        variant: "outlined"
      },
      style: {
        padding: "3px 9px",
        fontSize: e.typography.pxToRem(13)
      }
    }, {
      props: {
        size: "large",
        variant: "outlined"
      },
      style: {
        padding: "7px 21px",
        fontSize: e.typography.pxToRem(15)
      }
    }, {
      props: {
        size: "small",
        variant: "contained"
      },
      style: {
        padding: "4px 10px",
        fontSize: e.typography.pxToRem(13)
      }
    }, {
      props: {
        size: "large",
        variant: "contained"
      },
      style: {
        padding: "8px 22px",
        fontSize: e.typography.pxToRem(15)
      }
    }, {
      props: {
        disableElevation: !0
      },
      style: {
        boxShadow: "none",
        "&:hover": {
          boxShadow: "none"
        },
        [`&.${bh.focusVisible}`]: {
          boxShadow: "none"
        },
        "&:active": {
          boxShadow: "none"
        },
        [`&.${bh.disabled}`]: {
          boxShadow: "none"
        }
      }
    }, {
      props: {
        fullWidth: !0
      },
      style: {
        width: "100%"
      }
    }, {
      props: {
        loadingPosition: "center"
      },
      style: {
        transition: e.transitions.create(["background-color", "box-shadow", "border-color"], {
          duration: e.transitions.duration.short
        }),
        [`&.${bh.loading}`]: {
          color: "transparent"
        }
      }
    }]
  };
})), oM = Ne("span", {
  name: "MuiButton",
  slot: "StartIcon",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.startIcon, n.loading && t.startIconLoadingStart, t[`iconSize${Ue(n.size)}`]];
  }
})(({
  theme: e
}) => ({
  display: "inherit",
  marginRight: 8,
  marginLeft: -4,
  variants: [{
    props: {
      size: "small"
    },
    style: {
      marginLeft: -2
    }
  }, {
    props: {
      loadingPosition: "start",
      loading: !0
    },
    style: {
      transition: e.transitions.create(["opacity"], {
        duration: e.transitions.duration.short
      }),
      opacity: 0
    }
  }, {
    props: {
      loadingPosition: "start",
      loading: !0,
      fullWidth: !0
    },
    style: {
      marginRight: -8
    }
  }, ...vT]
})), lM = Ne("span", {
  name: "MuiButton",
  slot: "EndIcon",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.endIcon, n.loading && t.endIconLoadingEnd, t[`iconSize${Ue(n.size)}`]];
  }
})(({
  theme: e
}) => ({
  display: "inherit",
  marginRight: -4,
  marginLeft: 8,
  variants: [{
    props: {
      size: "small"
    },
    style: {
      marginRight: -2
    }
  }, {
    props: {
      loadingPosition: "end",
      loading: !0
    },
    style: {
      transition: e.transitions.create(["opacity"], {
        duration: e.transitions.duration.short
      }),
      opacity: 0
    }
  }, {
    props: {
      loadingPosition: "end",
      loading: !0,
      fullWidth: !0
    },
    style: {
      marginLeft: -8
    }
  }, ...vT]
})), cM = Ne("span", {
  name: "MuiButton",
  slot: "LoadingIndicator",
  overridesResolver: (e, t) => t.loadingIndicator
})(({
  theme: e
}) => ({
  display: "none",
  position: "absolute",
  visibility: "visible",
  variants: [{
    props: {
      loading: !0
    },
    style: {
      display: "flex"
    }
  }, {
    props: {
      loadingPosition: "start"
    },
    style: {
      left: 14
    }
  }, {
    props: {
      loadingPosition: "start",
      size: "small"
    },
    style: {
      left: 10
    }
  }, {
    props: {
      variant: "text",
      loadingPosition: "start"
    },
    style: {
      left: 6
    }
  }, {
    props: {
      loadingPosition: "center"
    },
    style: {
      left: "50%",
      transform: "translate(-50%)",
      color: (e.vars || e).palette.action.disabled
    }
  }, {
    props: {
      loadingPosition: "end"
    },
    style: {
      right: 14
    }
  }, {
    props: {
      loadingPosition: "end",
      size: "small"
    },
    style: {
      right: 10
    }
  }, {
    props: {
      variant: "text",
      loadingPosition: "end"
    },
    style: {
      right: 6
    }
  }, {
    props: {
      loadingPosition: "start",
      fullWidth: !0
    },
    style: {
      position: "relative",
      left: -10
    }
  }, {
    props: {
      loadingPosition: "end",
      fullWidth: !0
    },
    style: {
      position: "relative",
      right: -10
    }
  }]
})), j5 = Ne("span", {
  name: "MuiButton",
  slot: "LoadingIconPlaceholder",
  overridesResolver: (e, t) => t.loadingIconPlaceholder
})({
  display: "inline-block",
  width: "1em",
  height: "1em"
}), Gf = /* @__PURE__ */ tt.forwardRef(function(t, n) {
  const i = tt.useContext(iM), s = tt.useContext(rM), o = Eg(i, t), u = In({
    props: o,
    name: "MuiButton"
  }), {
    children: h,
    color: f = "primary",
    component: p = "button",
    className: g,
    disabled: v = !1,
    disableElevation: x = !1,
    disableFocusRipple: b = !1,
    endIcon: _,
    focusVisibleClassName: T,
    fullWidth: A = !1,
    id: O,
    loading: M = null,
    loadingIndicator: E,
    loadingPosition: R = "center",
    size: N = "medium",
    startIcon: U,
    type: q,
    variant: j = "text",
    ...V
  } = u, D = qg(O), G = E ?? /* @__PURE__ */ J.jsx(sT, {
    "aria-labelledby": D,
    color: "inherit",
    size: 16
  }), W = {
    ...u,
    color: f,
    component: p,
    disabled: v,
    disableElevation: x,
    disableFocusRipple: b,
    fullWidth: A,
    loading: M,
    loadingIndicator: G,
    loadingPosition: R,
    size: N,
    type: q,
    variant: j
  }, P = aM(W), H = (U || M && R === "start") && /* @__PURE__ */ J.jsx(oM, {
    className: P.startIcon,
    ownerState: W,
    children: U || /* @__PURE__ */ J.jsx(j5, {
      className: P.loadingIconPlaceholder,
      ownerState: W
    })
  }), I = (_ || M && R === "end") && /* @__PURE__ */ J.jsx(lM, {
    className: P.endIcon,
    ownerState: W,
    children: _ || /* @__PURE__ */ J.jsx(j5, {
      className: P.loadingIconPlaceholder,
      ownerState: W
    })
  }), K = s || "", Q = typeof M == "boolean" ? (
    // use plain HTML span to minimize the runtime overhead
    /* @__PURE__ */ J.jsx("span", {
      className: P.loadingWrapper,
      style: {
        display: "contents"
      },
      children: M && /* @__PURE__ */ J.jsx(cM, {
        className: P.loadingIndicator,
        ownerState: W,
        children: G
      })
    })
  ) : null;
  return /* @__PURE__ */ J.jsxs(sM, {
    ownerState: W,
    className: Fe(i.className, P.root, g, K),
    component: p,
    disabled: v || M,
    focusRipple: !b,
    focusVisibleClassName: Fe(P.focusVisible, T),
    ref: n,
    type: q,
    id: M ? D : O,
    ...V,
    classes: P,
    children: [H, R !== "end" && Q, h, R === "end" && Q, I]
  });
});
function uM(e) {
  const t = ga(e);
  return t.body === e ? Pu(e).innerWidth > t.documentElement.clientWidth : e.scrollHeight > e.clientHeight;
}
function Sg(e, t) {
  t ? e.setAttribute("aria-hidden", "true") : e.removeAttribute("aria-hidden");
}
function L5(e) {
  return parseInt(Pu(e).getComputedStyle(e).paddingRight, 10) || 0;
}
function dM(e) {
  const n = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"].includes(e.tagName), i = e.tagName === "INPUT" && e.getAttribute("type") === "hidden";
  return n || i;
}
function V5(e, t, n, i, s) {
  const o = [t, n, ...i];
  [].forEach.call(e.children, (u) => {
    const h = !o.includes(u), f = !dM(u);
    h && f && Sg(u, s);
  });
}
function cb(e, t) {
  let n = -1;
  return e.some((i, s) => t(i) ? (n = s, !0) : !1), n;
}
function hM(e, t) {
  const n = [], i = e.container;
  if (!t.disableScrollLock) {
    if (uM(i)) {
      const u = V3(Pu(i));
      n.push({
        value: i.style.paddingRight,
        property: "padding-right",
        el: i
      }), i.style.paddingRight = `${L5(i) + u}px`;
      const h = ga(i).querySelectorAll(".mui-fixed");
      [].forEach.call(h, (f) => {
        n.push({
          value: f.style.paddingRight,
          property: "padding-right",
          el: f
        }), f.style.paddingRight = `${L5(f) + u}px`;
      });
    }
    let o;
    if (i.parentNode instanceof DocumentFragment)
      o = ga(i).body;
    else {
      const u = i.parentElement, h = Pu(i);
      o = (u == null ? void 0 : u.nodeName) === "HTML" && h.getComputedStyle(u).overflowY === "scroll" ? u : i;
    }
    n.push({
      value: o.style.overflow,
      property: "overflow",
      el: o
    }, {
      value: o.style.overflowX,
      property: "overflow-x",
      el: o
    }, {
      value: o.style.overflowY,
      property: "overflow-y",
      el: o
    }), o.style.overflow = "hidden";
  }
  return () => {
    n.forEach(({
      value: o,
      el: u,
      property: h
    }) => {
      o ? u.style.setProperty(h, o) : u.style.removeProperty(h);
    });
  };
}
function fM(e) {
  const t = [];
  return [].forEach.call(e.children, (n) => {
    n.getAttribute("aria-hidden") === "true" && t.push(n);
  }), t;
}
class pM {
  constructor() {
    this.modals = [], this.containers = [];
  }
  add(t, n) {
    let i = this.modals.indexOf(t);
    if (i !== -1)
      return i;
    i = this.modals.length, this.modals.push(t), t.modalRef && Sg(t.modalRef, !1);
    const s = fM(n);
    V5(n, t.mount, t.modalRef, s, !0);
    const o = cb(this.containers, (u) => u.container === n);
    return o !== -1 ? (this.containers[o].modals.push(t), i) : (this.containers.push({
      modals: [t],
      container: n,
      restore: null,
      hiddenSiblings: s
    }), i);
  }
  mount(t, n) {
    const i = cb(this.containers, (o) => o.modals.includes(t)), s = this.containers[i];
    s.restore || (s.restore = hM(s, n));
  }
  remove(t, n = !0) {
    const i = this.modals.indexOf(t);
    if (i === -1)
      return i;
    const s = cb(this.containers, (u) => u.modals.includes(t)), o = this.containers[s];
    if (o.modals.splice(o.modals.indexOf(t), 1), this.modals.splice(i, 1), o.modals.length === 0)
      o.restore && o.restore(), t.modalRef && Sg(t.modalRef, n), V5(o.container, t.mount, t.modalRef, o.hiddenSiblings, !1), this.containers.splice(s, 1);
    else {
      const u = o.modals[o.modals.length - 1];
      u.modalRef && Sg(u.modalRef, !1);
    }
    return i;
  }
  isTopModal(t) {
    return this.modals.length > 0 && this.modals[this.modals.length - 1] === t;
  }
}
const mM = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
function gM(e) {
  const t = parseInt(e.getAttribute("tabindex") || "", 10);
  return Number.isNaN(t) ? e.contentEditable === "true" || (e.nodeName === "AUDIO" || e.nodeName === "VIDEO" || e.nodeName === "DETAILS") && e.getAttribute("tabindex") === null ? 0 : e.tabIndex : t;
}
function yM(e) {
  if (e.tagName !== "INPUT" || e.type !== "radio" || !e.name)
    return !1;
  const t = (i) => e.ownerDocument.querySelector(`input[type="radio"]${i}`);
  let n = t(`[name="${e.name}"]:checked`);
  return n || (n = t(`[name="${e.name}"]`)), n !== e;
}
function vM(e) {
  return !(e.disabled || e.tagName === "INPUT" && e.type === "hidden" || yM(e));
}
function bM(e) {
  const t = [], n = [];
  return Array.from(e.querySelectorAll(mM)).forEach((i, s) => {
    const o = gM(i);
    o === -1 || !vM(i) || (o === 0 ? t.push(i) : n.push({
      documentOrder: s,
      tabIndex: o,
      node: i
    }));
  }), n.sort((i, s) => i.tabIndex === s.tabIndex ? i.documentOrder - s.documentOrder : i.tabIndex - s.tabIndex).map((i) => i.node).concat(t);
}
function _M() {
  return !0;
}
function SM(e) {
  const {
    children: t,
    disableAutoFocus: n = !1,
    disableEnforceFocus: i = !1,
    disableRestoreFocus: s = !1,
    getTabbable: o = bM,
    isEnabled: u = _M,
    open: h
  } = e, f = tt.useRef(!1), p = tt.useRef(null), g = tt.useRef(null), v = tt.useRef(null), x = tt.useRef(null), b = tt.useRef(!1), _ = tt.useRef(null), T = jr(up(t), _), A = tt.useRef(null);
  tt.useEffect(() => {
    !h || !_.current || (b.current = !n);
  }, [n, h]), tt.useEffect(() => {
    if (!h || !_.current)
      return;
    const E = ga(_.current);
    return _.current.contains(E.activeElement) || (_.current.hasAttribute("tabIndex") || _.current.setAttribute("tabIndex", "-1"), b.current && _.current.focus()), () => {
      s || (v.current && v.current.focus && (f.current = !0, v.current.focus()), v.current = null);
    };
  }, [h]), tt.useEffect(() => {
    if (!h || !_.current)
      return;
    const E = ga(_.current), R = (q) => {
      A.current = q, !(i || !u() || q.key !== "Tab") && E.activeElement === _.current && q.shiftKey && (f.current = !0, g.current && g.current.focus());
    }, N = () => {
      var V, D;
      const q = _.current;
      if (q === null)
        return;
      if (!E.hasFocus() || !u() || f.current) {
        f.current = !1;
        return;
      }
      if (q.contains(E.activeElement) || i && E.activeElement !== p.current && E.activeElement !== g.current)
        return;
      if (E.activeElement !== x.current)
        x.current = null;
      else if (x.current !== null)
        return;
      if (!b.current)
        return;
      let j = [];
      if ((E.activeElement === p.current || E.activeElement === g.current) && (j = o(_.current)), j.length > 0) {
        const G = !!((V = A.current) != null && V.shiftKey && ((D = A.current) == null ? void 0 : D.key) === "Tab"), W = j[0], P = j[j.length - 1];
        typeof W != "string" && typeof P != "string" && (G ? P.focus() : W.focus());
      } else
        q.focus();
    };
    E.addEventListener("focusin", N), E.addEventListener("keydown", R, !0);
    const U = setInterval(() => {
      E.activeElement && E.activeElement.tagName === "BODY" && N();
    }, 50);
    return () => {
      clearInterval(U), E.removeEventListener("focusin", N), E.removeEventListener("keydown", R, !0);
    };
  }, [n, i, s, u, h, o]);
  const O = (E) => {
    v.current === null && (v.current = E.relatedTarget), b.current = !0, x.current = E.target;
    const R = t.props.onFocus;
    R && R(E);
  }, M = (E) => {
    v.current === null && (v.current = E.relatedTarget), b.current = !0;
  };
  return /* @__PURE__ */ J.jsxs(tt.Fragment, {
    children: [/* @__PURE__ */ J.jsx("div", {
      tabIndex: h ? 0 : -1,
      onFocus: M,
      ref: p,
      "data-testid": "sentinelStart"
    }), /* @__PURE__ */ tt.cloneElement(t, {
      ref: T,
      onFocus: O
    }), /* @__PURE__ */ J.jsx("div", {
      tabIndex: h ? 0 : -1,
      onFocus: M,
      ref: g,
      "data-testid": "sentinelEnd"
    })]
  });
}
function xM(e) {
  return typeof e == "function" ? e() : e;
}
function TM(e) {
  return e ? e.props.hasOwnProperty("in") : !1;
}
const I5 = () => {
}, Ty = new pM();
function CM(e) {
  const {
    container: t,
    disableEscapeKeyDown: n = !1,
    disableScrollLock: i = !1,
    closeAfterTransition: s = !1,
    onTransitionEnter: o,
    onTransitionExited: u,
    children: h,
    onClose: f,
    open: p,
    rootRef: g
  } = e, v = tt.useRef({}), x = tt.useRef(null), b = tt.useRef(null), _ = jr(b, g), [T, A] = tt.useState(!p), O = TM(h);
  let M = !0;
  (e["aria-hidden"] === "false" || e["aria-hidden"] === !1) && (M = !1);
  const E = () => ga(x.current), R = () => (v.current.modalRef = b.current, v.current.mount = x.current, v.current), N = () => {
    Ty.mount(R(), {
      disableScrollLock: i
    }), b.current && (b.current.scrollTop = 0);
  }, U = Oo(() => {
    const I = xM(t) || E().body;
    Ty.add(R(), I), b.current && N();
  }), q = () => Ty.isTopModal(R()), j = Oo((I) => {
    x.current = I, I && (p && q() ? N() : b.current && Sg(b.current, M));
  }), V = tt.useCallback(() => {
    Ty.remove(R(), M);
  }, [M]);
  tt.useEffect(() => () => {
    V();
  }, [V]), tt.useEffect(() => {
    p ? U() : (!O || !s) && V();
  }, [p, V, O, s, U]);
  const D = (I) => (K) => {
    var Q;
    (Q = I.onKeyDown) == null || Q.call(I, K), !(K.key !== "Escape" || K.which === 229 || // Wait until IME is settled.
    !q()) && (n || (K.stopPropagation(), f && f(K, "escapeKeyDown")));
  }, G = (I) => (K) => {
    var Q;
    (Q = I.onClick) == null || Q.call(I, K), K.target === K.currentTarget && f && f(K, "backdropClick");
  };
  return {
    getRootProps: (I = {}) => {
      const K = vg(e);
      delete K.onTransitionEnter, delete K.onTransitionExited;
      const Q = {
        ...K,
        ...I
      };
      return {
        /*
         * Marking an element with the role presentation indicates to assistive technology
         * that this element should be ignored; it exists to support the web application and
         * is not meant for humans to interact with directly.
         * https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/no-static-element-interactions.md
         */
        role: "presentation",
        ...Q,
        onKeyDown: D(Q),
        ref: _
      };
    },
    getBackdropProps: (I = {}) => {
      const K = I;
      return {
        "aria-hidden": !0,
        ...K,
        onClick: G(K),
        open: p
      };
    },
    getTransitionProps: () => {
      const I = () => {
        A(!1), o && o();
      }, K = () => {
        A(!0), u && u(), s && V();
      };
      return {
        onEnter: a5(I, (h == null ? void 0 : h.props.onEnter) ?? I5),
        onExited: a5(K, (h == null ? void 0 : h.props.onExited) ?? I5)
      };
    },
    rootRef: _,
    portalRef: j,
    isTopModal: q,
    exited: T,
    hasTransition: O
  };
}
function wM(e) {
  return Un("MuiModal", e);
}
zn("MuiModal", ["root", "hidden", "backdrop"]);
const EM = (e) => {
  const {
    open: t,
    exited: n,
    classes: i
  } = e;
  return jn({
    root: ["root", !t && n && "hidden"],
    backdrop: ["backdrop"]
  }, wM, i);
}, AM = Ne("div", {
  name: "MuiModal",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, !n.open && n.exited && t.hidden];
  }
})(En(({
  theme: e
}) => ({
  position: "fixed",
  zIndex: (e.vars || e).zIndex.modal,
  right: 0,
  bottom: 0,
  top: 0,
  left: 0,
  variants: [{
    props: ({
      ownerState: t
    }) => !t.open && t.exited,
    style: {
      visibility: "hidden"
    }
  }]
}))), MM = Ne(JA, {
  name: "MuiModal",
  slot: "Backdrop",
  overridesResolver: (e, t) => t.backdrop
})({
  zIndex: -1
}), bT = /* @__PURE__ */ tt.forwardRef(function(t, n) {
  const i = In({
    name: "MuiModal",
    props: t
  }), {
    BackdropComponent: s = MM,
    BackdropProps: o,
    classes: u,
    className: h,
    closeAfterTransition: f = !1,
    children: p,
    container: g,
    component: v,
    components: x = {},
    componentsProps: b = {},
    disableAutoFocus: _ = !1,
    disableEnforceFocus: T = !1,
    disableEscapeKeyDown: A = !1,
    disablePortal: O = !1,
    disableRestoreFocus: M = !1,
    disableScrollLock: E = !1,
    hideBackdrop: R = !1,
    keepMounted: N = !1,
    onBackdropClick: U,
    onClose: q,
    onTransitionEnter: j,
    onTransitionExited: V,
    open: D,
    slotProps: G = {},
    slots: W = {},
    // eslint-disable-next-line react/prop-types
    theme: P,
    ...H
  } = i, I = {
    ...i,
    closeAfterTransition: f,
    disableAutoFocus: _,
    disableEnforceFocus: T,
    disableEscapeKeyDown: A,
    disablePortal: O,
    disableRestoreFocus: M,
    disableScrollLock: E,
    hideBackdrop: R,
    keepMounted: N
  }, {
    getRootProps: K,
    getBackdropProps: Q,
    getTransitionProps: it,
    portalRef: nt,
    isTopModal: X,
    exited: rt,
    hasTransition: vt
  } = CM({
    ...I,
    rootRef: n
  }), ct = {
    ...I,
    exited: rt
  }, dt = EM(ct), ht = {};
  if (p.props.tabIndex === void 0 && (ht.tabIndex = "-1"), vt) {
    const {
      onEnter: Bt,
      onExited: Ot
    } = it();
    ht.onEnter = Bt, ht.onExited = Ot;
  }
  const Et = {
    slots: {
      root: x.Root,
      backdrop: x.Backdrop,
      ...W
    },
    slotProps: {
      ...b,
      ...G
    }
  }, [ot, lt] = gr("root", {
    ref: n,
    elementType: AM,
    externalForwardedProps: {
      ...Et,
      ...H,
      component: v
    },
    getSlotProps: K,
    ownerState: ct,
    className: Fe(h, dt == null ? void 0 : dt.root, !ct.open && ct.exited && (dt == null ? void 0 : dt.hidden))
  }), [ft, Tt] = gr("backdrop", {
    ref: o == null ? void 0 : o.ref,
    elementType: s,
    externalForwardedProps: Et,
    shouldForwardComponentProp: !0,
    additionalProps: o,
    getSlotProps: (Bt) => Q({
      ...Bt,
      onClick: (Ot) => {
        U && U(Ot), Bt != null && Bt.onClick && Bt.onClick(Ot);
      }
    }),
    className: Fe(o == null ? void 0 : o.className, dt == null ? void 0 : dt.backdrop),
    ownerState: ct
  });
  return !N && !D && (!vt || rt) ? null : /* @__PURE__ */ J.jsx(gT, {
    ref: nt,
    container: g,
    disablePortal: O,
    children: /* @__PURE__ */ J.jsxs(ot, {
      ...lt,
      children: [!R && s ? /* @__PURE__ */ J.jsx(ft, {
        ...Tt
      }) : null, /* @__PURE__ */ J.jsx(SM, {
        disableEnforceFocus: T,
        disableAutoFocus: _,
        disableRestoreFocus: M,
        isEnabled: X,
        open: D,
        children: /* @__PURE__ */ tt.cloneElement(p, ht)
      })]
    })
  });
});
function RM(e) {
  return Un("MuiDivider", e);
}
const F5 = zn("MuiDivider", ["root", "absolute", "fullWidth", "inset", "middle", "flexItem", "light", "vertical", "withChildren", "withChildrenVertical", "textAlignRight", "textAlignLeft", "wrapper", "wrapperVertical"]), OM = (e) => {
  const {
    absolute: t,
    children: n,
    classes: i,
    flexItem: s,
    light: o,
    orientation: u,
    textAlign: h,
    variant: f
  } = e;
  return jn({
    root: ["root", t && "absolute", f, o && "light", u === "vertical" && "vertical", s && "flexItem", n && "withChildren", n && u === "vertical" && "withChildrenVertical", h === "right" && u !== "vertical" && "textAlignRight", h === "left" && u !== "vertical" && "textAlignLeft"],
    wrapper: ["wrapper", u === "vertical" && "wrapperVertical"]
  }, RM, i);
}, NM = Ne("div", {
  name: "MuiDivider",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.absolute && t.absolute, t[n.variant], n.light && t.light, n.orientation === "vertical" && t.vertical, n.flexItem && t.flexItem, n.children && t.withChildren, n.children && n.orientation === "vertical" && t.withChildrenVertical, n.textAlign === "right" && n.orientation !== "vertical" && t.textAlignRight, n.textAlign === "left" && n.orientation !== "vertical" && t.textAlignLeft];
  }
})(En(({
  theme: e
}) => ({
  margin: 0,
  // Reset browser default style.
  flexShrink: 0,
  borderWidth: 0,
  borderStyle: "solid",
  borderColor: (e.vars || e).palette.divider,
  borderBottomWidth: "thin",
  variants: [{
    props: {
      absolute: !0
    },
    style: {
      position: "absolute",
      bottom: 0,
      left: 0,
      width: "100%"
    }
  }, {
    props: {
      light: !0
    },
    style: {
      borderColor: e.vars ? `rgba(${e.vars.palette.dividerChannel} / 0.08)` : xi(e.palette.divider, 0.08)
    }
  }, {
    props: {
      variant: "inset"
    },
    style: {
      marginLeft: 72
    }
  }, {
    props: {
      variant: "middle",
      orientation: "horizontal"
    },
    style: {
      marginLeft: e.spacing(2),
      marginRight: e.spacing(2)
    }
  }, {
    props: {
      variant: "middle",
      orientation: "vertical"
    },
    style: {
      marginTop: e.spacing(1),
      marginBottom: e.spacing(1)
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      height: "100%",
      borderBottomWidth: 0,
      borderRightWidth: "thin"
    }
  }, {
    props: {
      flexItem: !0
    },
    style: {
      alignSelf: "stretch",
      height: "auto"
    }
  }, {
    props: ({
      ownerState: t
    }) => !!t.children,
    style: {
      display: "flex",
      textAlign: "center",
      border: 0,
      borderTopStyle: "solid",
      borderLeftStyle: "solid",
      "&::before, &::after": {
        content: '""',
        alignSelf: "center"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.children && t.orientation !== "vertical",
    style: {
      "&::before, &::after": {
        width: "100%",
        borderTop: `thin solid ${(e.vars || e).palette.divider}`,
        borderTopStyle: "inherit"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.orientation === "vertical" && t.children,
    style: {
      flexDirection: "column",
      "&::before, &::after": {
        height: "100%",
        borderLeft: `thin solid ${(e.vars || e).palette.divider}`,
        borderLeftStyle: "inherit"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.textAlign === "right" && t.orientation !== "vertical",
    style: {
      "&::before": {
        width: "90%"
      },
      "&::after": {
        width: "10%"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.textAlign === "left" && t.orientation !== "vertical",
    style: {
      "&::before": {
        width: "10%"
      },
      "&::after": {
        width: "90%"
      }
    }
  }]
}))), kM = Ne("span", {
  name: "MuiDivider",
  slot: "Wrapper",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.wrapper, n.orientation === "vertical" && t.wrapperVertical];
  }
})(En(({
  theme: e
}) => ({
  display: "inline-block",
  paddingLeft: `calc(${e.spacing(1)} * 1.2)`,
  paddingRight: `calc(${e.spacing(1)} * 1.2)`,
  whiteSpace: "nowrap",
  variants: [{
    props: {
      orientation: "vertical"
    },
    style: {
      paddingTop: `calc(${e.spacing(1)} * 1.2)`,
      paddingBottom: `calc(${e.spacing(1)} * 1.2)`
    }
  }]
}))), e2 = /* @__PURE__ */ tt.forwardRef(function(t, n) {
  const i = In({
    props: t,
    name: "MuiDivider"
  }), {
    absolute: s = !1,
    children: o,
    className: u,
    orientation: h = "horizontal",
    component: f = o || h === "vertical" ? "div" : "hr",
    flexItem: p = !1,
    light: g = !1,
    role: v = f !== "hr" ? "separator" : void 0,
    textAlign: x = "center",
    variant: b = "fullWidth",
    ..._
  } = i, T = {
    ...i,
    absolute: s,
    component: f,
    flexItem: p,
    light: g,
    orientation: h,
    role: v,
    textAlign: x,
    variant: b
  }, A = OM(T);
  return /* @__PURE__ */ J.jsx(NM, {
    as: f,
    className: Fe(A.root, u),
    role: v,
    ref: n,
    ownerState: T,
    "aria-orientation": v === "separator" && (f !== "hr" || h === "vertical") ? h : void 0,
    ..._,
    children: o ? /* @__PURE__ */ J.jsx(kM, {
      className: A.wrapper,
      ownerState: T,
      children: o
    }) : null
  });
});
e2 && (e2.muiSkipListHighlight = !0);
const DM = (e) => {
  const {
    classes: t,
    disableUnderline: n,
    startAdornment: i,
    endAdornment: s,
    size: o,
    hiddenLabel: u,
    multiline: h
  } = e, f = {
    root: ["root", !n && "underline", i && "adornedStart", s && "adornedEnd", o === "small" && `size${Ue(o)}`, u && "hiddenLabel", h && "multiline"],
    input: ["input"]
  }, p = jn(f, KA, t);
  return {
    ...t,
    // forward classes to the InputBase
    ...p
  };
}, BM = Ne(H1, {
  shouldForwardProp: (e) => Po(e) || e === "classes",
  name: "MuiFilledInput",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [...q1(e, t), !n.disableUnderline && t.underline];
  }
})(En(({
  theme: e
}) => {
  const t = e.palette.mode === "light", n = t ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)", i = t ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)", s = t ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)", o = t ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
  return {
    position: "relative",
    backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : i,
    borderTopLeftRadius: (e.vars || e).shape.borderRadius,
    borderTopRightRadius: (e.vars || e).shape.borderRadius,
    transition: e.transitions.create("background-color", {
      duration: e.transitions.duration.shorter,
      easing: e.transitions.easing.easeOut
    }),
    "&:hover": {
      backgroundColor: e.vars ? e.vars.palette.FilledInput.hoverBg : s,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : i
      }
    },
    [`&.${vh.focused}`]: {
      backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : i
    },
    [`&.${vh.disabled}`]: {
      backgroundColor: e.vars ? e.vars.palette.FilledInput.disabledBg : o
    },
    variants: [{
      props: ({
        ownerState: u
      }) => !u.disableUnderline,
      style: {
        "&::after": {
          left: 0,
          bottom: 0,
          content: '""',
          position: "absolute",
          right: 0,
          transform: "scaleX(0)",
          transition: e.transitions.create("transform", {
            duration: e.transitions.duration.shorter,
            easing: e.transitions.easing.easeOut
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&.${vh.focused}:after`]: {
          // translateX(0) is a workaround for Safari transform scale bug
          // See https://github.com/mui/material-ui/issues/31766
          transform: "scaleX(1) translateX(0)"
        },
        [`&.${vh.error}`]: {
          "&::before, &::after": {
            borderBottomColor: (e.vars || e).palette.error.main
          }
        },
        "&::before": {
          borderBottom: `1px solid ${e.vars ? `rgba(${e.vars.palette.common.onBackgroundChannel} / ${e.vars.opacity.inputUnderline})` : n}`,
          left: 0,
          bottom: 0,
          content: '"\\00a0"',
          position: "absolute",
          right: 0,
          transition: e.transitions.create("border-bottom-color", {
            duration: e.transitions.duration.shorter
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&:hover:not(.${vh.disabled}, .${vh.error}):before`]: {
          borderBottom: `1px solid ${(e.vars || e).palette.text.primary}`
        },
        [`&.${vh.disabled}:before`]: {
          borderBottomStyle: "dotted"
        }
      }
    }, ...Object.entries(e.palette).filter(Qs()).map(([u]) => {
      var h;
      return {
        props: {
          disableUnderline: !1,
          color: u
        },
        style: {
          "&::after": {
            borderBottom: `2px solid ${(h = (e.vars || e).palette[u]) == null ? void 0 : h.main}`
          }
        }
      };
    }), {
      props: ({
        ownerState: u
      }) => u.startAdornment,
      style: {
        paddingLeft: 12
      }
    }, {
      props: ({
        ownerState: u
      }) => u.endAdornment,
      style: {
        paddingRight: 12
      }
    }, {
      props: ({
        ownerState: u
      }) => u.multiline,
      style: {
        padding: "25px 12px 8px"
      }
    }, {
      props: ({
        ownerState: u,
        size: h
      }) => u.multiline && h === "small",
      style: {
        paddingTop: 21,
        paddingBottom: 4
      }
    }, {
      props: ({
        ownerState: u
      }) => u.multiline && u.hiddenLabel,
      style: {
        paddingTop: 16,
        paddingBottom: 17
      }
    }, {
      props: ({
        ownerState: u
      }) => u.multiline && u.hiddenLabel && u.size === "small",
      style: {
        paddingTop: 8,
        paddingBottom: 9
      }
    }]
  };
})), zM = Ne(K1, {
  name: "MuiFilledInput",
  slot: "Input",
  overridesResolver: G1
})(En(({
  theme: e
}) => ({
  paddingTop: 25,
  paddingRight: 12,
  paddingBottom: 8,
  paddingLeft: 12,
  ...!e.vars && {
    "&:-webkit-autofill": {
      WebkitBoxShadow: e.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
      WebkitTextFillColor: e.palette.mode === "light" ? null : "#fff",
      caretColor: e.palette.mode === "light" ? null : "#fff",
      borderTopLeftRadius: "inherit",
      borderTopRightRadius: "inherit"
    }
  },
  ...e.vars && {
    "&:-webkit-autofill": {
      borderTopLeftRadius: "inherit",
      borderTopRightRadius: "inherit"
    },
    [e.getColorSchemeSelector("dark")]: {
      "&:-webkit-autofill": {
        WebkitBoxShadow: "0 0 0 100px #266798 inset",
        WebkitTextFillColor: "#fff",
        caretColor: "#fff"
      }
    }
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      paddingTop: 21,
      paddingBottom: 4
    }
  }, {
    props: ({
      ownerState: t
    }) => t.hiddenLabel,
    style: {
      paddingTop: 16,
      paddingBottom: 17
    }
  }, {
    props: ({
      ownerState: t
    }) => t.startAdornment,
    style: {
      paddingLeft: 0
    }
  }, {
    props: ({
      ownerState: t
    }) => t.endAdornment,
    style: {
      paddingRight: 0
    }
  }, {
    props: ({
      ownerState: t
    }) => t.hiddenLabel && t.size === "small",
    style: {
      paddingTop: 8,
      paddingBottom: 9
    }
  }, {
    props: ({
      ownerState: t
    }) => t.multiline,
    style: {
      paddingTop: 0,
      paddingBottom: 0,
      paddingLeft: 0,
      paddingRight: 0
    }
  }]
}))), Q2 = /* @__PURE__ */ tt.forwardRef(function(t, n) {
  const i = In({
    props: t,
    name: "MuiFilledInput"
  }), {
    disableUnderline: s = !1,
    components: o = {},
    componentsProps: u,
    fullWidth: h = !1,
    hiddenLabel: f,
    // declare here to prevent spreading to DOM
    inputComponent: p = "input",
    multiline: g = !1,
    slotProps: v,
    slots: x = {},
    type: b = "text",
    ..._
  } = i, T = {
    ...i,
    disableUnderline: s,
    fullWidth: h,
    inputComponent: p,
    multiline: g,
    type: b
  }, A = DM(i), O = {
    root: {
      ownerState: T
    },
    input: {
      ownerState: T
    }
  }, M = v ?? u ? Na(O, v ?? u) : O, E = x.root ?? o.Root ?? BM, R = x.input ?? o.Input ?? zM;
  return /* @__PURE__ */ J.jsx($2, {
    slots: {
      root: E,
      input: R
    },
    slotProps: M,
    fullWidth: h,
    inputComponent: p,
    multiline: g,
    ref: n,
    type: b,
    ..._,
    classes: A
  });
});
Q2.muiName = "Input";
function PM(e) {
  return Un("MuiFormControl", e);
}
zn("MuiFormControl", ["root", "marginNone", "marginNormal", "marginDense", "fullWidth", "disabled"]);
const UM = (e) => {
  const {
    classes: t,
    margin: n,
    fullWidth: i
  } = e, s = {
    root: ["root", n !== "none" && `margin${Ue(n)}`, i && "fullWidth"]
  };
  return jn(s, PM, t);
}, jM = Ne("div", {
  name: "MuiFormControl",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, t[`margin${Ue(n.margin)}`], n.fullWidth && t.fullWidth];
  }
})({
  display: "inline-flex",
  flexDirection: "column",
  position: "relative",
  // Reset fieldset default style.
  minWidth: 0,
  padding: 0,
  margin: 0,
  border: 0,
  verticalAlign: "top",
  // Fix alignment issue on Safari.
  variants: [{
    props: {
      margin: "normal"
    },
    style: {
      marginTop: 16,
      marginBottom: 8
    }
  }, {
    props: {
      margin: "dense"
    },
    style: {
      marginTop: 8,
      marginBottom: 4
    }
  }, {
    props: {
      fullWidth: !0
    },
    style: {
      width: "100%"
    }
  }]
}), LM = /* @__PURE__ */ tt.forwardRef(function(t, n) {
  const i = In({
    props: t,
    name: "MuiFormControl"
  }), {
    children: s,
    className: o,
    color: u = "primary",
    component: h = "div",
    disabled: f = !1,
    error: p = !1,
    focused: g,
    fullWidth: v = !1,
    hiddenLabel: x = !1,
    margin: b = "none",
    required: _ = !1,
    size: T = "medium",
    variant: A = "outlined",
    ...O
  } = i, M = {
    ...i,
    color: u,
    component: h,
    disabled: f,
    error: p,
    fullWidth: v,
    hiddenLabel: x,
    margin: b,
    required: _,
    size: T,
    variant: A
  }, E = UM(M), [R, N] = tt.useState(() => {
    let I = !1;
    return s && tt.Children.forEach(s, (K) => {
      if (!rb(K, ["Input", "Select"]))
        return;
      const Q = rb(K, ["Select"]) ? K.props.input : K;
      Q && IA(Q.props) && (I = !0);
    }), I;
  }), [U, q] = tt.useState(() => {
    let I = !1;
    return s && tt.Children.forEach(s, (K) => {
      rb(K, ["Input", "Select"]) && (i1(K.props, !0) || i1(K.props.inputProps, !0)) && (I = !0);
    }), I;
  }), [j, V] = tt.useState(!1);
  f && j && V(!1);
  const D = g !== void 0 && !f ? g : j;
  let G;
  tt.useRef(!1);
  const W = tt.useCallback(() => {
    q(!0);
  }, []), P = tt.useCallback(() => {
    q(!1);
  }, []), H = tt.useMemo(() => ({
    adornedStart: R,
    setAdornedStart: N,
    color: u,
    disabled: f,
    error: p,
    filled: U,
    focused: D,
    fullWidth: v,
    hiddenLabel: x,
    size: T,
    onBlur: () => {
      V(!1);
    },
    onFocus: () => {
      V(!0);
    },
    onEmpty: P,
    onFilled: W,
    registerEffect: G,
    required: _,
    variant: A
  }), [R, u, f, p, U, D, v, x, G, P, W, _, T, A]);
  return /* @__PURE__ */ J.jsx(W2.Provider, {
    value: H,
    children: /* @__PURE__ */ J.jsx(jM, {
      as: h,
      ownerState: M,
      className: Fe(E.root, o),
      ref: n,
      ...O,
      children: s
    })
  });
});
function VM(e) {
  return Un("MuiFormHelperText", e);
}
const q5 = zn("MuiFormHelperText", ["root", "error", "disabled", "sizeSmall", "sizeMedium", "contained", "focused", "filled", "required"]);
var G5;
const IM = (e) => {
  const {
    classes: t,
    contained: n,
    size: i,
    disabled: s,
    error: o,
    filled: u,
    focused: h,
    required: f
  } = e, p = {
    root: ["root", s && "disabled", o && "error", i && `size${Ue(i)}`, n && "contained", h && "focused", u && "filled", f && "required"]
  };
  return jn(p, VM, t);
}, FM = Ne("p", {
  name: "MuiFormHelperText",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.size && t[`size${Ue(n.size)}`], n.contained && t.contained, n.filled && t.filled];
  }
})(En(({
  theme: e
}) => ({
  color: (e.vars || e).palette.text.secondary,
  ...e.typography.caption,
  textAlign: "left",
  marginTop: 3,
  marginRight: 0,
  marginBottom: 0,
  marginLeft: 0,
  [`&.${q5.disabled}`]: {
    color: (e.vars || e).palette.text.disabled
  },
  [`&.${q5.error}`]: {
    color: (e.vars || e).palette.error.main
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      marginTop: 4
    }
  }, {
    props: ({
      ownerState: t
    }) => t.contained,
    style: {
      marginLeft: 14,
      marginRight: 14
    }
  }]
}))), qM = /* @__PURE__ */ tt.forwardRef(function(t, n) {
  const i = In({
    props: t,
    name: "MuiFormHelperText"
  }), {
    children: s,
    className: o,
    component: u = "p",
    disabled: h,
    error: f,
    filled: p,
    focused: g,
    margin: v,
    required: x,
    variant: b,
    ..._
  } = i, T = hp(), A = dp({
    props: i,
    muiFormControl: T,
    states: ["variant", "size", "disabled", "error", "filled", "focused", "required"]
  }), O = {
    ...i,
    component: u,
    contained: A.variant === "filled" || A.variant === "outlined",
    variant: A.variant,
    size: A.size,
    disabled: A.disabled,
    error: A.error,
    filled: A.filled,
    focused: A.focused,
    required: A.required
  };
  delete O.ownerState;
  const M = IM(O);
  return /* @__PURE__ */ J.jsx(FM, {
    as: u,
    className: Fe(M.root, o),
    ref: n,
    ..._,
    ownerState: O,
    children: s === " " ? (
      // notranslate needed while Google Translate will not fix zero-width space issue
      G5 || (G5 = /* @__PURE__ */ J.jsx("span", {
        className: "notranslate",
        "aria-hidden": !0,
        children: "​"
      }))
    ) : s
  });
});
function GM(e) {
  return Un("MuiFormLabel", e);
}
const xg = zn("MuiFormLabel", ["root", "colorSecondary", "focused", "disabled", "error", "filled", "required", "asterisk"]), HM = (e) => {
  const {
    classes: t,
    color: n,
    focused: i,
    disabled: s,
    error: o,
    filled: u,
    required: h
  } = e, f = {
    root: ["root", `color${Ue(n)}`, s && "disabled", o && "error", u && "filled", i && "focused", h && "required"],
    asterisk: ["asterisk", o && "error"]
  };
  return jn(f, GM, t);
}, KM = Ne("label", {
  name: "MuiFormLabel",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.color === "secondary" && t.colorSecondary, n.filled && t.filled];
  }
})(En(({
  theme: e
}) => ({
  color: (e.vars || e).palette.text.secondary,
  ...e.typography.body1,
  lineHeight: "1.4375em",
  padding: 0,
  position: "relative",
  variants: [...Object.entries(e.palette).filter(Qs()).map(([t]) => ({
    props: {
      color: t
    },
    style: {
      [`&.${xg.focused}`]: {
        color: (e.vars || e).palette[t].main
      }
    }
  })), {
    props: {},
    style: {
      [`&.${xg.disabled}`]: {
        color: (e.vars || e).palette.text.disabled
      },
      [`&.${xg.error}`]: {
        color: (e.vars || e).palette.error.main
      }
    }
  }]
}))), YM = Ne("span", {
  name: "MuiFormLabel",
  slot: "Asterisk",
  overridesResolver: (e, t) => t.asterisk
})(En(({
  theme: e
}) => ({
  [`&.${xg.error}`]: {
    color: (e.vars || e).palette.error.main
  }
}))), XM = /* @__PURE__ */ tt.forwardRef(function(t, n) {
  const i = In({
    props: t,
    name: "MuiFormLabel"
  }), {
    children: s,
    className: o,
    color: u,
    component: h = "label",
    disabled: f,
    error: p,
    filled: g,
    focused: v,
    required: x,
    ...b
  } = i, _ = hp(), T = dp({
    props: i,
    muiFormControl: _,
    states: ["color", "required", "focused", "disabled", "error", "filled"]
  }), A = {
    ...i,
    color: T.color || "primary",
    component: h,
    disabled: T.disabled,
    error: T.error,
    filled: T.filled,
    focused: T.focused,
    required: T.required
  }, O = HM(A);
  return /* @__PURE__ */ J.jsxs(KM, {
    as: h,
    ownerState: A,
    className: Fe(O.root, o),
    ref: n,
    ...b,
    children: [s, T.required && /* @__PURE__ */ J.jsxs(YM, {
      ownerState: A,
      "aria-hidden": !0,
      className: O.asterisk,
      children: [" ", "*"]
    })]
  });
});
function n2(e) {
  return `scale(${e}, ${e ** 2})`;
}
const WM = {
  entering: {
    opacity: 1,
    transform: n2(1)
  },
  entered: {
    opacity: 1,
    transform: "none"
  }
}, ub = typeof navigator < "u" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent), r1 = /* @__PURE__ */ tt.forwardRef(function(t, n) {
  const {
    addEndListener: i,
    appear: s = !0,
    children: o,
    easing: u,
    in: h,
    onEnter: f,
    onEntered: p,
    onEntering: g,
    onExit: v,
    onExited: x,
    onExiting: b,
    style: _,
    timeout: T = "auto",
    // eslint-disable-next-line react/prop-types
    TransitionComponent: A = Nc,
    ...O
  } = t, M = jf(), E = tt.useRef(), R = L1(), N = tt.useRef(null), U = jr(N, up(o), n), q = (I) => (K) => {
    if (I) {
      const Q = N.current;
      K === void 0 ? I(Q) : I(Q, K);
    }
  }, j = q(g), V = q((I, K) => {
    aT(I);
    const {
      duration: Q,
      delay: it,
      easing: nt
    } = t1({
      style: _,
      timeout: T,
      easing: u
    }, {
      mode: "enter"
    });
    let X;
    T === "auto" ? (X = R.transitions.getAutoHeightDuration(I.clientHeight), E.current = X) : X = Q, I.style.transition = [R.transitions.create("opacity", {
      duration: X,
      delay: it
    }), R.transitions.create("transform", {
      duration: ub ? X : X * 0.666,
      delay: it,
      easing: nt
    })].join(","), f && f(I, K);
  }), D = q(p), G = q(b), W = q((I) => {
    const {
      duration: K,
      delay: Q,
      easing: it
    } = t1({
      style: _,
      timeout: T,
      easing: u
    }, {
      mode: "exit"
    });
    let nt;
    T === "auto" ? (nt = R.transitions.getAutoHeightDuration(I.clientHeight), E.current = nt) : nt = K, I.style.transition = [R.transitions.create("opacity", {
      duration: nt,
      delay: Q
    }), R.transitions.create("transform", {
      duration: ub ? nt : nt * 0.666,
      delay: ub ? Q : Q || nt * 0.333,
      easing: it
    })].join(","), I.style.opacity = 0, I.style.transform = n2(0.75), v && v(I);
  }), P = q(x), H = (I) => {
    T === "auto" && M.start(E.current || 0, I), i && i(N.current, I);
  };
  return /* @__PURE__ */ J.jsx(A, {
    appear: s,
    in: h,
    nodeRef: N,
    onEnter: V,
    onEntered: D,
    onEntering: j,
    onExit: W,
    onExited: P,
    onExiting: G,
    addEndListener: H,
    timeout: T === "auto" ? null : T,
    ...O,
    children: (I, {
      ownerState: K,
      ...Q
    }) => /* @__PURE__ */ tt.cloneElement(o, {
      style: {
        opacity: 0,
        transform: n2(0.75),
        visibility: I === "exited" && !h ? "hidden" : void 0,
        ...WM[I],
        ..._,
        ...o.props.style
      },
      ref: U,
      ...Q
    })
  });
});
r1 && (r1.muiSupportAuto = !0);
const $M = (e) => {
  const {
    classes: t,
    disableUnderline: n
  } = e, s = jn({
    root: ["root", !n && "underline"],
    input: ["input"]
  }, GA, t);
  return {
    ...t,
    // forward classes to the InputBase
    ...s
  };
}, QM = Ne(H1, {
  shouldForwardProp: (e) => Po(e) || e === "classes",
  name: "MuiInput",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [...q1(e, t), !n.disableUnderline && t.underline];
  }
})(En(({
  theme: e
}) => {
  let n = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
  return e.vars && (n = `rgba(${e.vars.palette.common.onBackgroundChannel} / ${e.vars.opacity.inputUnderline})`), {
    position: "relative",
    variants: [{
      props: ({
        ownerState: i
      }) => i.formControl,
      style: {
        "label + &": {
          marginTop: 16
        }
      }
    }, {
      props: ({
        ownerState: i
      }) => !i.disableUnderline,
      style: {
        "&::after": {
          left: 0,
          bottom: 0,
          content: '""',
          position: "absolute",
          right: 0,
          transform: "scaleX(0)",
          transition: e.transitions.create("transform", {
            duration: e.transitions.duration.shorter,
            easing: e.transitions.easing.easeOut
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&.${mm.focused}:after`]: {
          // translateX(0) is a workaround for Safari transform scale bug
          // See https://github.com/mui/material-ui/issues/31766
          transform: "scaleX(1) translateX(0)"
        },
        [`&.${mm.error}`]: {
          "&::before, &::after": {
            borderBottomColor: (e.vars || e).palette.error.main
          }
        },
        "&::before": {
          borderBottom: `1px solid ${n}`,
          left: 0,
          bottom: 0,
          content: '"\\00a0"',
          position: "absolute",
          right: 0,
          transition: e.transitions.create("border-bottom-color", {
            duration: e.transitions.duration.shorter
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&:hover:not(.${mm.disabled}, .${mm.error}):before`]: {
          borderBottom: `2px solid ${(e.vars || e).palette.text.primary}`,
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            borderBottom: `1px solid ${n}`
          }
        },
        [`&.${mm.disabled}:before`]: {
          borderBottomStyle: "dotted"
        }
      }
    }, ...Object.entries(e.palette).filter(Qs()).map(([i]) => ({
      props: {
        color: i,
        disableUnderline: !1
      },
      style: {
        "&::after": {
          borderBottom: `2px solid ${(e.vars || e).palette[i].main}`
        }
      }
    }))]
  };
})), ZM = Ne(K1, {
  name: "MuiInput",
  slot: "Input",
  overridesResolver: G1
})({}), Z2 = /* @__PURE__ */ tt.forwardRef(function(t, n) {
  const i = In({
    props: t,
    name: "MuiInput"
  }), {
    disableUnderline: s = !1,
    components: o = {},
    componentsProps: u,
    fullWidth: h = !1,
    inputComponent: f = "input",
    multiline: p = !1,
    slotProps: g,
    slots: v = {},
    type: x = "text",
    ...b
  } = i, _ = $M(i), A = {
    root: {
      ownerState: {
        disableUnderline: s
      }
    }
  }, O = g ?? u ? Na(g ?? u, A) : A, M = v.root ?? o.Root ?? QM, E = v.input ?? o.Input ?? ZM;
  return /* @__PURE__ */ J.jsx($2, {
    slots: {
      root: M,
      input: E
    },
    slotProps: O,
    fullWidth: h,
    inputComponent: f,
    multiline: p,
    ref: n,
    type: x,
    ...b,
    classes: _
  });
});
Z2.muiName = "Input";
function JM(e) {
  return Un("MuiInputLabel", e);
}
zn("MuiInputLabel", ["root", "focused", "disabled", "error", "required", "asterisk", "formControl", "sizeSmall", "shrink", "animated", "standard", "filled", "outlined"]);
const tR = (e) => {
  const {
    classes: t,
    formControl: n,
    size: i,
    shrink: s,
    disableAnimation: o,
    variant: u,
    required: h
  } = e, f = {
    root: ["root", n && "formControl", !o && "animated", s && "shrink", i && i !== "normal" && `size${Ue(i)}`, u],
    asterisk: [h && "asterisk"]
  }, p = jn(f, JM, t);
  return {
    ...t,
    // forward the focused, disabled, etc. classes to the FormLabel
    ...p
  };
}, eR = Ne(XM, {
  shouldForwardProp: (e) => Po(e) || e === "classes",
  name: "MuiInputLabel",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [{
      [`& .${xg.asterisk}`]: t.asterisk
    }, t.root, n.formControl && t.formControl, n.size === "small" && t.sizeSmall, n.shrink && t.shrink, !n.disableAnimation && t.animated, n.focused && t.focused, t[n.variant]];
  }
})(En(({
  theme: e
}) => ({
  display: "block",
  transformOrigin: "top left",
  whiteSpace: "nowrap",
  overflow: "hidden",
  textOverflow: "ellipsis",
  maxWidth: "100%",
  variants: [{
    props: ({
      ownerState: t
    }) => t.formControl,
    style: {
      position: "absolute",
      left: 0,
      top: 0,
      // slight alteration to spec spacing to match visual spec result
      transform: "translate(0, 20px) scale(1)"
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      // Compensation for the `Input.inputSizeSmall` style.
      transform: "translate(0, 17px) scale(1)"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.shrink,
    style: {
      transform: "translate(0, -1.5px) scale(0.75)",
      transformOrigin: "top left",
      maxWidth: "133%"
    }
  }, {
    props: ({
      ownerState: t
    }) => !t.disableAnimation,
    style: {
      transition: e.transitions.create(["color", "transform", "max-width"], {
        duration: e.transitions.duration.shorter,
        easing: e.transitions.easing.easeOut
      })
    }
  }, {
    props: {
      variant: "filled"
    },
    style: {
      // Chrome's autofill feature gives the input field a yellow background.
      // Since the input field is behind the label in the HTML tree,
      // the input field is drawn last and hides the label with an opaque background color.
      // zIndex: 1 will raise the label above opaque background-colors of input.
      zIndex: 1,
      pointerEvents: "none",
      transform: "translate(12px, 16px) scale(1)",
      maxWidth: "calc(100% - 24px)"
    }
  }, {
    props: {
      variant: "filled",
      size: "small"
    },
    style: {
      transform: "translate(12px, 13px) scale(1)"
    }
  }, {
    props: ({
      variant: t,
      ownerState: n
    }) => t === "filled" && n.shrink,
    style: {
      userSelect: "none",
      pointerEvents: "auto",
      transform: "translate(12px, 7px) scale(0.75)",
      maxWidth: "calc(133% - 24px)"
    }
  }, {
    props: ({
      variant: t,
      ownerState: n,
      size: i
    }) => t === "filled" && n.shrink && i === "small",
    style: {
      transform: "translate(12px, 4px) scale(0.75)"
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      // see comment above on filled.zIndex
      zIndex: 1,
      pointerEvents: "none",
      transform: "translate(14px, 16px) scale(1)",
      maxWidth: "calc(100% - 24px)"
    }
  }, {
    props: {
      variant: "outlined",
      size: "small"
    },
    style: {
      transform: "translate(14px, 9px) scale(1)"
    }
  }, {
    props: ({
      variant: t,
      ownerState: n
    }) => t === "outlined" && n.shrink,
    style: {
      userSelect: "none",
      pointerEvents: "auto",
      // Theoretically, we should have (8+5)*2/0.75 = 34px
      // but it feels a better when it bleeds a bit on the left, so 32px.
      maxWidth: "calc(133% - 32px)",
      transform: "translate(14px, -9px) scale(0.75)"
    }
  }]
}))), nR = /* @__PURE__ */ tt.forwardRef(function(t, n) {
  const i = In({
    name: "MuiInputLabel",
    props: t
  }), {
    disableAnimation: s = !1,
    margin: o,
    shrink: u,
    variant: h,
    className: f,
    ...p
  } = i, g = hp();
  let v = u;
  typeof v > "u" && g && (v = g.filled || g.focused || g.adornedStart);
  const x = dp({
    props: i,
    muiFormControl: g,
    states: ["size", "variant", "required", "focused"]
  }), b = {
    ...i,
    disableAnimation: s,
    formControl: g,
    shrink: v,
    size: x.size,
    variant: x.variant,
    required: x.required,
    focused: x.focused
  }, _ = tR(b);
  return /* @__PURE__ */ J.jsx(eR, {
    "data-shrink": v,
    ref: n,
    className: Fe(_.root, f),
    ...p,
    ownerState: b,
    classes: _
  });
}), kg = /* @__PURE__ */ tt.createContext({});
function iR(e) {
  return Un("MuiList", e);
}
zn("MuiList", ["root", "padding", "dense", "subheader"]);
const rR = (e) => {
  const {
    classes: t,
    disablePadding: n,
    dense: i,
    subheader: s
  } = e;
  return jn({
    root: ["root", !n && "padding", i && "dense", s && "subheader"]
  }, iR, t);
}, aR = Ne("ul", {
  name: "MuiList",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, !n.disablePadding && t.padding, n.dense && t.dense, n.subheader && t.subheader];
  }
})({
  listStyle: "none",
  margin: 0,
  padding: 0,
  position: "relative",
  variants: [{
    props: ({
      ownerState: e
    }) => !e.disablePadding,
    style: {
      paddingTop: 8,
      paddingBottom: 8
    }
  }, {
    props: ({
      ownerState: e
    }) => e.subheader,
    style: {
      paddingTop: 0
    }
  }]
}), sR = /* @__PURE__ */ tt.forwardRef(function(t, n) {
  const i = In({
    props: t,
    name: "MuiList"
  }), {
    children: s,
    className: o,
    component: u = "ul",
    dense: h = !1,
    disablePadding: f = !1,
    subheader: p,
    ...g
  } = i, v = tt.useMemo(() => ({
    dense: h
  }), [h]), x = {
    ...i,
    component: u,
    dense: h,
    disablePadding: f
  }, b = rR(x);
  return /* @__PURE__ */ J.jsx(kg.Provider, {
    value: v,
    children: /* @__PURE__ */ J.jsxs(aR, {
      as: u,
      className: Fe(b.root, o),
      ref: n,
      ownerState: x,
      ...g,
      children: [p, s]
    })
  });
});
function oR(e) {
  return Un("MuiListItemIcon", e);
}
const H5 = zn("MuiListItemIcon", ["root", "alignItemsFlexStart"]), lR = (e) => {
  const {
    alignItems: t,
    classes: n
  } = e;
  return jn({
    root: ["root", t === "flex-start" && "alignItemsFlexStart"]
  }, oR, n);
}, cR = Ne("div", {
  name: "MuiListItemIcon",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.alignItems === "flex-start" && t.alignItemsFlexStart];
  }
})(En(({
  theme: e
}) => ({
  minWidth: 56,
  color: (e.vars || e).palette.action.active,
  flexShrink: 0,
  display: "inline-flex",
  variants: [{
    props: {
      alignItems: "flex-start"
    },
    style: {
      marginTop: 8
    }
  }]
}))), db = /* @__PURE__ */ tt.forwardRef(function(t, n) {
  const i = In({
    props: t,
    name: "MuiListItemIcon"
  }), {
    className: s,
    ...o
  } = i, u = tt.useContext(kg), h = {
    ...i,
    alignItems: u.alignItems
  }, f = lR(h);
  return /* @__PURE__ */ J.jsx(cR, {
    className: Fe(f.root, s),
    ownerState: h,
    ref: n,
    ...o
  });
});
function uR(e) {
  return Un("MuiListItemText", e);
}
const Lf = zn("MuiListItemText", ["root", "multiline", "dense", "inset", "primary", "secondary"]), dR = (e) => {
  const {
    classes: t,
    inset: n,
    primary: i,
    secondary: s,
    dense: o
  } = e;
  return jn({
    root: ["root", n && "inset", o && "dense", i && s && "multiline"],
    primary: ["primary"],
    secondary: ["secondary"]
  }, uR, t);
}, hR = Ne("div", {
  name: "MuiListItemText",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [{
      [`& .${Lf.primary}`]: t.primary
    }, {
      [`& .${Lf.secondary}`]: t.secondary
    }, t.root, n.inset && t.inset, n.primary && n.secondary && t.multiline, n.dense && t.dense];
  }
})({
  flex: "1 1 auto",
  minWidth: 0,
  marginTop: 4,
  marginBottom: 4,
  [`.${T5.root}:where(& .${Lf.primary})`]: {
    display: "block"
  },
  [`.${T5.root}:where(& .${Lf.secondary})`]: {
    display: "block"
  },
  variants: [{
    props: ({
      ownerState: e
    }) => e.primary && e.secondary,
    style: {
      marginTop: 6,
      marginBottom: 6
    }
  }, {
    props: ({
      ownerState: e
    }) => e.inset,
    style: {
      paddingLeft: 56
    }
  }]
}), hb = /* @__PURE__ */ tt.forwardRef(function(t, n) {
  const i = In({
    props: t,
    name: "MuiListItemText"
  }), {
    children: s,
    className: o,
    disableTypography: u = !1,
    inset: h = !1,
    primary: f,
    primaryTypographyProps: p,
    secondary: g,
    secondaryTypographyProps: v,
    slots: x = {},
    slotProps: b = {},
    ..._
  } = i, {
    dense: T
  } = tt.useContext(kg);
  let A = f ?? s, O = g;
  const M = {
    ...i,
    disableTypography: u,
    inset: h,
    primary: !!A,
    secondary: !!O,
    dense: T
  }, E = dR(M), R = {
    slots: x,
    slotProps: {
      primary: p,
      secondary: v,
      ...b
    }
  }, [N, U] = gr("root", {
    className: Fe(E.root, o),
    elementType: hR,
    externalForwardedProps: {
      ...R,
      ..._
    },
    ownerState: M,
    ref: n
  }), [q, j] = gr("primary", {
    className: E.primary,
    elementType: Wa,
    externalForwardedProps: R,
    ownerState: M
  }), [V, D] = gr("secondary", {
    className: E.secondary,
    elementType: Wa,
    externalForwardedProps: R,
    ownerState: M
  });
  return A != null && A.type !== Wa && !u && (A = /* @__PURE__ */ J.jsx(q, {
    variant: T ? "body2" : "body1",
    component: j != null && j.variant ? void 0 : "span",
    ...j,
    children: A
  })), O != null && O.type !== Wa && !u && (O = /* @__PURE__ */ J.jsx(V, {
    variant: "body2",
    color: "textSecondary",
    ...D,
    children: O
  })), /* @__PURE__ */ J.jsxs(N, {
    ...U,
    children: [A, O]
  });
});
function fb(e, t, n) {
  return e === t ? e.firstChild : t && t.nextElementSibling ? t.nextElementSibling : n ? null : e.firstChild;
}
function K5(e, t, n) {
  return e === t ? n ? e.firstChild : e.lastChild : t && t.previousElementSibling ? t.previousElementSibling : n ? null : e.lastChild;
}
function _T(e, t) {
  if (t === void 0)
    return !0;
  let n = e.innerText;
  return n === void 0 && (n = e.textContent), n = n.trim().toLowerCase(), n.length === 0 ? !1 : t.repeating ? n[0] === t.keys[0] : n.startsWith(t.keys.join(""));
}
function gm(e, t, n, i, s, o) {
  let u = !1, h = s(e, t, t ? n : !1);
  for (; h; ) {
    if (h === e.firstChild) {
      if (u)
        return !1;
      u = !0;
    }
    const f = i ? !1 : h.disabled || h.getAttribute("aria-disabled") === "true";
    if (!h.hasAttribute("tabindex") || !_T(h, o) || f)
      h = s(e, h, n);
    else
      return h.focus(), !0;
  }
  return !1;
}
const fR = /* @__PURE__ */ tt.forwardRef(function(t, n) {
  const {
    // private
    // eslint-disable-next-line react/prop-types
    actions: i,
    autoFocus: s = !1,
    autoFocusItem: o = !1,
    children: u,
    className: h,
    disabledItemsFocusable: f = !1,
    disableListWrap: p = !1,
    onKeyDown: g,
    variant: v = "selectedMenu",
    ...x
  } = t, b = tt.useRef(null), _ = tt.useRef({
    keys: [],
    repeating: !0,
    previousKeyMatched: !0,
    lastTime: null
  });
  ko(() => {
    s && b.current.focus();
  }, [s]), tt.useImperativeHandle(i, () => ({
    adjustStyleForScrollbar: (E, {
      direction: R
    }) => {
      const N = !b.current.style.width;
      if (E.clientHeight < b.current.clientHeight && N) {
        const U = `${V3(Pu(E))}px`;
        b.current.style[R === "rtl" ? "paddingLeft" : "paddingRight"] = U, b.current.style.width = `calc(100% + ${U})`;
      }
      return b.current;
    }
  }), []);
  const T = (E) => {
    const R = b.current, N = E.key;
    if (E.ctrlKey || E.metaKey || E.altKey) {
      g && g(E);
      return;
    }
    const q = ga(R).activeElement;
    if (N === "ArrowDown")
      E.preventDefault(), gm(R, q, p, f, fb);
    else if (N === "ArrowUp")
      E.preventDefault(), gm(R, q, p, f, K5);
    else if (N === "Home")
      E.preventDefault(), gm(R, null, p, f, fb);
    else if (N === "End")
      E.preventDefault(), gm(R, null, p, f, K5);
    else if (N.length === 1) {
      const j = _.current, V = N.toLowerCase(), D = performance.now();
      j.keys.length > 0 && (D - j.lastTime > 500 ? (j.keys = [], j.repeating = !0, j.previousKeyMatched = !0) : j.repeating && V !== j.keys[0] && (j.repeating = !1)), j.lastTime = D, j.keys.push(V);
      const G = q && !j.repeating && _T(q, j);
      j.previousKeyMatched && (G || gm(R, q, !1, f, fb, j)) ? E.preventDefault() : j.previousKeyMatched = !1;
    }
    g && g(E);
  }, A = jr(b, n);
  let O = -1;
  tt.Children.forEach(u, (E, R) => {
    if (!/* @__PURE__ */ tt.isValidElement(E)) {
      O === R && (O += 1, O >= u.length && (O = -1));
      return;
    }
    E.props.disabled || (v === "selectedMenu" && E.props.selected || O === -1) && (O = R), O === R && (E.props.disabled || E.props.muiSkipListHighlight || E.type.muiSkipListHighlight) && (O += 1, O >= u.length && (O = -1));
  });
  const M = tt.Children.map(u, (E, R) => {
    if (R === O) {
      const N = {};
      return o && (N.autoFocus = !0), E.props.tabIndex === void 0 && v === "selectedMenu" && (N.tabIndex = 0), /* @__PURE__ */ tt.cloneElement(E, N);
    }
    return E;
  });
  return /* @__PURE__ */ J.jsx(sR, {
    role: "menu",
    ref: A,
    className: h,
    onKeyDown: T,
    tabIndex: s ? 0 : -1,
    ...x,
    children: M
  });
});
function pR(e) {
  return Un("MuiPopover", e);
}
zn("MuiPopover", ["root", "paper"]);
function Y5(e, t) {
  let n = 0;
  return typeof t == "number" ? n = t : t === "center" ? n = e.height / 2 : t === "bottom" && (n = e.height), n;
}
function X5(e, t) {
  let n = 0;
  return typeof t == "number" ? n = t : t === "center" ? n = e.width / 2 : t === "right" && (n = e.width), n;
}
function W5(e) {
  return [e.horizontal, e.vertical].map((t) => typeof t == "number" ? `${t}px` : t).join(" ");
}
function pb(e) {
  return typeof e == "function" ? e() : e;
}
const mR = (e) => {
  const {
    classes: t
  } = e;
  return jn({
    root: ["root"],
    paper: ["paper"]
  }, pR, t);
}, gR = Ne(bT, {
  name: "MuiPopover",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({}), ST = Ne(G9, {
  name: "MuiPopover",
  slot: "Paper",
  overridesResolver: (e, t) => t.paper
})({
  position: "absolute",
  overflowY: "auto",
  overflowX: "hidden",
  // So we see the popover when it's empty.
  // It's most likely on issue on userland.
  minWidth: 16,
  minHeight: 16,
  maxWidth: "calc(100% - 32px)",
  maxHeight: "calc(100% - 32px)",
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
}), xT = /* @__PURE__ */ tt.forwardRef(function(t, n) {
  const i = In({
    props: t,
    name: "MuiPopover"
  }), {
    action: s,
    anchorEl: o,
    anchorOrigin: u = {
      vertical: "top",
      horizontal: "left"
    },
    anchorPosition: h,
    anchorReference: f = "anchorEl",
    children: p,
    className: g,
    container: v,
    elevation: x = 8,
    marginThreshold: b = 16,
    open: _,
    PaperProps: T = {},
    // TODO: remove in v7
    slots: A = {},
    slotProps: O = {},
    transformOrigin: M = {
      vertical: "top",
      horizontal: "left"
    },
    TransitionComponent: E,
    // TODO: remove in v7
    transitionDuration: R = "auto",
    TransitionProps: N = {},
    // TODO: remove in v7
    disableScrollLock: U = !1,
    ...q
  } = i, j = tt.useRef(), V = {
    ...i,
    anchorOrigin: u,
    anchorReference: f,
    elevation: x,
    marginThreshold: b,
    transformOrigin: M,
    TransitionComponent: E,
    transitionDuration: R,
    TransitionProps: N
  }, D = mR(V), G = tt.useCallback(() => {
    if (f === "anchorPosition")
      return h;
    const Tt = pb(o), Ot = (Tt && Tt.nodeType === 1 ? Tt : ga(j.current).body).getBoundingClientRect();
    return {
      top: Ot.top + Y5(Ot, u.vertical),
      left: Ot.left + X5(Ot, u.horizontal)
    };
  }, [o, u.horizontal, u.vertical, h, f]), W = tt.useCallback((Tt) => ({
    vertical: Y5(Tt, M.vertical),
    horizontal: X5(Tt, M.horizontal)
  }), [M.horizontal, M.vertical]), P = tt.useCallback((Tt) => {
    const Bt = {
      width: Tt.offsetWidth,
      height: Tt.offsetHeight
    }, Ot = W(Bt);
    if (f === "none")
      return {
        top: null,
        left: null,
        transformOrigin: W5(Ot)
      };
    const ie = G();
    let ce = ie.top - Ot.vertical, Ut = ie.left - Ot.horizontal;
    const se = ce + Bt.height, re = Ut + Bt.width, ue = Pu(pb(o)), Ae = ue.innerHeight - b, ve = ue.innerWidth - b;
    if (b !== null && ce < b) {
      const Re = ce - b;
      ce -= Re, Ot.vertical += Re;
    } else if (b !== null && se > Ae) {
      const Re = se - Ae;
      ce -= Re, Ot.vertical += Re;
    }
    if (b !== null && Ut < b) {
      const Re = Ut - b;
      Ut -= Re, Ot.horizontal += Re;
    } else if (re > ve) {
      const Re = re - ve;
      Ut -= Re, Ot.horizontal += Re;
    }
    return {
      top: `${Math.round(ce)}px`,
      left: `${Math.round(Ut)}px`,
      transformOrigin: W5(Ot)
    };
  }, [o, f, G, W, b]), [H, I] = tt.useState(_), K = tt.useCallback(() => {
    const Tt = j.current;
    if (!Tt)
      return;
    const Bt = P(Tt);
    Bt.top !== null && Tt.style.setProperty("top", Bt.top), Bt.left !== null && (Tt.style.left = Bt.left), Tt.style.transformOrigin = Bt.transformOrigin, I(!0);
  }, [P]);
  tt.useEffect(() => (U && window.addEventListener("scroll", K), () => window.removeEventListener("scroll", K)), [o, U, K]);
  const Q = () => {
    K();
  }, it = () => {
    I(!1);
  };
  tt.useEffect(() => {
    _ && K();
  }), tt.useImperativeHandle(s, () => _ ? {
    updatePosition: () => {
      K();
    }
  } : null, [_, K]), tt.useEffect(() => {
    if (!_)
      return;
    const Tt = j3(() => {
      K();
    }), Bt = Pu(o);
    return Bt.addEventListener("resize", Tt), () => {
      Tt.clear(), Bt.removeEventListener("resize", Tt);
    };
  }, [o, _, K]);
  let nt = R;
  const X = {
    slots: {
      transition: E,
      ...A
    },
    slotProps: {
      transition: N,
      paper: T,
      ...O
    }
  }, [rt, vt] = gr("transition", {
    elementType: r1,
    externalForwardedProps: X,
    ownerState: V,
    getSlotProps: (Tt) => ({
      ...Tt,
      onEntering: (Bt, Ot) => {
        var ie;
        (ie = Tt.onEntering) == null || ie.call(Tt, Bt, Ot), Q();
      },
      onExited: (Bt) => {
        var Ot;
        (Ot = Tt.onExited) == null || Ot.call(Tt, Bt), it();
      }
    }),
    additionalProps: {
      appear: !0,
      in: _
    }
  });
  R === "auto" && !rt.muiSupportAuto && (nt = void 0);
  const ct = v || (o ? ga(pb(o)).body : void 0), [dt, {
    slots: ht,
    slotProps: Et,
    ...ot
  }] = gr("root", {
    ref: n,
    elementType: gR,
    externalForwardedProps: {
      ...X,
      ...q
    },
    shouldForwardComponentProp: !0,
    additionalProps: {
      slots: {
        backdrop: A.backdrop
      },
      slotProps: {
        backdrop: D9(typeof O.backdrop == "function" ? O.backdrop(V) : O.backdrop, {
          invisible: !0
        })
      },
      container: ct,
      open: _
    },
    ownerState: V,
    className: Fe(D.root, g)
  }), [lt, ft] = gr("paper", {
    ref: j,
    className: D.paper,
    elementType: ST,
    externalForwardedProps: X,
    shouldForwardComponentProp: !0,
    additionalProps: {
      elevation: x,
      style: H ? void 0 : {
        opacity: 0
      }
    },
    ownerState: V
  });
  return /* @__PURE__ */ J.jsx(dt, {
    ...ot,
    ...!Dh(dt) && {
      slots: ht,
      slotProps: Et,
      disableScrollLock: U
    },
    children: /* @__PURE__ */ J.jsx(rt, {
      ...vt,
      timeout: nt,
      children: /* @__PURE__ */ J.jsx(lt, {
        ...ft,
        children: p
      })
    })
  });
});
function yR(e) {
  return Un("MuiMenu", e);
}
zn("MuiMenu", ["root", "paper", "list"]);
const vR = {
  vertical: "top",
  horizontal: "right"
}, bR = {
  vertical: "top",
  horizontal: "left"
}, _R = (e) => {
  const {
    classes: t
  } = e;
  return jn({
    root: ["root"],
    paper: ["paper"],
    list: ["list"]
  }, yR, t);
}, SR = Ne(xT, {
  shouldForwardProp: (e) => Po(e) || e === "classes",
  name: "MuiMenu",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({}), xR = Ne(ST, {
  name: "MuiMenu",
  slot: "Paper",
  overridesResolver: (e, t) => t.paper
})({
  // specZ: The maximum height of a simple menu should be one or more rows less than the view
  // height. This ensures a tappable area outside of the simple menu with which to dismiss
  // the menu.
  maxHeight: "calc(100% - 96px)",
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch"
}), TR = Ne(fR, {
  name: "MuiMenu",
  slot: "List",
  overridesResolver: (e, t) => t.list
})({
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
}), J2 = /* @__PURE__ */ tt.forwardRef(function(t, n) {
  const i = In({
    props: t,
    name: "MuiMenu"
  }), {
    autoFocus: s = !0,
    children: o,
    className: u,
    disableAutoFocusItem: h = !1,
    MenuListProps: f = {},
    onClose: p,
    open: g,
    PaperProps: v = {},
    PopoverClasses: x,
    transitionDuration: b = "auto",
    TransitionProps: {
      onEntering: _,
      ...T
    } = {},
    variant: A = "selectedMenu",
    slots: O = {},
    slotProps: M = {},
    ...E
  } = i, R = U1(), N = {
    ...i,
    autoFocus: s,
    disableAutoFocusItem: h,
    MenuListProps: f,
    onEntering: _,
    PaperProps: v,
    transitionDuration: b,
    TransitionProps: T,
    variant: A
  }, U = _R(N), q = s && !h && g, j = tt.useRef(null), V = (nt, X) => {
    j.current && j.current.adjustStyleForScrollbar(nt, {
      direction: R ? "rtl" : "ltr"
    }), _ && _(nt, X);
  }, D = (nt) => {
    nt.key === "Tab" && (nt.preventDefault(), p && p(nt, "tabKeyDown"));
  };
  let G = -1;
  tt.Children.map(o, (nt, X) => {
    /* @__PURE__ */ tt.isValidElement(nt) && (nt.props.disabled || (A === "selectedMenu" && nt.props.selected || G === -1) && (G = X));
  });
  const W = {
    slots: O,
    slotProps: {
      list: f,
      transition: T,
      paper: v,
      ...M
    }
  }, P = vc({
    elementType: O.root,
    externalSlotProps: M.root,
    ownerState: N,
    className: [U.root, u]
  }), [H, I] = gr("paper", {
    className: U.paper,
    elementType: xR,
    externalForwardedProps: W,
    shouldForwardComponentProp: !0,
    ownerState: N
  }), [K, Q] = gr("list", {
    className: Fe(U.list, f.className),
    elementType: TR,
    shouldForwardComponentProp: !0,
    externalForwardedProps: W,
    getSlotProps: (nt) => ({
      ...nt,
      onKeyDown: (X) => {
        var rt;
        D(X), (rt = nt.onKeyDown) == null || rt.call(nt, X);
      }
    }),
    ownerState: N
  }), it = typeof W.slotProps.transition == "function" ? W.slotProps.transition(N) : W.slotProps.transition;
  return /* @__PURE__ */ J.jsx(SR, {
    onClose: p,
    anchorOrigin: {
      vertical: "bottom",
      horizontal: R ? "right" : "left"
    },
    transformOrigin: R ? vR : bR,
    slots: {
      root: O.root,
      paper: H,
      backdrop: O.backdrop,
      ...O.transition && {
        // TODO: pass `slots.transition` directly once `TransitionComponent` is removed from Popover
        transition: O.transition
      }
    },
    slotProps: {
      root: P,
      paper: I,
      backdrop: typeof M.backdrop == "function" ? M.backdrop(N) : M.backdrop,
      transition: {
        ...it,
        onEntering: (...nt) => {
          var X;
          V(...nt), (X = it == null ? void 0 : it.onEntering) == null || X.call(it, ...nt);
        }
      }
    },
    open: g,
    ref: n,
    transitionDuration: b,
    ownerState: N,
    ...E,
    classes: x,
    children: /* @__PURE__ */ J.jsx(K, {
      actions: j,
      autoFocus: s && (G === -1 || h),
      autoFocusItem: q,
      variant: A,
      ...Q,
      children: o
    })
  });
});
function CR(e) {
  return Un("MuiMenuItem", e);
}
const ym = zn("MuiMenuItem", ["root", "focusVisible", "dense", "disabled", "divider", "gutters", "selected"]), wR = (e, t) => {
  const {
    ownerState: n
  } = e;
  return [t.root, n.dense && t.dense, n.divider && t.divider, !n.disableGutters && t.gutters];
}, ER = (e) => {
  const {
    disabled: t,
    dense: n,
    divider: i,
    disableGutters: s,
    selected: o,
    classes: u
  } = e, f = jn({
    root: ["root", n && "dense", t && "disabled", !s && "gutters", i && "divider", o && "selected"]
  }, CR, u);
  return {
    ...u,
    ...f
  };
}, AR = Ne(I1, {
  shouldForwardProp: (e) => Po(e) || e === "classes",
  name: "MuiMenuItem",
  slot: "Root",
  overridesResolver: wR
})(En(({
  theme: e
}) => ({
  ...e.typography.body1,
  display: "flex",
  justifyContent: "flex-start",
  alignItems: "center",
  position: "relative",
  textDecoration: "none",
  minHeight: 48,
  paddingTop: 6,
  paddingBottom: 6,
  boxSizing: "border-box",
  whiteSpace: "nowrap",
  "&:hover": {
    textDecoration: "none",
    backgroundColor: (e.vars || e).palette.action.hover,
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  [`&.${ym.selected}`]: {
    backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : xi(e.palette.primary.main, e.palette.action.selectedOpacity),
    [`&.${ym.focusVisible}`]: {
      backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.focusOpacity}))` : xi(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.focusOpacity)
    }
  },
  [`&.${ym.selected}:hover`]: {
    backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.hoverOpacity}))` : xi(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : xi(e.palette.primary.main, e.palette.action.selectedOpacity)
    }
  },
  [`&.${ym.focusVisible}`]: {
    backgroundColor: (e.vars || e).palette.action.focus
  },
  [`&.${ym.disabled}`]: {
    opacity: (e.vars || e).palette.action.disabledOpacity
  },
  [`& + .${F5.root}`]: {
    marginTop: e.spacing(1),
    marginBottom: e.spacing(1)
  },
  [`& + .${F5.inset}`]: {
    marginLeft: 52
  },
  [`& .${Lf.root}`]: {
    marginTop: 0,
    marginBottom: 0
  },
  [`& .${Lf.inset}`]: {
    paddingLeft: 36
  },
  [`& .${H5.root}`]: {
    minWidth: 36
  },
  variants: [{
    props: ({
      ownerState: t
    }) => !t.disableGutters,
    style: {
      paddingLeft: 16,
      paddingRight: 16
    }
  }, {
    props: ({
      ownerState: t
    }) => t.divider,
    style: {
      borderBottom: `1px solid ${(e.vars || e).palette.divider}`,
      backgroundClip: "padding-box"
    }
  }, {
    props: ({
      ownerState: t
    }) => !t.dense,
    style: {
      [e.breakpoints.up("sm")]: {
        minHeight: "auto"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.dense,
    style: {
      minHeight: 32,
      // https://m2.material.io/components/menus#specs > Dense
      paddingTop: 4,
      paddingBottom: 4,
      ...e.typography.body2,
      [`& .${H5.root} svg`]: {
        fontSize: "1.25rem"
      }
    }
  }]
}))), Sc = /* @__PURE__ */ tt.forwardRef(function(t, n) {
  const i = In({
    props: t,
    name: "MuiMenuItem"
  }), {
    autoFocus: s = !1,
    component: o = "li",
    dense: u = !1,
    divider: h = !1,
    disableGutters: f = !1,
    focusVisibleClassName: p,
    role: g = "menuitem",
    tabIndex: v,
    className: x,
    ...b
  } = i, _ = tt.useContext(kg), T = tt.useMemo(() => ({
    dense: u || _.dense || !1,
    disableGutters: f
  }), [_.dense, u, f]), A = tt.useRef(null);
  ko(() => {
    s && A.current && A.current.focus();
  }, [s]);
  const O = {
    ...i,
    dense: T.dense,
    divider: h,
    disableGutters: f
  }, M = ER(i), E = jr(A, n);
  let R;
  return i.disabled || (R = v !== void 0 ? v : -1), /* @__PURE__ */ J.jsx(kg.Provider, {
    value: T,
    children: /* @__PURE__ */ J.jsx(AR, {
      ref: E,
      role: g,
      tabIndex: R,
      component: o,
      focusVisibleClassName: Fe(M.focusVisible, p),
      className: Fe(M.root, x),
      ...b,
      ownerState: O,
      classes: M
    })
  });
});
function MR(e) {
  return Un("MuiNativeSelect", e);
}
const t_ = zn("MuiNativeSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]), RR = (e) => {
  const {
    classes: t,
    variant: n,
    disabled: i,
    multiple: s,
    open: o,
    error: u
  } = e, h = {
    select: ["select", n, i && "disabled", s && "multiple", u && "error"],
    icon: ["icon", `icon${Ue(n)}`, o && "iconOpen", i && "disabled"]
  };
  return jn(h, MR, t);
}, TT = Ne("select")(({
  theme: e
}) => ({
  // Reset
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // When interacting quickly, the text can end up selected.
  // Native select can't be selected either.
  userSelect: "none",
  // Reset
  borderRadius: 0,
  cursor: "pointer",
  "&:focus": {
    // Reset Chrome style
    borderRadius: 0
  },
  [`&.${t_.disabled}`]: {
    cursor: "default"
  },
  "&[multiple]": {
    height: "auto"
  },
  "&:not([multiple]) option, &:not([multiple]) optgroup": {
    backgroundColor: (e.vars || e).palette.background.paper
  },
  variants: [{
    props: ({
      ownerState: t
    }) => t.variant !== "filled" && t.variant !== "outlined",
    style: {
      // Bump specificity to allow extending custom inputs
      "&&&": {
        paddingRight: 24,
        minWidth: 16
        // So it doesn't collapse.
      }
    }
  }, {
    props: {
      variant: "filled"
    },
    style: {
      "&&&": {
        paddingRight: 32
      }
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      borderRadius: (e.vars || e).shape.borderRadius,
      "&:focus": {
        borderRadius: (e.vars || e).shape.borderRadius
        // Reset the reset for Chrome style
      },
      "&&&": {
        paddingRight: 32
      }
    }
  }]
})), OR = Ne(TT, {
  name: "MuiNativeSelect",
  slot: "Select",
  shouldForwardProp: Po,
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.select, t[n.variant], n.error && t.error, {
      [`&.${t_.multiple}`]: t.multiple
    }];
  }
})({}), CT = Ne("svg")(({
  theme: e
}) => ({
  // We use a position absolute over a flexbox in order to forward the pointer events
  // to the input and to support wrapping tags..
  position: "absolute",
  right: 0,
  // Center vertically, height is 1em
  top: "calc(50% - .5em)",
  // Don't block pointer events on the select under the icon.
  pointerEvents: "none",
  color: (e.vars || e).palette.action.active,
  [`&.${t_.disabled}`]: {
    color: (e.vars || e).palette.action.disabled
  },
  variants: [{
    props: ({
      ownerState: t
    }) => t.open,
    style: {
      transform: "rotate(180deg)"
    }
  }, {
    props: {
      variant: "filled"
    },
    style: {
      right: 7
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      right: 7
    }
  }]
})), NR = Ne(CT, {
  name: "MuiNativeSelect",
  slot: "Icon",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.icon, n.variant && t[`icon${Ue(n.variant)}`], n.open && t.iconOpen];
  }
})({}), kR = /* @__PURE__ */ tt.forwardRef(function(t, n) {
  const {
    className: i,
    disabled: s,
    error: o,
    IconComponent: u,
    inputRef: h,
    variant: f = "standard",
    ...p
  } = t, g = {
    ...t,
    disabled: s,
    variant: f,
    error: o
  }, v = RR(g);
  return /* @__PURE__ */ J.jsxs(tt.Fragment, {
    children: [/* @__PURE__ */ J.jsx(OR, {
      ownerState: g,
      className: Fe(v.select, i),
      disabled: s,
      ref: h || n,
      ...p
    }), t.multiple ? null : /* @__PURE__ */ J.jsx(NR, {
      as: u,
      ownerState: g,
      className: v.icon
    })]
  });
});
var $5;
const DR = Ne("fieldset", {
  shouldForwardProp: Po
})({
  textAlign: "left",
  position: "absolute",
  bottom: 0,
  right: 0,
  top: -5,
  left: 0,
  margin: 0,
  padding: "0 8px",
  pointerEvents: "none",
  borderRadius: "inherit",
  borderStyle: "solid",
  borderWidth: 1,
  overflow: "hidden",
  minWidth: "0%"
}), BR = Ne("legend", {
  shouldForwardProp: Po
})(En(({
  theme: e
}) => ({
  float: "unset",
  // Fix conflict with bootstrap
  width: "auto",
  // Fix conflict with bootstrap
  overflow: "hidden",
  // Fix Horizontal scroll when label too long
  variants: [{
    props: ({
      ownerState: t
    }) => !t.withLabel,
    style: {
      padding: 0,
      lineHeight: "11px",
      // sync with `height` in `legend` styles
      transition: e.transitions.create("width", {
        duration: 150,
        easing: e.transitions.easing.easeOut
      })
    }
  }, {
    props: ({
      ownerState: t
    }) => t.withLabel,
    style: {
      display: "block",
      // Fix conflict with normalize.css and sanitize.css
      padding: 0,
      height: 11,
      // sync with `lineHeight` in `legend` styles
      fontSize: "0.75em",
      visibility: "hidden",
      maxWidth: 0.01,
      transition: e.transitions.create("max-width", {
        duration: 50,
        easing: e.transitions.easing.easeOut
      }),
      whiteSpace: "nowrap",
      "& > span": {
        paddingLeft: 5,
        paddingRight: 5,
        display: "inline-block",
        opacity: 0,
        visibility: "visible"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.withLabel && t.notched,
    style: {
      maxWidth: "100%",
      transition: e.transitions.create("max-width", {
        duration: 100,
        easing: e.transitions.easing.easeOut,
        delay: 50
      })
    }
  }]
})));
function zR(e) {
  const {
    children: t,
    classes: n,
    className: i,
    label: s,
    notched: o,
    ...u
  } = e, h = s != null && s !== "", f = {
    ...e,
    notched: o,
    withLabel: h
  };
  return /* @__PURE__ */ J.jsx(DR, {
    "aria-hidden": !0,
    className: i,
    ownerState: f,
    ...u,
    children: /* @__PURE__ */ J.jsx(BR, {
      ownerState: f,
      children: h ? /* @__PURE__ */ J.jsx("span", {
        children: s
      }) : (
        // notranslate needed while Google Translate will not fix zero-width space issue
        $5 || ($5 = /* @__PURE__ */ J.jsx("span", {
          className: "notranslate",
          "aria-hidden": !0,
          children: "​"
        }))
      )
    })
  });
}
const PR = (e) => {
  const {
    classes: t
  } = e, i = jn({
    root: ["root"],
    notchedOutline: ["notchedOutline"],
    input: ["input"]
  }, HA, t);
  return {
    ...t,
    // forward classes to the InputBase
    ...i
  };
}, UR = Ne(H1, {
  shouldForwardProp: (e) => Po(e) || e === "classes",
  name: "MuiOutlinedInput",
  slot: "Root",
  overridesResolver: q1
})(En(({
  theme: e
}) => {
  const t = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return {
    position: "relative",
    borderRadius: (e.vars || e).shape.borderRadius,
    [`&:hover .${yc.notchedOutline}`]: {
      borderColor: (e.vars || e).palette.text.primary
    },
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      [`&:hover .${yc.notchedOutline}`]: {
        borderColor: e.vars ? `rgba(${e.vars.palette.common.onBackgroundChannel} / 0.23)` : t
      }
    },
    [`&.${yc.focused} .${yc.notchedOutline}`]: {
      borderWidth: 2
    },
    variants: [...Object.entries(e.palette).filter(Qs()).map(([n]) => ({
      props: {
        color: n
      },
      style: {
        [`&.${yc.focused} .${yc.notchedOutline}`]: {
          borderColor: (e.vars || e).palette[n].main
        }
      }
    })), {
      props: {},
      // to overide the above style
      style: {
        [`&.${yc.error} .${yc.notchedOutline}`]: {
          borderColor: (e.vars || e).palette.error.main
        },
        [`&.${yc.disabled} .${yc.notchedOutline}`]: {
          borderColor: (e.vars || e).palette.action.disabled
        }
      }
    }, {
      props: ({
        ownerState: n
      }) => n.startAdornment,
      style: {
        paddingLeft: 14
      }
    }, {
      props: ({
        ownerState: n
      }) => n.endAdornment,
      style: {
        paddingRight: 14
      }
    }, {
      props: ({
        ownerState: n
      }) => n.multiline,
      style: {
        padding: "16.5px 14px"
      }
    }, {
      props: ({
        ownerState: n,
        size: i
      }) => n.multiline && i === "small",
      style: {
        padding: "8.5px 14px"
      }
    }]
  };
})), jR = Ne(zR, {
  name: "MuiOutlinedInput",
  slot: "NotchedOutline",
  overridesResolver: (e, t) => t.notchedOutline
})(En(({
  theme: e
}) => {
  const t = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return {
    borderColor: e.vars ? `rgba(${e.vars.palette.common.onBackgroundChannel} / 0.23)` : t
  };
})), LR = Ne(K1, {
  name: "MuiOutlinedInput",
  slot: "Input",
  overridesResolver: G1
})(En(({
  theme: e
}) => ({
  padding: "16.5px 14px",
  ...!e.vars && {
    "&:-webkit-autofill": {
      WebkitBoxShadow: e.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
      WebkitTextFillColor: e.palette.mode === "light" ? null : "#fff",
      caretColor: e.palette.mode === "light" ? null : "#fff",
      borderRadius: "inherit"
    }
  },
  ...e.vars && {
    "&:-webkit-autofill": {
      borderRadius: "inherit"
    },
    [e.getColorSchemeSelector("dark")]: {
      "&:-webkit-autofill": {
        WebkitBoxShadow: "0 0 0 100px #266798 inset",
        WebkitTextFillColor: "#fff",
        caretColor: "#fff"
      }
    }
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      padding: "8.5px 14px"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.multiline,
    style: {
      padding: 0
    }
  }, {
    props: ({
      ownerState: t
    }) => t.startAdornment,
    style: {
      paddingLeft: 0
    }
  }, {
    props: ({
      ownerState: t
    }) => t.endAdornment,
    style: {
      paddingRight: 0
    }
  }]
}))), e_ = /* @__PURE__ */ tt.forwardRef(function(t, n) {
  var i;
  const s = In({
    props: t,
    name: "MuiOutlinedInput"
  }), {
    components: o = {},
    fullWidth: u = !1,
    inputComponent: h = "input",
    label: f,
    multiline: p = !1,
    notched: g,
    slots: v = {},
    type: x = "text",
    ...b
  } = s, _ = PR(s), T = hp(), A = dp({
    props: s,
    muiFormControl: T,
    states: ["color", "disabled", "error", "focused", "hiddenLabel", "size", "required"]
  }), O = {
    ...s,
    color: A.color || "primary",
    disabled: A.disabled,
    error: A.error,
    focused: A.focused,
    formControl: T,
    fullWidth: u,
    hiddenLabel: A.hiddenLabel,
    multiline: p,
    size: A.size,
    type: x
  }, M = v.root ?? o.Root ?? UR, E = v.input ?? o.Input ?? LR;
  return /* @__PURE__ */ J.jsx($2, {
    slots: {
      root: M,
      input: E
    },
    renderSuffix: (R) => /* @__PURE__ */ J.jsx(jR, {
      ownerState: O,
      className: _.notchedOutline,
      label: f != null && f !== "" && A.required ? i || (i = /* @__PURE__ */ J.jsxs(tt.Fragment, {
        children: [f, " ", "*"]
      })) : f,
      notched: typeof g < "u" ? g : !!(R.startAdornment || R.filled || R.focused)
    }),
    fullWidth: u,
    inputComponent: h,
    multiline: p,
    ref: n,
    type: x,
    ...b,
    classes: {
      ..._,
      notchedOutline: null
    }
  });
});
e_.muiName = "Input";
function wT(e) {
  return Un("MuiSelect", e);
}
const vm = zn("MuiSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "focused", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]);
var Q5;
const VR = Ne(TT, {
  name: "MuiSelect",
  slot: "Select",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [
      // Win specificity over the input base
      {
        [`&.${vm.select}`]: t.select
      },
      {
        [`&.${vm.select}`]: t[n.variant]
      },
      {
        [`&.${vm.error}`]: t.error
      },
      {
        [`&.${vm.multiple}`]: t.multiple
      }
    ];
  }
})({
  // Win specificity over the input base
  [`&.${vm.select}`]: {
    height: "auto",
    // Resets for multiple select with chips
    minHeight: "1.4375em",
    // Required for select\text-field height consistency
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    overflow: "hidden"
  }
}), IR = Ne(CT, {
  name: "MuiSelect",
  slot: "Icon",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.icon, n.variant && t[`icon${Ue(n.variant)}`], n.open && t.iconOpen];
  }
})({}), FR = Ne("input", {
  shouldForwardProp: (e) => V1(e) && e !== "classes",
  name: "MuiSelect",
  slot: "NativeInput",
  overridesResolver: (e, t) => t.nativeInput
})({
  bottom: 0,
  left: 0,
  position: "absolute",
  opacity: 0,
  pointerEvents: "none",
  width: "100%",
  boxSizing: "border-box"
});
function Z5(e, t) {
  return typeof t == "object" && t !== null ? e === t : String(e) === String(t);
}
function qR(e) {
  return e == null || typeof e == "string" && !e.trim();
}
const GR = (e) => {
  const {
    classes: t,
    variant: n,
    disabled: i,
    multiple: s,
    open: o,
    error: u
  } = e, h = {
    select: ["select", n, i && "disabled", s && "multiple", u && "error"],
    icon: ["icon", `icon${Ue(n)}`, o && "iconOpen", i && "disabled"],
    nativeInput: ["nativeInput"]
  };
  return jn(h, wT, t);
}, HR = /* @__PURE__ */ tt.forwardRef(function(t, n) {
  var Me;
  const {
    "aria-describedby": i,
    "aria-label": s,
    autoFocus: o,
    autoWidth: u,
    children: h,
    className: f,
    defaultOpen: p,
    defaultValue: g,
    disabled: v,
    displayEmpty: x,
    error: b = !1,
    IconComponent: _,
    inputRef: T,
    labelId: A,
    MenuProps: O = {},
    multiple: M,
    name: E,
    onBlur: R,
    onChange: N,
    onClose: U,
    onFocus: q,
    onOpen: j,
    open: V,
    readOnly: D,
    renderValue: G,
    required: W,
    SelectDisplayProps: P = {},
    tabIndex: H,
    // catching `type` from Input which makes no sense for SelectInput
    type: I,
    value: K,
    variant: Q = "standard",
    ...it
  } = t, [nt, X] = Zy({
    controlled: K,
    default: g,
    name: "Select"
  }), [rt, vt] = Zy({
    controlled: V,
    default: p,
    name: "Select"
  }), ct = tt.useRef(null), dt = tt.useRef(null), [ht, Et] = tt.useState(null), {
    current: ot
  } = tt.useRef(V != null), [lt, ft] = tt.useState(), Tt = jr(n, T), Bt = tt.useCallback((Te) => {
    dt.current = Te, Te && Et(Te);
  }, []), Ot = ht == null ? void 0 : ht.parentNode;
  tt.useImperativeHandle(Tt, () => ({
    focus: () => {
      dt.current.focus();
    },
    node: ct.current,
    value: nt
  }), [nt]), tt.useEffect(() => {
    p && rt && ht && !ot && (ft(u ? null : Ot.clientWidth), dt.current.focus());
  }, [ht, u]), tt.useEffect(() => {
    o && dt.current.focus();
  }, [o]), tt.useEffect(() => {
    if (!A)
      return;
    const Te = ga(dt.current).getElementById(A);
    if (Te) {
      const ne = () => {
        getSelection().isCollapsed && dt.current.focus();
      };
      return Te.addEventListener("click", ne), () => {
        Te.removeEventListener("click", ne);
      };
    }
  }, [A]);
  const ie = (Te, ne) => {
    Te ? j && j(ne) : U && U(ne), ot || (ft(u ? null : Ot.clientWidth), vt(Te));
  }, ce = (Te) => {
    Te.button === 0 && (Te.preventDefault(), dt.current.focus(), ie(!0, Te));
  }, Ut = (Te) => {
    ie(!1, Te);
  }, se = tt.Children.toArray(h), re = (Te) => {
    const ne = se.find((Ve) => Ve.props.value === Te.target.value);
    ne !== void 0 && (X(ne.props.value), N && N(Te, ne));
  }, ue = (Te) => (ne) => {
    let Ve;
    if (ne.currentTarget.hasAttribute("tabindex")) {
      if (M) {
        Ve = Array.isArray(nt) ? nt.slice() : [];
        const fn = nt.indexOf(Te.props.value);
        fn === -1 ? Ve.push(Te.props.value) : Ve.splice(fn, 1);
      } else
        Ve = Te.props.value;
      if (Te.props.onClick && Te.props.onClick(ne), nt !== Ve && (X(Ve), N)) {
        const fn = ne.nativeEvent || ne, _r = new fn.constructor(fn.type, fn);
        Object.defineProperty(_r, "target", {
          writable: !0,
          value: {
            value: Ve,
            name: E
          }
        }), N(_r, Te);
      }
      M || ie(!1, ne);
    }
  }, Ae = (Te) => {
    D || [
      " ",
      "ArrowUp",
      "ArrowDown",
      // The native select doesn't respond to enter on macOS, but it's recommended by
      // https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-select-only/
      "Enter"
    ].includes(Te.key) && (Te.preventDefault(), ie(!0, Te));
  }, ve = ht !== null && rt, Re = (Te) => {
    !ve && R && (Object.defineProperty(Te, "target", {
      writable: !0,
      value: {
        value: nt,
        name: E
      }
    }), R(Te));
  };
  delete it["aria-invalid"];
  let oe, Le;
  const De = [];
  let Kt = !1;
  (i1({
    value: nt
  }) || x) && (G ? oe = G(nt) : Kt = !0);
  const te = se.map((Te) => {
    if (!/* @__PURE__ */ tt.isValidElement(Te))
      return null;
    let ne;
    if (M) {
      if (!Array.isArray(nt))
        throw new Error(Bu(2));
      ne = nt.some((Ve) => Z5(Ve, Te.props.value)), ne && Kt && De.push(Te.props.children);
    } else
      ne = Z5(nt, Te.props.value), ne && Kt && (Le = Te.props.children);
    return /* @__PURE__ */ tt.cloneElement(Te, {
      "aria-selected": ne ? "true" : "false",
      onClick: ue(Te),
      onKeyUp: (Ve) => {
        Ve.key === " " && Ve.preventDefault(), Te.props.onKeyUp && Te.props.onKeyUp(Ve);
      },
      role: "option",
      selected: ne,
      value: void 0,
      // The value is most likely not a valid HTML attribute.
      "data-value": Te.props.value
      // Instead, we provide it as a data attribute.
    });
  });
  Kt && (M ? De.length === 0 ? oe = null : oe = De.reduce((Te, ne, Ve) => (Te.push(ne), Ve < De.length - 1 && Te.push(", "), Te), []) : oe = Le);
  let It = lt;
  !u && ot && ht && (It = Ot.clientWidth);
  let Ht;
  typeof H < "u" ? Ht = H : Ht = v ? null : 0;
  const Jt = P.id || (E ? `mui-component-select-${E}` : void 0), Yt = {
    ...t,
    variant: Q,
    value: nt,
    open: ve,
    error: b
  }, ae = GR(Yt), le = {
    ...O.PaperProps,
    ...(Me = O.slotProps) == null ? void 0 : Me.paper
  }, fe = qg();
  return /* @__PURE__ */ J.jsxs(tt.Fragment, {
    children: [/* @__PURE__ */ J.jsx(VR, {
      as: "div",
      ref: Bt,
      tabIndex: Ht,
      role: "combobox",
      "aria-controls": ve ? fe : void 0,
      "aria-disabled": v ? "true" : void 0,
      "aria-expanded": ve ? "true" : "false",
      "aria-haspopup": "listbox",
      "aria-label": s,
      "aria-labelledby": [A, Jt].filter(Boolean).join(" ") || void 0,
      "aria-describedby": i,
      "aria-required": W ? "true" : void 0,
      "aria-invalid": b ? "true" : void 0,
      onKeyDown: Ae,
      onMouseDown: v || D ? null : ce,
      onBlur: Re,
      onFocus: q,
      ...P,
      ownerState: Yt,
      className: Fe(P.className, ae.select, f),
      id: Jt,
      children: qR(oe) ? (
        // notranslate needed while Google Translate will not fix zero-width space issue
        Q5 || (Q5 = /* @__PURE__ */ J.jsx("span", {
          className: "notranslate",
          "aria-hidden": !0,
          children: "​"
        }))
      ) : oe
    }), /* @__PURE__ */ J.jsx(FR, {
      "aria-invalid": b,
      value: Array.isArray(nt) ? nt.join(",") : nt,
      name: E,
      ref: ct,
      "aria-hidden": !0,
      onChange: re,
      tabIndex: -1,
      disabled: v,
      className: ae.nativeInput,
      autoFocus: o,
      required: W,
      ...it,
      ownerState: Yt
    }), /* @__PURE__ */ J.jsx(IR, {
      as: _,
      className: ae.icon,
      ownerState: Yt
    }), /* @__PURE__ */ J.jsx(J2, {
      id: `menu-${E || ""}`,
      anchorEl: Ot,
      open: ve,
      onClose: Ut,
      anchorOrigin: {
        vertical: "bottom",
        horizontal: "center"
      },
      transformOrigin: {
        vertical: "top",
        horizontal: "center"
      },
      ...O,
      slotProps: {
        ...O.slotProps,
        list: {
          "aria-labelledby": A,
          role: "listbox",
          "aria-multiselectable": M ? "true" : void 0,
          disableListWrap: !0,
          id: fe,
          ...O.MenuListProps
        },
        paper: {
          ...le,
          style: {
            minWidth: It,
            ...le != null ? le.style : null
          }
        }
      },
      children: te
    })]
  });
}), KR = (e) => {
  const {
    classes: t
  } = e, i = jn({
    root: ["root"]
  }, wT, t);
  return {
    ...t,
    ...i
  };
}, n_ = {
  name: "MuiSelect",
  overridesResolver: (e, t) => t.root,
  shouldForwardProp: (e) => Po(e) && e !== "variant",
  slot: "Root"
}, YR = Ne(Z2, n_)(""), XR = Ne(e_, n_)(""), WR = Ne(Q2, n_)(""), a1 = /* @__PURE__ */ tt.forwardRef(function(t, n) {
  const i = In({
    name: "MuiSelect",
    props: t
  }), {
    autoWidth: s = !1,
    children: o,
    classes: u = {},
    className: h,
    defaultOpen: f = !1,
    displayEmpty: p = !1,
    IconComponent: g = YA,
    id: v,
    input: x,
    inputProps: b,
    label: _,
    labelId: T,
    MenuProps: A,
    multiple: O = !1,
    native: M = !1,
    onClose: E,
    onOpen: R,
    open: N,
    renderValue: U,
    SelectDisplayProps: q,
    variant: j = "outlined",
    ...V
  } = i, D = M ? kR : HR, G = hp(), W = dp({
    props: i,
    muiFormControl: G,
    states: ["variant", "error"]
  }), P = W.variant || j, H = {
    ...i,
    variant: P,
    classes: u
  }, I = KR(H), {
    root: K,
    ...Q
  } = I, it = x || {
    standard: /* @__PURE__ */ J.jsx(YR, {
      ownerState: H
    }),
    outlined: /* @__PURE__ */ J.jsx(XR, {
      label: _,
      ownerState: H
    }),
    filled: /* @__PURE__ */ J.jsx(WR, {
      ownerState: H
    })
  }[P], nt = jr(n, up(it));
  return /* @__PURE__ */ J.jsx(tt.Fragment, {
    children: /* @__PURE__ */ tt.cloneElement(it, {
      // Most of the logic is implemented in `SelectInput`.
      // The `Select` component is a simple API wrapper to expose something better to play with.
      inputComponent: D,
      inputProps: {
        children: o,
        error: W.error,
        IconComponent: g,
        variant: P,
        type: void 0,
        // We render a select. We can ignore the type provided by the `Input`.
        multiple: O,
        ...M ? {
          id: v
        } : {
          autoWidth: s,
          defaultOpen: f,
          displayEmpty: p,
          labelId: T,
          MenuProps: A,
          onClose: E,
          onOpen: R,
          open: N,
          renderValue: U,
          SelectDisplayProps: {
            id: v,
            ...q
          }
        },
        ...b,
        classes: b ? Na(Q, b.classes) : Q,
        ...x ? x.props.inputProps : {}
      },
      ...(O && M || p) && P === "outlined" ? {
        notched: !0
      } : {},
      ref: nt,
      className: Fe(it.props.className, h, I.root),
      // If a custom input is provided via 'input' prop, do not allow 'variant' to be propagated to it's root element. See https://github.com/mui/material-ui/issues/33894.
      ...!x && {
        variant: P
      },
      ...V
    })
  });
});
a1.muiName = "Select";
function $R(e, t, n = (i, s) => i === s) {
  return e.length === t.length && e.every((i, s) => n(i, t[s]));
}
const QR = 2;
function kf(e, t, n, i, s) {
  return n === 1 ? Math.min(e + t, s) : Math.max(e - t, i);
}
function ET(e, t) {
  return e - t;
}
function J5(e, t) {
  const {
    index: n
  } = e.reduce((i, s, o) => {
    const u = Math.abs(t - s);
    return i === null || u < i.distance || u === i.distance ? {
      distance: u,
      index: o
    } : i;
  }, null) ?? {};
  return n;
}
function Cy(e, t) {
  if (t.current !== void 0 && e.changedTouches) {
    const n = e;
    for (let i = 0; i < n.changedTouches.length; i += 1) {
      const s = n.changedTouches[i];
      if (s.identifier === t.current)
        return {
          x: s.clientX,
          y: s.clientY
        };
    }
    return !1;
  }
  return {
    x: e.clientX,
    y: e.clientY
  };
}
function s1(e, t, n) {
  return (e - t) * 100 / (n - t);
}
function ZR(e, t, n) {
  return (n - t) * e + t;
}
function JR(e) {
  if (Math.abs(e) < 1) {
    const n = e.toExponential().split("e-"), i = n[0].split(".")[1];
    return (i ? i.length : 0) + parseInt(n[1], 10);
  }
  const t = e.toString().split(".")[1];
  return t ? t.length : 0;
}
function tO(e, t, n) {
  const i = Math.round((e - n) / t) * t + n;
  return Number(i.toFixed(JR(t)));
}
function tx({
  values: e,
  newValue: t,
  index: n
}) {
  const i = e.slice();
  return i[n] = t, i.sort(ET);
}
function wy({
  sliderRef: e,
  activeIndex: t,
  setActive: n
}) {
  var s, o, u;
  const i = ga(e.current);
  (!((s = e.current) != null && s.contains(i.activeElement)) || Number((o = i == null ? void 0 : i.activeElement) == null ? void 0 : o.getAttribute("data-index")) !== t) && ((u = e.current) == null || u.querySelector(`[type="range"][data-index="${t}"]`).focus()), n && n(t);
}
function Ey(e, t) {
  return typeof e == "number" && typeof t == "number" ? e === t : typeof e == "object" && typeof t == "object" ? $R(e, t) : !1;
}
const eO = {
  horizontal: {
    offset: (e) => ({
      left: `${e}%`
    }),
    leap: (e) => ({
      width: `${e}%`
    })
  },
  "horizontal-reverse": {
    offset: (e) => ({
      right: `${e}%`
    }),
    leap: (e) => ({
      width: `${e}%`
    })
  },
  vertical: {
    offset: (e) => ({
      bottom: `${e}%`
    }),
    leap: (e) => ({
      height: `${e}%`
    })
  }
}, nO = (e) => e;
let Ay;
function ex() {
  return Ay === void 0 && (typeof CSS < "u" && typeof CSS.supports == "function" ? Ay = CSS.supports("touch-action", "none") : Ay = !0), Ay;
}
function iO(e) {
  const {
    "aria-labelledby": t,
    defaultValue: n,
    disabled: i = !1,
    disableSwap: s = !1,
    isRtl: o = !1,
    marks: u = !1,
    max: h = 100,
    min: f = 0,
    name: p,
    onChange: g,
    onChangeCommitted: v,
    orientation: x = "horizontal",
    rootRef: b,
    scale: _ = nO,
    step: T = 1,
    shiftStep: A = 10,
    tabIndex: O,
    value: M
  } = e, E = tt.useRef(void 0), [R, N] = tt.useState(-1), [U, q] = tt.useState(-1), [j, V] = tt.useState(!1), D = tt.useRef(0), G = tt.useRef(null), [W, P] = Zy({
    controlled: M,
    default: n ?? f,
    name: "Slider"
  }), H = g && ((Kt, te, It) => {
    const Ht = Kt.nativeEvent || Kt, Jt = new Ht.constructor(Ht.type, Ht);
    Object.defineProperty(Jt, "target", {
      writable: !0,
      value: {
        value: te,
        name: p
      }
    }), G.current = te, g(Jt, te, It);
  }), I = Array.isArray(W);
  let K = I ? W.slice().sort(ET) : [W];
  K = K.map((Kt) => Kt == null ? f : Bf(Kt, f, h));
  const Q = u === !0 && T !== null ? [...Array(Math.floor((h - f) / T) + 1)].map((Kt, te) => ({
    value: f + T * te
  })) : u || [], it = Q.map((Kt) => Kt.value), [nt, X] = tt.useState(-1), rt = tt.useRef(null), vt = jr(b, rt), ct = (Kt) => (te) => {
    var Ht;
    const It = Number(te.currentTarget.getAttribute("data-index"));
    Yf(te.target) && X(It), q(It), (Ht = Kt == null ? void 0 : Kt.onFocus) == null || Ht.call(Kt, te);
  }, dt = (Kt) => (te) => {
    var It;
    Yf(te.target) || X(-1), q(-1), (It = Kt == null ? void 0 : Kt.onBlur) == null || It.call(Kt, te);
  }, ht = (Kt, te) => {
    const It = Number(Kt.currentTarget.getAttribute("data-index")), Ht = K[It], Jt = it.indexOf(Ht);
    let Yt = te;
    if (Q && T == null) {
      const ae = it[it.length - 1];
      Yt >= ae ? Yt = ae : Yt <= it[0] ? Yt = it[0] : Yt = Yt < Ht ? it[Jt - 1] : it[Jt + 1];
    }
    if (Yt = Bf(Yt, f, h), I) {
      s && (Yt = Bf(Yt, K[It - 1] || -1 / 0, K[It + 1] || 1 / 0));
      const ae = Yt;
      Yt = tx({
        values: K,
        newValue: Yt,
        index: It
      });
      let le = It;
      s || (le = Yt.indexOf(ae)), wy({
        sliderRef: rt,
        activeIndex: le
      });
    }
    P(Yt), X(It), H && !Ey(Yt, W) && H(Kt, Yt, It), v && v(Kt, G.current ?? Yt);
  }, Et = (Kt) => (te) => {
    var It;
    if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "PageUp", "PageDown", "Home", "End"].includes(te.key)) {
      te.preventDefault();
      const Ht = Number(te.currentTarget.getAttribute("data-index")), Jt = K[Ht];
      let Yt = null;
      if (T != null) {
        const ae = te.shiftKey ? A : T;
        switch (te.key) {
          case "ArrowUp":
            Yt = kf(Jt, ae, 1, f, h);
            break;
          case "ArrowRight":
            Yt = kf(Jt, ae, o ? -1 : 1, f, h);
            break;
          case "ArrowDown":
            Yt = kf(Jt, ae, -1, f, h);
            break;
          case "ArrowLeft":
            Yt = kf(Jt, ae, o ? 1 : -1, f, h);
            break;
          case "PageUp":
            Yt = kf(Jt, A, 1, f, h);
            break;
          case "PageDown":
            Yt = kf(Jt, A, -1, f, h);
            break;
          case "Home":
            Yt = f;
            break;
          case "End":
            Yt = h;
            break;
        }
      } else if (Q) {
        const ae = it[it.length - 1], le = it.indexOf(Jt), fe = [o ? "ArrowRight" : "ArrowLeft", "ArrowDown", "PageDown", "Home"], Me = [o ? "ArrowLeft" : "ArrowRight", "ArrowUp", "PageUp", "End"];
        fe.includes(te.key) ? le === 0 ? Yt = it[0] : Yt = it[le - 1] : Me.includes(te.key) && (le === it.length - 1 ? Yt = ae : Yt = it[le + 1]);
      }
      Yt != null && ht(te, Yt);
    }
    (It = Kt == null ? void 0 : Kt.onKeyDown) == null || It.call(Kt, te);
  };
  ko(() => {
    var Kt;
    i && rt.current.contains(document.activeElement) && ((Kt = document.activeElement) == null || Kt.blur());
  }, [i]), i && R !== -1 && N(-1), i && nt !== -1 && X(-1);
  const ot = (Kt) => (te) => {
    var It;
    (It = Kt.onChange) == null || It.call(Kt, te), ht(te, te.target.valueAsNumber);
  }, lt = tt.useRef(void 0);
  let ft = x;
  o && x === "horizontal" && (ft += "-reverse");
  const Tt = ({
    finger: Kt,
    move: te = !1
  }) => {
    const {
      current: It
    } = rt, {
      width: Ht,
      height: Jt,
      bottom: Yt,
      left: ae
    } = It.getBoundingClientRect();
    let le;
    ft.startsWith("vertical") ? le = (Yt - Kt.y) / Jt : le = (Kt.x - ae) / Ht, ft.includes("-reverse") && (le = 1 - le);
    let fe;
    if (fe = ZR(le, f, h), T)
      fe = tO(fe, T, f);
    else {
      const Te = J5(it, fe);
      fe = it[Te];
    }
    fe = Bf(fe, f, h);
    let Me = 0;
    if (I) {
      te ? Me = lt.current : Me = J5(K, fe), s && (fe = Bf(fe, K[Me - 1] || -1 / 0, K[Me + 1] || 1 / 0));
      const Te = fe;
      fe = tx({
        values: K,
        newValue: fe,
        index: Me
      }), s && te || (Me = fe.indexOf(Te), lt.current = Me);
    }
    return {
      newValue: fe,
      activeIndex: Me
    };
  }, Bt = Oo((Kt) => {
    const te = Cy(Kt, E);
    if (!te)
      return;
    if (D.current += 1, Kt.type === "mousemove" && Kt.buttons === 0) {
      Ot(Kt);
      return;
    }
    const {
      newValue: It,
      activeIndex: Ht
    } = Tt({
      finger: te,
      move: !0
    });
    wy({
      sliderRef: rt,
      activeIndex: Ht,
      setActive: N
    }), P(It), !j && D.current > QR && V(!0), H && !Ey(It, W) && H(Kt, It, Ht);
  }), Ot = Oo((Kt) => {
    const te = Cy(Kt, E);
    if (V(!1), !te)
      return;
    const {
      newValue: It
    } = Tt({
      finger: te,
      move: !0
    });
    N(-1), Kt.type === "touchend" && q(-1), v && v(Kt, G.current ?? It), E.current = void 0, ce();
  }), ie = Oo((Kt) => {
    if (i)
      return;
    ex() || Kt.preventDefault();
    const te = Kt.changedTouches[0];
    te != null && (E.current = te.identifier);
    const It = Cy(Kt, E);
    if (It !== !1) {
      const {
        newValue: Jt,
        activeIndex: Yt
      } = Tt({
        finger: It
      });
      wy({
        sliderRef: rt,
        activeIndex: Yt,
        setActive: N
      }), P(Jt), H && !Ey(Jt, W) && H(Kt, Jt, Yt);
    }
    D.current = 0;
    const Ht = ga(rt.current);
    Ht.addEventListener("touchmove", Bt, {
      passive: !0
    }), Ht.addEventListener("touchend", Ot, {
      passive: !0
    });
  }), ce = tt.useCallback(() => {
    const Kt = ga(rt.current);
    Kt.removeEventListener("mousemove", Bt), Kt.removeEventListener("mouseup", Ot), Kt.removeEventListener("touchmove", Bt), Kt.removeEventListener("touchend", Ot);
  }, [Ot, Bt]);
  tt.useEffect(() => {
    const {
      current: Kt
    } = rt;
    return Kt.addEventListener("touchstart", ie, {
      passive: ex()
    }), () => {
      Kt.removeEventListener("touchstart", ie), ce();
    };
  }, [ce, ie]), tt.useEffect(() => {
    i && ce();
  }, [i, ce]);
  const Ut = (Kt) => (te) => {
    var Jt;
    if ((Jt = Kt.onMouseDown) == null || Jt.call(Kt, te), i || te.defaultPrevented || te.button !== 0)
      return;
    te.preventDefault();
    const It = Cy(te, E);
    if (It !== !1) {
      const {
        newValue: Yt,
        activeIndex: ae
      } = Tt({
        finger: It
      });
      wy({
        sliderRef: rt,
        activeIndex: ae,
        setActive: N
      }), P(Yt), H && !Ey(Yt, W) && H(te, Yt, ae);
    }
    D.current = 0;
    const Ht = ga(rt.current);
    Ht.addEventListener("mousemove", Bt, {
      passive: !0
    }), Ht.addEventListener("mouseup", Ot);
  }, se = s1(I ? K[0] : f, f, h), re = s1(K[K.length - 1], f, h) - se, ue = (Kt = {}) => {
    const te = vg(Kt), It = {
      onMouseDown: Ut(te || {})
    }, Ht = {
      ...te,
      ...It
    };
    return {
      ...Kt,
      ref: vt,
      ...Ht
    };
  }, Ae = (Kt) => (te) => {
    var Ht;
    (Ht = Kt.onMouseOver) == null || Ht.call(Kt, te);
    const It = Number(te.currentTarget.getAttribute("data-index"));
    q(It);
  }, ve = (Kt) => (te) => {
    var It;
    (It = Kt.onMouseLeave) == null || It.call(Kt, te), q(-1);
  }, Re = (Kt = {}) => {
    const te = vg(Kt), It = {
      onMouseOver: Ae(te || {}),
      onMouseLeave: ve(te || {})
    };
    return {
      ...Kt,
      ...te,
      ...It
    };
  }, oe = (Kt) => ({
    // So the non active thumb doesn't show its label on hover.
    pointerEvents: R !== -1 && R !== Kt ? "none" : void 0
  });
  let Le;
  return x === "vertical" && (Le = o ? "vertical-rl" : "vertical-lr"), {
    active: R,
    axis: ft,
    axisProps: eO,
    dragging: j,
    focusedThumbIndex: nt,
    getHiddenInputProps: (Kt = {}) => {
      const te = vg(Kt), It = {
        onChange: ot(te || {}),
        onFocus: ct(te || {}),
        onBlur: dt(te || {}),
        onKeyDown: Et(te || {})
      }, Ht = {
        ...te,
        ...It
      };
      return {
        tabIndex: O,
        "aria-labelledby": t,
        "aria-orientation": x,
        "aria-valuemax": _(h),
        "aria-valuemin": _(f),
        name: p,
        type: "range",
        min: e.min,
        max: e.max,
        step: e.step === null && e.marks ? "any" : e.step ?? void 0,
        disabled: i,
        ...Kt,
        ...Ht,
        style: {
          ...wE,
          direction: o ? "rtl" : "ltr",
          // So that VoiceOver's focus indicator matches the thumb's dimensions
          width: "100%",
          height: "100%",
          writingMode: Le
        }
      };
    },
    getRootProps: ue,
    getThumbProps: Re,
    marks: Q,
    open: U,
    range: I,
    rootRef: vt,
    trackLeap: re,
    trackOffset: se,
    values: K,
    getThumbStyle: oe
  };
}
const rO = (e) => !e || !Dh(e);
function aO(e) {
  return Un("MuiSlider", e);
}
const Ro = zn("MuiSlider", ["root", "active", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "disabled", "dragging", "focusVisible", "mark", "markActive", "marked", "markLabel", "markLabelActive", "rail", "sizeSmall", "thumb", "thumbColorPrimary", "thumbColorSecondary", "thumbColorError", "thumbColorSuccess", "thumbColorInfo", "thumbColorWarning", "track", "trackInverted", "trackFalse", "thumbSizeSmall", "valueLabel", "valueLabelOpen", "valueLabelCircle", "valueLabelLabel", "vertical"]), sO = (e) => {
  const {
    open: t
  } = e;
  return {
    offset: Fe(t && Ro.valueLabelOpen),
    circle: Ro.valueLabelCircle,
    label: Ro.valueLabelLabel
  };
};
function oO(e) {
  const {
    children: t,
    className: n,
    value: i
  } = e, s = sO(e);
  return t ? /* @__PURE__ */ tt.cloneElement(t, {
    className: Fe(t.props.className)
  }, /* @__PURE__ */ J.jsxs(tt.Fragment, {
    children: [t.props.children, /* @__PURE__ */ J.jsx("span", {
      className: Fe(s.offset, n),
      "aria-hidden": !0,
      children: /* @__PURE__ */ J.jsx("span", {
        className: s.circle,
        children: /* @__PURE__ */ J.jsx("span", {
          className: s.label,
          children: i
        })
      })
    })]
  })) : null;
}
function nx(e) {
  return e;
}
const lO = Ne("span", {
  name: "MuiSlider",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, t[`color${Ue(n.color)}`], n.size !== "medium" && t[`size${Ue(n.size)}`], n.marked && t.marked, n.orientation === "vertical" && t.vertical, n.track === "inverted" && t.trackInverted, n.track === !1 && t.trackFalse];
  }
})(En(({
  theme: e
}) => ({
  borderRadius: 12,
  boxSizing: "content-box",
  display: "inline-block",
  position: "relative",
  cursor: "pointer",
  touchAction: "none",
  WebkitTapHighlightColor: "transparent",
  "@media print": {
    colorAdjust: "exact"
  },
  [`&.${Ro.disabled}`]: {
    pointerEvents: "none",
    cursor: "default",
    color: (e.vars || e).palette.grey[400]
  },
  [`&.${Ro.dragging}`]: {
    [`& .${Ro.thumb}, & .${Ro.track}`]: {
      transition: "none"
    }
  },
  variants: [...Object.entries(e.palette).filter(Qs()).map(([t]) => ({
    props: {
      color: t
    },
    style: {
      color: (e.vars || e).palette[t].main
    }
  })), {
    props: {
      orientation: "horizontal"
    },
    style: {
      height: 4,
      width: "100%",
      padding: "13px 0",
      // The primary input mechanism of the device includes a pointing device of limited accuracy.
      "@media (pointer: coarse)": {
        // Reach 42px touch target, about ~8mm on screen.
        padding: "20px 0"
      }
    }
  }, {
    props: {
      orientation: "horizontal",
      size: "small"
    },
    style: {
      height: 2
    }
  }, {
    props: {
      orientation: "horizontal",
      marked: !0
    },
    style: {
      marginBottom: 20
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      height: "100%",
      width: 4,
      padding: "0 13px",
      // The primary input mechanism of the device includes a pointing device of limited accuracy.
      "@media (pointer: coarse)": {
        // Reach 42px touch target, about ~8mm on screen.
        padding: "0 20px"
      }
    }
  }, {
    props: {
      orientation: "vertical",
      size: "small"
    },
    style: {
      width: 2
    }
  }, {
    props: {
      orientation: "vertical",
      marked: !0
    },
    style: {
      marginRight: 44
    }
  }]
}))), cO = Ne("span", {
  name: "MuiSlider",
  slot: "Rail",
  overridesResolver: (e, t) => t.rail
})({
  display: "block",
  position: "absolute",
  borderRadius: "inherit",
  backgroundColor: "currentColor",
  opacity: 0.38,
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      width: "100%",
      height: "inherit",
      top: "50%",
      transform: "translateY(-50%)"
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      height: "100%",
      width: "inherit",
      left: "50%",
      transform: "translateX(-50%)"
    }
  }, {
    props: {
      track: "inverted"
    },
    style: {
      opacity: 1
    }
  }]
}), uO = Ne("span", {
  name: "MuiSlider",
  slot: "Track",
  overridesResolver: (e, t) => t.track
})(En(({
  theme: e
}) => ({
  display: "block",
  position: "absolute",
  borderRadius: "inherit",
  border: "1px solid currentColor",
  backgroundColor: "currentColor",
  transition: e.transitions.create(["left", "width", "bottom", "height"], {
    duration: e.transitions.duration.shortest
  }),
  variants: [{
    props: {
      size: "small"
    },
    style: {
      border: "none"
    }
  }, {
    props: {
      orientation: "horizontal"
    },
    style: {
      height: "inherit",
      top: "50%",
      transform: "translateY(-50%)"
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      width: "inherit",
      left: "50%",
      transform: "translateX(-50%)"
    }
  }, {
    props: {
      track: !1
    },
    style: {
      display: "none"
    }
  }, ...Object.entries(e.palette).filter(Qs()).map(([t]) => ({
    props: {
      color: t,
      track: "inverted"
    },
    style: {
      ...e.vars ? {
        backgroundColor: e.vars.palette.Slider[`${t}Track`],
        borderColor: e.vars.palette.Slider[`${t}Track`]
      } : {
        backgroundColor: Mg(e.palette[t].main, 0.62),
        borderColor: Mg(e.palette[t].main, 0.62),
        ...e.applyStyles("dark", {
          backgroundColor: Ag(e.palette[t].main, 0.5)
        }),
        ...e.applyStyles("dark", {
          borderColor: Ag(e.palette[t].main, 0.5)
        })
      }
    }
  }))]
}))), dO = Ne("span", {
  name: "MuiSlider",
  slot: "Thumb",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.thumb, t[`thumbColor${Ue(n.color)}`], n.size !== "medium" && t[`thumbSize${Ue(n.size)}`]];
  }
})(En(({
  theme: e
}) => ({
  position: "absolute",
  width: 20,
  height: 20,
  boxSizing: "border-box",
  borderRadius: "50%",
  outline: 0,
  backgroundColor: "currentColor",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  transition: e.transitions.create(["box-shadow", "left", "bottom"], {
    duration: e.transitions.duration.shortest
  }),
  "&::before": {
    position: "absolute",
    content: '""',
    borderRadius: "inherit",
    width: "100%",
    height: "100%",
    boxShadow: (e.vars || e).shadows[2]
  },
  "&::after": {
    position: "absolute",
    content: '""',
    borderRadius: "50%",
    // 42px is the hit target
    width: 42,
    height: 42,
    top: "50%",
    left: "50%",
    transform: "translate(-50%, -50%)"
  },
  [`&.${Ro.disabled}`]: {
    "&:hover": {
      boxShadow: "none"
    }
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      width: 12,
      height: 12,
      "&::before": {
        boxShadow: "none"
      }
    }
  }, {
    props: {
      orientation: "horizontal"
    },
    style: {
      top: "50%",
      transform: "translate(-50%, -50%)"
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      left: "50%",
      transform: "translate(-50%, 50%)"
    }
  }, ...Object.entries(e.palette).filter(Qs()).map(([t]) => ({
    props: {
      color: t
    },
    style: {
      [`&:hover, &.${Ro.focusVisible}`]: {
        ...e.vars ? {
          boxShadow: `0px 0px 0px 8px rgba(${e.vars.palette[t].mainChannel} / 0.16)`
        } : {
          boxShadow: `0px 0px 0px 8px ${xi(e.palette[t].main, 0.16)}`
        },
        "@media (hover: none)": {
          boxShadow: "none"
        }
      },
      [`&.${Ro.active}`]: {
        ...e.vars ? {
          boxShadow: `0px 0px 0px 14px rgba(${e.vars.palette[t].mainChannel} / 0.16)`
        } : {
          boxShadow: `0px 0px 0px 14px ${xi(e.palette[t].main, 0.16)}`
        }
      }
    }
  }))]
}))), hO = Ne(oO, {
  name: "MuiSlider",
  slot: "ValueLabel",
  overridesResolver: (e, t) => t.valueLabel
})(En(({
  theme: e
}) => ({
  zIndex: 1,
  whiteSpace: "nowrap",
  ...e.typography.body2,
  fontWeight: 500,
  transition: e.transitions.create(["transform"], {
    duration: e.transitions.duration.shortest
  }),
  position: "absolute",
  backgroundColor: (e.vars || e).palette.grey[600],
  borderRadius: 2,
  color: (e.vars || e).palette.common.white,
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  padding: "0.25rem 0.75rem",
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      transform: "translateY(-100%) scale(0)",
      top: "-10px",
      transformOrigin: "bottom center",
      "&::before": {
        position: "absolute",
        content: '""',
        width: 8,
        height: 8,
        transform: "translate(-50%, 50%) rotate(45deg)",
        backgroundColor: "inherit",
        bottom: 0,
        left: "50%"
      },
      [`&.${Ro.valueLabelOpen}`]: {
        transform: "translateY(-100%) scale(1)"
      }
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      transform: "translateY(-50%) scale(0)",
      right: "30px",
      top: "50%",
      transformOrigin: "right center",
      "&::before": {
        position: "absolute",
        content: '""',
        width: 8,
        height: 8,
        transform: "translate(-50%, -50%) rotate(45deg)",
        backgroundColor: "inherit",
        right: -8,
        top: "50%"
      },
      [`&.${Ro.valueLabelOpen}`]: {
        transform: "translateY(-50%) scale(1)"
      }
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      fontSize: e.typography.pxToRem(12),
      padding: "0.25rem 0.5rem"
    }
  }, {
    props: {
      orientation: "vertical",
      size: "small"
    },
    style: {
      right: "20px"
    }
  }]
}))), fO = Ne("span", {
  name: "MuiSlider",
  slot: "Mark",
  shouldForwardProp: (e) => V1(e) && e !== "markActive",
  overridesResolver: (e, t) => {
    const {
      markActive: n
    } = e;
    return [t.mark, n && t.markActive];
  }
})(En(({
  theme: e
}) => ({
  position: "absolute",
  width: 2,
  height: 2,
  borderRadius: 1,
  backgroundColor: "currentColor",
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      top: "50%",
      transform: "translate(-1px, -50%)"
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      left: "50%",
      transform: "translate(-50%, 1px)"
    }
  }, {
    props: {
      markActive: !0
    },
    style: {
      backgroundColor: (e.vars || e).palette.background.paper,
      opacity: 0.8
    }
  }]
}))), pO = Ne("span", {
  name: "MuiSlider",
  slot: "MarkLabel",
  shouldForwardProp: (e) => V1(e) && e !== "markLabelActive",
  overridesResolver: (e, t) => t.markLabel
})(En(({
  theme: e
}) => ({
  ...e.typography.body2,
  color: (e.vars || e).palette.text.secondary,
  position: "absolute",
  whiteSpace: "nowrap",
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      top: 30,
      transform: "translateX(-50%)",
      "@media (pointer: coarse)": {
        top: 40
      }
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      left: 36,
      transform: "translateY(50%)",
      "@media (pointer: coarse)": {
        left: 44
      }
    }
  }, {
    props: {
      markLabelActive: !0
    },
    style: {
      color: (e.vars || e).palette.text.primary
    }
  }]
}))), mO = (e) => {
  const {
    disabled: t,
    dragging: n,
    marked: i,
    orientation: s,
    track: o,
    classes: u,
    color: h,
    size: f
  } = e, p = {
    root: ["root", t && "disabled", n && "dragging", i && "marked", s === "vertical" && "vertical", o === "inverted" && "trackInverted", o === !1 && "trackFalse", h && `color${Ue(h)}`, f && `size${Ue(f)}`],
    rail: ["rail"],
    track: ["track"],
    mark: ["mark"],
    markActive: ["markActive"],
    markLabel: ["markLabel"],
    markLabelActive: ["markLabelActive"],
    valueLabel: ["valueLabel"],
    thumb: ["thumb", t && "disabled", f && `thumbSize${Ue(f)}`, h && `thumbColor${Ue(h)}`],
    active: ["active"],
    disabled: ["disabled"],
    focusVisible: ["focusVisible"]
  };
  return jn(p, aO, u);
}, gO = ({
  children: e
}) => e, ix = /* @__PURE__ */ tt.forwardRef(function(t, n) {
  const i = In({
    props: t,
    name: "MuiSlider"
  }), s = U1(), {
    "aria-label": o,
    "aria-valuetext": u,
    "aria-labelledby": h,
    // eslint-disable-next-line react/prop-types
    component: f = "span",
    components: p = {},
    componentsProps: g = {},
    color: v = "primary",
    classes: x,
    className: b,
    disableSwap: _ = !1,
    disabled: T = !1,
    getAriaLabel: A,
    getAriaValueText: O,
    marks: M = !1,
    max: E = 100,
    min: R = 0,
    name: N,
    onChange: U,
    onChangeCommitted: q,
    orientation: j = "horizontal",
    shiftStep: V = 10,
    size: D = "medium",
    step: G = 1,
    scale: W = nx,
    slotProps: P,
    slots: H,
    tabIndex: I,
    track: K = "normal",
    value: Q,
    valueLabelDisplay: it = "off",
    valueLabelFormat: nt = nx,
    ...X
  } = i, rt = {
    ...i,
    isRtl: s,
    max: E,
    min: R,
    classes: x,
    disabled: T,
    disableSwap: _,
    orientation: j,
    marks: M,
    color: v,
    size: D,
    step: G,
    shiftStep: V,
    scale: W,
    track: K,
    valueLabelDisplay: it,
    valueLabelFormat: nt
  }, {
    axisProps: vt,
    getRootProps: ct,
    getHiddenInputProps: dt,
    getThumbProps: ht,
    open: Et,
    active: ot,
    axis: lt,
    focusedThumbIndex: ft,
    range: Tt,
    dragging: Bt,
    marks: Ot,
    values: ie,
    trackOffset: ce,
    trackLeap: Ut,
    getThumbStyle: se
  } = iO({
    ...rt,
    rootRef: n
  });
  rt.marked = Ot.length > 0 && Ot.some((Rn) => Rn.label), rt.dragging = Bt, rt.focusedThumbIndex = ft;
  const re = mO(rt), ue = (H == null ? void 0 : H.root) ?? p.Root ?? lO, Ae = (H == null ? void 0 : H.rail) ?? p.Rail ?? cO, ve = (H == null ? void 0 : H.track) ?? p.Track ?? uO, Re = (H == null ? void 0 : H.thumb) ?? p.Thumb ?? dO, oe = (H == null ? void 0 : H.valueLabel) ?? p.ValueLabel ?? hO, Le = (H == null ? void 0 : H.mark) ?? p.Mark ?? fO, De = (H == null ? void 0 : H.markLabel) ?? p.MarkLabel ?? pO, Kt = (H == null ? void 0 : H.input) ?? p.Input ?? "input", te = (P == null ? void 0 : P.root) ?? g.root, It = (P == null ? void 0 : P.rail) ?? g.rail, Ht = (P == null ? void 0 : P.track) ?? g.track, Jt = (P == null ? void 0 : P.thumb) ?? g.thumb, Yt = (P == null ? void 0 : P.valueLabel) ?? g.valueLabel, ae = (P == null ? void 0 : P.mark) ?? g.mark, le = (P == null ? void 0 : P.markLabel) ?? g.markLabel, fe = (P == null ? void 0 : P.input) ?? g.input, Me = vc({
    elementType: ue,
    getSlotProps: ct,
    externalSlotProps: te,
    externalForwardedProps: X,
    additionalProps: {
      ...rO(ue) && {
        as: f
      }
    },
    ownerState: {
      ...rt,
      ...te == null ? void 0 : te.ownerState
    },
    className: [re.root, b]
  }), Te = vc({
    elementType: Ae,
    externalSlotProps: It,
    ownerState: rt,
    className: re.rail
  }), ne = vc({
    elementType: ve,
    externalSlotProps: Ht,
    additionalProps: {
      style: {
        ...vt[lt].offset(ce),
        ...vt[lt].leap(Ut)
      }
    },
    ownerState: {
      ...rt,
      ...Ht == null ? void 0 : Ht.ownerState
    },
    className: re.track
  }), Ve = vc({
    elementType: Re,
    getSlotProps: ht,
    externalSlotProps: Jt,
    ownerState: {
      ...rt,
      ...Jt == null ? void 0 : Jt.ownerState
    },
    className: re.thumb
  }), fn = vc({
    elementType: oe,
    externalSlotProps: Yt,
    ownerState: {
      ...rt,
      ...Yt == null ? void 0 : Yt.ownerState
    },
    className: re.valueLabel
  }), _r = vc({
    elementType: Le,
    externalSlotProps: ae,
    ownerState: rt,
    className: re.mark
  }), Ce = vc({
    elementType: De,
    externalSlotProps: le,
    ownerState: rt,
    className: re.markLabel
  }), Xi = vc({
    elementType: Kt,
    getSlotProps: dt,
    externalSlotProps: fe,
    ownerState: rt
  });
  return /* @__PURE__ */ J.jsxs(ue, {
    ...Me,
    children: [/* @__PURE__ */ J.jsx(Ae, {
      ...Te
    }), /* @__PURE__ */ J.jsx(ve, {
      ...ne
    }), Ot.filter((Rn) => Rn.value >= R && Rn.value <= E).map((Rn, Ze) => {
      const Vr = s1(Rn.value, R, E), Wi = vt[lt].offset(Vr);
      let Sr;
      return K === !1 ? Sr = ie.includes(Rn.value) : Sr = K === "normal" && (Tt ? Rn.value >= ie[0] && Rn.value <= ie[ie.length - 1] : Rn.value <= ie[0]) || K === "inverted" && (Tt ? Rn.value <= ie[0] || Rn.value >= ie[ie.length - 1] : Rn.value >= ie[0]), /* @__PURE__ */ J.jsxs(tt.Fragment, {
        children: [/* @__PURE__ */ J.jsx(Le, {
          "data-index": Ze,
          ..._r,
          ...!Dh(Le) && {
            markActive: Sr
          },
          style: {
            ...Wi,
            ..._r.style
          },
          className: Fe(_r.className, Sr && re.markActive)
        }), Rn.label != null ? /* @__PURE__ */ J.jsx(De, {
          "aria-hidden": !0,
          "data-index": Ze,
          ...Ce,
          ...!Dh(De) && {
            markLabelActive: Sr
          },
          style: {
            ...Wi,
            ...Ce.style
          },
          className: Fe(re.markLabel, Ce.className, Sr && re.markLabelActive),
          children: Rn.label
        }) : null]
      }, Ze);
    }), ie.map((Rn, Ze) => {
      const Vr = s1(Rn, R, E), Wi = vt[lt].offset(Vr), Sr = it === "off" ? gO : oe;
      return (
        /* TODO v6: Change component structure. It will help in avoiding the complicated React.cloneElement API added in SliderValueLabel component. Should be: Thumb -> Input, ValueLabel. Follow Joy UI's Slider structure. */
        /* @__PURE__ */ J.jsx(Sr, {
          ...!Dh(Sr) && {
            valueLabelFormat: nt,
            valueLabelDisplay: it,
            value: typeof nt == "function" ? nt(W(Rn), Ze) : nt,
            index: Ze,
            open: Et === Ze || ot === Ze || it === "on",
            disabled: T
          },
          ...fn,
          children: /* @__PURE__ */ J.jsx(Re, {
            "data-index": Ze,
            ...Ve,
            className: Fe(re.thumb, Ve.className, ot === Ze && re.active, ft === Ze && re.focusVisible),
            style: {
              ...Wi,
              ...se(Ze),
              ...Ve.style
            },
            children: /* @__PURE__ */ J.jsx(Kt, {
              "data-index": Ze,
              "aria-label": A ? A(Ze) : o,
              "aria-valuenow": W(Rn),
              "aria-labelledby": h,
              "aria-valuetext": O ? O(W(Rn), Ze) : u,
              value: ie[Ze],
              ...Xi
            })
          })
        }, Ze)
      );
    })]
  });
});
function yO(e) {
  return Un("MuiTooltip", e);
}
const ar = zn("MuiTooltip", ["popper", "popperInteractive", "popperArrow", "popperClose", "tooltip", "tooltipArrow", "touch", "tooltipPlacementLeft", "tooltipPlacementRight", "tooltipPlacementTop", "tooltipPlacementBottom", "arrow"]);
function vO(e) {
  return Math.round(e * 1e5) / 1e5;
}
const bO = (e) => {
  const {
    classes: t,
    disableInteractive: n,
    arrow: i,
    touch: s,
    placement: o
  } = e, u = {
    popper: ["popper", !n && "popperInteractive", i && "popperArrow"],
    tooltip: ["tooltip", i && "tooltipArrow", s && "touch", `tooltipPlacement${Ue(o.split("-")[0])}`],
    arrow: ["arrow"]
  };
  return jn(u, yO, t);
}, _O = Ne(yT, {
  name: "MuiTooltip",
  slot: "Popper",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.popper, !n.disableInteractive && t.popperInteractive, n.arrow && t.popperArrow, !n.open && t.popperClose];
  }
})(En(({
  theme: e
}) => ({
  zIndex: (e.vars || e).zIndex.tooltip,
  pointerEvents: "none",
  variants: [{
    props: ({
      ownerState: t
    }) => !t.disableInteractive,
    style: {
      pointerEvents: "auto"
    }
  }, {
    props: ({
      open: t
    }) => !t,
    style: {
      pointerEvents: "none"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.arrow,
    style: {
      [`&[data-popper-placement*="bottom"] .${ar.arrow}`]: {
        top: 0,
        marginTop: "-0.71em",
        "&::before": {
          transformOrigin: "0 100%"
        }
      },
      [`&[data-popper-placement*="top"] .${ar.arrow}`]: {
        bottom: 0,
        marginBottom: "-0.71em",
        "&::before": {
          transformOrigin: "100% 0"
        }
      },
      [`&[data-popper-placement*="right"] .${ar.arrow}`]: {
        height: "1em",
        width: "0.71em",
        "&::before": {
          transformOrigin: "100% 100%"
        }
      },
      [`&[data-popper-placement*="left"] .${ar.arrow}`]: {
        height: "1em",
        width: "0.71em",
        "&::before": {
          transformOrigin: "0 0"
        }
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.arrow && !t.isRtl,
    style: {
      [`&[data-popper-placement*="right"] .${ar.arrow}`]: {
        left: 0,
        marginLeft: "-0.71em"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.arrow && !!t.isRtl,
    style: {
      [`&[data-popper-placement*="right"] .${ar.arrow}`]: {
        right: 0,
        marginRight: "-0.71em"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.arrow && !t.isRtl,
    style: {
      [`&[data-popper-placement*="left"] .${ar.arrow}`]: {
        right: 0,
        marginRight: "-0.71em"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.arrow && !!t.isRtl,
    style: {
      [`&[data-popper-placement*="left"] .${ar.arrow}`]: {
        left: 0,
        marginLeft: "-0.71em"
      }
    }
  }]
}))), SO = Ne("div", {
  name: "MuiTooltip",
  slot: "Tooltip",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.tooltip, n.touch && t.touch, n.arrow && t.tooltipArrow, t[`tooltipPlacement${Ue(n.placement.split("-")[0])}`]];
  }
})(En(({
  theme: e
}) => ({
  backgroundColor: e.vars ? e.vars.palette.Tooltip.bg : xi(e.palette.grey[700], 0.92),
  borderRadius: (e.vars || e).shape.borderRadius,
  color: (e.vars || e).palette.common.white,
  fontFamily: e.typography.fontFamily,
  padding: "4px 8px",
  fontSize: e.typography.pxToRem(11),
  maxWidth: 300,
  margin: 2,
  wordWrap: "break-word",
  fontWeight: e.typography.fontWeightMedium,
  [`.${ar.popper}[data-popper-placement*="left"] &`]: {
    transformOrigin: "right center"
  },
  [`.${ar.popper}[data-popper-placement*="right"] &`]: {
    transformOrigin: "left center"
  },
  [`.${ar.popper}[data-popper-placement*="top"] &`]: {
    transformOrigin: "center bottom",
    marginBottom: "14px"
  },
  [`.${ar.popper}[data-popper-placement*="bottom"] &`]: {
    transformOrigin: "center top",
    marginTop: "14px"
  },
  variants: [{
    props: ({
      ownerState: t
    }) => t.arrow,
    style: {
      position: "relative",
      margin: 0
    }
  }, {
    props: ({
      ownerState: t
    }) => t.touch,
    style: {
      padding: "8px 16px",
      fontSize: e.typography.pxToRem(14),
      lineHeight: `${vO(16 / 14)}em`,
      fontWeight: e.typography.fontWeightRegular
    }
  }, {
    props: ({
      ownerState: t
    }) => !t.isRtl,
    style: {
      [`.${ar.popper}[data-popper-placement*="left"] &`]: {
        marginRight: "14px"
      },
      [`.${ar.popper}[data-popper-placement*="right"] &`]: {
        marginLeft: "14px"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => !t.isRtl && t.touch,
    style: {
      [`.${ar.popper}[data-popper-placement*="left"] &`]: {
        marginRight: "24px"
      },
      [`.${ar.popper}[data-popper-placement*="right"] &`]: {
        marginLeft: "24px"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => !!t.isRtl,
    style: {
      [`.${ar.popper}[data-popper-placement*="left"] &`]: {
        marginLeft: "14px"
      },
      [`.${ar.popper}[data-popper-placement*="right"] &`]: {
        marginRight: "14px"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => !!t.isRtl && t.touch,
    style: {
      [`.${ar.popper}[data-popper-placement*="left"] &`]: {
        marginLeft: "24px"
      },
      [`.${ar.popper}[data-popper-placement*="right"] &`]: {
        marginRight: "24px"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.touch,
    style: {
      [`.${ar.popper}[data-popper-placement*="top"] &`]: {
        marginBottom: "24px"
      }
    }
  }, {
    props: ({
      ownerState: t
    }) => t.touch,
    style: {
      [`.${ar.popper}[data-popper-placement*="bottom"] &`]: {
        marginTop: "24px"
      }
    }
  }]
}))), xO = Ne("span", {
  name: "MuiTooltip",
  slot: "Arrow",
  overridesResolver: (e, t) => t.arrow
})(En(({
  theme: e
}) => ({
  overflow: "hidden",
  position: "absolute",
  width: "1em",
  height: "0.71em",
  boxSizing: "border-box",
  color: e.vars ? e.vars.palette.Tooltip.bg : xi(e.palette.grey[700], 0.9),
  "&::before": {
    content: '""',
    margin: "auto",
    display: "block",
    width: "100%",
    height: "100%",
    backgroundColor: "currentColor",
    transform: "rotate(45deg)"
  }
})));
let My = !1;
const rx = new P1();
let bm = {
  x: 0,
  y: 0
};
function Ry(e, t) {
  return (n, ...i) => {
    t && t(n, ...i), e(n, ...i);
  };
}
const Oy = /* @__PURE__ */ tt.forwardRef(function(t, n) {
  const i = In({
    props: t,
    name: "MuiTooltip"
  }), {
    arrow: s = !1,
    children: o,
    classes: u,
    components: h = {},
    componentsProps: f = {},
    describeChild: p = !1,
    disableFocusListener: g = !1,
    disableHoverListener: v = !1,
    disableInteractive: x = !1,
    disableTouchListener: b = !1,
    enterDelay: _ = 100,
    enterNextDelay: T = 0,
    enterTouchDelay: A = 700,
    followCursor: O = !1,
    id: M,
    leaveDelay: E = 0,
    leaveTouchDelay: R = 1500,
    onClose: N,
    onOpen: U,
    open: q,
    placement: j = "bottom",
    PopperComponent: V,
    PopperProps: D = {},
    slotProps: G = {},
    slots: W = {},
    title: P,
    TransitionComponent: H,
    TransitionProps: I,
    ...K
  } = i, Q = /* @__PURE__ */ tt.isValidElement(o) ? o : /* @__PURE__ */ J.jsx("span", {
    children: o
  }), it = L1(), nt = U1(), [X, rt] = tt.useState(), [vt, ct] = tt.useState(null), dt = tt.useRef(!1), ht = x || O, Et = jf(), ot = jf(), lt = jf(), ft = jf(), [Tt, Bt] = Zy({
    controlled: q,
    default: !1,
    name: "Tooltip",
    state: "open"
  });
  let Ot = Tt;
  const ie = qg(M), ce = tt.useRef(), Ut = Oo(() => {
    ce.current !== void 0 && (document.body.style.WebkitUserSelect = ce.current, ce.current = void 0), ft.clear();
  });
  tt.useEffect(() => Ut, [Ut]);
  const se = (Ke) => {
    rx.clear(), My = !0, Bt(!0), U && !Ot && U(Ke);
  }, re = Oo(
    /**
     * @param {React.SyntheticEvent | Event} event
     */
    (Ke) => {
      rx.start(800 + E, () => {
        My = !1;
      }), Bt(!1), N && Ot && N(Ke), Et.start(it.transitions.duration.shortest, () => {
        dt.current = !1;
      });
    }
  ), ue = (Ke) => {
    dt.current && Ke.type !== "touchstart" || (X && X.removeAttribute("title"), ot.clear(), lt.clear(), _ || My && T ? ot.start(My ? T : _, () => {
      se(Ke);
    }) : se(Ke));
  }, Ae = (Ke) => {
    ot.clear(), lt.start(E, () => {
      re(Ke);
    });
  }, [, ve] = tt.useState(!1), Re = (Ke) => {
    Yf(Ke.target) || (ve(!1), Ae(Ke));
  }, oe = (Ke) => {
    X || rt(Ke.currentTarget), Yf(Ke.target) && (ve(!0), ue(Ke));
  }, Le = (Ke) => {
    dt.current = !0;
    const gi = Q.props;
    gi.onTouchStart && gi.onTouchStart(Ke);
  }, De = (Ke) => {
    Le(Ke), lt.clear(), Et.clear(), Ut(), ce.current = document.body.style.WebkitUserSelect, document.body.style.WebkitUserSelect = "none", ft.start(A, () => {
      document.body.style.WebkitUserSelect = ce.current, ue(Ke);
    });
  }, Kt = (Ke) => {
    Q.props.onTouchEnd && Q.props.onTouchEnd(Ke), Ut(), lt.start(R, () => {
      re(Ke);
    });
  };
  tt.useEffect(() => {
    if (!Ot)
      return;
    function Ke(gi) {
      gi.key === "Escape" && re(gi);
    }
    return document.addEventListener("keydown", Ke), () => {
      document.removeEventListener("keydown", Ke);
    };
  }, [re, Ot]);
  const te = jr(up(Q), rt, n);
  !P && P !== 0 && (Ot = !1);
  const It = tt.useRef(), Ht = (Ke) => {
    const gi = Q.props;
    gi.onMouseMove && gi.onMouseMove(Ke), bm = {
      x: Ke.clientX,
      y: Ke.clientY
    }, It.current && It.current.update();
  }, Jt = {}, Yt = typeof P == "string";
  p ? (Jt.title = !Ot && Yt && !v ? P : null, Jt["aria-describedby"] = Ot ? ie : null) : (Jt["aria-label"] = Yt ? P : null, Jt["aria-labelledby"] = Ot && !Yt ? ie : null);
  const ae = {
    ...Jt,
    ...K,
    ...Q.props,
    className: Fe(K.className, Q.props.className),
    onTouchStart: Le,
    ref: te,
    ...O ? {
      onMouseMove: Ht
    } : {}
  }, le = {};
  b || (ae.onTouchStart = De, ae.onTouchEnd = Kt), v || (ae.onMouseOver = Ry(ue, ae.onMouseOver), ae.onMouseLeave = Ry(Ae, ae.onMouseLeave), ht || (le.onMouseOver = ue, le.onMouseLeave = Ae)), g || (ae.onFocus = Ry(oe, ae.onFocus), ae.onBlur = Ry(Re, ae.onBlur), ht || (le.onFocus = oe, le.onBlur = Re));
  const fe = {
    ...i,
    isRtl: nt,
    arrow: s,
    disableInteractive: ht,
    placement: j,
    PopperComponentProp: V,
    touch: dt.current
  }, Me = typeof G.popper == "function" ? G.popper(fe) : G.popper, Te = tt.useMemo(() => {
    var gi, va;
    let Ke = [{
      name: "arrow",
      enabled: !!vt,
      options: {
        element: vt,
        padding: 4
      }
    }];
    return (gi = D.popperOptions) != null && gi.modifiers && (Ke = Ke.concat(D.popperOptions.modifiers)), (va = Me == null ? void 0 : Me.popperOptions) != null && va.modifiers && (Ke = Ke.concat(Me.popperOptions.modifiers)), {
      ...D.popperOptions,
      ...Me == null ? void 0 : Me.popperOptions,
      modifiers: Ke
    };
  }, [vt, D.popperOptions, Me == null ? void 0 : Me.popperOptions]), ne = bO(fe), Ve = typeof G.transition == "function" ? G.transition(fe) : G.transition, fn = {
    slots: {
      popper: h.Popper,
      transition: h.Transition ?? H,
      tooltip: h.Tooltip,
      arrow: h.Arrow,
      ...W
    },
    slotProps: {
      arrow: G.arrow ?? f.arrow,
      popper: {
        ...D,
        ...Me ?? f.popper
      },
      // resolvedPopperProps can be spread because it's already an object
      tooltip: G.tooltip ?? f.tooltip,
      transition: {
        ...I,
        ...Ve ?? f.transition
      }
    }
  }, [_r, Ce] = gr("popper", {
    elementType: _O,
    externalForwardedProps: fn,
    ownerState: fe,
    className: Fe(ne.popper, D == null ? void 0 : D.className)
  }), [Xi, Rn] = gr("transition", {
    elementType: r1,
    externalForwardedProps: fn,
    ownerState: fe
  }), [Ze, Vr] = gr("tooltip", {
    elementType: SO,
    className: ne.tooltip,
    externalForwardedProps: fn,
    ownerState: fe
  }), [Wi, Sr] = gr("arrow", {
    elementType: xO,
    className: ne.arrow,
    externalForwardedProps: fn,
    ownerState: fe,
    ref: ct
  });
  return /* @__PURE__ */ J.jsxs(tt.Fragment, {
    children: [/* @__PURE__ */ tt.cloneElement(Q, ae), /* @__PURE__ */ J.jsx(_r, {
      as: V ?? yT,
      placement: j,
      anchorEl: O ? {
        getBoundingClientRect: () => ({
          top: bm.y,
          left: bm.x,
          right: bm.x,
          bottom: bm.y,
          width: 0,
          height: 0
        })
      } : X,
      popperRef: It,
      open: X ? Ot : !1,
      id: ie,
      transition: !0,
      ...le,
      ...Ce,
      popperOptions: Te,
      children: ({
        TransitionProps: Ke
      }) => /* @__PURE__ */ J.jsx(Xi, {
        timeout: it.transitions.duration.shorter,
        ...Ke,
        ...Rn,
        children: /* @__PURE__ */ J.jsxs(Ze, {
          ...Vr,
          children: [P, s ? /* @__PURE__ */ J.jsx(Wi, {
            ...Sr
          }) : null]
        })
      })
    })]
  });
});
function TO(e) {
  return Un("MuiTextField", e);
}
zn("MuiTextField", ["root"]);
const CO = {
  standard: Z2,
  filled: Q2,
  outlined: e_
}, wO = (e) => {
  const {
    classes: t
  } = e;
  return jn({
    root: ["root"]
  }, TO, t);
}, EO = Ne(LM, {
  name: "MuiTextField",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({}), i_ = /* @__PURE__ */ tt.forwardRef(function(t, n) {
  const i = In({
    props: t,
    name: "MuiTextField"
  }), {
    autoComplete: s,
    autoFocus: o = !1,
    children: u,
    className: h,
    color: f = "primary",
    defaultValue: p,
    disabled: g = !1,
    error: v = !1,
    FormHelperTextProps: x,
    fullWidth: b = !1,
    helperText: _,
    id: T,
    InputLabelProps: A,
    inputProps: O,
    InputProps: M,
    inputRef: E,
    label: R,
    maxRows: N,
    minRows: U,
    multiline: q = !1,
    name: j,
    onBlur: V,
    onChange: D,
    onFocus: G,
    placeholder: W,
    required: P = !1,
    rows: H,
    select: I = !1,
    SelectProps: K,
    slots: Q = {},
    slotProps: it = {},
    type: nt,
    value: X,
    variant: rt = "outlined",
    ...vt
  } = i, ct = {
    ...i,
    autoFocus: o,
    color: f,
    disabled: g,
    error: v,
    fullWidth: b,
    multiline: q,
    required: P,
    select: I,
    variant: rt
  }, dt = wO(ct), ht = qg(T), Et = _ && ht ? `${ht}-helper-text` : void 0, ot = R && ht ? `${ht}-label` : void 0, lt = CO[rt], ft = {
    slots: Q,
    slotProps: {
      input: M,
      inputLabel: A,
      htmlInput: O,
      formHelperText: x,
      select: K,
      ...it
    }
  }, Tt = {}, Bt = ft.slotProps.inputLabel;
  rt === "outlined" && (Bt && typeof Bt.shrink < "u" && (Tt.notched = Bt.shrink), Tt.label = R), I && ((!K || !K.native) && (Tt.id = void 0), Tt["aria-describedby"] = void 0);
  const [Ot, ie] = gr("input", {
    elementType: lt,
    externalForwardedProps: ft,
    additionalProps: Tt,
    ownerState: ct
  }), [ce, Ut] = gr("inputLabel", {
    elementType: nR,
    externalForwardedProps: ft,
    ownerState: ct
  }), [se, re] = gr("htmlInput", {
    elementType: "input",
    externalForwardedProps: ft,
    ownerState: ct
  }), [ue, Ae] = gr("formHelperText", {
    elementType: qM,
    externalForwardedProps: ft,
    ownerState: ct
  }), [ve, Re] = gr("select", {
    elementType: a1,
    externalForwardedProps: ft,
    ownerState: ct
  }), oe = /* @__PURE__ */ J.jsx(Ot, {
    "aria-describedby": Et,
    autoComplete: s,
    autoFocus: o,
    defaultValue: p,
    fullWidth: b,
    multiline: q,
    name: j,
    rows: H,
    maxRows: N,
    minRows: U,
    type: nt,
    value: X,
    id: ht,
    inputRef: E,
    onBlur: V,
    onChange: D,
    onFocus: G,
    placeholder: W,
    inputProps: re,
    slots: {
      input: Q.htmlInput ? se : void 0
    },
    ...ie
  });
  return /* @__PURE__ */ J.jsxs(EO, {
    className: Fe(dt.root, h),
    disabled: g,
    error: v,
    fullWidth: b,
    ref: n,
    required: P,
    color: f,
    variant: rt,
    ownerState: ct,
    ...vt,
    children: [R != null && R !== "" && /* @__PURE__ */ J.jsx(ce, {
      htmlFor: ht,
      id: ot,
      ...Ut,
      children: R
    }), I ? /* @__PURE__ */ J.jsx(ve, {
      "aria-describedby": Et,
      id: ht,
      labelId: ot,
      value: X,
      input: oe,
      ...Re,
      children: u
    }) : oe, _ && /* @__PURE__ */ J.jsx(ue, {
      id: Et,
      ...Ae,
      children: _
    })]
  });
});
function AO(e) {
  return Un("MuiToggleButton", e);
}
const Rh = zn("MuiToggleButton", ["root", "disabled", "selected", "standard", "primary", "secondary", "sizeSmall", "sizeMedium", "sizeLarge", "fullWidth"]), AT = /* @__PURE__ */ tt.createContext({}), MT = /* @__PURE__ */ tt.createContext(void 0);
function MO(e, t) {
  return t === void 0 || e === void 0 ? !1 : Array.isArray(t) ? t.includes(e) : e === t;
}
const RO = (e) => {
  const {
    classes: t,
    fullWidth: n,
    selected: i,
    disabled: s,
    size: o,
    color: u
  } = e, h = {
    root: ["root", i && "selected", s && "disabled", n && "fullWidth", `size${Ue(o)}`, u]
  };
  return jn(h, AO, t);
}, OO = Ne(I1, {
  name: "MuiToggleButton",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, t[`size${Ue(n.size)}`]];
  }
})(En(({
  theme: e
}) => ({
  ...e.typography.button,
  borderRadius: (e.vars || e).shape.borderRadius,
  padding: 11,
  border: `1px solid ${(e.vars || e).palette.divider}`,
  color: (e.vars || e).palette.action.active,
  [`&.${Rh.disabled}`]: {
    color: (e.vars || e).palette.action.disabled,
    border: `1px solid ${(e.vars || e).palette.action.disabledBackground}`
  },
  "&:hover": {
    textDecoration: "none",
    // Reset on mouse devices
    backgroundColor: e.vars ? `rgba(${e.vars.palette.text.primaryChannel} / ${e.vars.palette.action.hoverOpacity})` : xi(e.palette.text.primary, e.palette.action.hoverOpacity),
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  variants: [{
    props: {
      color: "standard"
    },
    style: {
      [`&.${Rh.selected}`]: {
        color: (e.vars || e).palette.text.primary,
        backgroundColor: e.vars ? `rgba(${e.vars.palette.text.primaryChannel} / ${e.vars.palette.action.selectedOpacity})` : xi(e.palette.text.primary, e.palette.action.selectedOpacity),
        "&:hover": {
          backgroundColor: e.vars ? `rgba(${e.vars.palette.text.primaryChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.hoverOpacity}))` : xi(e.palette.text.primary, e.palette.action.selectedOpacity + e.palette.action.hoverOpacity),
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            backgroundColor: e.vars ? `rgba(${e.vars.palette.text.primaryChannel} / ${e.vars.palette.action.selectedOpacity})` : xi(e.palette.text.primary, e.palette.action.selectedOpacity)
          }
        }
      }
    }
  }, ...Object.entries(e.palette).filter(Qs()).map(([t]) => ({
    props: {
      color: t
    },
    style: {
      [`&.${Rh.selected}`]: {
        color: (e.vars || e).palette[t].main,
        backgroundColor: e.vars ? `rgba(${e.vars.palette[t].mainChannel} / ${e.vars.palette.action.selectedOpacity})` : xi(e.palette[t].main, e.palette.action.selectedOpacity),
        "&:hover": {
          backgroundColor: e.vars ? `rgba(${e.vars.palette[t].mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.hoverOpacity}))` : xi(e.palette[t].main, e.palette.action.selectedOpacity + e.palette.action.hoverOpacity),
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            backgroundColor: e.vars ? `rgba(${e.vars.palette[t].mainChannel} / ${e.vars.palette.action.selectedOpacity})` : xi(e.palette[t].main, e.palette.action.selectedOpacity)
          }
        }
      }
    }
  })), {
    props: {
      fullWidth: !0
    },
    style: {
      width: "100%"
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      padding: 7,
      fontSize: e.typography.pxToRem(13)
    }
  }, {
    props: {
      size: "large"
    },
    style: {
      padding: 15,
      fontSize: e.typography.pxToRem(15)
    }
  }]
}))), ax = /* @__PURE__ */ tt.forwardRef(function(t, n) {
  const {
    value: i,
    ...s
  } = tt.useContext(AT), o = tt.useContext(MT), u = Eg({
    ...s,
    selected: MO(t.value, i)
  }, t), h = In({
    props: u,
    name: "MuiToggleButton"
  }), {
    children: f,
    className: p,
    color: g = "standard",
    disabled: v = !1,
    disableFocusRipple: x = !1,
    fullWidth: b = !1,
    onChange: _,
    onClick: T,
    selected: A,
    size: O = "medium",
    value: M,
    ...E
  } = h, R = {
    ...h,
    color: g,
    disabled: v,
    disableFocusRipple: x,
    fullWidth: b,
    size: O
  }, N = RO(R), U = (j) => {
    T && (T(j, M), j.defaultPrevented) || _ && _(j, M);
  }, q = o || "";
  return /* @__PURE__ */ J.jsx(OO, {
    className: Fe(s.className, N.root, p, q),
    disabled: v,
    focusRipple: !x,
    ref: n,
    onClick: U,
    onChange: _,
    value: M,
    ownerState: R,
    "aria-pressed": A,
    ...E,
    children: f
  });
});
function NO(e) {
  return Un("MuiToggleButtonGroup", e);
}
const Ai = zn("MuiToggleButtonGroup", ["root", "selected", "horizontal", "vertical", "disabled", "grouped", "groupedHorizontal", "groupedVertical", "fullWidth", "firstButton", "lastButton", "middleButton"]), kO = (e) => {
  const {
    classes: t,
    orientation: n,
    fullWidth: i,
    disabled: s
  } = e, o = {
    root: ["root", n, i && "fullWidth"],
    grouped: ["grouped", `grouped${Ue(n)}`, s && "disabled"],
    firstButton: ["firstButton"],
    lastButton: ["lastButton"],
    middleButton: ["middleButton"]
  };
  return jn(o, NO, t);
}, DO = Ne("div", {
  name: "MuiToggleButtonGroup",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [{
      [`& .${Ai.grouped}`]: t.grouped
    }, {
      [`& .${Ai.grouped}`]: t[`grouped${Ue(n.orientation)}`]
    }, {
      [`& .${Ai.firstButton}`]: t.firstButton
    }, {
      [`& .${Ai.lastButton}`]: t.lastButton
    }, {
      [`& .${Ai.middleButton}`]: t.middleButton
    }, t.root, n.orientation === "vertical" && t.vertical, n.fullWidth && t.fullWidth];
  }
})(En(({
  theme: e
}) => ({
  display: "inline-flex",
  borderRadius: (e.vars || e).shape.borderRadius,
  variants: [{
    props: {
      orientation: "vertical"
    },
    style: {
      flexDirection: "column",
      [`& .${Ai.grouped}`]: {
        [`&.${Ai.selected} + .${Ai.grouped}.${Ai.selected}`]: {
          borderTop: 0,
          marginTop: 0
        }
      },
      [`& .${Ai.firstButton},& .${Ai.middleButton}`]: {
        borderBottomLeftRadius: 0,
        borderBottomRightRadius: 0
      },
      [`& .${Ai.lastButton},& .${Ai.middleButton}`]: {
        marginTop: -1,
        borderTop: "1px solid transparent",
        borderTopLeftRadius: 0,
        borderTopRightRadius: 0
      },
      [`& .${Ai.lastButton}.${Rh.disabled},& .${Ai.middleButton}.${Rh.disabled}`]: {
        borderTop: "1px solid transparent"
      }
    }
  }, {
    props: {
      fullWidth: !0
    },
    style: {
      width: "100%"
    }
  }, {
    props: {
      orientation: "horizontal"
    },
    style: {
      [`& .${Ai.grouped}`]: {
        [`&.${Ai.selected} + .${Ai.grouped}.${Ai.selected}`]: {
          borderLeft: 0,
          marginLeft: 0
        }
      },
      [`& .${Ai.firstButton},& .${Ai.middleButton}`]: {
        borderTopRightRadius: 0,
        borderBottomRightRadius: 0
      },
      [`& .${Ai.lastButton},& .${Ai.middleButton}`]: {
        marginLeft: -1,
        borderLeft: "1px solid transparent",
        borderTopLeftRadius: 0,
        borderBottomLeftRadius: 0
      },
      [`& .${Ai.lastButton}.${Rh.disabled},& .${Ai.middleButton}.${Rh.disabled}`]: {
        borderLeft: "1px solid transparent"
      }
    }
  }]
}))), BO = /* @__PURE__ */ tt.forwardRef(function(t, n) {
  const i = In({
    props: t,
    name: "MuiToggleButtonGroup"
  }), {
    children: s,
    className: o,
    color: u = "standard",
    disabled: h = !1,
    exclusive: f = !1,
    fullWidth: p = !1,
    onChange: g,
    orientation: v = "horizontal",
    size: x = "medium",
    value: b,
    ..._
  } = i, T = {
    ...i,
    disabled: h,
    fullWidth: p,
    orientation: v,
    size: x
  }, A = kO(T), O = tt.useCallback((q, j) => {
    if (!g)
      return;
    const V = b && b.indexOf(j);
    let D;
    b && V >= 0 ? (D = b.slice(), D.splice(V, 1)) : D = b ? b.concat(j) : [j], g(q, D);
  }, [g, b]), M = tt.useCallback((q, j) => {
    g && g(q, b === j ? null : j);
  }, [g, b]), E = tt.useMemo(() => ({
    className: A.grouped,
    onChange: f ? M : O,
    value: b,
    size: x,
    fullWidth: p,
    color: u,
    disabled: h
  }), [A.grouped, f, M, O, b, x, p, u, h]), R = CE(s), N = R.length, U = (q) => {
    const j = q === 0, V = q === N - 1;
    return j && V ? "" : j ? A.firstButton : V ? A.lastButton : A.middleButton;
  };
  return /* @__PURE__ */ J.jsx(DO, {
    role: "group",
    className: Fe(A.root, o),
    ref: n,
    ownerState: T,
    ..._,
    children: /* @__PURE__ */ J.jsx(AT.Provider, {
      value: E,
      children: R.map((q, j) => /* @__PURE__ */ J.jsx(MT.Provider, {
        value: U(j),
        children: q
      }, j))
    })
  });
}), zO = Ba(/* @__PURE__ */ J.jsx("path", {
  d: "M8 5v14l11-7z"
}), "PlayArrow"), PO = Ba(/* @__PURE__ */ J.jsx("path", {
  d: "M6 19h4V5H6zm8-14v14h4V5z"
}), "Pause"), UO = Ba(/* @__PURE__ */ J.jsx("path", {
  d: "M6 6h2v12H6zm3.5 6 8.5 6V6z"
}), "SkipPrevious"), jO = Ba([/* @__PURE__ */ J.jsx("path", {
  d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"
}, "0"), /* @__PURE__ */ J.jsx("path", {
  d: "M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"
}, "1")], "ZoomIn"), LO = Ba(/* @__PURE__ */ J.jsx("path", {
  d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14M7 9h5v1H7z"
}), "ZoomOut"), VO = Ba(/* @__PURE__ */ J.jsx("path", {
  d: "M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8"
}), "Undo"), IO = Ba(/* @__PURE__ */ J.jsx("path", {
  d: "M18.4 10.6C16.55 8.99 14.15 8 11.5 8c-4.65 0-8.58 3.03-9.96 7.22L3.9 16c1.05-3.19 4.05-5.5 7.6-5.5 1.95 0 3.73.72 5.12 1.88L13 16h9V7z"
}), "Redo"), FO = Ba(/* @__PURE__ */ J.jsx("path", {
  d: "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6z"
}), "Add"), qO = ({ bpm: e, onBpmChange: t }) => {
  const n = tt.useRef(null), i = (u) => {
    var h;
    u.key === "Enter" && (u.preventDefault(), (h = n.current) == null || h.blur());
  }, s = () => {
    var u;
    (u = n.current) == null || u.select();
  }, o = (u) => `${u.toString().length * 10}px`;
  return /* @__PURE__ */ J.jsxs(xe, { sx: { display: "flex", alignItems: "center" }, children: [
    /* @__PURE__ */ J.jsx(xe, { sx: { width: "28px", textAlign: "right" }, children: /* @__PURE__ */ J.jsx(
      i_,
      {
        value: e,
        onChange: t,
        onKeyDown: i,
        type: "number",
        onFocus: s,
        onClick: s,
        inputRef: n,
        inputProps: {
          min: 1,
          max: 999,
          style: {
            padding: "0px 0px",
            width: o(e),
            color: "white",
            backgroundColor: "transparent",
            border: "none",
            textAlign: "center",
            cursor: "pointer",
            caretColor: "transparent"
          }
        },
        sx: {
          "& input::selection": {
            backgroundColor: "transparent"
          },
          "@keyframes gentleFlash": {
            "0%": { backgroundColor: "#333" },
            "50%": { backgroundColor: "#444" },
            "100%": { backgroundColor: "#333" }
          },
          "& .MuiInput-root": {
            fontSize: "1rem",
            width: "auto"
          },
          "& .MuiInput-root:before, & .MuiInput-root:after": {
            display: "none"
          },
          "& input::-webkit-outer-spin-button, & input::-webkit-inner-spin-button": {
            display: "none"
          },
          "& input:focus": {
            backgroundColor: "#333",
            outline: "none",
            borderRadius: "2px",
            animation: "gentleFlash 2s ease-in-out infinite"
          }
        },
        variant: "standard"
      }
    ) }),
    /* @__PURE__ */ J.jsx(xe, { sx: { opacity: 0.7, ml: 1 }, children: "bpm" })
  ] });
}, sx = ({
  anchorEl: e,
  open: t,
  onClose: n,
  selectedValue: i,
  options: s,
  onSelect: o
}) => /* @__PURE__ */ J.jsx(
  J2,
  {
    anchorEl: e,
    open: t,
    onClose: n,
    anchorOrigin: {
      vertical: "bottom",
      horizontal: "center"
    },
    transformOrigin: {
      vertical: -12,
      horizontal: "center"
    },
    slotProps: {
      paper: {
        elevation: 4,
        sx: {
          overflow: "visible",
          filter: "drop-shadow(0px 2px 8px rgba(0,0,0,0.32))",
          bgcolor: "#1A1A1A",
          color: "white",
          "&::before": {
            content: '""',
            display: "block",
            position: "absolute",
            top: 0,
            right: 14,
            width: 10,
            height: 10,
            bgcolor: "#1A1A1A",
            transform: "translateY(-50%) rotate(45deg)",
            zIndex: 0
          }
        }
      }
    },
    children: s.map((u) => /* @__PURE__ */ J.jsx(
      Sc,
      {
        onClick: () => o(u),
        selected: u === i,
        sx: {
          borderRadius: 1,
          mx: 0.5,
          mb: 0.5,
          "&:hover": {
            bgcolor: "rgba(255, 255, 255, 0.1)"
          },
          "&.Mui-selected": {
            bgcolor: "rgba(255, 255, 255, 0.2)"
          }
        },
        children: u
      },
      u
    ))
  }
), ox = ({
  value: e,
  onClick: t
}) => /* @__PURE__ */ J.jsx(
  xe,
  {
    component: "span",
    onClick: t,
    sx: {
      cursor: "pointer",
      width: "16px",
      display: "inline-block",
      textAlign: "center",
      "&:hover": {
        color: "#888"
      },
      transition: "color 0.2s"
    },
    children: e
  }
), GO = ({
  topNumber: e,
  bottomNumber: t,
  onTopNumberChange: n,
  onBottomNumberChange: i
}) => {
  const [s, o] = tt.useState(null), [u, h] = tt.useState(null), f = (_) => {
    o(_.currentTarget);
  }, p = (_) => {
    h(_.currentTarget);
  }, g = () => {
    o(null);
  }, v = () => {
    h(null);
  }, x = (_) => {
    n && n(_), g();
  }, b = (_) => {
    i && i(_), v();
  };
  return /* @__PURE__ */ J.jsxs(
    xe,
    {
      sx: {
        display: "flex",
        alignItems: "center",
        bgcolor: "#1E1E1E",
        borderRadius: 1,
        px: 2,
        py: 0.5,
        height: "24px"
      },
      children: [
        /* @__PURE__ */ J.jsx(ox, { value: e, onClick: f }),
        /* @__PURE__ */ J.jsx(xe, { component: "span", sx: { mx: 1 }, children: "/" }),
        /* @__PURE__ */ J.jsx(ox, { value: t, onClick: p }),
        /* @__PURE__ */ J.jsx(
          sx,
          {
            anchorEl: s,
            open: !!s,
            onClose: g,
            selectedValue: e,
            options: [1, 2, 3, 4, 5, 6],
            onSelect: x
          }
        ),
        /* @__PURE__ */ J.jsx(
          sx,
          {
            anchorEl: u,
            open: !!u,
            onClose: v,
            selectedValue: t,
            options: [1, 2, 4, 8],
            onSelect: b
          }
        )
      ]
    }
  );
}, HO = ["C", "D", "E", "F", "G", "A", "B"], KO = ["C♯/D♭", "D♯/E♭", "F♯/G♭", "G♯/A♭", "A♯/B♭"], YO = ({ selectedKey: e = "C major", onKeyChange: t }) => {
  const [n, i] = tt.useState(null), [s, o] = tt.useState(
    e.toLowerCase().includes("minor") ? "minor" : "major"
  ), u = (v) => {
    i(v.currentTarget);
  }, h = () => {
    i(null);
  }, f = (v) => {
    t(`${v} ${s}`), h();
  }, p = (v, x) => {
    x !== null && (o(x), e.includes("minor") && x === "major" ? t(e.replace("minor", "major")) : e.includes("major") && x === "minor" && t(e.replace("major", "minor")));
  }, g = !!n;
  return /* @__PURE__ */ J.jsxs(xe, { sx: { width: "124px" }, children: [
    /* @__PURE__ */ J.jsx(
      Gf,
      {
        onClick: u,
        sx: {
          bgcolor: "#1E1E1E",
          color: "white",
          width: "100%",
          px: 2,
          py: 0.5,
          borderRadius: 1,
          textTransform: "none",
          "&:hover": {
            bgcolor: "#2E2E2E"
          }
        },
        children: e
      }
    ),
    /* @__PURE__ */ J.jsxs(
      xT,
      {
        open: g,
        anchorEl: n,
        onClose: h,
        anchorOrigin: {
          vertical: "bottom",
          horizontal: "left"
        },
        transformOrigin: {
          vertical: "top",
          horizontal: "left"
        },
        PaperProps: {
          sx: {
            bgcolor: "#1A1A1A",
            color: "white",
            mt: 1,
            width: "auto",
            p: 1
          }
        },
        children: [
          /* @__PURE__ */ J.jsx(xe, { sx: { mb: 1 }, children: /* @__PURE__ */ J.jsxs(
            BO,
            {
              value: s,
              exclusive: !0,
              onChange: p,
              sx: {
                bgcolor: "#111",
                ".MuiToggleButton-root": {
                  color: "#666",
                  textTransform: "none",
                  "&.Mui-selected": {
                    color: "white",
                    bgcolor: "#333",
                    "&:hover": {
                      bgcolor: "#444"
                    }
                  },
                  "&:hover": {
                    bgcolor: "#222"
                  }
                }
              },
              children: [
                /* @__PURE__ */ J.jsx(ax, { value: "major", sx: { px: 2 }, children: "Major" }),
                /* @__PURE__ */ J.jsx(ax, { value: "minor", sx: { px: 2 }, children: "Minor" })
              ]
            }
          ) }),
          /* @__PURE__ */ J.jsxs(
            xe,
            {
              sx: {
                display: "grid",
                gridTemplateColumns: "repeat(auto-fit, minmax(60px, 1fr))",
                gap: 0.5
              },
              children: [
                HO.map((v) => /* @__PURE__ */ J.jsx(
                  Gf,
                  {
                    onClick: () => f(v),
                    variant: e === `${v} ${s}` ? "contained" : "text",
                    sx: {
                      minWidth: 0,
                      p: 1,
                      textTransform: "none",
                      bgcolor: e === `${v} ${s}` ? "#333" : "transparent",
                      color: e === `${v} ${s}` ? "white" : "#666",
                      "&:hover": {
                        bgcolor: e === `${v} ${s}` ? "#444" : "#222"
                      }
                    },
                    children: v
                  },
                  v
                )),
                KO.map((v) => /* @__PURE__ */ J.jsx(
                  Gf,
                  {
                    onClick: () => f(v),
                    variant: e === `${v} ${s}` ? "contained" : "text",
                    sx: {
                      minWidth: 0,
                      p: 1,
                      textTransform: "none",
                      bgcolor: e === `${v} ${s}` ? "#333" : "transparent",
                      color: e === `${v} ${s}` ? "white" : "#666",
                      "&:hover": {
                        bgcolor: e === `${v} ${s}` ? "#444" : "#222"
                      }
                    },
                    children: v
                  },
                  v
                ))
              ]
            }
          )
        ]
      }
    )
  ] });
}, XO = Ba(/* @__PURE__ */ J.jsx("path", {
  d: "M3 9v6h4l5 5V4L7 9zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02M14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77"
}), "VolumeUp"), WO = Ba(/* @__PURE__ */ J.jsx("path", {
  d: "M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63m2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71M4.27 3 3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9zM12 4 9.91 6.09 12 8.18z"
}), "VolumeOff"), $O = Ba(/* @__PURE__ */ J.jsx("path", {
  d: "M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6zM19 4h-3.5l-1-1h-5l-1 1H5v2h14z"
}), "Delete"), QO = Ba(/* @__PURE__ */ J.jsx("path", {
  d: "M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5"
}), "PanTool"), bn = {
  headerHeight: 28,
  trackHeight: 80,
  drumPadHeight: 20,
  measureWidth: 200,
  borderWidth: 1,
  borderColor: "#333",
  sidebarWidth: 200,
  measureCount: 20,
  pixelsPerSecond: 100,
  controlsWidth: 0,
  gridSubdivisions: 4,
  minorGridOpacity: 0.3,
  majorGridOpacity: 1,
  beatsPerMeasure: 4,
  midiNoteHeight: 4,
  // Height of MIDI notes in the track preview
  scrollThreshold: 50,
  cursorColor: "#ff5555",
  // Color for the playback cursor
  cursorColorInactive: "#aaaaaa",
  // Color for inactive cursor
  borderRadiusMedium: "10px",
  borderRadiusLarge: "50px",
  // Track color palette - 10 distinct colors distributed evenly around the color wheel
  trackColors: [
    "#4CAF50",
    // Green (Material UI's default green)
    "#673AB7",
    // Deep Purple
    "#E91E63",
    // Pink
    "#2196F3",
    // Blue
    "#FF9800",
    // Orange
    "#00BCD4",
    // Cyan
    "#9C27B0",
    // Purple
    "#FF5252",
    // Red
    "#FFEB3B"
    // Yellow
  ]
}, o1 = (e, t, n) => {
  const i = n ? n[0] : bn.beatsPerMeasure;
  console.log("Calculating track width:", {
    durationInSeconds: e,
    bpm: t,
    timeSignature: n,
    beatsPerMeasure: i,
    measureWidth: bn.measureWidth
  });
  const s = t / 60, o = e * s, u = o / i, h = u * bn.measureWidth;
  return console.log("Track width calculation results:", {
    beatsPerSecond: s,
    totalBeats: o,
    measuresCount: u,
    finalWidth: h
  }), h;
}, ZO = (e, t, n) => {
  const i = n ? n[0] : bn.beatsPerMeasure, s = t / 60, o = e * s, u = Math.floor(o / i), h = o % i, f = bn.measureWidth / i;
  return u * bn.measureWidth + h * f;
}, r_ = (e, t, n) => {
  const i = n ? n[0] : bn.beatsPerMeasure, s = bn.measureWidth / i, o = e / s, u = t / 60;
  return o / u;
}, a_ = (e) => {
  const t = e % bn.trackColors.length;
  return bn.trackColors[t];
}, JO = ({
  tracks: e,
  onVolumeChange: t,
  onPanChange: n,
  onMuteToggle: i,
  onSoloToggle: s,
  onTrackDelete: o
}) => e.length === 0 ? /* @__PURE__ */ J.jsxs(xe, { sx: {
  p: 2,
  textAlign: "center",
  color: "rgba(255, 255, 255, 0.5)",
  display: "flex",
  flexDirection: "column",
  alignItems: "center",
  justifyContent: "center",
  height: "100%"
}, children: [
  /* @__PURE__ */ J.jsx(Wa, { variant: "body2", children: "No tracks yet" }),
  /* @__PURE__ */ J.jsx(Wa, { variant: "caption", sx: { mt: 1 }, children: "Add tracks using the button above" })
] }) : /* @__PURE__ */ J.jsx(xe, { sx: {
  width: "100%",
  height: "100%",
  overflow: "auto"
}, children: e.map((u, h) => /* @__PURE__ */ J.jsx(
  tN,
  {
    track: u,
    index: h,
    onVolumeChange: t,
    onPanChange: n,
    onMuteToggle: i,
    onSoloToggle: s,
    onTrackDelete: o
  },
  u.id
)) }), tN = ({
  track: e,
  index: t,
  onVolumeChange: n,
  onPanChange: i,
  onMuteToggle: s,
  onSoloToggle: o,
  onTrackDelete: u,
  onTrackNameChange: h
}) => {
  const f = a_(t), [p, g] = tt.useState(!1), [v, x] = tt.useState(e.name), b = tt.useRef(null), [_, T] = tt.useState(e.volume), [A, O] = tt.useState(e.pan);
  tt.useEffect(() => {
    T(e.volume);
  }, [e.volume]), tt.useEffect(() => {
    O(e.pan);
  }, [e.pan]);
  const M = (G, W) => {
    T(W);
  }, E = (G, W) => {
    n(e.id, W);
  }, R = (G, W) => {
    O(W);
  }, N = (G, W) => {
    i(e.id, W);
  }, U = () => {
    s(e.id, !e.muted);
  }, q = () => {
    o(e.id, !e.soloed);
  }, j = () => {
    u(e.id);
  }, V = () => {
    v.trim() !== "" && h && h(e.id, v), g(!1);
  };
  tt.useEffect(() => {
    p && b.current && b.current.focus();
  }, [p]);
  const D = () => {
    var G;
    switch (e.type) {
      case "midi":
        return /* @__PURE__ */ J.jsxs(xe, { sx: { mb: 1 }, children: [
          /* @__PURE__ */ J.jsx(Wa, { variant: "caption", sx: { color: "rgba(255,255,255,0.6)" }, children: "Instrument" }),
          /* @__PURE__ */ J.jsxs(
            a1,
            {
              size: "small",
              value: "synth",
              fullWidth: !0,
              sx: {
                mt: 0.5,
                fontSize: "12px",
                ".MuiSelect-select": { py: 0.5 },
                bgcolor: "rgba(0,0,0,0.2)"
              },
              children: [
                /* @__PURE__ */ J.jsx(Sc, { value: "synth", children: "Synth" }),
                /* @__PURE__ */ J.jsx(Sc, { value: "piano", children: "Piano" }),
                /* @__PURE__ */ J.jsx(Sc, { value: "bass", children: "Bass" })
              ]
            }
          )
        ] });
      case "drum":
        return /* @__PURE__ */ J.jsxs(xe, { sx: { mb: 1 }, children: [
          /* @__PURE__ */ J.jsx(Wa, { variant: "caption", sx: { color: "rgba(255,255,255,0.6)" }, children: "Drum Kit" }),
          /* @__PURE__ */ J.jsxs(
            a1,
            {
              size: "small",
              value: "808",
              fullWidth: !0,
              sx: {
                mt: 0.5,
                fontSize: "12px",
                ".MuiSelect-select": { py: 0.5 },
                bgcolor: "rgba(0,0,0,0.2)"
              },
              children: [
                /* @__PURE__ */ J.jsx(Sc, { value: "808", children: "808 Kit" }),
                /* @__PURE__ */ J.jsx(Sc, { value: "acoustic", children: "Acoustic Kit" }),
                /* @__PURE__ */ J.jsx(Sc, { value: "electronic", children: "Electronic Kit" })
              ]
            }
          )
        ] });
      case "audio":
        return /* @__PURE__ */ J.jsxs(xe, { sx: { mb: 1 }, children: [
          /* @__PURE__ */ J.jsx(Wa, { variant: "caption", sx: { color: "rgba(255,255,255,0.6)" }, children: "Audio File" }),
          /* @__PURE__ */ J.jsx(xe, { sx: {
            mt: 0.5,
            fontSize: "12px",
            color: "rgba(255,255,255,0.8)",
            bgcolor: "rgba(0,0,0,0.2)",
            p: 0.5,
            borderRadius: 1,
            overflow: "hidden",
            textOverflow: "ellipsis",
            whiteSpace: "nowrap"
          }, children: ((G = e.audioFile) == null ? void 0 : G.name) || "No file loaded" })
        ] });
      default:
        return null;
    }
  };
  return /* @__PURE__ */ J.jsxs(xe, { sx: {
    p: 1,
    mb: 0.5,
    borderBottom: "1px solid rgba(255, 255, 255, 0.1)",
    borderLeft: `4px solid ${f}`,
    bgcolor: "rgba(30, 30, 30, 0.7)",
    "&:hover": {
      bgcolor: "rgba(40, 40, 40, 0.9)"
    }
  }, children: [
    /* @__PURE__ */ J.jsxs(xe, { sx: {
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between",
      mb: 1
    }, children: [
      p ? /* @__PURE__ */ J.jsx(
        i_,
        {
          inputRef: b,
          size: "small",
          value: v,
          onChange: (G) => x(G.target.value),
          onBlur: V,
          onKeyDown: (G) => {
            G.key === "Enter" && V(), G.key === "Escape" && (x(e.name), g(!1));
          },
          sx: {
            minWidth: "120px",
            ".MuiInputBase-input": {
              color: "white",
              fontSize: "13px",
              py: 0.5,
              px: 1
            }
          }
        }
      ) : /* @__PURE__ */ J.jsx(
        Wa,
        {
          variant: "subtitle2",
          sx: {
            fontWeight: "bold",
            cursor: "pointer",
            "&:hover": { textDecoration: "underline" }
          },
          onClick: () => g(!0),
          children: e.name
        }
      ),
      /* @__PURE__ */ J.jsx(xe, { sx: { display: "flex", gap: 0.5 }, children: /* @__PURE__ */ J.jsx(Oy, { title: "Delete track", children: /* @__PURE__ */ J.jsx(
        Od,
        {
          size: "small",
          onClick: j,
          sx: {
            color: "rgba(255, 255, 255, 0.7)",
            "&:hover": {
              color: "#ff5252",
              bgcolor: "rgba(255, 82, 82, 0.1)"
            }
          },
          children: /* @__PURE__ */ J.jsx($O, { fontSize: "small" })
        }
      ) }) })
    ] }),
    /* @__PURE__ */ J.jsxs(xe, { sx: { display: "flex", alignItems: "center", mb: 1, gap: 0.5 }, children: [
      /* @__PURE__ */ J.jsx(
        xe,
        {
          sx: {
            bgcolor: e.type === "audio" ? "#4caf50" : e.type === "midi" ? "#2196f3" : e.type === "drum" ? "#ff9800" : "#9c27b0",
            borderRadius: "3px",
            px: 0.7,
            py: 0.2,
            fontSize: "10px",
            fontWeight: "bold",
            color: "white"
          },
          children: e.type.toUpperCase()
        }
      ),
      /* @__PURE__ */ J.jsx(Wa, { variant: "caption", sx: { color: "rgba(255, 255, 255, 0.6)" }, children: e.type === "audio" ? "Audio Track" : e.type === "midi" ? "MIDI Instrument" : e.type === "drum" ? "Drum Machine" : "Video Track" })
    ] }),
    D(),
    /* @__PURE__ */ J.jsxs(xe, { sx: { display: "flex", alignItems: "center", mb: 1 }, children: [
      /* @__PURE__ */ J.jsx(Oy, { title: e.muted ? "Unmute" : "Mute", children: /* @__PURE__ */ J.jsx(
        Od,
        {
          size: "small",
          onClick: U,
          sx: {
            color: e.muted ? "rgba(255, 82, 82, 0.9)" : "rgba(255, 255, 255, 0.7)",
            "&:hover": { color: e.muted ? "#ff5252" : "white" }
          },
          children: e.muted ? /* @__PURE__ */ J.jsx(WO, { fontSize: "small" }) : /* @__PURE__ */ J.jsx(XO, { fontSize: "small" })
        }
      ) }),
      /* @__PURE__ */ J.jsx(
        ix,
        {
          size: "small",
          value: _,
          onChange: M,
          onChangeCommitted: E,
          "aria-label": "Volume",
          min: 0,
          max: 100,
          sx: {
            mx: 1,
            color: e.muted ? "rgba(255, 255, 255, 0.3)" : f,
            opacity: e.muted ? 0.5 : 1,
            "& .MuiSlider-thumb": {
              width: 12,
              height: 12,
              "&:hover, &.Mui-focusVisible": {
                boxShadow: `0px 0px 0px 8px ${f}20`
              }
            }
          }
        }
      ),
      /* @__PURE__ */ J.jsxs(Wa, { variant: "caption", sx: {
        minWidth: "30px",
        textAlign: "right",
        color: e.muted ? "rgba(255, 255, 255, 0.3)" : "rgba(255, 255, 255, 0.8)"
      }, children: [
        _,
        "%"
      ] })
    ] }),
    /* @__PURE__ */ J.jsxs(xe, { sx: { display: "flex", alignItems: "center", mb: 1 }, children: [
      /* @__PURE__ */ J.jsx(Oy, { title: "Pan", children: /* @__PURE__ */ J.jsx(
        QO,
        {
          fontSize: "small",
          sx: {
            color: "rgba(255, 255, 255, 0.7)",
            transform: "rotate(90deg)",
            fontSize: 18,
            mx: 0.5
          }
        }
      ) }),
      /* @__PURE__ */ J.jsx(
        ix,
        {
          size: "small",
          value: A,
          onChange: R,
          onChangeCommitted: N,
          "aria-label": "Pan",
          min: -100,
          max: 100,
          sx: {
            mx: 1,
            color: f,
            "& .MuiSlider-thumb": {
              width: 12,
              height: 12,
              "&:hover, &.Mui-focusVisible": {
                boxShadow: `0px 0px 0px 8px ${f}20`
              }
            },
            "& .MuiSlider-track": {
              // Makes the track always grow from center for pan
              "&::before": {
                content: '""',
                position: "absolute",
                height: "100%",
                width: "2px",
                backgroundColor: "rgba(255, 255, 255, 0.3)",
                left: "50%",
                transform: "translateX(-50%)"
              }
            }
          },
          marks: [
            { value: -100, label: "L" },
            { value: 0, label: "C" },
            { value: 100, label: "R" }
          ]
        }
      ),
      /* @__PURE__ */ J.jsx(Wa, { variant: "caption", sx: {
        minWidth: "36px",
        textAlign: "right",
        color: "rgba(255, 255, 255, 0.8)"
      }, children: A === 0 ? "C" : A < 0 ? `L${Math.abs(A)}` : `R${A}` })
    ] }),
    /* @__PURE__ */ J.jsx(xe, { sx: { display: "flex", justifyContent: "flex-end" }, children: /* @__PURE__ */ J.jsx(Oy, { title: e.soloed ? "Unsolo" : "Solo", children: /* @__PURE__ */ J.jsx(
      xe,
      {
        onClick: q,
        sx: {
          bgcolor: e.soloed ? "#ffc107" : "rgba(255, 255, 255, 0.1)",
          color: e.soloed ? "#000" : "rgba(255, 255, 255, 0.7)",
          borderRadius: "3px",
          px: 1,
          py: 0.3,
          fontSize: "10px",
          fontWeight: "bold",
          cursor: "pointer",
          "&:hover": {
            bgcolor: e.soloed ? "#e6ac00" : "rgba(255, 255, 255, 0.15)"
          }
        },
        children: "S"
      }
    ) }) })
  ] });
}, eN = ({
  audioFile: e,
  trackColor: t,
  duration: n,
  width: i
}) => {
  const s = tt.useRef(null);
  return tt.useEffect(() => {
    var v, x, b;
    if (!e || !s.current) {
      console.error("Missing audio file or canvas reference");
      return;
    }
    const o = s.current, u = o.getContext("2d");
    if (!u) {
      console.error("Failed to get canvas context");
      return;
    }
    console.log("Canvas initial dimensions:", {
      clientWidth: o.clientWidth,
      clientHeight: o.clientHeight,
      offsetWidth: o.offsetWidth,
      offsetHeight: o.offsetHeight,
      parentWidth: (v = o.parentElement) == null ? void 0 : v.clientWidth,
      parentHeight: (x = o.parentElement) == null ? void 0 : x.clientHeight
    });
    const h = window.devicePixelRatio || 1, f = i, p = ((b = o.parentElement) == null ? void 0 : b.clientHeight) || 80;
    o.style.width = `${f}px`, o.style.height = `${p}px`, o.width = f * h, o.height = p * h, u.scale(h, h), u.clearRect(0, 0, f, p);
    const g = new FileReader();
    g.onload = (_) => {
      var A;
      if (!((A = _.target) != null && A.result)) {
        console.error("Failed to read file");
        return;
      }
      new (window.AudioContext || window.webkitAudioContext)().decodeAudioData(_.target.result).then((O) => {
        const M = O.getChannelData(0);
        nN(M, o, u);
      }).catch((O) => {
        throw console.error("Error decoding audio data:", O), new Error("Failed to decode audio data");
      });
    }, g.onerror = () => {
      throw console.error("Error reading file"), new Error("Failed to read audio file");
    }, g.readAsArrayBuffer(e);
  }, [e, t, i]), /* @__PURE__ */ J.jsx(xe, { sx: {
    height: "100%",
    width: "100%",
    display: "flex",
    alignItems: "center",
    overflow: "hidden",
    position: "relative"
  }, children: /* @__PURE__ */ J.jsx(
    "canvas",
    {
      ref: s,
      style: {
        position: "absolute",
        left: 0,
        top: 0,
        width: "100%",
        height: "100%",
        display: "block"
      }
    }
  ) });
};
function nN(e, t, n, i) {
  const s = window.devicePixelRatio || 1, o = t.width / s, u = t.height / s, h = u / 2;
  console.log("Drawing waveform with dimensions:", { width: o, height: u, middle: h, dpr: s }), n.clearRect(0, 0, o, u), n.imageSmoothingEnabled = !0, n.imageSmoothingQuality = "high";
  const f = e.length, p = Math.max(1, Math.floor(f / o)), g = [], v = [];
  n.fillStyle = "rgba(255,255,255,0.2)", n.fillRect(0, h, o, 1), n.fillStyle = "rgba(255, 255, 255, 0.25)";
  for (let x = 0; x < o; x++) {
    const b = Math.floor(x * f / o);
    let _ = 0, T = 0;
    for (let U = 0; U < p; U++) {
      const q = b + U;
      if (q < f) {
        const j = e[q];
        j < _ && (_ = j), j > T && (T = j);
      }
    }
    const A = Math.min(0, _), O = Math.max(0, T), M = 0.5, E = h + A * u * M, R = h + O * u * M;
    g.push({ x, y: E }), v.push({ x, y: R });
    const N = R - E;
    n.fillRect(x, E, 1, N);
  }
  if (n.strokeStyle = "rgba(255,255,255,1.0)", n.lineWidth = 1, n.beginPath(), g.length > 0) {
    n.moveTo(g[0].x, g[0].y);
    for (let x = 1; x < g.length; x++)
      n.lineTo(g[x].x, g[x].y);
    n.stroke();
  }
  if (n.beginPath(), v.length > 0) {
    n.moveTo(v[0].x, v[0].y);
    for (let x = 1; x < v.length; x++)
      n.lineTo(v[x].x, v[x].y);
    n.stroke();
  }
}
class iN {
  constructor() {
    Qe(this, "undoStack", []);
    Qe(this, "redoStack", []);
    Qe(this, "listeners", /* @__PURE__ */ new Set());
    console.log("📝 History Manager initialized");
  }
  subscribe(t) {
    this.listeners.add(t);
  }
  unsubscribe(t) {
    this.listeners.delete(t);
  }
  notifyListeners() {
    this.listeners.forEach((t) => t());
  }
  async executeAction(t) {
    await t.execute(), this.undoStack.push(t), this.redoStack = [], this.logState(), this.notifyListeners();
  }
  async undo() {
    const t = this.undoStack.pop();
    t && (await t.undo(), this.redoStack.push(t), this.logState(), this.notifyListeners());
  }
  async redo() {
    const t = this.redoStack.pop();
    t && (await t.execute(), this.undoStack.push(t), this.logState(), this.notifyListeners());
  }
  canUndo() {
    return this.undoStack.length > 0;
  }
  canRedo() {
    return this.redoStack.length > 0;
  }
  logState() {
    console.log("📝 History State:", {
      undoStack: this.undoStack.map((t) => ({ type: t.type })),
      redoStack: this.redoStack.map((t) => ({ type: t.type })),
      canUndo: this.canUndo(),
      canRedo: this.canRedo()
    });
  }
}
const Cn = new iN();
class rN {
  constructor(t, n, i, s) {
    Qe(this, "type", "NOTE_CREATE");
    this.store = t, this.setNotes = n, this.newNote = i, this.prevNotes = s;
  }
  async execute() {
    this.setNotes([...this.prevNotes, this.newNote]), this.newNote.trackId && this.store.getMidiManager && await this.store.getMidiManager().addNoteToTrack(this.newNote.trackId, this.newNote);
  }
  async undo() {
    this.setNotes(this.prevNotes), this.newNote.trackId && this.store.getMidiManager && await this.store.getMidiManager().removeNoteFromTrack(this.newNote.trackId, this.newNote.id);
  }
}
class aN {
  constructor(t, n, i, s, o, u) {
    Qe(this, "type", "NOTE_MOVE");
    this.store = t, this.setNotes = n, this.noteId = i, this.oldPosition = s, this.newPosition = o, this.prevNotes = u;
  }
  async execute() {
    const t = this.prevNotes.map(
      (i) => i.id === this.noteId ? { ...i, row: this.newPosition.y, column: this.newPosition.x } : i
    );
    this.setNotes(t);
    const n = t.find((i) => i.id === this.noteId);
    n != null && n.trackId && this.store.getMidiManager && await this.store.getMidiManager().updateNote(n.trackId, n);
  }
  async undo() {
    const t = this.prevNotes.map(
      (i) => i.id === this.noteId ? { ...i, row: this.oldPosition.y, column: this.oldPosition.x } : i
    );
    this.setNotes(t);
    const n = t.find((i) => i.id === this.noteId);
    n != null && n.trackId && this.store.getMidiManager && await this.store.getMidiManager().updateNote(n.trackId, n);
  }
}
class sN {
  constructor(t, n, i, s, o, u, h, f) {
    Qe(this, "type", "NOTE_RESIZE");
    this.store = t, this.setNotes = n, this.noteId = i, this.oldLength = s, this.newLength = o, this.prevNotes = u, this.oldColumn = h, this.newColumn = f;
  }
  async execute() {
    const t = this.prevNotes.map(
      (i) => i.id === this.noteId ? {
        ...i,
        length: this.newLength,
        ...this.newColumn !== void 0 && { column: this.newColumn }
      } : i
    );
    this.setNotes(t);
    const n = t.find((i) => i.id === this.noteId);
    n != null && n.trackId && this.store.getMidiManager && await this.store.getMidiManager().updateNote(n.trackId, n);
  }
  async undo() {
    const t = this.prevNotes.map(
      (i) => i.id === this.noteId ? {
        ...i,
        length: this.oldLength,
        ...this.oldColumn !== void 0 && { column: this.oldColumn }
      } : i
    );
    this.setNotes(t);
    const n = t.find((i) => i.id === this.noteId);
    n != null && n.trackId && this.store.getMidiManager && await this.store.getMidiManager().updateNote(n.trackId, n);
  }
}
const lx = (e) => {
  let t;
  const n = /* @__PURE__ */ new Set(), i = (p, g) => {
    const v = typeof p == "function" ? p(t) : p;
    if (!Object.is(v, t)) {
      const x = t;
      t = g ?? (typeof v != "object" || v === null) ? v : Object.assign({}, t, v), n.forEach((b) => b(t, x));
    }
  }, s = () => t, h = { setState: i, getState: s, getInitialState: () => f, subscribe: (p) => (n.add(p), () => n.delete(p)) }, f = t = e(i, s, h);
  return h;
}, oN = (e) => e ? lx(e) : lx, lN = (e) => e;
function cN(e, t = lN) {
  const n = an.useSyncExternalStore(
    e.subscribe,
    () => t(e.getState()),
    () => t(e.getInitialState())
  );
  return an.useDebugValue(n), n;
}
const cx = (e) => {
  const t = oN(e), n = (i) => cN(t, i);
  return Object.assign(n, t), n;
}, uN = (e) => e ? cx(e) : cx, RT = "15.0.4", ux = (e, t, n) => ({ endTime: t, insertTime: n, type: "exponentialRampToValue", value: e }), dx = (e, t, n) => ({ endTime: t, insertTime: n, type: "linearRampToValue", value: e }), i2 = (e, t) => ({ startTime: t, type: "setValue", value: e }), OT = (e, t, n) => ({ duration: n, startTime: t, type: "setValueCurve", values: e }), NT = (e, t, { startTime: n, target: i, timeConstant: s }) => i + (t - i) * Math.exp((n - e) / s), Vf = (e) => e.type === "exponentialRampToValue", l1 = (e) => e.type === "linearRampToValue", Nd = (e) => Vf(e) || l1(e), s_ = (e) => e.type === "setValue", Ou = (e) => e.type === "setValueCurve", c1 = (e, t, n, i) => {
  const s = e[t];
  return s === void 0 ? i : Nd(s) || s_(s) ? s.value : Ou(s) ? s.values[s.values.length - 1] : NT(n, c1(e, t - 1, s.startTime, i), s);
}, hx = (e, t, n, i, s) => n === void 0 ? [i.insertTime, s] : Nd(n) ? [n.endTime, n.value] : s_(n) ? [n.startTime, n.value] : Ou(n) ? [
  n.startTime + n.duration,
  n.values[n.values.length - 1]
] : [
  n.startTime,
  c1(e, t - 1, n.startTime, s)
], r2 = (e) => e.type === "cancelAndHold", a2 = (e) => e.type === "cancelScheduledValues", Ad = (e) => r2(e) || a2(e) ? e.cancelTime : Vf(e) || l1(e) ? e.endTime : e.startTime, fx = (e, t, n, { endTime: i, value: s }) => n === s ? s : 0 < n && 0 < s || n < 0 && s < 0 ? n * (s / n) ** ((e - t) / (i - t)) : 0, px = (e, t, n, { endTime: i, value: s }) => n + (e - t) / (i - t) * (s - n), dN = (e, t) => {
  const n = Math.floor(t), i = Math.ceil(t);
  return n === i ? e[n] : (1 - (t - n)) * e[n] + (1 - (i - t)) * e[i];
}, hN = (e, { duration: t, startTime: n, values: i }) => {
  const s = (e - n) / t * (i.length - 1);
  return dN(i, s);
}, Ny = (e) => e.type === "setTarget";
class fN {
  constructor(t) {
    this._automationEvents = [], this._currenTime = 0, this._defaultValue = t;
  }
  [Symbol.iterator]() {
    return this._automationEvents[Symbol.iterator]();
  }
  add(t) {
    const n = Ad(t);
    if (r2(t) || a2(t)) {
      const i = this._automationEvents.findIndex((o) => a2(t) && Ou(o) ? o.startTime + o.duration >= n : Ad(o) >= n), s = this._automationEvents[i];
      if (i !== -1 && (this._automationEvents = this._automationEvents.slice(0, i)), r2(t)) {
        const o = this._automationEvents[this._automationEvents.length - 1];
        if (s !== void 0 && Nd(s)) {
          if (o !== void 0 && Ny(o))
            throw new Error("The internal list is malformed.");
          const u = o === void 0 ? s.insertTime : Ou(o) ? o.startTime + o.duration : Ad(o), h = o === void 0 ? this._defaultValue : Ou(o) ? o.values[o.values.length - 1] : o.value, f = Vf(s) ? fx(n, u, h, s) : px(n, u, h, s), p = Vf(s) ? ux(f, n, this._currenTime) : dx(f, n, this._currenTime);
          this._automationEvents.push(p);
        }
        if (o !== void 0 && Ny(o) && this._automationEvents.push(i2(this.getValue(n), n)), o !== void 0 && Ou(o) && o.startTime + o.duration > n) {
          const u = n - o.startTime, h = (o.values.length - 1) / o.duration, f = Math.max(2, 1 + Math.ceil(u * h)), p = u / (f - 1) * h, g = o.values.slice(0, f);
          if (p < 1)
            for (let v = 1; v < f; v += 1) {
              const x = p * v % 1;
              g[v] = o.values[v - 1] * (1 - x) + o.values[v] * x;
            }
          this._automationEvents[this._automationEvents.length - 1] = OT(g, o.startTime, u);
        }
      }
    } else {
      const i = this._automationEvents.findIndex((u) => Ad(u) > n), s = i === -1 ? this._automationEvents[this._automationEvents.length - 1] : this._automationEvents[i - 1];
      if (s !== void 0 && Ou(s) && Ad(s) + s.duration > n)
        return !1;
      const o = Vf(t) ? ux(t.value, t.endTime, this._currenTime) : l1(t) ? dx(t.value, n, this._currenTime) : t;
      if (i === -1)
        this._automationEvents.push(o);
      else {
        if (Ou(t) && n + t.duration > Ad(this._automationEvents[i]))
          return !1;
        this._automationEvents.splice(i, 0, o);
      }
    }
    return !0;
  }
  flush(t) {
    const n = this._automationEvents.findIndex((i) => Ad(i) > t);
    if (n > 1) {
      const i = this._automationEvents.slice(n - 1), s = i[0];
      Ny(s) && i.unshift(i2(c1(this._automationEvents, n - 2, s.startTime, this._defaultValue), s.startTime)), this._automationEvents = i;
    }
  }
  getValue(t) {
    if (this._automationEvents.length === 0)
      return this._defaultValue;
    const n = this._automationEvents.findIndex((u) => Ad(u) > t), i = this._automationEvents[n], s = (n === -1 ? this._automationEvents.length : n) - 1, o = this._automationEvents[s];
    if (o !== void 0 && Ny(o) && (i === void 0 || !Nd(i) || i.insertTime > t))
      return NT(t, c1(this._automationEvents, s - 1, o.startTime, this._defaultValue), o);
    if (o !== void 0 && s_(o) && (i === void 0 || !Nd(i)))
      return o.value;
    if (o !== void 0 && Ou(o) && (i === void 0 || !Nd(i) || o.startTime + o.duration > t))
      return t < o.startTime + o.duration ? hN(t, o) : o.values[o.values.length - 1];
    if (o !== void 0 && Nd(o) && (i === void 0 || !Nd(i)))
      return o.value;
    if (i !== void 0 && Vf(i)) {
      const [u, h] = hx(this._automationEvents, s, o, i, this._defaultValue);
      return fx(t, u, h, i);
    }
    if (i !== void 0 && l1(i)) {
      const [u, h] = hx(this._automationEvents, s, o, i, this._defaultValue);
      return px(t, u, h, i);
    }
    return this._defaultValue;
  }
}
const pN = (e) => ({ cancelTime: e, type: "cancelAndHold" }), mN = (e) => ({ cancelTime: e, type: "cancelScheduledValues" }), gN = (e, t) => ({ endTime: t, type: "exponentialRampToValue", value: e }), yN = (e, t) => ({ endTime: t, type: "linearRampToValue", value: e }), vN = (e, t, n) => ({ startTime: t, target: e, timeConstant: n, type: "setTarget" }), bN = () => new DOMException("", "AbortError"), _N = (e) => (t, n, [i, s, o], u) => {
  e(t[s], [n, i, o], (h) => h[0] === n && h[1] === i, u);
}, SN = (e) => (t, n, i) => {
  const s = [];
  for (let o = 0; o < i.numberOfInputs; o += 1)
    s.push(/* @__PURE__ */ new Set());
  e.set(t, {
    activeInputs: s,
    outputs: /* @__PURE__ */ new Set(),
    passiveInputs: /* @__PURE__ */ new WeakMap(),
    renderer: n
  });
}, xN = (e) => (t, n) => {
  e.set(t, { activeInputs: /* @__PURE__ */ new Set(), passiveInputs: /* @__PURE__ */ new WeakMap(), renderer: n });
}, Jf = /* @__PURE__ */ new WeakSet(), kT = /* @__PURE__ */ new WeakMap(), o_ = /* @__PURE__ */ new WeakMap(), DT = /* @__PURE__ */ new WeakMap(), l_ = /* @__PURE__ */ new WeakMap(), Y1 = /* @__PURE__ */ new WeakMap(), BT = /* @__PURE__ */ new WeakMap(), s2 = /* @__PURE__ */ new WeakMap(), o2 = /* @__PURE__ */ new WeakMap(), l2 = /* @__PURE__ */ new WeakMap(), zT = {
  construct() {
    return zT;
  }
}, TN = (e) => {
  try {
    const t = new Proxy(e, zT);
    new t();
  } catch {
    return !1;
  }
  return !0;
}, mx = /^import(?:(?:[\s]+[\w]+|(?:[\s]+[\w]+[\s]*,)?[\s]*\{[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?(?:[\s]*,[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?)*[\s]*}|(?:[\s]+[\w]+[\s]*,)?[\s]*\*[\s]+as[\s]+[\w]+)[\s]+from)?(?:[\s]*)("([^"\\]|\\.)+"|'([^'\\]|\\.)+')(?:[\s]*);?/, gx = (e, t) => {
  const n = [];
  let i = e.replace(/^[\s]+/, ""), s = i.match(mx);
  for (; s !== null; ) {
    const o = s[1].slice(1, -1), u = s[0].replace(/([\s]+)?;?$/, "").replace(o, new URL(o, t).toString());
    n.push(u), i = i.slice(s[0].length).replace(/^[\s]+/, ""), s = i.match(mx);
  }
  return [n.join(";"), i];
}, yx = (e) => {
  if (e !== void 0 && !Array.isArray(e))
    throw new TypeError("The parameterDescriptors property of given value for processorCtor is not an array.");
}, vx = (e) => {
  if (!TN(e))
    throw new TypeError("The given value for processorCtor should be a constructor.");
  if (e.prototype === null || typeof e.prototype != "object")
    throw new TypeError("The given value for processorCtor should have a prototype.");
}, CN = (e, t, n, i, s, o, u, h, f, p, g, v, x) => {
  let b = 0;
  return (_, T, A = { credentials: "omit" }) => {
    const O = g.get(_);
    if (O !== void 0 && O.has(T))
      return Promise.resolve();
    const M = p.get(_);
    if (M !== void 0) {
      const N = M.get(T);
      if (N !== void 0)
        return N;
    }
    const E = o(_), R = E.audioWorklet === void 0 ? s(T).then(([N, U]) => {
      const [q, j] = gx(N, U), V = `${q};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${j}
})})(window,'_AWGS')`;
      return n(V);
    }).then(() => {
      const N = x._AWGS.pop();
      if (N === void 0)
        throw new SyntaxError();
      i(E.currentTime, E.sampleRate, () => N(class {
      }, void 0, (U, q) => {
        if (U.trim() === "")
          throw t();
        const j = o2.get(E);
        if (j !== void 0) {
          if (j.has(U))
            throw t();
          vx(q), yx(q.parameterDescriptors), j.set(U, q);
        } else
          vx(q), yx(q.parameterDescriptors), o2.set(E, /* @__PURE__ */ new Map([[U, q]]));
      }, E.sampleRate, void 0, void 0));
    }) : Promise.all([
      s(T),
      Promise.resolve(e(v, v))
    ]).then(([[N, U], q]) => {
      const j = b + 1;
      b = j;
      const [V, D] = gx(N, U), H = `${V};((AudioWorkletProcessor,registerProcessor)=>{${D}
})(${q ? "AudioWorkletProcessor" : "class extends AudioWorkletProcessor {__b=new WeakSet();constructor(){super();(p=>p.postMessage=(q=>(m,t)=>q.call(p,m,t?t.filter(u=>!this.__b.has(u)):t))(p.postMessage))(this.port)}}"},(n,p)=>registerProcessor(n,class extends p{${q ? "" : "__c = (a) => a.forEach(e=>this.__b.add(e.buffer));"}process(i,o,p){${q ? "" : "i.forEach(this.__c);o.forEach(this.__c);this.__c(Object.values(p));"}return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}));registerProcessor('__sac${j}',class extends AudioWorkletProcessor{process(){return !1}})`, I = new Blob([H], { type: "application/javascript; charset=utf-8" }), K = URL.createObjectURL(I);
      return E.audioWorklet.addModule(K, A).then(() => {
        if (h(E))
          return E;
        const Q = u(E);
        return Q.audioWorklet.addModule(K, A).then(() => Q);
      }).then((Q) => {
        if (f === null)
          throw new SyntaxError();
        try {
          new f(Q, `__sac${j}`);
        } catch {
          throw new SyntaxError();
        }
      }).finally(() => URL.revokeObjectURL(K));
    });
    return M === void 0 ? p.set(_, /* @__PURE__ */ new Map([[T, R]])) : M.set(T, R), R.then(() => {
      const N = g.get(_);
      N === void 0 ? g.set(_, /* @__PURE__ */ new Set([T])) : N.add(T);
    }).finally(() => {
      const N = p.get(_);
      N !== void 0 && N.delete(T);
    }), R;
  };
}, Sl = (e, t) => {
  const n = e.get(t);
  if (n === void 0)
    throw new Error("A value with the given key could not be found.");
  return n;
}, X1 = (e, t) => {
  const n = Array.from(e).filter(t);
  if (n.length > 1)
    throw Error("More than one element was found.");
  if (n.length === 0)
    throw Error("No element was found.");
  const [i] = n;
  return e.delete(i), i;
}, PT = (e, t, n, i) => {
  const s = Sl(e, t), o = X1(s, (u) => u[0] === n && u[1] === i);
  return s.size === 0 && e.delete(t), o;
}, Kg = (e) => Sl(BT, e), tp = (e) => {
  if (Jf.has(e))
    throw new Error("The AudioNode is already stored.");
  Jf.add(e), Kg(e).forEach((t) => t(!0));
}, UT = (e) => "port" in e, Yg = (e) => {
  if (!Jf.has(e))
    throw new Error("The AudioNode is not stored.");
  Jf.delete(e), Kg(e).forEach((t) => t(!1));
}, c2 = (e, t) => {
  !UT(e) && t.every((n) => n.size === 0) && Yg(e);
}, wN = (e, t, n, i, s, o, u, h, f, p, g, v, x) => {
  const b = /* @__PURE__ */ new WeakMap();
  return (_, T, A, O, M) => {
    const { activeInputs: E, passiveInputs: R } = o(T), { outputs: N } = o(_), U = h(_), q = (j) => {
      const V = f(T), D = f(_);
      if (j) {
        const G = PT(R, _, A, O);
        e(E, _, G, !1), !M && !v(_) && n(D, V, A, O), x(T) && tp(T);
      } else {
        const G = i(E, _, A, O);
        t(R, O, G, !1), !M && !v(_) && s(D, V, A, O);
        const W = u(T);
        if (W === 0)
          g(T) && c2(T, E);
        else {
          const P = b.get(T);
          P !== void 0 && clearTimeout(P), b.set(T, setTimeout(() => {
            g(T) && c2(T, E);
          }, W * 1e3));
        }
      }
    };
    return p(N, [T, A, O], (j) => j[0] === T && j[1] === A && j[2] === O, !0) ? (U.add(q), g(_) ? e(E, _, [A, O, q], !0) : t(R, O, [_, A, q], !0), !0) : !1;
  };
}, EN = (e) => (t, n, [i, s, o], u) => {
  const h = t.get(i);
  h === void 0 ? t.set(i, /* @__PURE__ */ new Set([[s, n, o]])) : e(h, [s, n, o], (f) => f[0] === s && f[1] === n, u);
}, AN = (e) => (t, n) => {
  const i = e(t, {
    channelCount: 1,
    channelCountMode: "explicit",
    channelInterpretation: "discrete",
    gain: 0
  });
  n.connect(i).connect(t.destination);
  const s = () => {
    n.removeEventListener("ended", s), n.disconnect(i), i.disconnect();
  };
  n.addEventListener("ended", s);
}, MN = (e) => (t, n) => {
  e(t).add(n);
}, RN = {
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers",
  fftSize: 2048,
  maxDecibels: -30,
  minDecibels: -100,
  smoothingTimeConstant: 0.8
}, ON = (e, t, n, i, s, o) => class extends e {
  constructor(h, f) {
    const p = s(h), g = { ...RN, ...f }, v = i(p, g), x = o(p) ? t() : null;
    super(h, !1, v, x), this._nativeAnalyserNode = v;
  }
  get fftSize() {
    return this._nativeAnalyserNode.fftSize;
  }
  set fftSize(h) {
    this._nativeAnalyserNode.fftSize = h;
  }
  get frequencyBinCount() {
    return this._nativeAnalyserNode.frequencyBinCount;
  }
  get maxDecibels() {
    return this._nativeAnalyserNode.maxDecibels;
  }
  set maxDecibels(h) {
    const f = this._nativeAnalyserNode.maxDecibels;
    if (this._nativeAnalyserNode.maxDecibels = h, !(h > this._nativeAnalyserNode.minDecibels))
      throw this._nativeAnalyserNode.maxDecibels = f, n();
  }
  get minDecibels() {
    return this._nativeAnalyserNode.minDecibels;
  }
  set minDecibels(h) {
    const f = this._nativeAnalyserNode.minDecibels;
    if (this._nativeAnalyserNode.minDecibels = h, !(this._nativeAnalyserNode.maxDecibels > h))
      throw this._nativeAnalyserNode.minDecibels = f, n();
  }
  get smoothingTimeConstant() {
    return this._nativeAnalyserNode.smoothingTimeConstant;
  }
  set smoothingTimeConstant(h) {
    this._nativeAnalyserNode.smoothingTimeConstant = h;
  }
  getByteFrequencyData(h) {
    this._nativeAnalyserNode.getByteFrequencyData(h);
  }
  getByteTimeDomainData(h) {
    this._nativeAnalyserNode.getByteTimeDomainData(h);
  }
  getFloatFrequencyData(h) {
    this._nativeAnalyserNode.getFloatFrequencyData(h);
  }
  getFloatTimeDomainData(h) {
    this._nativeAnalyserNode.getFloatTimeDomainData(h);
  }
}, za = (e, t) => e.context === t, NN = (e, t, n) => () => {
  const i = /* @__PURE__ */ new WeakMap(), s = async (o, u) => {
    let h = t(o);
    if (!za(h, u)) {
      const p = {
        channelCount: h.channelCount,
        channelCountMode: h.channelCountMode,
        channelInterpretation: h.channelInterpretation,
        fftSize: h.fftSize,
        maxDecibels: h.maxDecibels,
        minDecibels: h.minDecibels,
        smoothingTimeConstant: h.smoothingTimeConstant
      };
      h = e(u, p);
    }
    return i.set(u, h), await n(o, u, h), h;
  };
  return {
    render(o, u) {
      const h = i.get(u);
      return h !== void 0 ? Promise.resolve(h) : s(o, u);
    }
  };
}, u1 = (e) => {
  try {
    e.copyToChannel(new Float32Array(1), 0, -1);
  } catch {
    return !1;
  }
  return !0;
}, kc = () => new DOMException("", "IndexSizeError"), c_ = (e) => {
  e.getChannelData = /* @__PURE__ */ ((t) => (n) => {
    try {
      return t.call(e, n);
    } catch (i) {
      throw i.code === 12 ? kc() : i;
    }
  })(e.getChannelData);
}, kN = {
  numberOfChannels: 1
}, DN = (e, t, n, i, s, o, u, h) => {
  let f = null;
  return class jT {
    constructor(g) {
      if (s === null)
        throw new Error("Missing the native OfflineAudioContext constructor.");
      const { length: v, numberOfChannels: x, sampleRate: b } = { ...kN, ...g };
      f === null && (f = new s(1, 1, 44100));
      const _ = i !== null && t(o, o) ? new i({ length: v, numberOfChannels: x, sampleRate: b }) : f.createBuffer(x, v, b);
      if (_.numberOfChannels === 0)
        throw n();
      return typeof _.copyFromChannel != "function" ? (u(_), c_(_)) : t(u1, () => u1(_)) || h(_), e.add(_), _;
    }
    static [Symbol.hasInstance](g) {
      return g !== null && typeof g == "object" && Object.getPrototypeOf(g) === jT.prototype || e.has(g);
    }
  };
}, Ks = -34028234663852886e22, $a = 34028234663852886e22, Du = (e) => Jf.has(e), BN = {
  buffer: null,
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers",
  // Bug #149: Safari does not yet support the detune AudioParam.
  loop: !1,
  loopEnd: 0,
  loopStart: 0,
  playbackRate: 1
}, zN = (e, t, n, i, s, o, u, h) => class extends e {
  constructor(p, g) {
    const v = o(p), x = { ...BN, ...g }, b = s(v, x), _ = u(v), T = _ ? t() : null;
    super(p, !1, b, T), this._audioBufferSourceNodeRenderer = T, this._isBufferNullified = !1, this._isBufferSet = x.buffer !== null, this._nativeAudioBufferSourceNode = b, this._onended = null, this._playbackRate = n(this, _, b.playbackRate, $a, Ks);
  }
  get buffer() {
    return this._isBufferNullified ? null : this._nativeAudioBufferSourceNode.buffer;
  }
  set buffer(p) {
    if (this._nativeAudioBufferSourceNode.buffer = p, p !== null) {
      if (this._isBufferSet)
        throw i();
      this._isBufferSet = !0;
    }
  }
  get loop() {
    return this._nativeAudioBufferSourceNode.loop;
  }
  set loop(p) {
    this._nativeAudioBufferSourceNode.loop = p;
  }
  get loopEnd() {
    return this._nativeAudioBufferSourceNode.loopEnd;
  }
  set loopEnd(p) {
    this._nativeAudioBufferSourceNode.loopEnd = p;
  }
  get loopStart() {
    return this._nativeAudioBufferSourceNode.loopStart;
  }
  set loopStart(p) {
    this._nativeAudioBufferSourceNode.loopStart = p;
  }
  get onended() {
    return this._onended;
  }
  set onended(p) {
    const g = typeof p == "function" ? h(this, p) : null;
    this._nativeAudioBufferSourceNode.onended = g;
    const v = this._nativeAudioBufferSourceNode.onended;
    this._onended = v !== null && v === g ? p : v;
  }
  get playbackRate() {
    return this._playbackRate;
  }
  start(p = 0, g = 0, v) {
    if (this._nativeAudioBufferSourceNode.start(p, g, v), this._audioBufferSourceNodeRenderer !== null && (this._audioBufferSourceNodeRenderer.start = v === void 0 ? [p, g] : [p, g, v]), this.context.state !== "closed") {
      tp(this);
      const x = () => {
        this._nativeAudioBufferSourceNode.removeEventListener("ended", x), Du(this) && Yg(this);
      };
      this._nativeAudioBufferSourceNode.addEventListener("ended", x);
    }
  }
  stop(p = 0) {
    this._nativeAudioBufferSourceNode.stop(p), this._audioBufferSourceNodeRenderer !== null && (this._audioBufferSourceNodeRenderer.stop = p);
  }
}, PN = (e, t, n, i, s) => () => {
  const o = /* @__PURE__ */ new WeakMap();
  let u = null, h = null;
  const f = async (p, g) => {
    let v = n(p);
    const x = za(v, g);
    if (!x) {
      const b = {
        buffer: v.buffer,
        channelCount: v.channelCount,
        channelCountMode: v.channelCountMode,
        channelInterpretation: v.channelInterpretation,
        // Bug #149: Safari does not yet support the detune AudioParam.
        loop: v.loop,
        loopEnd: v.loopEnd,
        loopStart: v.loopStart,
        playbackRate: v.playbackRate.value
      };
      v = t(g, b), u !== null && v.start(...u), h !== null && v.stop(h);
    }
    return o.set(g, v), x ? await e(g, p.playbackRate, v.playbackRate) : await i(g, p.playbackRate, v.playbackRate), await s(p, g, v), v;
  };
  return {
    set start(p) {
      u = p;
    },
    set stop(p) {
      h = p;
    },
    render(p, g) {
      const v = o.get(g);
      return v !== void 0 ? Promise.resolve(v) : f(p, g);
    }
  };
}, UN = (e) => "playbackRate" in e, jN = (e) => "frequency" in e && "gain" in e, LN = (e) => "offset" in e, VN = (e) => !("frequency" in e) && "gain" in e, IN = (e) => "detune" in e && "frequency" in e && !("gain" in e), FN = (e) => "pan" in e, Qa = (e) => Sl(kT, e), Xg = (e) => Sl(DT, e), u2 = (e, t) => {
  const { activeInputs: n } = Qa(e);
  n.forEach((s) => s.forEach(([o]) => {
    t.includes(e) || u2(o, [...t, e]);
  }));
  const i = UN(e) ? [
    // Bug #149: Safari does not yet support the detune AudioParam.
    e.playbackRate
  ] : UT(e) ? Array.from(e.parameters.values()) : jN(e) ? [e.Q, e.detune, e.frequency, e.gain] : LN(e) ? [e.offset] : VN(e) ? [e.gain] : IN(e) ? [e.detune, e.frequency] : FN(e) ? [e.pan] : [];
  for (const s of i) {
    const o = Xg(s);
    o !== void 0 && o.activeInputs.forEach(([u]) => u2(u, t));
  }
  Du(e) && Yg(e);
}, LT = (e) => {
  u2(e.destination, []);
}, qN = (e) => e === void 0 || typeof e == "number" || typeof e == "string" && (e === "balanced" || e === "interactive" || e === "playback"), GN = (e, t, n, i, s, o, u, h, f) => class extends e {
  constructor(g = {}) {
    if (f === null)
      throw new Error("Missing the native AudioContext constructor.");
    let v;
    try {
      v = new f(g);
    } catch (_) {
      throw _.code === 12 && _.message === "sampleRate is not in range" ? n() : _;
    }
    if (v === null)
      throw i();
    if (!qN(g.latencyHint))
      throw new TypeError(`The provided value '${g.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);
    if (g.sampleRate !== void 0 && v.sampleRate !== g.sampleRate)
      throw n();
    super(v, 2);
    const { latencyHint: x } = g, { sampleRate: b } = v;
    if (this._baseLatency = typeof v.baseLatency == "number" ? v.baseLatency : x === "balanced" ? 512 / b : x === "interactive" || x === void 0 ? 256 / b : x === "playback" ? 1024 / b : (
      /*
       * @todo The min (256) and max (16384) values are taken from the allowed bufferSize values of a
       * ScriptProcessorNode.
       */
      Math.max(2, Math.min(128, Math.round(x * b / 128))) * 128 / b
    ), this._nativeAudioContext = v, f.name === "webkitAudioContext" ? (this._nativeGainNode = v.createGain(), this._nativeOscillatorNode = v.createOscillator(), this._nativeGainNode.gain.value = 1e-37, this._nativeOscillatorNode.connect(this._nativeGainNode).connect(v.destination), this._nativeOscillatorNode.start()) : (this._nativeGainNode = null, this._nativeOscillatorNode = null), this._state = null, v.state === "running") {
      this._state = "suspended";
      const _ = () => {
        this._state === "suspended" && (this._state = null), v.removeEventListener("statechange", _);
      };
      v.addEventListener("statechange", _);
    }
  }
  get baseLatency() {
    return this._baseLatency;
  }
  get state() {
    return this._state !== null ? this._state : this._nativeAudioContext.state;
  }
  close() {
    return this.state === "closed" ? this._nativeAudioContext.close().then(() => {
      throw t();
    }) : (this._state === "suspended" && (this._state = null), this._nativeAudioContext.close().then(() => {
      this._nativeGainNode !== null && this._nativeOscillatorNode !== null && (this._nativeOscillatorNode.stop(), this._nativeGainNode.disconnect(), this._nativeOscillatorNode.disconnect()), LT(this);
    }));
  }
  createMediaElementSource(g) {
    return new s(this, { mediaElement: g });
  }
  createMediaStreamDestination() {
    return new o(this);
  }
  createMediaStreamSource(g) {
    return new u(this, { mediaStream: g });
  }
  createMediaStreamTrackSource(g) {
    return new h(this, { mediaStreamTrack: g });
  }
  resume() {
    return this._state === "suspended" ? new Promise((g, v) => {
      const x = () => {
        this._nativeAudioContext.removeEventListener("statechange", x), this._nativeAudioContext.state === "running" ? g() : this.resume().then(g, v);
      };
      this._nativeAudioContext.addEventListener("statechange", x);
    }) : this._nativeAudioContext.resume().catch((g) => {
      throw g === void 0 || g.code === 15 ? t() : g;
    });
  }
  suspend() {
    return this._nativeAudioContext.suspend().catch((g) => {
      throw g === void 0 ? t() : g;
    });
  }
}, HN = (e, t, n, i, s, o, u, h) => class extends e {
  constructor(p, g) {
    const v = o(p), x = u(v), b = s(v, g, x), _ = x ? t(h) : null;
    super(p, !1, b, _), this._isNodeOfNativeOfflineAudioContext = x, this._nativeAudioDestinationNode = b;
  }
  get channelCount() {
    return this._nativeAudioDestinationNode.channelCount;
  }
  set channelCount(p) {
    if (this._isNodeOfNativeOfflineAudioContext)
      throw i();
    if (p > this._nativeAudioDestinationNode.maxChannelCount)
      throw n();
    this._nativeAudioDestinationNode.channelCount = p;
  }
  get channelCountMode() {
    return this._nativeAudioDestinationNode.channelCountMode;
  }
  set channelCountMode(p) {
    if (this._isNodeOfNativeOfflineAudioContext)
      throw i();
    this._nativeAudioDestinationNode.channelCountMode = p;
  }
  get maxChannelCount() {
    return this._nativeAudioDestinationNode.maxChannelCount;
  }
}, KN = (e) => {
  const t = /* @__PURE__ */ new WeakMap(), n = async (i, s) => {
    const o = s.destination;
    return t.set(s, o), await e(i, s, o), o;
  };
  return {
    render(i, s) {
      const o = t.get(s);
      return o !== void 0 ? Promise.resolve(o) : n(i, s);
    }
  };
}, YN = (e, t, n, i, s, o, u, h) => (f, p) => {
  const g = p.listener, v = () => {
    const N = new Float32Array(1), U = t(p, {
      channelCount: 1,
      channelCountMode: "explicit",
      channelInterpretation: "speakers",
      numberOfInputs: 9
    }), q = u(p);
    let j = !1, V = [0, 0, -1, 0, 1, 0], D = [0, 0, 0];
    const G = () => {
      if (j)
        return;
      j = !0;
      const I = i(p, 256, 9, 0);
      I.onaudioprocess = ({ inputBuffer: K }) => {
        const Q = [
          o(K, N, 0),
          o(K, N, 1),
          o(K, N, 2),
          o(K, N, 3),
          o(K, N, 4),
          o(K, N, 5)
        ];
        Q.some((nt, X) => nt !== V[X]) && (g.setOrientation(...Q), V = Q);
        const it = [
          o(K, N, 6),
          o(K, N, 7),
          o(K, N, 8)
        ];
        it.some((nt, X) => nt !== D[X]) && (g.setPosition(...it), D = it);
      }, U.connect(I);
    }, W = (I) => (K) => {
      K !== V[I] && (V[I] = K, g.setOrientation(...V));
    }, P = (I) => (K) => {
      K !== D[I] && (D[I] = K, g.setPosition(...D));
    }, H = (I, K, Q) => {
      const it = n(p, {
        channelCount: 1,
        channelCountMode: "explicit",
        channelInterpretation: "discrete",
        offset: K
      });
      it.connect(U, 0, I), it.start(), Object.defineProperty(it.offset, "defaultValue", {
        get() {
          return K;
        }
      });
      const nt = e({ context: f }, q, it.offset, $a, Ks);
      return h(nt, "value", (X) => () => X.call(nt), (X) => (rt) => {
        try {
          X.call(nt, rt);
        } catch (vt) {
          if (vt.code !== 9)
            throw vt;
        }
        G(), q && Q(rt);
      }), nt.cancelAndHoldAtTime = /* @__PURE__ */ ((X) => q ? () => {
        throw s();
      } : (...rt) => {
        const vt = X.apply(nt, rt);
        return G(), vt;
      })(nt.cancelAndHoldAtTime), nt.cancelScheduledValues = /* @__PURE__ */ ((X) => q ? () => {
        throw s();
      } : (...rt) => {
        const vt = X.apply(nt, rt);
        return G(), vt;
      })(nt.cancelScheduledValues), nt.exponentialRampToValueAtTime = /* @__PURE__ */ ((X) => q ? () => {
        throw s();
      } : (...rt) => {
        const vt = X.apply(nt, rt);
        return G(), vt;
      })(nt.exponentialRampToValueAtTime), nt.linearRampToValueAtTime = /* @__PURE__ */ ((X) => q ? () => {
        throw s();
      } : (...rt) => {
        const vt = X.apply(nt, rt);
        return G(), vt;
      })(nt.linearRampToValueAtTime), nt.setTargetAtTime = /* @__PURE__ */ ((X) => q ? () => {
        throw s();
      } : (...rt) => {
        const vt = X.apply(nt, rt);
        return G(), vt;
      })(nt.setTargetAtTime), nt.setValueAtTime = /* @__PURE__ */ ((X) => q ? () => {
        throw s();
      } : (...rt) => {
        const vt = X.apply(nt, rt);
        return G(), vt;
      })(nt.setValueAtTime), nt.setValueCurveAtTime = /* @__PURE__ */ ((X) => q ? () => {
        throw s();
      } : (...rt) => {
        const vt = X.apply(nt, rt);
        return G(), vt;
      })(nt.setValueCurveAtTime), nt;
    };
    return {
      forwardX: H(0, 0, W(0)),
      forwardY: H(1, 0, W(1)),
      forwardZ: H(2, -1, W(2)),
      positionX: H(6, 0, P(0)),
      positionY: H(7, 0, P(1)),
      positionZ: H(8, 0, P(2)),
      upX: H(3, 0, W(3)),
      upY: H(4, 1, W(4)),
      upZ: H(5, 0, W(5))
    };
  }, { forwardX: x, forwardY: b, forwardZ: _, positionX: T, positionY: A, positionZ: O, upX: M, upY: E, upZ: R } = g.forwardX === void 0 ? v() : g;
  return {
    get forwardX() {
      return x;
    },
    get forwardY() {
      return b;
    },
    get forwardZ() {
      return _;
    },
    get positionX() {
      return T;
    },
    get positionY() {
      return A;
    },
    get positionZ() {
      return O;
    },
    get upX() {
      return M;
    },
    get upY() {
      return E;
    },
    get upZ() {
      return R;
    }
  };
}, d1 = (e) => "context" in e, Wg = (e) => d1(e[0]), Vh = (e, t, n, i) => {
  for (const s of e)
    if (n(s)) {
      if (i)
        return !1;
      throw Error("The set contains at least one similar element.");
    }
  return e.add(t), !0;
}, bx = (e, t, [n, i], s) => {
  Vh(e, [t, n, i], (o) => o[0] === t && o[1] === n, s);
}, _x = (e, [t, n, i], s) => {
  const o = e.get(t);
  o === void 0 ? e.set(t, /* @__PURE__ */ new Set([[n, i]])) : Vh(o, [n, i], (u) => u[0] === n, s);
}, fp = (e) => "inputs" in e, h1 = (e, t, n, i) => {
  if (fp(t)) {
    const s = t.inputs[i];
    return e.connect(s, n, 0), [s, n, 0];
  }
  return e.connect(t, n, i), [t, n, i];
}, VT = (e, t, n) => {
  for (const i of e)
    if (i[0] === t && i[1] === n)
      return e.delete(i), i;
  return null;
}, XN = (e, t, n) => X1(e, (i) => i[0] === t && i[1] === n), IT = (e, t) => {
  if (!Kg(e).delete(t))
    throw new Error("Missing the expected event listener.");
}, FT = (e, t, n) => {
  const i = Sl(e, t), s = X1(i, (o) => o[0] === n);
  return i.size === 0 && e.delete(t), s;
}, f1 = (e, t, n, i) => {
  fp(t) ? e.disconnect(t.inputs[i], n, 0) : e.disconnect(t, n, i);
}, Ri = (e) => Sl(o_, e), Dg = (e) => Sl(l_, e), Ph = (e) => s2.has(e), Hy = (e) => !Jf.has(e), Sx = (e, t) => new Promise((n) => {
  if (t !== null)
    n(!0);
  else {
    const i = e.createScriptProcessor(256, 1, 1), s = e.createGain(), o = e.createBuffer(1, 2, 44100), u = o.getChannelData(0);
    u[0] = 1, u[1] = 1;
    const h = e.createBufferSource();
    h.buffer = o, h.loop = !0, h.connect(i).connect(e.destination), h.connect(s), h.disconnect(s), i.onaudioprocess = (f) => {
      const p = f.inputBuffer.getChannelData(0);
      Array.prototype.some.call(p, (g) => g === 1) ? n(!0) : n(!1), h.stop(), i.onaudioprocess = null, h.disconnect(i), i.disconnect(e.destination);
    }, h.start();
  }
}), mb = (e, t) => {
  const n = /* @__PURE__ */ new Map();
  for (const i of e)
    for (const s of i) {
      const o = n.get(s);
      n.set(s, o === void 0 ? 1 : o + 1);
    }
  n.forEach((i, s) => t(s, i));
}, p1 = (e) => "context" in e, WN = (e) => {
  const t = /* @__PURE__ */ new Map();
  e.connect = /* @__PURE__ */ ((n) => (i, s = 0, o = 0) => {
    const u = p1(i) ? n(i, s, o) : n(i, s), h = t.get(i);
    return h === void 0 ? t.set(i, [{ input: o, output: s }]) : h.every((f) => f.input !== o || f.output !== s) && h.push({ input: o, output: s }), u;
  })(e.connect.bind(e)), e.disconnect = /* @__PURE__ */ ((n) => (i, s, o) => {
    if (n.apply(e), i === void 0)
      t.clear();
    else if (typeof i == "number")
      for (const [u, h] of t) {
        const f = h.filter((p) => p.output !== i);
        f.length === 0 ? t.delete(u) : t.set(u, f);
      }
    else if (t.has(i))
      if (s === void 0)
        t.delete(i);
      else {
        const u = t.get(i);
        if (u !== void 0) {
          const h = u.filter((f) => f.output !== s && (f.input !== o || o === void 0));
          h.length === 0 ? t.delete(i) : t.set(i, h);
        }
      }
    for (const [u, h] of t)
      h.forEach((f) => {
        p1(u) ? e.connect(u, f.output, f.input) : e.connect(u, f.output);
      });
  })(e.disconnect);
}, $N = (e, t, n, i) => {
  const { activeInputs: s, passiveInputs: o } = Xg(t), { outputs: u } = Qa(e), h = Kg(e), f = (p) => {
    const g = Ri(e), v = Dg(t);
    if (p) {
      const x = FT(o, e, n);
      bx(s, e, x, !1), !i && !Ph(e) && g.connect(v, n);
    } else {
      const x = XN(s, e, n);
      _x(o, x, !1), !i && !Ph(e) && g.disconnect(v, n);
    }
  };
  return Vh(u, [t, n], (p) => p[0] === t && p[1] === n, !0) ? (h.add(f), Du(e) ? bx(s, e, [n, f], !0) : _x(o, [e, n, f], !0), !0) : !1;
}, QN = (e, t, n, i) => {
  const { activeInputs: s, passiveInputs: o } = Qa(t), u = VT(s[i], e, n);
  return u === null ? [PT(o, e, n, i)[2], !1] : [u[2], !0];
}, ZN = (e, t, n) => {
  const { activeInputs: i, passiveInputs: s } = Xg(t), o = VT(i, e, n);
  return o === null ? [FT(s, e, n)[1], !1] : [o[2], !0];
}, u_ = (e, t, n, i, s) => {
  const [o, u] = QN(e, n, i, s);
  if (o !== null && (IT(e, o), u && !t && !Ph(e) && f1(Ri(e), Ri(n), i, s)), Du(n)) {
    const { activeInputs: h } = Qa(n);
    c2(n, h);
  }
}, d_ = (e, t, n, i) => {
  const [s, o] = ZN(e, n, i);
  s !== null && (IT(e, s), o && !t && !Ph(e) && Ri(e).disconnect(Dg(n), i));
}, JN = (e, t) => {
  const n = Qa(e), i = [];
  for (const s of n.outputs)
    Wg(s) ? u_(e, t, ...s) : d_(e, t, ...s), i.push(s[0]);
  return n.outputs.clear(), i;
}, tk = (e, t, n) => {
  const i = Qa(e), s = [];
  for (const o of i.outputs)
    o[1] === n && (Wg(o) ? u_(e, t, ...o) : d_(e, t, ...o), s.push(o[0]), i.outputs.delete(o));
  return s;
}, ek = (e, t, n, i, s) => {
  const o = Qa(e);
  return Array.from(o.outputs).filter((u) => u[0] === n && (i === void 0 || u[1] === i) && (s === void 0 || u[2] === s)).map((u) => (Wg(u) ? u_(e, t, ...u) : d_(e, t, ...u), o.outputs.delete(u), u[0]));
}, nk = (e, t, n, i, s, o, u, h, f, p, g, v, x, b, _, T) => class extends p {
  constructor(O, M, E, R) {
    super(E), this._context = O, this._nativeAudioNode = E;
    const N = g(O);
    v(N) && n(Sx, () => Sx(N, T)) !== !0 && WN(E), o_.set(this, E), BT.set(this, /* @__PURE__ */ new Set()), O.state !== "closed" && M && tp(this), e(this, R, E);
  }
  get channelCount() {
    return this._nativeAudioNode.channelCount;
  }
  set channelCount(O) {
    this._nativeAudioNode.channelCount = O;
  }
  get channelCountMode() {
    return this._nativeAudioNode.channelCountMode;
  }
  set channelCountMode(O) {
    this._nativeAudioNode.channelCountMode = O;
  }
  get channelInterpretation() {
    return this._nativeAudioNode.channelInterpretation;
  }
  set channelInterpretation(O) {
    this._nativeAudioNode.channelInterpretation = O;
  }
  get context() {
    return this._context;
  }
  get numberOfInputs() {
    return this._nativeAudioNode.numberOfInputs;
  }
  get numberOfOutputs() {
    return this._nativeAudioNode.numberOfOutputs;
  }
  // tslint:disable-next-line:invalid-void
  connect(O, M = 0, E = 0) {
    if (M < 0 || M >= this._nativeAudioNode.numberOfOutputs)
      throw s();
    const R = g(this._context), N = _(R);
    if (x(O) || b(O))
      throw o();
    if (d1(O)) {
      const j = Ri(O);
      try {
        const D = h1(this._nativeAudioNode, j, M, E), G = Hy(this);
        (N || G) && this._nativeAudioNode.disconnect(...D), this.context.state !== "closed" && !G && Hy(O) && tp(O);
      } catch (D) {
        throw D.code === 12 ? o() : D;
      }
      if (t(this, O, M, E, N)) {
        const D = f([this], O);
        mb(D, i(N));
      }
      return O;
    }
    const U = Dg(O);
    if (U.name === "playbackRate" && U.maxValue === 1024)
      throw u();
    try {
      this._nativeAudioNode.connect(U, M), (N || Hy(this)) && this._nativeAudioNode.disconnect(U, M);
    } catch (j) {
      throw j.code === 12 ? o() : j;
    }
    if ($N(this, O, M, N)) {
      const j = f([this], O);
      mb(j, i(N));
    }
  }
  disconnect(O, M, E) {
    let R;
    const N = g(this._context), U = _(N);
    if (O === void 0)
      R = JN(this, U);
    else if (typeof O == "number") {
      if (O < 0 || O >= this.numberOfOutputs)
        throw s();
      R = tk(this, U, O);
    } else {
      if (M !== void 0 && (M < 0 || M >= this.numberOfOutputs) || d1(O) && E !== void 0 && (E < 0 || E >= O.numberOfInputs))
        throw s();
      if (R = ek(this, U, O, M, E), R.length === 0)
        throw o();
    }
    for (const q of R) {
      const j = f([this], q);
      mb(j, h);
    }
  }
}, ik = (e, t, n, i, s, o, u, h, f, p, g, v, x) => (b, _, T, A = null, O = null) => {
  const M = T.value, E = new fN(M), R = _ ? i(E) : null, N = {
    get defaultValue() {
      return M;
    },
    get maxValue() {
      return A === null ? T.maxValue : A;
    },
    get minValue() {
      return O === null ? T.minValue : O;
    },
    get value() {
      return T.value;
    },
    set value(U) {
      T.value = U, N.setValueAtTime(U, b.context.currentTime);
    },
    cancelAndHoldAtTime(U) {
      if (typeof T.cancelAndHoldAtTime == "function")
        R === null && E.flush(b.context.currentTime), E.add(s(U)), T.cancelAndHoldAtTime(U);
      else {
        const q = Array.from(E).pop();
        R === null && E.flush(b.context.currentTime), E.add(s(U));
        const j = Array.from(E).pop();
        T.cancelScheduledValues(U), q !== j && j !== void 0 && (j.type === "exponentialRampToValue" ? T.exponentialRampToValueAtTime(j.value, j.endTime) : j.type === "linearRampToValue" ? T.linearRampToValueAtTime(j.value, j.endTime) : j.type === "setValue" ? T.setValueAtTime(j.value, j.startTime) : j.type === "setValueCurve" && T.setValueCurveAtTime(j.values, j.startTime, j.duration));
      }
      return N;
    },
    cancelScheduledValues(U) {
      return R === null && E.flush(b.context.currentTime), E.add(o(U)), T.cancelScheduledValues(U), N;
    },
    exponentialRampToValueAtTime(U, q) {
      if (U === 0)
        throw new RangeError();
      if (!Number.isFinite(q) || q < 0)
        throw new RangeError();
      const j = b.context.currentTime;
      return R === null && E.flush(j), Array.from(E).length === 0 && (E.add(p(M, j)), T.setValueAtTime(M, j)), E.add(u(U, q)), T.exponentialRampToValueAtTime(U, q), N;
    },
    linearRampToValueAtTime(U, q) {
      const j = b.context.currentTime;
      return R === null && E.flush(j), Array.from(E).length === 0 && (E.add(p(M, j)), T.setValueAtTime(M, j)), E.add(h(U, q)), T.linearRampToValueAtTime(U, q), N;
    },
    setTargetAtTime(U, q, j) {
      return R === null && E.flush(b.context.currentTime), E.add(f(U, q, j)), T.setTargetAtTime(U, q, j), N;
    },
    setValueAtTime(U, q) {
      return R === null && E.flush(b.context.currentTime), E.add(p(U, q)), T.setValueAtTime(U, q), N;
    },
    setValueCurveAtTime(U, q, j) {
      const V = U instanceof Float32Array ? U : new Float32Array(U);
      if (v !== null && v.name === "webkitAudioContext") {
        const D = q + j, G = b.context.sampleRate, W = Math.ceil(q * G), P = Math.floor(D * G), H = P - W, I = new Float32Array(H);
        for (let Q = 0; Q < H; Q += 1) {
          const it = (V.length - 1) / j * ((W + Q) / G - q), nt = Math.floor(it), X = Math.ceil(it);
          I[Q] = nt === X ? V[nt] : (1 - (it - nt)) * V[nt] + (1 - (X - it)) * V[X];
        }
        R === null && E.flush(b.context.currentTime), E.add(g(I, q, j)), T.setValueCurveAtTime(I, q, j);
        const K = P / G;
        K < D && x(N, I[I.length - 1], K), x(N, V[V.length - 1], D);
      } else
        R === null && E.flush(b.context.currentTime), E.add(g(V, q, j)), T.setValueCurveAtTime(V, q, j);
      return N;
    }
  };
  return n.set(N, T), t.set(N, b), e(N, R), N;
}, rk = (e) => ({
  replay(t) {
    for (const n of e)
      if (n.type === "exponentialRampToValue") {
        const { endTime: i, value: s } = n;
        t.exponentialRampToValueAtTime(s, i);
      } else if (n.type === "linearRampToValue") {
        const { endTime: i, value: s } = n;
        t.linearRampToValueAtTime(s, i);
      } else if (n.type === "setTarget") {
        const { startTime: i, target: s, timeConstant: o } = n;
        t.setTargetAtTime(s, i, o);
      } else if (n.type === "setValue") {
        const { startTime: i, value: s } = n;
        t.setValueAtTime(s, i);
      } else if (n.type === "setValueCurve") {
        const { duration: i, startTime: s, values: o } = n;
        t.setValueCurveAtTime(o, s, i);
      } else
        throw new Error("Can't apply an unknown automation.");
  }
});
class qT {
  constructor(t) {
    this._map = new Map(t);
  }
  get size() {
    return this._map.size;
  }
  entries() {
    return this._map.entries();
  }
  forEach(t, n = null) {
    return this._map.forEach((i, s) => t.call(n, i, s, this));
  }
  get(t) {
    return this._map.get(t);
  }
  has(t) {
    return this._map.has(t);
  }
  keys() {
    return this._map.keys();
  }
  values() {
    return this._map.values();
  }
}
const ak = {
  channelCount: 2,
  // Bug #61: The channelCountMode should be 'max' according to the spec but is set to 'explicit' to achieve consistent behavior.
  channelCountMode: "explicit",
  channelInterpretation: "speakers",
  numberOfInputs: 1,
  numberOfOutputs: 1,
  parameterData: {},
  processorOptions: {}
}, sk = (e, t, n, i, s, o, u, h, f, p, g, v, x, b) => class extends t {
  constructor(T, A, O) {
    var M;
    const E = h(T), R = f(E), N = g({ ...ak, ...O });
    x(N);
    const U = o2.get(E), q = U == null ? void 0 : U.get(A), j = R || E.state !== "closed" ? E : (M = u(E)) !== null && M !== void 0 ? M : E, V = s(j, R ? null : T.baseLatency, p, A, q, N), D = R ? i(A, N, q) : null;
    super(T, !0, V, D);
    const G = [];
    V.parameters.forEach((P, H) => {
      const I = n(this, R, P);
      G.push([H, I]);
    }), this._nativeAudioWorkletNode = V, this._onprocessorerror = null, this._parameters = new qT(G), R && e(E, this);
    const { activeInputs: W } = o(this);
    v(V, W);
  }
  get onprocessorerror() {
    return this._onprocessorerror;
  }
  set onprocessorerror(T) {
    const A = typeof T == "function" ? b(this, T) : null;
    this._nativeAudioWorkletNode.onprocessorerror = A;
    const O = this._nativeAudioWorkletNode.onprocessorerror;
    this._onprocessorerror = O !== null && O === A ? T : O;
  }
  get parameters() {
    return this._parameters === null ? this._nativeAudioWorkletNode.parameters : this._parameters;
  }
  get port() {
    return this._nativeAudioWorkletNode.port;
  }
};
function m1(e, t, n, i, s) {
  if (typeof e.copyFromChannel == "function")
    t[n].byteLength === 0 && (t[n] = new Float32Array(128)), e.copyFromChannel(t[n], i, s);
  else {
    const o = e.getChannelData(i);
    if (t[n].byteLength === 0)
      t[n] = o.slice(s, s + 128);
    else {
      const u = new Float32Array(o.buffer, s * Float32Array.BYTES_PER_ELEMENT, 128);
      t[n].set(u);
    }
  }
}
const GT = (e, t, n, i, s) => {
  typeof e.copyToChannel == "function" ? t[n].byteLength !== 0 && e.copyToChannel(t[n], i, s) : t[n].byteLength !== 0 && e.getChannelData(i).set(t[n], s);
}, g1 = (e, t) => {
  const n = [];
  for (let i = 0; i < e; i += 1) {
    const s = [], o = typeof t == "number" ? t : t[i];
    for (let u = 0; u < o; u += 1)
      s.push(new Float32Array(128));
    n.push(s);
  }
  return n;
}, ok = (e, t) => {
  const n = Sl(l2, e), i = Ri(t);
  return Sl(n, i);
}, lk = async (e, t, n, i, s, o, u) => {
  const h = t === null ? Math.ceil(e.context.length / 128) * 128 : t.length, f = i.channelCount * i.numberOfInputs, p = s.reduce((A, O) => A + O, 0), g = p === 0 ? null : n.createBuffer(p, h, n.sampleRate);
  if (o === void 0)
    throw new Error("Missing the processor constructor.");
  const v = Qa(e), x = await ok(n, e), b = g1(i.numberOfInputs, i.channelCount), _ = g1(i.numberOfOutputs, s), T = Array.from(e.parameters.keys()).reduce((A, O) => ({ ...A, [O]: new Float32Array(128) }), {});
  for (let A = 0; A < h; A += 128) {
    if (i.numberOfInputs > 0 && t !== null)
      for (let O = 0; O < i.numberOfInputs; O += 1)
        for (let M = 0; M < i.channelCount; M += 1)
          m1(t, b[O], M, M, A);
    o.parameterDescriptors !== void 0 && t !== null && o.parameterDescriptors.forEach(({ name: O }, M) => {
      m1(t, T, O, f + M, A);
    });
    for (let O = 0; O < i.numberOfInputs; O += 1)
      for (let M = 0; M < s[O]; M += 1)
        _[O][M].byteLength === 0 && (_[O][M] = new Float32Array(128));
    try {
      const O = b.map((E, R) => v.activeInputs[R].size === 0 ? [] : E), M = u(A / n.sampleRate, n.sampleRate, () => x.process(O, _, T));
      if (g !== null)
        for (let E = 0, R = 0; E < i.numberOfOutputs; E += 1) {
          for (let N = 0; N < s[E]; N += 1)
            GT(g, _[E], N, R + N, A);
          R += s[E];
        }
      if (!M)
        break;
    } catch (O) {
      e.dispatchEvent(new ErrorEvent("processorerror", {
        colno: O.colno,
        filename: O.filename,
        lineno: O.lineno,
        message: O.message
      }));
      break;
    }
  }
  return g;
}, ck = (e, t, n, i, s, o, u, h, f, p, g, v, x, b, _, T) => (A, O, M) => {
  const E = /* @__PURE__ */ new WeakMap();
  let R = null;
  const N = async (U, q) => {
    let j = g(U), V = null;
    const D = za(j, q), G = Array.isArray(O.outputChannelCount) ? O.outputChannelCount : Array.from(O.outputChannelCount);
    if (v === null) {
      const W = G.reduce((K, Q) => K + Q, 0), P = s(q, {
        channelCount: Math.max(1, W),
        channelCountMode: "explicit",
        channelInterpretation: "discrete",
        numberOfOutputs: Math.max(1, W)
      }), H = [];
      for (let K = 0; K < U.numberOfOutputs; K += 1)
        H.push(i(q, {
          channelCount: 1,
          channelCountMode: "explicit",
          channelInterpretation: "speakers",
          numberOfInputs: G[K]
        }));
      const I = u(q, {
        channelCount: O.channelCount,
        channelCountMode: O.channelCountMode,
        channelInterpretation: O.channelInterpretation,
        gain: 1
      });
      I.connect = t.bind(null, H), I.disconnect = f.bind(null, H), V = [P, H, I];
    } else D || (j = new v(q, A));
    if (E.set(q, V === null ? j : V[2]), V !== null) {
      if (R === null) {
        if (M === void 0)
          throw new Error("Missing the processor constructor.");
        if (x === null)
          throw new Error("Missing the native OfflineAudioContext constructor.");
        const Q = U.channelCount * U.numberOfInputs, it = M.parameterDescriptors === void 0 ? 0 : M.parameterDescriptors.length, nt = Q + it;
        R = lk(U, nt === 0 ? null : await (async () => {
          const rt = new x(
            nt,
            // Ceil the length to the next full render quantum.
            // Bug #17: Safari does not yet expose the length.
            Math.ceil(U.context.length / 128) * 128,
            q.sampleRate
          ), vt = [], ct = [];
          for (let Et = 0; Et < O.numberOfInputs; Et += 1)
            vt.push(u(rt, {
              channelCount: O.channelCount,
              channelCountMode: O.channelCountMode,
              channelInterpretation: O.channelInterpretation,
              gain: 1
            })), ct.push(s(rt, {
              channelCount: O.channelCount,
              channelCountMode: "explicit",
              channelInterpretation: "discrete",
              numberOfOutputs: O.channelCount
            }));
          const dt = await Promise.all(Array.from(U.parameters.values()).map(async (Et) => {
            const ot = o(rt, {
              channelCount: 1,
              channelCountMode: "explicit",
              channelInterpretation: "discrete",
              offset: Et.value
            });
            return await b(rt, Et, ot.offset), ot;
          })), ht = i(rt, {
            channelCount: 1,
            channelCountMode: "explicit",
            channelInterpretation: "speakers",
            numberOfInputs: Math.max(1, Q + it)
          });
          for (let Et = 0; Et < O.numberOfInputs; Et += 1) {
            vt[Et].connect(ct[Et]);
            for (let ot = 0; ot < O.channelCount; ot += 1)
              ct[Et].connect(ht, ot, Et * O.channelCount + ot);
          }
          for (const [Et, ot] of dt.entries())
            ot.connect(ht, 0, Q + Et), ot.start(0);
          return ht.connect(rt.destination), await Promise.all(vt.map((Et) => _(U, rt, Et))), T(rt);
        })(), q, O, G, M, p);
      }
      const W = await R, P = n(q, {
        buffer: null,
        channelCount: 2,
        channelCountMode: "max",
        channelInterpretation: "speakers",
        loop: !1,
        loopEnd: 0,
        loopStart: 0,
        playbackRate: 1
      }), [H, I, K] = V;
      W !== null && (P.buffer = W, P.start(0)), P.connect(H);
      for (let Q = 0, it = 0; Q < U.numberOfOutputs; Q += 1) {
        const nt = I[Q];
        for (let X = 0; X < G[Q]; X += 1)
          H.connect(nt, it + X, X);
        it += G[Q];
      }
      return K;
    }
    if (D)
      for (const [W, P] of U.parameters.entries())
        await e(
          q,
          P,
          // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.
          j.parameters.get(W)
        );
    else
      for (const [W, P] of U.parameters.entries())
        await b(
          q,
          P,
          // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.
          j.parameters.get(W)
        );
    return await _(U, q, j), j;
  };
  return {
    render(U, q) {
      h(q, U);
      const j = E.get(q);
      return j !== void 0 ? Promise.resolve(j) : N(U, q);
    }
  };
}, uk = (e, t, n, i, s, o, u, h, f, p, g, v, x, b, _, T, A, O, M, E) => class extends _ {
  constructor(N, U) {
    super(N, U), this._nativeContext = N, this._audioWorklet = e === void 0 ? void 0 : {
      addModule: (q, j) => e(this, q, j)
    };
  }
  get audioWorklet() {
    return this._audioWorklet;
  }
  createAnalyser() {
    return new t(this);
  }
  createBiquadFilter() {
    return new s(this);
  }
  createBuffer(N, U, q) {
    return new n({ length: U, numberOfChannels: N, sampleRate: q });
  }
  createBufferSource() {
    return new i(this);
  }
  createChannelMerger(N = 6) {
    return new o(this, { numberOfInputs: N });
  }
  createChannelSplitter(N = 6) {
    return new u(this, { numberOfOutputs: N });
  }
  createConstantSource() {
    return new h(this);
  }
  createConvolver() {
    return new f(this);
  }
  createDelay(N = 1) {
    return new g(this, { maxDelayTime: N });
  }
  createDynamicsCompressor() {
    return new v(this);
  }
  createGain() {
    return new x(this);
  }
  createIIRFilter(N, U) {
    return new b(this, { feedback: U, feedforward: N });
  }
  createOscillator() {
    return new T(this);
  }
  createPanner() {
    return new A(this);
  }
  createPeriodicWave(N, U, q = { disableNormalization: !1 }) {
    return new O(this, { ...q, imag: U, real: N });
  }
  createStereoPanner() {
    return new M(this);
  }
  createWaveShaper() {
    return new E(this);
  }
  decodeAudioData(N, U, q) {
    return p(this._nativeContext, N).then((j) => (typeof U == "function" && U(j), j), (j) => {
      throw typeof q == "function" && q(j), j;
    });
  }
}, dk = {
  Q: 1,
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers",
  detune: 0,
  frequency: 350,
  gain: 0,
  type: "lowpass"
}, hk = (e, t, n, i, s, o, u, h) => class extends e {
  constructor(p, g) {
    const v = o(p), x = { ...dk, ...g }, b = s(v, x), _ = u(v), T = _ ? n() : null;
    super(p, !1, b, T), this._Q = t(this, _, b.Q, $a, Ks), this._detune = t(this, _, b.detune, 1200 * Math.log2($a), -1200 * Math.log2($a)), this._frequency = t(this, _, b.frequency, p.sampleRate / 2, 0), this._gain = t(this, _, b.gain, 40 * Math.log10($a), Ks), this._nativeBiquadFilterNode = b, h(this, 1);
  }
  get detune() {
    return this._detune;
  }
  get frequency() {
    return this._frequency;
  }
  get gain() {
    return this._gain;
  }
  get Q() {
    return this._Q;
  }
  get type() {
    return this._nativeBiquadFilterNode.type;
  }
  set type(p) {
    this._nativeBiquadFilterNode.type = p;
  }
  getFrequencyResponse(p, g, v) {
    try {
      this._nativeBiquadFilterNode.getFrequencyResponse(p, g, v);
    } catch (x) {
      throw x.code === 11 ? i() : x;
    }
    if (p.length !== g.length || g.length !== v.length)
      throw i();
  }
}, fk = (e, t, n, i, s) => () => {
  const o = /* @__PURE__ */ new WeakMap(), u = async (h, f) => {
    let p = n(h);
    const g = za(p, f);
    if (!g) {
      const v = {
        Q: p.Q.value,
        channelCount: p.channelCount,
        channelCountMode: p.channelCountMode,
        channelInterpretation: p.channelInterpretation,
        detune: p.detune.value,
        frequency: p.frequency.value,
        gain: p.gain.value,
        type: p.type
      };
      p = t(f, v);
    }
    return o.set(f, p), g ? (await e(f, h.Q, p.Q), await e(f, h.detune, p.detune), await e(f, h.frequency, p.frequency), await e(f, h.gain, p.gain)) : (await i(f, h.Q, p.Q), await i(f, h.detune, p.detune), await i(f, h.frequency, p.frequency), await i(f, h.gain, p.gain)), await s(h, f, p), p;
  };
  return {
    render(h, f) {
      const p = o.get(f);
      return p !== void 0 ? Promise.resolve(p) : u(h, f);
    }
  };
}, pk = (e, t) => (n, i) => {
  const s = t.get(n);
  if (s !== void 0)
    return s;
  const o = e.get(n);
  if (o !== void 0)
    return o;
  try {
    const u = i();
    return u instanceof Promise ? (e.set(n, u), u.catch(() => !1).then((h) => (e.delete(n), t.set(n, h), h))) : (t.set(n, u), u);
  } catch {
    return t.set(n, !1), !1;
  }
}, mk = {
  channelCount: 1,
  channelCountMode: "explicit",
  channelInterpretation: "speakers",
  numberOfInputs: 6
}, gk = (e, t, n, i, s) => class extends e {
  constructor(u, h) {
    const f = i(u), p = { ...mk, ...h }, g = n(f, p), v = s(f) ? t() : null;
    super(u, !1, g, v);
  }
}, yk = (e, t, n) => () => {
  const i = /* @__PURE__ */ new WeakMap(), s = async (o, u) => {
    let h = t(o);
    if (!za(h, u)) {
      const p = {
        channelCount: h.channelCount,
        channelCountMode: h.channelCountMode,
        channelInterpretation: h.channelInterpretation,
        numberOfInputs: h.numberOfInputs
      };
      h = e(u, p);
    }
    return i.set(u, h), await n(o, u, h), h;
  };
  return {
    render(o, u) {
      const h = i.get(u);
      return h !== void 0 ? Promise.resolve(h) : s(o, u);
    }
  };
}, vk = {
  channelCount: 6,
  channelCountMode: "explicit",
  channelInterpretation: "discrete",
  numberOfOutputs: 6
}, bk = (e, t, n, i, s, o) => class extends e {
  constructor(h, f) {
    const p = i(h), g = o({ ...vk, ...f }), v = n(p, g), x = s(p) ? t() : null;
    super(h, !1, v, x);
  }
}, _k = (e, t, n) => () => {
  const i = /* @__PURE__ */ new WeakMap(), s = async (o, u) => {
    let h = t(o);
    if (!za(h, u)) {
      const p = {
        channelCount: h.channelCount,
        channelCountMode: h.channelCountMode,
        channelInterpretation: h.channelInterpretation,
        numberOfOutputs: h.numberOfOutputs
      };
      h = e(u, p);
    }
    return i.set(u, h), await n(o, u, h), h;
  };
  return {
    render(o, u) {
      const h = i.get(u);
      return h !== void 0 ? Promise.resolve(h) : s(o, u);
    }
  };
}, Sk = (e) => (t, n, i) => e(n, t, i), xk = (e) => (t, n, i = 0, s = 0) => {
  const o = t[i];
  if (o === void 0)
    throw e();
  return p1(n) ? o.connect(n, 0, s) : o.connect(n, 0);
}, Tk = (e) => (t, n) => {
  const i = e(t, {
    buffer: null,
    channelCount: 2,
    channelCountMode: "max",
    channelInterpretation: "speakers",
    loop: !1,
    loopEnd: 0,
    loopStart: 0,
    playbackRate: 1
  }), s = t.createBuffer(1, 2, 44100);
  return i.buffer = s, i.loop = !0, i.connect(n), i.start(), () => {
    i.stop(), i.disconnect(n);
  };
}, Ck = {
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers",
  offset: 1
}, wk = (e, t, n, i, s, o, u) => class extends e {
  constructor(f, p) {
    const g = s(f), v = { ...Ck, ...p }, x = i(g, v), b = o(g), _ = b ? n() : null;
    super(f, !1, x, _), this._constantSourceNodeRenderer = _, this._nativeConstantSourceNode = x, this._offset = t(this, b, x.offset, $a, Ks), this._onended = null;
  }
  get offset() {
    return this._offset;
  }
  get onended() {
    return this._onended;
  }
  set onended(f) {
    const p = typeof f == "function" ? u(this, f) : null;
    this._nativeConstantSourceNode.onended = p;
    const g = this._nativeConstantSourceNode.onended;
    this._onended = g !== null && g === p ? f : g;
  }
  start(f = 0) {
    if (this._nativeConstantSourceNode.start(f), this._constantSourceNodeRenderer !== null && (this._constantSourceNodeRenderer.start = f), this.context.state !== "closed") {
      tp(this);
      const p = () => {
        this._nativeConstantSourceNode.removeEventListener("ended", p), Du(this) && Yg(this);
      };
      this._nativeConstantSourceNode.addEventListener("ended", p);
    }
  }
  stop(f = 0) {
    this._nativeConstantSourceNode.stop(f), this._constantSourceNodeRenderer !== null && (this._constantSourceNodeRenderer.stop = f);
  }
}, Ek = (e, t, n, i, s) => () => {
  const o = /* @__PURE__ */ new WeakMap();
  let u = null, h = null;
  const f = async (p, g) => {
    let v = n(p);
    const x = za(v, g);
    if (!x) {
      const b = {
        channelCount: v.channelCount,
        channelCountMode: v.channelCountMode,
        channelInterpretation: v.channelInterpretation,
        offset: v.offset.value
      };
      v = t(g, b), u !== null && v.start(u), h !== null && v.stop(h);
    }
    return o.set(g, v), x ? await e(g, p.offset, v.offset) : await i(g, p.offset, v.offset), await s(p, g, v), v;
  };
  return {
    set start(p) {
      u = p;
    },
    set stop(p) {
      h = p;
    },
    render(p, g) {
      const v = o.get(g);
      return v !== void 0 ? Promise.resolve(v) : f(p, g);
    }
  };
}, Ak = (e) => (t) => (e[0] = t, e[0]), Mk = {
  buffer: null,
  channelCount: 2,
  channelCountMode: "clamped-max",
  channelInterpretation: "speakers",
  disableNormalization: !1
}, Rk = (e, t, n, i, s, o) => class extends e {
  constructor(h, f) {
    const p = i(h), g = { ...Mk, ...f }, v = n(p, g), b = s(p) ? t() : null;
    super(h, !1, v, b), this._isBufferNullified = !1, this._nativeConvolverNode = v, g.buffer !== null && o(this, g.buffer.duration);
  }
  get buffer() {
    return this._isBufferNullified ? null : this._nativeConvolverNode.buffer;
  }
  set buffer(h) {
    if (this._nativeConvolverNode.buffer = h, h === null && this._nativeConvolverNode.buffer !== null) {
      const f = this._nativeConvolverNode.context;
      this._nativeConvolverNode.buffer = f.createBuffer(1, 1, f.sampleRate), this._isBufferNullified = !0, o(this, 0);
    } else
      this._isBufferNullified = !1, o(this, this._nativeConvolverNode.buffer === null ? 0 : this._nativeConvolverNode.buffer.duration);
  }
  get normalize() {
    return this._nativeConvolverNode.normalize;
  }
  set normalize(h) {
    this._nativeConvolverNode.normalize = h;
  }
}, Ok = (e, t, n) => () => {
  const i = /* @__PURE__ */ new WeakMap(), s = async (o, u) => {
    let h = t(o);
    if (!za(h, u)) {
      const p = {
        buffer: h.buffer,
        channelCount: h.channelCount,
        channelCountMode: h.channelCountMode,
        channelInterpretation: h.channelInterpretation,
        disableNormalization: !h.normalize
      };
      h = e(u, p);
    }
    return i.set(u, h), fp(h) ? await n(o, u, h.inputs[0]) : await n(o, u, h), h;
  };
  return {
    render(o, u) {
      const h = i.get(u);
      return h !== void 0 ? Promise.resolve(h) : s(o, u);
    }
  };
}, Nk = (e, t) => (n, i, s) => {
  if (t === null)
    throw new Error("Missing the native OfflineAudioContext constructor.");
  try {
    return new t(n, i, s);
  } catch (o) {
    throw o.name === "SyntaxError" ? e() : o;
  }
}, kk = () => new DOMException("", "DataCloneError"), xx = (e) => {
  const { port1: t, port2: n } = new MessageChannel();
  return new Promise((i) => {
    const s = () => {
      n.onmessage = null, t.close(), n.close(), i();
    };
    n.onmessage = () => s();
    try {
      t.postMessage(e, [e]);
    } catch {
    } finally {
      s();
    }
  });
}, Dk = (e, t, n, i, s, o, u, h, f, p, g) => (v, x) => {
  const b = u(v) ? v : o(v);
  if (s.has(x)) {
    const _ = n();
    return Promise.reject(_);
  }
  try {
    s.add(x);
  } catch {
  }
  return t(f, () => f(b)) ? b.decodeAudioData(x).then((_) => (xx(x).catch(() => {
  }), t(h, () => h(_)) || g(_), e.add(_), _)) : new Promise((_, T) => {
    const A = async () => {
      try {
        await xx(x);
      } catch {
      }
    }, O = (M) => {
      T(M), A();
    };
    try {
      b.decodeAudioData(x, (M) => {
        typeof M.copyFromChannel != "function" && (p(M), c_(M)), e.add(M), A().then(() => _(M));
      }, (M) => {
        O(M === null ? i() : M);
      });
    } catch (M) {
      O(M);
    }
  });
}, Bk = (e, t, n, i, s, o, u, h) => (f, p) => {
  const g = t.get(f);
  if (g === void 0)
    throw new Error("Missing the expected cycle count.");
  const v = o(f.context), x = h(v);
  if (g === p) {
    if (t.delete(f), !x && u(f)) {
      const b = i(f), { outputs: _ } = n(f);
      for (const T of _)
        if (Wg(T)) {
          const A = i(T[0]);
          e(b, A, T[1], T[2]);
        } else {
          const A = s(T[0]);
          b.connect(A, T[1]);
        }
    }
  } else
    t.set(f, g - p);
}, zk = {
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers",
  delayTime: 0,
  maxDelayTime: 1
}, Pk = (e, t, n, i, s, o, u) => class extends e {
  constructor(f, p) {
    const g = s(f), v = { ...zk, ...p }, x = i(g, v), b = o(g), _ = b ? n(v.maxDelayTime) : null;
    super(f, !1, x, _), this._delayTime = t(this, b, x.delayTime), u(this, v.maxDelayTime);
  }
  get delayTime() {
    return this._delayTime;
  }
}, Uk = (e, t, n, i, s) => (o) => {
  const u = /* @__PURE__ */ new WeakMap(), h = async (f, p) => {
    let g = n(f);
    const v = za(g, p);
    if (!v) {
      const x = {
        channelCount: g.channelCount,
        channelCountMode: g.channelCountMode,
        channelInterpretation: g.channelInterpretation,
        delayTime: g.delayTime.value,
        maxDelayTime: o
      };
      g = t(p, x);
    }
    return u.set(p, g), v ? await e(p, f.delayTime, g.delayTime) : await i(p, f.delayTime, g.delayTime), await s(f, p, g), g;
  };
  return {
    render(f, p) {
      const g = u.get(p);
      return g !== void 0 ? Promise.resolve(g) : h(f, p);
    }
  };
}, jk = (e) => (t, n, i, s) => e(t[s], (o) => o[0] === n && o[1] === i), Lk = (e) => (t, n) => {
  e(t).delete(n);
}, Vk = (e) => "delayTime" in e, Ik = (e, t, n) => function i(s, o) {
  const u = d1(o) ? o : n(e, o);
  if (Vk(u))
    return [];
  if (s[0] === u)
    return [s];
  if (s.includes(u))
    return [];
  const { outputs: h } = t(u);
  return Array.from(h).map((f) => i([...s, u], f[0])).reduce((f, p) => f.concat(p), []);
}, ky = (e, t, n) => {
  const i = t[n];
  if (i === void 0)
    throw e();
  return i;
}, Fk = (e) => (t, n = void 0, i = void 0, s = 0) => n === void 0 ? t.forEach((o) => o.disconnect()) : typeof n == "number" ? ky(e, t, n).disconnect() : p1(n) ? i === void 0 ? t.forEach((o) => o.disconnect(n)) : s === void 0 ? ky(e, t, i).disconnect(n, 0) : ky(e, t, i).disconnect(n, 0, s) : i === void 0 ? t.forEach((o) => o.disconnect(n)) : ky(e, t, i).disconnect(n, 0), qk = {
  attack: 3e-3,
  channelCount: 2,
  channelCountMode: "clamped-max",
  channelInterpretation: "speakers",
  knee: 30,
  ratio: 12,
  release: 0.25,
  threshold: -24
}, Gk = (e, t, n, i, s, o, u, h) => class extends e {
  constructor(p, g) {
    const v = o(p), x = { ...qk, ...g }, b = i(v, x), _ = u(v), T = _ ? n() : null;
    super(p, !1, b, T), this._attack = t(this, _, b.attack), this._knee = t(this, _, b.knee), this._nativeDynamicsCompressorNode = b, this._ratio = t(this, _, b.ratio), this._release = t(this, _, b.release), this._threshold = t(this, _, b.threshold), h(this, 6e-3);
  }
  get attack() {
    return this._attack;
  }
  // Bug #108: Safari allows a channelCount of three and above which is why the getter and setter needs to be overwritten here.
  get channelCount() {
    return this._nativeDynamicsCompressorNode.channelCount;
  }
  set channelCount(p) {
    const g = this._nativeDynamicsCompressorNode.channelCount;
    if (this._nativeDynamicsCompressorNode.channelCount = p, p > 2)
      throw this._nativeDynamicsCompressorNode.channelCount = g, s();
  }
  /*
   * Bug #109: Only Chrome and Firefox disallow a channelCountMode of 'max' yet which is why the getter and setter needs to be
   * overwritten here.
   */
  get channelCountMode() {
    return this._nativeDynamicsCompressorNode.channelCountMode;
  }
  set channelCountMode(p) {
    const g = this._nativeDynamicsCompressorNode.channelCountMode;
    if (this._nativeDynamicsCompressorNode.channelCountMode = p, p === "max")
      throw this._nativeDynamicsCompressorNode.channelCountMode = g, s();
  }
  get knee() {
    return this._knee;
  }
  get ratio() {
    return this._ratio;
  }
  get reduction() {
    return typeof this._nativeDynamicsCompressorNode.reduction.value == "number" ? this._nativeDynamicsCompressorNode.reduction.value : this._nativeDynamicsCompressorNode.reduction;
  }
  get release() {
    return this._release;
  }
  get threshold() {
    return this._threshold;
  }
}, Hk = (e, t, n, i, s) => () => {
  const o = /* @__PURE__ */ new WeakMap(), u = async (h, f) => {
    let p = n(h);
    const g = za(p, f);
    if (!g) {
      const v = {
        attack: p.attack.value,
        channelCount: p.channelCount,
        channelCountMode: p.channelCountMode,
        channelInterpretation: p.channelInterpretation,
        knee: p.knee.value,
        ratio: p.ratio.value,
        release: p.release.value,
        threshold: p.threshold.value
      };
      p = t(f, v);
    }
    return o.set(f, p), g ? (await e(f, h.attack, p.attack), await e(f, h.knee, p.knee), await e(f, h.ratio, p.ratio), await e(f, h.release, p.release), await e(f, h.threshold, p.threshold)) : (await i(f, h.attack, p.attack), await i(f, h.knee, p.knee), await i(f, h.ratio, p.ratio), await i(f, h.release, p.release), await i(f, h.threshold, p.threshold)), await s(h, f, p), p;
  };
  return {
    render(h, f) {
      const p = o.get(f);
      return p !== void 0 ? Promise.resolve(p) : u(h, f);
    }
  };
}, Kk = () => new DOMException("", "EncodingError"), Yk = (e) => (t) => new Promise((n, i) => {
  if (e === null) {
    i(new SyntaxError());
    return;
  }
  const s = e.document.head;
  if (s === null)
    i(new SyntaxError());
  else {
    const o = e.document.createElement("script"), u = new Blob([t], { type: "application/javascript" }), h = URL.createObjectURL(u), f = e.onerror, p = () => {
      e.onerror = f, URL.revokeObjectURL(h);
    };
    e.onerror = (g, v, x, b, _) => {
      if (v === h || v === e.location.href && x === 1 && b === 1)
        return p(), i(_), !1;
      if (f !== null)
        return f(g, v, x, b, _);
    }, o.onerror = () => {
      p(), i(new SyntaxError());
    }, o.onload = () => {
      p(), n();
    }, o.src = h, o.type = "module", s.appendChild(o);
  }
}), Xk = (e) => class {
  constructor(n) {
    this._nativeEventTarget = n, this._listeners = /* @__PURE__ */ new WeakMap();
  }
  addEventListener(n, i, s) {
    if (i !== null) {
      let o = this._listeners.get(i);
      o === void 0 && (o = e(this, i), typeof i == "function" && this._listeners.set(i, o)), this._nativeEventTarget.addEventListener(n, o, s);
    }
  }
  dispatchEvent(n) {
    return this._nativeEventTarget.dispatchEvent(n);
  }
  removeEventListener(n, i, s) {
    const o = i === null ? void 0 : this._listeners.get(i);
    this._nativeEventTarget.removeEventListener(n, o === void 0 ? null : o, s);
  }
}, Wk = (e) => (t, n, i) => {
  Object.defineProperties(e, {
    currentFrame: {
      configurable: !0,
      get() {
        return Math.round(t * n);
      }
    },
    currentTime: {
      configurable: !0,
      get() {
        return t;
      }
    }
  });
  try {
    return i();
  } finally {
    e !== null && (delete e.currentFrame, delete e.currentTime);
  }
}, $k = (e) => async (t) => {
  try {
    const n = await fetch(t);
    if (n.ok)
      return [await n.text(), n.url];
  } catch {
  }
  throw e();
}, Qk = {
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers",
  gain: 1
}, Zk = (e, t, n, i, s, o) => class extends e {
  constructor(h, f) {
    const p = s(h), g = { ...Qk, ...f }, v = i(p, g), x = o(p), b = x ? n() : null;
    super(h, !1, v, b), this._gain = t(this, x, v.gain, $a, Ks);
  }
  get gain() {
    return this._gain;
  }
}, Jk = (e, t, n, i, s) => () => {
  const o = /* @__PURE__ */ new WeakMap(), u = async (h, f) => {
    let p = n(h);
    const g = za(p, f);
    if (!g) {
      const v = {
        channelCount: p.channelCount,
        channelCountMode: p.channelCountMode,
        channelInterpretation: p.channelInterpretation,
        gain: p.gain.value
      };
      p = t(f, v);
    }
    return o.set(f, p), g ? await e(f, h.gain, p.gain) : await i(f, h.gain, p.gain), await s(h, f, p), p;
  };
  return {
    render(h, f) {
      const p = o.get(f);
      return p !== void 0 ? Promise.resolve(p) : u(h, f);
    }
  };
}, tD = (e, t) => (n) => t(e, n), eD = (e) => (t) => {
  const n = e(t);
  if (n.renderer === null)
    throw new Error("Missing the renderer of the given AudioNode in the audio graph.");
  return n.renderer;
}, nD = (e) => (t) => {
  var n;
  return (n = e.get(t)) !== null && n !== void 0 ? n : 0;
}, iD = (e) => (t) => {
  const n = e(t);
  if (n.renderer === null)
    throw new Error("Missing the renderer of the given AudioParam in the audio graph.");
  return n.renderer;
}, rD = (e) => (t) => e.get(t), Zr = () => new DOMException("", "InvalidStateError"), aD = (e) => (t) => {
  const n = e.get(t);
  if (n === void 0)
    throw Zr();
  return n;
}, sD = (e, t) => (n) => {
  let i = e.get(n);
  if (i !== void 0)
    return i;
  if (t === null)
    throw new Error("Missing the native OfflineAudioContext constructor.");
  return i = new t(1, 1, 44100), e.set(n, i), i;
}, oD = (e) => (t) => {
  const n = e.get(t);
  if (n === void 0)
    throw new Error("The context has no set of AudioWorkletNodes.");
  return n;
}, W1 = () => new DOMException("", "InvalidAccessError"), lD = (e) => {
  e.getFrequencyResponse = /* @__PURE__ */ ((t) => (n, i, s) => {
    if (n.length !== i.length || i.length !== s.length)
      throw W1();
    return t.call(e, n, i, s);
  })(e.getFrequencyResponse);
}, cD = {
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers"
}, uD = (e, t, n, i, s, o) => class extends e {
  constructor(h, f) {
    const p = i(h), g = s(p), v = { ...cD, ...f }, x = t(p, g ? null : h.baseLatency, v), b = g ? n(v.feedback, v.feedforward) : null;
    super(h, !1, x, b), lD(x), this._nativeIIRFilterNode = x, o(this, 1);
  }
  getFrequencyResponse(h, f, p) {
    return this._nativeIIRFilterNode.getFrequencyResponse(h, f, p);
  }
}, HT = (e, t, n, i, s, o, u, h, f, p, g) => {
  const v = p.length;
  let x = h;
  for (let b = 0; b < v; b += 1) {
    let _ = n[0] * p[b];
    for (let T = 1; T < s; T += 1) {
      const A = x - T & f - 1;
      _ += n[T] * o[A], _ -= e[T] * u[A];
    }
    for (let T = s; T < i; T += 1)
      _ += n[T] * o[x - T & f - 1];
    for (let T = s; T < t; T += 1)
      _ -= e[T] * u[x - T & f - 1];
    o[x] = p[b], u[x] = _, x = x + 1 & f - 1, g[b] = _;
  }
  return x;
}, dD = (e, t, n, i) => {
  const s = n instanceof Float64Array ? n : new Float64Array(n), o = i instanceof Float64Array ? i : new Float64Array(i), u = s.length, h = o.length, f = Math.min(u, h);
  if (s[0] !== 1) {
    for (let _ = 0; _ < u; _ += 1)
      o[_] /= s[0];
    for (let _ = 1; _ < h; _ += 1)
      s[_] /= s[0];
  }
  const p = 32, g = new Float32Array(p), v = new Float32Array(p), x = t.createBuffer(e.numberOfChannels, e.length, e.sampleRate), b = e.numberOfChannels;
  for (let _ = 0; _ < b; _ += 1) {
    const T = e.getChannelData(_), A = x.getChannelData(_);
    g.fill(0), v.fill(0), HT(s, u, o, h, f, g, v, 0, p, T, A);
  }
  return x;
}, hD = (e, t, n, i, s) => (o, u) => {
  const h = /* @__PURE__ */ new WeakMap();
  let f = null;
  const p = async (g, v) => {
    let x = null, b = t(g);
    const _ = za(b, v);
    if (v.createIIRFilter === void 0 ? x = e(v, {
      buffer: null,
      channelCount: 2,
      channelCountMode: "max",
      channelInterpretation: "speakers",
      loop: !1,
      loopEnd: 0,
      loopStart: 0,
      playbackRate: 1
    }) : _ || (b = v.createIIRFilter(u, o)), h.set(v, x === null ? b : x), x !== null) {
      if (f === null) {
        if (n === null)
          throw new Error("Missing the native OfflineAudioContext constructor.");
        const A = new n(
          // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.
          g.context.destination.channelCount,
          // Bug #17: Safari does not yet expose the length.
          g.context.length,
          v.sampleRate
        );
        f = (async () => {
          await i(g, A, A.destination);
          const O = await s(A);
          return dD(O, v, o, u);
        })();
      }
      const T = await f;
      return x.buffer = T, x.start(0), x;
    }
    return await i(g, v, b), b;
  };
  return {
    render(g, v) {
      const x = h.get(v);
      return x !== void 0 ? Promise.resolve(x) : p(g, v);
    }
  };
}, fD = (e, t, n, i, s, o) => (u) => (h, f) => {
  const p = e.get(h);
  if (p === void 0) {
    if (!u && o(h)) {
      const g = i(h), { outputs: v } = n(h);
      for (const x of v)
        if (Wg(x)) {
          const b = i(x[0]);
          t(g, b, x[1], x[2]);
        } else {
          const b = s(x[0]);
          g.disconnect(b, x[1]);
        }
    }
    e.set(h, f);
  } else
    e.set(h, p + f);
}, pD = (e, t) => (n) => {
  const i = e.get(n);
  return t(i) || t(n);
}, mD = (e, t) => (n) => e.has(n) || t(n), gD = (e, t) => (n) => e.has(n) || t(n), yD = (e, t) => (n) => {
  const i = e.get(n);
  return t(i) || t(n);
}, vD = (e) => (t) => e !== null && t instanceof e, bD = (e) => (t) => e !== null && typeof e.AudioNode == "function" && t instanceof e.AudioNode, _D = (e) => (t) => e !== null && typeof e.AudioParam == "function" && t instanceof e.AudioParam, SD = (e, t) => (n) => e(n) || t(n), xD = (e) => (t) => e !== null && t instanceof e, TD = (e) => e !== null && e.isSecureContext, CD = (e, t, n, i) => class extends e {
  constructor(o, u) {
    const h = n(o), f = t(h, u);
    if (i(h))
      throw TypeError();
    super(o, !0, f, null), this._nativeMediaElementAudioSourceNode = f;
  }
  get mediaElement() {
    return this._nativeMediaElementAudioSourceNode.mediaElement;
  }
}, wD = {
  channelCount: 2,
  channelCountMode: "explicit",
  channelInterpretation: "speakers"
}, ED = (e, t, n, i) => class extends e {
  constructor(o, u) {
    const h = n(o);
    if (i(h))
      throw new TypeError();
    const f = { ...wD, ...u }, p = t(h, f);
    super(o, !1, p, null), this._nativeMediaStreamAudioDestinationNode = p;
  }
  get stream() {
    return this._nativeMediaStreamAudioDestinationNode.stream;
  }
}, AD = (e, t, n, i) => class extends e {
  constructor(o, u) {
    const h = n(o), f = t(h, u);
    if (i(h))
      throw new TypeError();
    super(o, !0, f, null), this._nativeMediaStreamAudioSourceNode = f;
  }
  get mediaStream() {
    return this._nativeMediaStreamAudioSourceNode.mediaStream;
  }
}, MD = (e, t, n) => class extends e {
  constructor(s, o) {
    const u = n(s), h = t(u, o);
    super(s, !0, h, null);
  }
}, RD = (e, t, n, i, s, o) => class extends n {
  constructor(h, f) {
    super(h), this._nativeContext = h, Y1.set(this, h), i(h) && s.set(h, /* @__PURE__ */ new Set()), this._destination = new e(this, f), this._listener = t(this, h), this._onstatechange = null;
  }
  get currentTime() {
    return this._nativeContext.currentTime;
  }
  get destination() {
    return this._destination;
  }
  get listener() {
    return this._listener;
  }
  get onstatechange() {
    return this._onstatechange;
  }
  set onstatechange(h) {
    const f = typeof h == "function" ? o(this, h) : null;
    this._nativeContext.onstatechange = f;
    const p = this._nativeContext.onstatechange;
    this._onstatechange = p !== null && p === f ? h : p;
  }
  get sampleRate() {
    return this._nativeContext.sampleRate;
  }
  get state() {
    return this._nativeContext.state;
  }
}, Bg = (e) => {
  const t = new Uint32Array([1179011410, 40, 1163280727, 544501094, 16, 131073, 44100, 176400, 1048580, 1635017060, 4, 0]);
  try {
    const n = e.decodeAudioData(t.buffer, () => {
    });
    return n === void 0 ? !1 : (n.catch(() => {
    }), !0);
  } catch {
  }
  return !1;
}, OD = (e, t) => (n, i, s) => {
  const o = /* @__PURE__ */ new Set();
  return n.connect = /* @__PURE__ */ ((u) => (h, f = 0, p = 0) => {
    const g = o.size === 0;
    if (t(h))
      return u.call(n, h, f, p), e(o, [h, f, p], (v) => v[0] === h && v[1] === f && v[2] === p, !0), g && i(), h;
    u.call(n, h, f), e(o, [h, f], (v) => v[0] === h && v[1] === f, !0), g && i();
  })(n.connect), n.disconnect = /* @__PURE__ */ ((u) => (h, f, p) => {
    const g = o.size > 0;
    if (h === void 0)
      u.apply(n), o.clear();
    else if (typeof h == "number") {
      u.call(n, h);
      for (const x of o)
        x[1] === h && o.delete(x);
    } else {
      t(h) ? u.call(n, h, f, p) : u.call(n, h, f);
      for (const x of o)
        x[0] === h && (f === void 0 || x[1] === f) && (p === void 0 || x[2] === p) && o.delete(x);
    }
    const v = o.size === 0;
    g && v && s();
  })(n.disconnect), n;
}, Bi = (e, t, n) => {
  const i = t[n];
  i !== void 0 && i !== e[n] && (e[n] = i);
}, Lr = (e, t) => {
  Bi(e, t, "channelCount"), Bi(e, t, "channelCountMode"), Bi(e, t, "channelInterpretation");
}, Tx = (e) => typeof e.getFloatTimeDomainData == "function", ND = (e) => {
  e.getFloatTimeDomainData = (t) => {
    const n = new Uint8Array(t.length);
    e.getByteTimeDomainData(n);
    const i = Math.max(n.length, e.fftSize);
    for (let s = 0; s < i; s += 1)
      t[s] = (n[s] - 128) * 78125e-7;
    return t;
  };
}, kD = (e, t) => (n, i) => {
  const s = n.createAnalyser();
  if (Lr(s, i), !(i.maxDecibels > i.minDecibels))
    throw t();
  return Bi(s, i, "fftSize"), Bi(s, i, "maxDecibels"), Bi(s, i, "minDecibels"), Bi(s, i, "smoothingTimeConstant"), e(Tx, () => Tx(s)) || ND(s), s;
}, DD = (e) => e === null ? null : e.hasOwnProperty("AudioBuffer") ? e.AudioBuffer : null, sr = (e, t, n) => {
  const i = t[n];
  i !== void 0 && i !== e[n].value && (e[n].value = i);
}, BD = (e) => {
  e.start = /* @__PURE__ */ ((t) => {
    let n = !1;
    return (i = 0, s = 0, o) => {
      if (n)
        throw Zr();
      t.call(e, i, s, o), n = !0;
    };
  })(e.start);
}, h_ = (e) => {
  e.start = /* @__PURE__ */ ((t) => (n = 0, i = 0, s) => {
    if (typeof s == "number" && s < 0 || i < 0 || n < 0)
      throw new RangeError("The parameters can't be negative.");
    t.call(e, n, i, s);
  })(e.start);
}, f_ = (e) => {
  e.stop = /* @__PURE__ */ ((t) => (n = 0) => {
    if (n < 0)
      throw new RangeError("The parameter can't be negative.");
    t.call(e, n);
  })(e.stop);
}, zD = (e, t, n, i, s, o, u, h, f, p, g) => (v, x) => {
  const b = v.createBufferSource();
  return Lr(b, x), sr(b, x, "playbackRate"), Bi(b, x, "buffer"), Bi(b, x, "loop"), Bi(b, x, "loopEnd"), Bi(b, x, "loopStart"), t(n, () => n(v)) || BD(b), t(i, () => i(v)) || f(b), t(s, () => s(v)) || p(b, v), t(o, () => o(v)) || h_(b), t(u, () => u(v)) || g(b, v), t(h, () => h(v)) || f_(b), e(v, b), b;
}, PD = (e) => e === null ? null : e.hasOwnProperty("AudioContext") ? e.AudioContext : e.hasOwnProperty("webkitAudioContext") ? e.webkitAudioContext : null, UD = (e, t) => (n, i, s) => {
  const o = n.destination;
  if (o.channelCount !== i)
    try {
      o.channelCount = i;
    } catch {
    }
  s && o.channelCountMode !== "explicit" && (o.channelCountMode = "explicit"), o.maxChannelCount === 0 && Object.defineProperty(o, "maxChannelCount", {
    value: i
  });
  const u = e(n, {
    channelCount: i,
    channelCountMode: o.channelCountMode,
    channelInterpretation: o.channelInterpretation,
    gain: 1
  });
  return t(u, "channelCount", (h) => () => h.call(u), (h) => (f) => {
    h.call(u, f);
    try {
      o.channelCount = f;
    } catch (p) {
      if (f > o.maxChannelCount)
        throw p;
    }
  }), t(u, "channelCountMode", (h) => () => h.call(u), (h) => (f) => {
    h.call(u, f), o.channelCountMode = f;
  }), t(u, "channelInterpretation", (h) => () => h.call(u), (h) => (f) => {
    h.call(u, f), o.channelInterpretation = f;
  }), Object.defineProperty(u, "maxChannelCount", {
    get: () => o.maxChannelCount
  }), u.connect(o), u;
}, jD = (e) => e === null ? null : e.hasOwnProperty("AudioWorkletNode") ? e.AudioWorkletNode : null, LD = (e) => {
  const { port1: t } = new MessageChannel();
  try {
    t.postMessage(e);
  } finally {
    t.close();
  }
}, VD = (e, t, n, i, s) => (o, u, h, f, p, g) => {
  if (h !== null)
    try {
      const v = new h(o, f, g), x = /* @__PURE__ */ new Map();
      let b = null;
      if (Object.defineProperties(v, {
        /*
         * Bug #61: Overwriting the property accessors for channelCount and channelCountMode is necessary as long as some
         * browsers have no native implementation to achieve a consistent behavior.
         */
        channelCount: {
          get: () => g.channelCount,
          set: () => {
            throw e();
          }
        },
        channelCountMode: {
          get: () => "explicit",
          set: () => {
            throw e();
          }
        },
        // Bug #156: Chrome and Edge do not yet fire an ErrorEvent.
        onprocessorerror: {
          get: () => b,
          set: (_) => {
            typeof b == "function" && v.removeEventListener("processorerror", b), b = typeof _ == "function" ? _ : null, typeof b == "function" && v.addEventListener("processorerror", b);
          }
        }
      }), v.addEventListener = /* @__PURE__ */ ((_) => (...T) => {
        if (T[0] === "processorerror") {
          const A = typeof T[1] == "function" ? T[1] : typeof T[1] == "object" && T[1] !== null && typeof T[1].handleEvent == "function" ? T[1].handleEvent : null;
          if (A !== null) {
            const O = x.get(T[1]);
            O !== void 0 ? T[1] = O : (T[1] = (M) => {
              M.type === "error" ? (Object.defineProperties(M, {
                type: { value: "processorerror" }
              }), A(M)) : A(new ErrorEvent(T[0], { ...M }));
            }, x.set(A, T[1]));
          }
        }
        return _.call(v, "error", T[1], T[2]), _.call(v, ...T);
      })(v.addEventListener), v.removeEventListener = /* @__PURE__ */ ((_) => (...T) => {
        if (T[0] === "processorerror") {
          const A = x.get(T[1]);
          A !== void 0 && (x.delete(T[1]), T[1] = A);
        }
        return _.call(v, "error", T[1], T[2]), _.call(v, T[0], T[1], T[2]);
      })(v.removeEventListener), g.numberOfOutputs !== 0) {
        const _ = n(o, {
          channelCount: 1,
          channelCountMode: "explicit",
          channelInterpretation: "discrete",
          gain: 0
        });
        return v.connect(_).connect(o.destination), s(v, () => _.disconnect(), () => _.connect(o.destination));
      }
      return v;
    } catch (v) {
      throw v.code === 11 ? i() : v;
    }
  if (p === void 0)
    throw i();
  return LD(g), t(o, u, p, g);
}, KT = (e, t) => e === null ? 512 : Math.max(512, Math.min(16384, Math.pow(2, Math.round(Math.log2(e * t))))), ID = (e) => new Promise((t, n) => {
  const { port1: i, port2: s } = new MessageChannel();
  i.onmessage = ({ data: o }) => {
    i.close(), s.close(), t(o);
  }, i.onmessageerror = ({ data: o }) => {
    i.close(), s.close(), n(o);
  }, s.postMessage(e);
}), FD = async (e, t) => {
  const n = await ID(t);
  return new e(n);
}, qD = (e, t, n, i) => {
  let s = l2.get(e);
  s === void 0 && (s = /* @__PURE__ */ new WeakMap(), l2.set(e, s));
  const o = FD(n, i);
  return s.set(t, o), o;
}, GD = (e, t, n, i, s, o, u, h, f, p, g, v, x) => (b, _, T, A) => {
  if (A.numberOfInputs === 0 && A.numberOfOutputs === 0)
    throw f();
  const O = Array.isArray(A.outputChannelCount) ? A.outputChannelCount : Array.from(A.outputChannelCount);
  if (O.some((Ut) => Ut < 1))
    throw f();
  if (O.length !== A.numberOfOutputs)
    throw t();
  if (A.channelCountMode !== "explicit")
    throw f();
  const M = A.channelCount * A.numberOfInputs, E = O.reduce((Ut, se) => Ut + se, 0), R = T.parameterDescriptors === void 0 ? 0 : T.parameterDescriptors.length;
  if (M + R > 6 || E > 6)
    throw f();
  const N = new MessageChannel(), U = [], q = [];
  for (let Ut = 0; Ut < A.numberOfInputs; Ut += 1)
    U.push(u(b, {
      channelCount: A.channelCount,
      channelCountMode: A.channelCountMode,
      channelInterpretation: A.channelInterpretation,
      gain: 1
    })), q.push(s(b, {
      channelCount: A.channelCount,
      channelCountMode: "explicit",
      channelInterpretation: "discrete",
      numberOfOutputs: A.channelCount
    }));
  const j = [];
  if (T.parameterDescriptors !== void 0)
    for (const { defaultValue: Ut, maxValue: se, minValue: re, name: ue } of T.parameterDescriptors) {
      const Ae = o(b, {
        channelCount: 1,
        channelCountMode: "explicit",
        channelInterpretation: "discrete",
        offset: A.parameterData[ue] !== void 0 ? A.parameterData[ue] : Ut === void 0 ? 0 : Ut
      });
      Object.defineProperties(Ae.offset, {
        defaultValue: {
          get: () => Ut === void 0 ? 0 : Ut
        },
        maxValue: {
          get: () => se === void 0 ? $a : se
        },
        minValue: {
          get: () => re === void 0 ? Ks : re
        }
      }), j.push(Ae);
    }
  const V = i(b, {
    channelCount: 1,
    channelCountMode: "explicit",
    channelInterpretation: "speakers",
    numberOfInputs: Math.max(1, M + R)
  }), D = KT(_, b.sampleRate), G = h(
    b,
    D,
    M + R,
    // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.
    Math.max(1, E)
  ), W = s(b, {
    channelCount: Math.max(1, E),
    channelCountMode: "explicit",
    channelInterpretation: "discrete",
    numberOfOutputs: Math.max(1, E)
  }), P = [];
  for (let Ut = 0; Ut < A.numberOfOutputs; Ut += 1)
    P.push(i(b, {
      channelCount: 1,
      channelCountMode: "explicit",
      channelInterpretation: "speakers",
      numberOfInputs: O[Ut]
    }));
  for (let Ut = 0; Ut < A.numberOfInputs; Ut += 1) {
    U[Ut].connect(q[Ut]);
    for (let se = 0; se < A.channelCount; se += 1)
      q[Ut].connect(V, se, Ut * A.channelCount + se);
  }
  const H = new qT(T.parameterDescriptors === void 0 ? [] : T.parameterDescriptors.map(({ name: Ut }, se) => {
    const re = j[se];
    return re.connect(V, 0, M + se), re.start(0), [Ut, re.offset];
  }));
  V.connect(G);
  let I = A.channelInterpretation, K = null;
  const Q = A.numberOfOutputs === 0 ? [G] : P, it = {
    get bufferSize() {
      return D;
    },
    get channelCount() {
      return A.channelCount;
    },
    set channelCount(Ut) {
      throw n();
    },
    get channelCountMode() {
      return A.channelCountMode;
    },
    set channelCountMode(Ut) {
      throw n();
    },
    get channelInterpretation() {
      return I;
    },
    set channelInterpretation(Ut) {
      for (const se of U)
        se.channelInterpretation = Ut;
      I = Ut;
    },
    get context() {
      return G.context;
    },
    get inputs() {
      return U;
    },
    get numberOfInputs() {
      return A.numberOfInputs;
    },
    get numberOfOutputs() {
      return A.numberOfOutputs;
    },
    get onprocessorerror() {
      return K;
    },
    set onprocessorerror(Ut) {
      typeof K == "function" && it.removeEventListener("processorerror", K), K = typeof Ut == "function" ? Ut : null, typeof K == "function" && it.addEventListener("processorerror", K);
    },
    get parameters() {
      return H;
    },
    get port() {
      return N.port2;
    },
    addEventListener(...Ut) {
      return G.addEventListener(Ut[0], Ut[1], Ut[2]);
    },
    connect: e.bind(null, Q),
    disconnect: p.bind(null, Q),
    dispatchEvent(...Ut) {
      return G.dispatchEvent(Ut[0]);
    },
    removeEventListener(...Ut) {
      return G.removeEventListener(Ut[0], Ut[1], Ut[2]);
    }
  }, nt = /* @__PURE__ */ new Map();
  N.port1.addEventListener = /* @__PURE__ */ ((Ut) => (...se) => {
    if (se[0] === "message") {
      const re = typeof se[1] == "function" ? se[1] : typeof se[1] == "object" && se[1] !== null && typeof se[1].handleEvent == "function" ? se[1].handleEvent : null;
      if (re !== null) {
        const ue = nt.get(se[1]);
        ue !== void 0 ? se[1] = ue : (se[1] = (Ae) => {
          g(b.currentTime, b.sampleRate, () => re(Ae));
        }, nt.set(re, se[1]));
      }
    }
    return Ut.call(N.port1, se[0], se[1], se[2]);
  })(N.port1.addEventListener), N.port1.removeEventListener = /* @__PURE__ */ ((Ut) => (...se) => {
    if (se[0] === "message") {
      const re = nt.get(se[1]);
      re !== void 0 && (nt.delete(se[1]), se[1] = re);
    }
    return Ut.call(N.port1, se[0], se[1], se[2]);
  })(N.port1.removeEventListener);
  let X = null;
  Object.defineProperty(N.port1, "onmessage", {
    get: () => X,
    set: (Ut) => {
      typeof X == "function" && N.port1.removeEventListener("message", X), X = typeof Ut == "function" ? Ut : null, typeof X == "function" && (N.port1.addEventListener("message", X), N.port1.start());
    }
  }), T.prototype.port = N.port1;
  let rt = null;
  qD(b, it, T, A).then((Ut) => rt = Ut);
  const ct = g1(A.numberOfInputs, A.channelCount), dt = g1(A.numberOfOutputs, O), ht = T.parameterDescriptors === void 0 ? [] : T.parameterDescriptors.reduce((Ut, { name: se }) => ({ ...Ut, [se]: new Float32Array(128) }), {});
  let Et = !0;
  const ot = () => {
    A.numberOfOutputs > 0 && G.disconnect(W);
    for (let Ut = 0, se = 0; Ut < A.numberOfOutputs; Ut += 1) {
      const re = P[Ut];
      for (let ue = 0; ue < O[Ut]; ue += 1)
        W.disconnect(re, se + ue, ue);
      se += O[Ut];
    }
  }, lt = /* @__PURE__ */ new Map();
  G.onaudioprocess = ({ inputBuffer: Ut, outputBuffer: se }) => {
    if (rt !== null) {
      const re = v(it);
      for (let ue = 0; ue < D; ue += 128) {
        for (let Ae = 0; Ae < A.numberOfInputs; Ae += 1)
          for (let ve = 0; ve < A.channelCount; ve += 1)
            m1(Ut, ct[Ae], ve, ve, ue);
        T.parameterDescriptors !== void 0 && T.parameterDescriptors.forEach(({ name: Ae }, ve) => {
          m1(Ut, ht, Ae, M + ve, ue);
        });
        for (let Ae = 0; Ae < A.numberOfInputs; Ae += 1)
          for (let ve = 0; ve < O[Ae]; ve += 1)
            dt[Ae][ve].byteLength === 0 && (dt[Ae][ve] = new Float32Array(128));
        try {
          const Ae = ct.map((Re, oe) => {
            if (re[oe].size > 0)
              return lt.set(oe, D / 128), Re;
            const De = lt.get(oe);
            return De === void 0 ? [] : (Re.every((Kt) => Kt.every((te) => te === 0)) && (De === 1 ? lt.delete(oe) : lt.set(oe, De - 1)), Re);
          });
          Et = g(b.currentTime + ue / b.sampleRate, b.sampleRate, () => rt.process(Ae, dt, ht));
          for (let Re = 0, oe = 0; Re < A.numberOfOutputs; Re += 1) {
            for (let Le = 0; Le < O[Re]; Le += 1)
              GT(se, dt[Re], Le, oe + Le, ue);
            oe += O[Re];
          }
        } catch (Ae) {
          Et = !1, it.dispatchEvent(new ErrorEvent("processorerror", {
            colno: Ae.colno,
            filename: Ae.filename,
            lineno: Ae.lineno,
            message: Ae.message
          }));
        }
        if (!Et) {
          for (let Ae = 0; Ae < A.numberOfInputs; Ae += 1) {
            U[Ae].disconnect(q[Ae]);
            for (let ve = 0; ve < A.channelCount; ve += 1)
              q[ue].disconnect(V, ve, Ae * A.channelCount + ve);
          }
          if (T.parameterDescriptors !== void 0) {
            const Ae = T.parameterDescriptors.length;
            for (let ve = 0; ve < Ae; ve += 1) {
              const Re = j[ve];
              Re.disconnect(V, 0, M + ve), Re.stop();
            }
          }
          V.disconnect(G), G.onaudioprocess = null, ft ? ot() : Ot();
          break;
        }
      }
    }
  };
  let ft = !1;
  const Tt = u(b, {
    channelCount: 1,
    channelCountMode: "explicit",
    channelInterpretation: "discrete",
    gain: 0
  }), Bt = () => G.connect(Tt).connect(b.destination), Ot = () => {
    G.disconnect(Tt), Tt.disconnect();
  }, ie = () => {
    if (Et) {
      Ot(), A.numberOfOutputs > 0 && G.connect(W);
      for (let Ut = 0, se = 0; Ut < A.numberOfOutputs; Ut += 1) {
        const re = P[Ut];
        for (let ue = 0; ue < O[Ut]; ue += 1)
          W.connect(re, se + ue, ue);
        se += O[Ut];
      }
    }
    ft = !0;
  }, ce = () => {
    Et && (Bt(), ot()), ft = !1;
  };
  return Bt(), x(it, ie, ce);
}, YT = (e, t) => {
  const n = e.createBiquadFilter();
  return Lr(n, t), sr(n, t, "Q"), sr(n, t, "detune"), sr(n, t, "frequency"), sr(n, t, "gain"), Bi(n, t, "type"), n;
}, HD = (e, t) => (n, i) => {
  const s = n.createChannelMerger(i.numberOfInputs);
  return e !== null && e.name === "webkitAudioContext" && t(n, s), Lr(s, i), s;
}, KD = (e) => {
  const t = e.numberOfOutputs;
  Object.defineProperty(e, "channelCount", {
    get: () => t,
    set: (n) => {
      if (n !== t)
        throw Zr();
    }
  }), Object.defineProperty(e, "channelCountMode", {
    get: () => "explicit",
    set: (n) => {
      if (n !== "explicit")
        throw Zr();
    }
  }), Object.defineProperty(e, "channelInterpretation", {
    get: () => "discrete",
    set: (n) => {
      if (n !== "discrete")
        throw Zr();
    }
  });
}, $g = (e, t) => {
  const n = e.createChannelSplitter(t.numberOfOutputs);
  return Lr(n, t), KD(n), n;
}, YD = (e, t, n, i, s) => (o, u) => {
  if (o.createConstantSource === void 0)
    return n(o, u);
  const h = o.createConstantSource();
  return Lr(h, u), sr(h, u, "offset"), t(i, () => i(o)) || h_(h), t(s, () => s(o)) || f_(h), e(o, h), h;
}, pp = (e, t) => (e.connect = t.connect.bind(t), e.disconnect = t.disconnect.bind(t), e), XD = (e, t, n, i) => (s, { offset: o, ...u }) => {
  const h = s.createBuffer(1, 2, 44100), f = t(s, {
    buffer: null,
    channelCount: 2,
    channelCountMode: "max",
    channelInterpretation: "speakers",
    loop: !1,
    loopEnd: 0,
    loopStart: 0,
    playbackRate: 1
  }), p = n(s, { ...u, gain: o }), g = h.getChannelData(0);
  g[0] = 1, g[1] = 1, f.buffer = h, f.loop = !0;
  const v = {
    get bufferSize() {
    },
    get channelCount() {
      return p.channelCount;
    },
    set channelCount(_) {
      p.channelCount = _;
    },
    get channelCountMode() {
      return p.channelCountMode;
    },
    set channelCountMode(_) {
      p.channelCountMode = _;
    },
    get channelInterpretation() {
      return p.channelInterpretation;
    },
    set channelInterpretation(_) {
      p.channelInterpretation = _;
    },
    get context() {
      return p.context;
    },
    get inputs() {
      return [];
    },
    get numberOfInputs() {
      return f.numberOfInputs;
    },
    get numberOfOutputs() {
      return p.numberOfOutputs;
    },
    get offset() {
      return p.gain;
    },
    get onended() {
      return f.onended;
    },
    set onended(_) {
      f.onended = _;
    },
    addEventListener(..._) {
      return f.addEventListener(_[0], _[1], _[2]);
    },
    dispatchEvent(..._) {
      return f.dispatchEvent(_[0]);
    },
    removeEventListener(..._) {
      return f.removeEventListener(_[0], _[1], _[2]);
    },
    start(_ = 0) {
      f.start.call(f, _);
    },
    stop(_ = 0) {
      f.stop.call(f, _);
    }
  }, x = () => f.connect(p), b = () => f.disconnect(p);
  return e(s, f), i(pp(v, p), x, b);
}, WD = (e, t) => (n, i) => {
  const s = n.createConvolver();
  if (Lr(s, i), i.disableNormalization === s.normalize && (s.normalize = !i.disableNormalization), Bi(s, i, "buffer"), i.channelCount > 2 || (t(s, "channelCount", (o) => () => o.call(s), (o) => (u) => {
    if (u > 2)
      throw e();
    return o.call(s, u);
  }), i.channelCountMode === "max"))
    throw e();
  return t(s, "channelCountMode", (o) => () => o.call(s), (o) => (u) => {
    if (u === "max")
      throw e();
    return o.call(s, u);
  }), s;
}, XT = (e, t) => {
  const n = e.createDelay(t.maxDelayTime);
  return Lr(n, t), sr(n, t, "delayTime"), n;
}, $D = (e) => (t, n) => {
  const i = t.createDynamicsCompressor();
  if (Lr(i, n), n.channelCount > 2 || n.channelCountMode === "max")
    throw e();
  return sr(i, n, "attack"), sr(i, n, "knee"), sr(i, n, "ratio"), sr(i, n, "release"), sr(i, n, "threshold"), i;
}, ws = (e, t) => {
  const n = e.createGain();
  return Lr(n, t), sr(n, t, "gain"), n;
}, QD = (e) => (t, n, i) => {
  if (t.createIIRFilter === void 0)
    return e(t, n, i);
  const s = t.createIIRFilter(i.feedforward, i.feedback);
  return Lr(s, i), s;
};
function ZD(e, t) {
  const n = t[0] * t[0] + t[1] * t[1];
  return [(e[0] * t[0] + e[1] * t[1]) / n, (e[1] * t[0] - e[0] * t[1]) / n];
}
function JD(e, t) {
  return [e[0] * t[0] - e[1] * t[1], e[0] * t[1] + e[1] * t[0]];
}
function Cx(e, t) {
  let n = [0, 0];
  for (let i = e.length - 1; i >= 0; i -= 1)
    n = JD(n, t), n[0] += e[i];
  return n;
}
const tB = (e, t, n, i) => (s, o, { channelCount: u, channelCountMode: h, channelInterpretation: f, feedback: p, feedforward: g }) => {
  const v = KT(o, s.sampleRate), x = p instanceof Float64Array ? p : new Float64Array(p), b = g instanceof Float64Array ? g : new Float64Array(g), _ = x.length, T = b.length, A = Math.min(_, T);
  if (_ === 0 || _ > 20)
    throw i();
  if (x[0] === 0)
    throw t();
  if (T === 0 || T > 20)
    throw i();
  if (b[0] === 0)
    throw t();
  if (x[0] !== 1) {
    for (let j = 0; j < T; j += 1)
      b[j] /= x[0];
    for (let j = 1; j < _; j += 1)
      x[j] /= x[0];
  }
  const O = n(s, v, u, u);
  O.channelCount = u, O.channelCountMode = h, O.channelInterpretation = f;
  const M = 32, E = [], R = [], N = [];
  for (let j = 0; j < u; j += 1) {
    E.push(0);
    const V = new Float32Array(M), D = new Float32Array(M);
    V.fill(0), D.fill(0), R.push(V), N.push(D);
  }
  O.onaudioprocess = (j) => {
    const V = j.inputBuffer, D = j.outputBuffer, G = V.numberOfChannels;
    for (let W = 0; W < G; W += 1) {
      const P = V.getChannelData(W), H = D.getChannelData(W);
      E[W] = HT(x, _, b, T, A, R[W], N[W], E[W], M, P, H);
    }
  };
  const U = s.sampleRate / 2;
  return pp({
    get bufferSize() {
      return v;
    },
    get channelCount() {
      return O.channelCount;
    },
    set channelCount(j) {
      O.channelCount = j;
    },
    get channelCountMode() {
      return O.channelCountMode;
    },
    set channelCountMode(j) {
      O.channelCountMode = j;
    },
    get channelInterpretation() {
      return O.channelInterpretation;
    },
    set channelInterpretation(j) {
      O.channelInterpretation = j;
    },
    get context() {
      return O.context;
    },
    get inputs() {
      return [O];
    },
    get numberOfInputs() {
      return O.numberOfInputs;
    },
    get numberOfOutputs() {
      return O.numberOfOutputs;
    },
    addEventListener(...j) {
      return O.addEventListener(j[0], j[1], j[2]);
    },
    dispatchEvent(...j) {
      return O.dispatchEvent(j[0]);
    },
    getFrequencyResponse(j, V, D) {
      if (j.length !== V.length || V.length !== D.length)
        throw e();
      const G = j.length;
      for (let W = 0; W < G; W += 1) {
        const P = -Math.PI * (j[W] / U), H = [Math.cos(P), Math.sin(P)], I = Cx(b, H), K = Cx(x, H), Q = ZD(I, K);
        V[W] = Math.sqrt(Q[0] * Q[0] + Q[1] * Q[1]), D[W] = Math.atan2(Q[1], Q[0]);
      }
    },
    removeEventListener(...j) {
      return O.removeEventListener(j[0], j[1], j[2]);
    }
  }, O);
}, eB = (e, t) => e.createMediaElementSource(t.mediaElement), nB = (e, t) => {
  const n = e.createMediaStreamDestination();
  return Lr(n, t), n.numberOfOutputs === 1 && Object.defineProperty(n, "numberOfOutputs", { get: () => 0 }), n;
}, iB = (e, { mediaStream: t }) => {
  const n = t.getAudioTracks();
  n.sort((o, u) => o.id < u.id ? -1 : o.id > u.id ? 1 : 0);
  const i = n.slice(0, 1), s = e.createMediaStreamSource(new MediaStream(i));
  return Object.defineProperty(s, "mediaStream", { value: t }), s;
}, rB = (e, t) => (n, { mediaStreamTrack: i }) => {
  if (typeof n.createMediaStreamTrackSource == "function")
    return n.createMediaStreamTrackSource(i);
  const s = new MediaStream([i]), o = n.createMediaStreamSource(s);
  if (i.kind !== "audio")
    throw e();
  if (t(n))
    throw new TypeError();
  return o;
}, aB = (e) => e === null ? null : e.hasOwnProperty("OfflineAudioContext") ? e.OfflineAudioContext : e.hasOwnProperty("webkitOfflineAudioContext") ? e.webkitOfflineAudioContext : null, sB = (e, t, n, i, s, o) => (u, h) => {
  const f = u.createOscillator();
  return Lr(f, h), sr(f, h, "detune"), sr(f, h, "frequency"), h.periodicWave !== void 0 ? f.setPeriodicWave(h.periodicWave) : Bi(f, h, "type"), t(n, () => n(u)) || h_(f), t(i, () => i(u)) || o(f, u), t(s, () => s(u)) || f_(f), e(u, f), f;
}, oB = (e) => (t, n) => {
  const i = t.createPanner();
  return i.orientationX === void 0 ? e(t, n) : (Lr(i, n), sr(i, n, "orientationX"), sr(i, n, "orientationY"), sr(i, n, "orientationZ"), sr(i, n, "positionX"), sr(i, n, "positionY"), sr(i, n, "positionZ"), Bi(i, n, "coneInnerAngle"), Bi(i, n, "coneOuterAngle"), Bi(i, n, "coneOuterGain"), Bi(i, n, "distanceModel"), Bi(i, n, "maxDistance"), Bi(i, n, "panningModel"), Bi(i, n, "refDistance"), Bi(i, n, "rolloffFactor"), i);
}, lB = (e, t, n, i, s, o, u, h, f, p) => (g, { coneInnerAngle: v, coneOuterAngle: x, coneOuterGain: b, distanceModel: _, maxDistance: T, orientationX: A, orientationY: O, orientationZ: M, panningModel: E, positionX: R, positionY: N, positionZ: U, refDistance: q, rolloffFactor: j, ...V }) => {
  const D = g.createPanner();
  if (V.channelCount > 2 || V.channelCountMode === "max")
    throw u();
  Lr(D, V);
  const G = {
    channelCount: 1,
    channelCountMode: "explicit",
    channelInterpretation: "discrete"
  }, W = n(g, {
    ...G,
    channelInterpretation: "speakers",
    numberOfInputs: 6
  }), P = i(g, { ...V, gain: 1 }), H = i(g, { ...G, gain: 1 }), I = i(g, { ...G, gain: 0 }), K = i(g, { ...G, gain: 0 }), Q = i(g, { ...G, gain: 0 }), it = i(g, { ...G, gain: 0 }), nt = i(g, { ...G, gain: 0 }), X = s(g, 256, 6, 1), rt = o(g, {
    ...G,
    curve: new Float32Array([1, 1]),
    oversample: "none"
  });
  let vt = [A, O, M], ct = [R, N, U];
  const dt = new Float32Array(1);
  X.onaudioprocess = ({ inputBuffer: lt }) => {
    const ft = [
      f(lt, dt, 0),
      f(lt, dt, 1),
      f(lt, dt, 2)
    ];
    ft.some((Bt, Ot) => Bt !== vt[Ot]) && (D.setOrientation(...ft), vt = ft);
    const Tt = [
      f(lt, dt, 3),
      f(lt, dt, 4),
      f(lt, dt, 5)
    ];
    Tt.some((Bt, Ot) => Bt !== ct[Ot]) && (D.setPosition(...Tt), ct = Tt);
  }, Object.defineProperty(I.gain, "defaultValue", { get: () => 0 }), Object.defineProperty(K.gain, "defaultValue", { get: () => 0 }), Object.defineProperty(Q.gain, "defaultValue", { get: () => 0 }), Object.defineProperty(it.gain, "defaultValue", { get: () => 0 }), Object.defineProperty(nt.gain, "defaultValue", { get: () => 0 });
  const ht = {
    get bufferSize() {
    },
    get channelCount() {
      return D.channelCount;
    },
    set channelCount(lt) {
      if (lt > 2)
        throw u();
      P.channelCount = lt, D.channelCount = lt;
    },
    get channelCountMode() {
      return D.channelCountMode;
    },
    set channelCountMode(lt) {
      if (lt === "max")
        throw u();
      P.channelCountMode = lt, D.channelCountMode = lt;
    },
    get channelInterpretation() {
      return D.channelInterpretation;
    },
    set channelInterpretation(lt) {
      P.channelInterpretation = lt, D.channelInterpretation = lt;
    },
    get coneInnerAngle() {
      return D.coneInnerAngle;
    },
    set coneInnerAngle(lt) {
      D.coneInnerAngle = lt;
    },
    get coneOuterAngle() {
      return D.coneOuterAngle;
    },
    set coneOuterAngle(lt) {
      D.coneOuterAngle = lt;
    },
    get coneOuterGain() {
      return D.coneOuterGain;
    },
    set coneOuterGain(lt) {
      if (lt < 0 || lt > 1)
        throw t();
      D.coneOuterGain = lt;
    },
    get context() {
      return D.context;
    },
    get distanceModel() {
      return D.distanceModel;
    },
    set distanceModel(lt) {
      D.distanceModel = lt;
    },
    get inputs() {
      return [P];
    },
    get maxDistance() {
      return D.maxDistance;
    },
    set maxDistance(lt) {
      if (lt < 0)
        throw new RangeError();
      D.maxDistance = lt;
    },
    get numberOfInputs() {
      return D.numberOfInputs;
    },
    get numberOfOutputs() {
      return D.numberOfOutputs;
    },
    get orientationX() {
      return H.gain;
    },
    get orientationY() {
      return I.gain;
    },
    get orientationZ() {
      return K.gain;
    },
    get panningModel() {
      return D.panningModel;
    },
    set panningModel(lt) {
      D.panningModel = lt;
    },
    get positionX() {
      return Q.gain;
    },
    get positionY() {
      return it.gain;
    },
    get positionZ() {
      return nt.gain;
    },
    get refDistance() {
      return D.refDistance;
    },
    set refDistance(lt) {
      if (lt < 0)
        throw new RangeError();
      D.refDistance = lt;
    },
    get rolloffFactor() {
      return D.rolloffFactor;
    },
    set rolloffFactor(lt) {
      if (lt < 0)
        throw new RangeError();
      D.rolloffFactor = lt;
    },
    addEventListener(...lt) {
      return P.addEventListener(lt[0], lt[1], lt[2]);
    },
    dispatchEvent(...lt) {
      return P.dispatchEvent(lt[0]);
    },
    removeEventListener(...lt) {
      return P.removeEventListener(lt[0], lt[1], lt[2]);
    }
  };
  v !== ht.coneInnerAngle && (ht.coneInnerAngle = v), x !== ht.coneOuterAngle && (ht.coneOuterAngle = x), b !== ht.coneOuterGain && (ht.coneOuterGain = b), _ !== ht.distanceModel && (ht.distanceModel = _), T !== ht.maxDistance && (ht.maxDistance = T), A !== ht.orientationX.value && (ht.orientationX.value = A), O !== ht.orientationY.value && (ht.orientationY.value = O), M !== ht.orientationZ.value && (ht.orientationZ.value = M), E !== ht.panningModel && (ht.panningModel = E), R !== ht.positionX.value && (ht.positionX.value = R), N !== ht.positionY.value && (ht.positionY.value = N), U !== ht.positionZ.value && (ht.positionZ.value = U), q !== ht.refDistance && (ht.refDistance = q), j !== ht.rolloffFactor && (ht.rolloffFactor = j), (vt[0] !== 1 || vt[1] !== 0 || vt[2] !== 0) && D.setOrientation(...vt), (ct[0] !== 0 || ct[1] !== 0 || ct[2] !== 0) && D.setPosition(...ct);
  const Et = () => {
    P.connect(D), e(P, rt, 0, 0), rt.connect(H).connect(W, 0, 0), rt.connect(I).connect(W, 0, 1), rt.connect(K).connect(W, 0, 2), rt.connect(Q).connect(W, 0, 3), rt.connect(it).connect(W, 0, 4), rt.connect(nt).connect(W, 0, 5), W.connect(X).connect(g.destination);
  }, ot = () => {
    P.disconnect(D), h(P, rt, 0, 0), rt.disconnect(H), H.disconnect(W), rt.disconnect(I), I.disconnect(W), rt.disconnect(K), K.disconnect(W), rt.disconnect(Q), Q.disconnect(W), rt.disconnect(it), it.disconnect(W), rt.disconnect(nt), nt.disconnect(W), W.disconnect(X), X.disconnect(g.destination);
  };
  return p(pp(ht, D), Et, ot);
}, cB = (e) => (t, { disableNormalization: n, imag: i, real: s }) => {
  const o = i instanceof Float32Array ? i : new Float32Array(i), u = s instanceof Float32Array ? s : new Float32Array(s), h = t.createPeriodicWave(u, o, { disableNormalization: n });
  if (Array.from(i).length < 2)
    throw e();
  return h;
}, Qg = (e, t, n, i) => e.createScriptProcessor(t, n, i), uB = (e, t) => (n, i) => {
  const s = i.channelCountMode;
  if (s === "clamped-max")
    throw t();
  if (n.createStereoPanner === void 0)
    return e(n, i);
  const o = n.createStereoPanner();
  return Lr(o, i), sr(o, i, "pan"), Object.defineProperty(o, "channelCountMode", {
    get: () => s,
    set: (u) => {
      if (u !== s)
        throw t();
    }
  }), o;
}, dB = (e, t, n, i, s, o) => {
  const h = new Float32Array([1, 1]), f = Math.PI / 2, p = { channelCount: 1, channelCountMode: "explicit", channelInterpretation: "discrete" }, g = { ...p, oversample: "none" }, v = (_, T, A, O) => {
    const M = new Float32Array(16385), E = new Float32Array(16385);
    for (let V = 0; V < 16385; V += 1) {
      const D = V / 16384 * f;
      M[V] = Math.cos(D), E[V] = Math.sin(D);
    }
    const R = n(_, { ...p, gain: 0 }), N = i(_, { ...g, curve: M }), U = i(_, { ...g, curve: h }), q = n(_, { ...p, gain: 0 }), j = i(_, { ...g, curve: E });
    return {
      connectGraph() {
        T.connect(R), T.connect(U.inputs === void 0 ? U : U.inputs[0]), T.connect(q), U.connect(A), A.connect(N.inputs === void 0 ? N : N.inputs[0]), A.connect(j.inputs === void 0 ? j : j.inputs[0]), N.connect(R.gain), j.connect(q.gain), R.connect(O, 0, 0), q.connect(O, 0, 1);
      },
      disconnectGraph() {
        T.disconnect(R), T.disconnect(U.inputs === void 0 ? U : U.inputs[0]), T.disconnect(q), U.disconnect(A), A.disconnect(N.inputs === void 0 ? N : N.inputs[0]), A.disconnect(j.inputs === void 0 ? j : j.inputs[0]), N.disconnect(R.gain), j.disconnect(q.gain), R.disconnect(O, 0, 0), q.disconnect(O, 0, 1);
      }
    };
  }, x = (_, T, A, O) => {
    const M = new Float32Array(16385), E = new Float32Array(16385), R = new Float32Array(16385), N = new Float32Array(16385), U = Math.floor(16385 / 2);
    for (let Q = 0; Q < 16385; Q += 1)
      if (Q > U) {
        const it = (Q - U) / (16384 - U) * f;
        M[Q] = Math.cos(it), E[Q] = Math.sin(it), R[Q] = 0, N[Q] = 1;
      } else {
        const it = Q / (16384 - U) * f;
        M[Q] = 1, E[Q] = 0, R[Q] = Math.cos(it), N[Q] = Math.sin(it);
      }
    const q = t(_, {
      channelCount: 2,
      channelCountMode: "explicit",
      channelInterpretation: "discrete",
      numberOfOutputs: 2
    }), j = n(_, { ...p, gain: 0 }), V = i(_, {
      ...g,
      curve: M
    }), D = n(_, { ...p, gain: 0 }), G = i(_, {
      ...g,
      curve: E
    }), W = i(_, { ...g, curve: h }), P = n(_, { ...p, gain: 0 }), H = i(_, {
      ...g,
      curve: R
    }), I = n(_, { ...p, gain: 0 }), K = i(_, {
      ...g,
      curve: N
    });
    return {
      connectGraph() {
        T.connect(q), T.connect(W.inputs === void 0 ? W : W.inputs[0]), q.connect(j, 0), q.connect(D, 0), q.connect(P, 1), q.connect(I, 1), W.connect(A), A.connect(V.inputs === void 0 ? V : V.inputs[0]), A.connect(G.inputs === void 0 ? G : G.inputs[0]), A.connect(H.inputs === void 0 ? H : H.inputs[0]), A.connect(K.inputs === void 0 ? K : K.inputs[0]), V.connect(j.gain), G.connect(D.gain), H.connect(P.gain), K.connect(I.gain), j.connect(O, 0, 0), P.connect(O, 0, 0), D.connect(O, 0, 1), I.connect(O, 0, 1);
      },
      disconnectGraph() {
        T.disconnect(q), T.disconnect(W.inputs === void 0 ? W : W.inputs[0]), q.disconnect(j, 0), q.disconnect(D, 0), q.disconnect(P, 1), q.disconnect(I, 1), W.disconnect(A), A.disconnect(V.inputs === void 0 ? V : V.inputs[0]), A.disconnect(G.inputs === void 0 ? G : G.inputs[0]), A.disconnect(H.inputs === void 0 ? H : H.inputs[0]), A.disconnect(K.inputs === void 0 ? K : K.inputs[0]), V.disconnect(j.gain), G.disconnect(D.gain), H.disconnect(P.gain), K.disconnect(I.gain), j.disconnect(O, 0, 0), P.disconnect(O, 0, 0), D.disconnect(O, 0, 1), I.disconnect(O, 0, 1);
      }
    };
  }, b = (_, T, A, O, M) => {
    if (T === 1)
      return v(_, A, O, M);
    if (T === 2)
      return x(_, A, O, M);
    throw s();
  };
  return (_, { channelCount: T, channelCountMode: A, pan: O, ...M }) => {
    if (A === "max")
      throw s();
    const E = e(_, {
      ...M,
      channelCount: 1,
      channelCountMode: A,
      numberOfInputs: 2
    }), R = n(_, { ...M, channelCount: T, channelCountMode: A, gain: 1 }), N = n(_, {
      channelCount: 1,
      channelCountMode: "explicit",
      channelInterpretation: "discrete",
      gain: O
    });
    let { connectGraph: U, disconnectGraph: q } = b(_, T, R, N, E);
    Object.defineProperty(N.gain, "defaultValue", { get: () => 0 }), Object.defineProperty(N.gain, "maxValue", { get: () => 1 }), Object.defineProperty(N.gain, "minValue", { get: () => -1 });
    const j = {
      get bufferSize() {
      },
      get channelCount() {
        return R.channelCount;
      },
      set channelCount(W) {
        R.channelCount !== W && (V && q(), { connectGraph: U, disconnectGraph: q } = b(_, W, R, N, E), V && U()), R.channelCount = W;
      },
      get channelCountMode() {
        return R.channelCountMode;
      },
      set channelCountMode(W) {
        if (W === "clamped-max" || W === "max")
          throw s();
        R.channelCountMode = W;
      },
      get channelInterpretation() {
        return R.channelInterpretation;
      },
      set channelInterpretation(W) {
        R.channelInterpretation = W;
      },
      get context() {
        return R.context;
      },
      get inputs() {
        return [R];
      },
      get numberOfInputs() {
        return R.numberOfInputs;
      },
      get numberOfOutputs() {
        return R.numberOfOutputs;
      },
      get pan() {
        return N.gain;
      },
      addEventListener(...W) {
        return R.addEventListener(W[0], W[1], W[2]);
      },
      dispatchEvent(...W) {
        return R.dispatchEvent(W[0]);
      },
      removeEventListener(...W) {
        return R.removeEventListener(W[0], W[1], W[2]);
      }
    };
    let V = !1;
    const D = () => {
      U(), V = !0;
    }, G = () => {
      q(), V = !1;
    };
    return o(pp(j, E), D, G);
  };
}, hB = (e, t, n, i, s, o, u) => (h, f) => {
  const p = h.createWaveShaper();
  if (o !== null && o.name === "webkitAudioContext" && h.createGain().gain.automationRate === void 0)
    return n(h, f);
  Lr(p, f);
  const g = f.curve === null || f.curve instanceof Float32Array ? f.curve : new Float32Array(f.curve);
  if (g !== null && g.length < 2)
    throw t();
  Bi(p, { curve: g }, "curve"), Bi(p, f, "oversample");
  let v = null, x = !1;
  return u(p, "curve", (T) => () => T.call(p), (T) => (A) => (T.call(p, A), x && (i(A) && v === null ? v = e(h, p) : !i(A) && v !== null && (v(), v = null)), A)), s(p, () => {
    x = !0, i(p.curve) && (v = e(h, p));
  }, () => {
    x = !1, v !== null && (v(), v = null);
  });
}, fB = (e, t, n, i, s) => (o, { curve: u, oversample: h, ...f }) => {
  const p = o.createWaveShaper(), g = o.createWaveShaper();
  Lr(p, f), Lr(g, f);
  const v = n(o, { ...f, gain: 1 }), x = n(o, { ...f, gain: -1 }), b = n(o, { ...f, gain: 1 }), _ = n(o, { ...f, gain: -1 });
  let T = null, A = !1, O = null;
  const M = {
    get bufferSize() {
    },
    get channelCount() {
      return p.channelCount;
    },
    set channelCount(N) {
      v.channelCount = N, x.channelCount = N, p.channelCount = N, b.channelCount = N, g.channelCount = N, _.channelCount = N;
    },
    get channelCountMode() {
      return p.channelCountMode;
    },
    set channelCountMode(N) {
      v.channelCountMode = N, x.channelCountMode = N, p.channelCountMode = N, b.channelCountMode = N, g.channelCountMode = N, _.channelCountMode = N;
    },
    get channelInterpretation() {
      return p.channelInterpretation;
    },
    set channelInterpretation(N) {
      v.channelInterpretation = N, x.channelInterpretation = N, p.channelInterpretation = N, b.channelInterpretation = N, g.channelInterpretation = N, _.channelInterpretation = N;
    },
    get context() {
      return p.context;
    },
    get curve() {
      return O;
    },
    set curve(N) {
      if (N !== null && N.length < 2)
        throw t();
      if (N === null)
        p.curve = N, g.curve = N;
      else {
        const U = N.length, q = new Float32Array(U + 2 - U % 2), j = new Float32Array(U + 2 - U % 2);
        q[0] = N[0], j[0] = -N[U - 1];
        const V = Math.ceil((U + 1) / 2), D = (U + 1) / 2 - 1;
        for (let G = 1; G < V; G += 1) {
          const W = G / V * D, P = Math.floor(W), H = Math.ceil(W);
          q[G] = P === H ? N[P] : (1 - (W - P)) * N[P] + (1 - (H - W)) * N[H], j[G] = P === H ? -N[U - 1 - P] : -((1 - (W - P)) * N[U - 1 - P]) - (1 - (H - W)) * N[U - 1 - H];
        }
        q[V] = U % 2 === 1 ? N[V - 1] : (N[V - 2] + N[V - 1]) / 2, p.curve = q, g.curve = j;
      }
      O = N, A && (i(O) && T === null ? T = e(o, v) : T !== null && (T(), T = null));
    },
    get inputs() {
      return [v];
    },
    get numberOfInputs() {
      return p.numberOfInputs;
    },
    get numberOfOutputs() {
      return p.numberOfOutputs;
    },
    get oversample() {
      return p.oversample;
    },
    set oversample(N) {
      p.oversample = N, g.oversample = N;
    },
    addEventListener(...N) {
      return v.addEventListener(N[0], N[1], N[2]);
    },
    dispatchEvent(...N) {
      return v.dispatchEvent(N[0]);
    },
    removeEventListener(...N) {
      return v.removeEventListener(N[0], N[1], N[2]);
    }
  };
  u !== null && (M.curve = u instanceof Float32Array ? u : new Float32Array(u)), h !== M.oversample && (M.oversample = h);
  const E = () => {
    v.connect(p).connect(b), v.connect(x).connect(g).connect(_).connect(b), A = !0, i(O) && (T = e(o, v));
  }, R = () => {
    v.disconnect(p), p.disconnect(b), v.disconnect(x), x.disconnect(g), g.disconnect(_), _.disconnect(b), A = !1, T !== null && (T(), T = null);
  };
  return s(pp(M, b), E, R);
}, Ja = () => new DOMException("", "NotSupportedError"), pB = {
  numberOfChannels: 1
}, mB = (e, t, n, i, s) => class extends e {
  constructor(u, h, f) {
    let p;
    if (typeof u == "number" && h !== void 0 && f !== void 0)
      p = { length: h, numberOfChannels: u, sampleRate: f };
    else if (typeof u == "object")
      p = u;
    else
      throw new Error("The given parameters are not valid.");
    const { length: g, numberOfChannels: v, sampleRate: x } = { ...pB, ...p }, b = i(v, g, x);
    t(Bg, () => Bg(b)) || b.addEventListener("statechange", /* @__PURE__ */ (() => {
      let _ = 0;
      const T = (A) => {
        this._state === "running" && (_ > 0 ? (b.removeEventListener("statechange", T), A.stopImmediatePropagation(), this._waitForThePromiseToSettle(A)) : _ += 1);
      };
      return T;
    })()), super(b, v), this._length = g, this._nativeOfflineAudioContext = b, this._state = null;
  }
  get length() {
    return this._nativeOfflineAudioContext.length === void 0 ? this._length : this._nativeOfflineAudioContext.length;
  }
  get state() {
    return this._state === null ? this._nativeOfflineAudioContext.state : this._state;
  }
  startRendering() {
    return this._state === "running" ? Promise.reject(n()) : (this._state = "running", s(this.destination, this._nativeOfflineAudioContext).finally(() => {
      this._state = null, LT(this);
    }));
  }
  _waitForThePromiseToSettle(u) {
    this._state === null ? this._nativeOfflineAudioContext.dispatchEvent(u) : setTimeout(() => this._waitForThePromiseToSettle(u));
  }
}, gB = {
  channelCount: 2,
  channelCountMode: "max",
  // This attribute has no effect for nodes with no inputs.
  channelInterpretation: "speakers",
  // This attribute has no effect for nodes with no inputs.
  detune: 0,
  frequency: 440,
  periodicWave: void 0,
  type: "sine"
}, yB = (e, t, n, i, s, o, u) => class extends e {
  constructor(f, p) {
    const g = s(f), v = { ...gB, ...p }, x = n(g, v), b = o(g), _ = b ? i() : null, T = f.sampleRate / 2;
    super(f, !1, x, _), this._detune = t(this, b, x.detune, 153600, -153600), this._frequency = t(this, b, x.frequency, T, -T), this._nativeOscillatorNode = x, this._onended = null, this._oscillatorNodeRenderer = _, this._oscillatorNodeRenderer !== null && v.periodicWave !== void 0 && (this._oscillatorNodeRenderer.periodicWave = v.periodicWave);
  }
  get detune() {
    return this._detune;
  }
  get frequency() {
    return this._frequency;
  }
  get onended() {
    return this._onended;
  }
  set onended(f) {
    const p = typeof f == "function" ? u(this, f) : null;
    this._nativeOscillatorNode.onended = p;
    const g = this._nativeOscillatorNode.onended;
    this._onended = g !== null && g === p ? f : g;
  }
  get type() {
    return this._nativeOscillatorNode.type;
  }
  set type(f) {
    this._nativeOscillatorNode.type = f, this._oscillatorNodeRenderer !== null && (this._oscillatorNodeRenderer.periodicWave = null);
  }
  setPeriodicWave(f) {
    this._nativeOscillatorNode.setPeriodicWave(f), this._oscillatorNodeRenderer !== null && (this._oscillatorNodeRenderer.periodicWave = f);
  }
  start(f = 0) {
    if (this._nativeOscillatorNode.start(f), this._oscillatorNodeRenderer !== null && (this._oscillatorNodeRenderer.start = f), this.context.state !== "closed") {
      tp(this);
      const p = () => {
        this._nativeOscillatorNode.removeEventListener("ended", p), Du(this) && Yg(this);
      };
      this._nativeOscillatorNode.addEventListener("ended", p);
    }
  }
  stop(f = 0) {
    this._nativeOscillatorNode.stop(f), this._oscillatorNodeRenderer !== null && (this._oscillatorNodeRenderer.stop = f);
  }
}, vB = (e, t, n, i, s) => () => {
  const o = /* @__PURE__ */ new WeakMap();
  let u = null, h = null, f = null;
  const p = async (g, v) => {
    let x = n(g);
    const b = za(x, v);
    if (!b) {
      const _ = {
        channelCount: x.channelCount,
        channelCountMode: x.channelCountMode,
        channelInterpretation: x.channelInterpretation,
        detune: x.detune.value,
        frequency: x.frequency.value,
        periodicWave: u === null ? void 0 : u,
        type: x.type
      };
      x = t(v, _), h !== null && x.start(h), f !== null && x.stop(f);
    }
    return o.set(v, x), b ? (await e(v, g.detune, x.detune), await e(v, g.frequency, x.frequency)) : (await i(v, g.detune, x.detune), await i(v, g.frequency, x.frequency)), await s(g, v, x), x;
  };
  return {
    set periodicWave(g) {
      u = g;
    },
    set start(g) {
      h = g;
    },
    set stop(g) {
      f = g;
    },
    render(g, v) {
      const x = o.get(v);
      return x !== void 0 ? Promise.resolve(x) : p(g, v);
    }
  };
}, bB = {
  channelCount: 2,
  channelCountMode: "clamped-max",
  channelInterpretation: "speakers",
  coneInnerAngle: 360,
  coneOuterAngle: 360,
  coneOuterGain: 0,
  distanceModel: "inverse",
  maxDistance: 1e4,
  orientationX: 1,
  orientationY: 0,
  orientationZ: 0,
  panningModel: "equalpower",
  positionX: 0,
  positionY: 0,
  positionZ: 0,
  refDistance: 1,
  rolloffFactor: 1
}, _B = (e, t, n, i, s, o, u) => class extends e {
  constructor(f, p) {
    const g = s(f), v = { ...bB, ...p }, x = n(g, v), b = o(g), _ = b ? i() : null;
    super(f, !1, x, _), this._nativePannerNode = x, this._orientationX = t(this, b, x.orientationX, $a, Ks), this._orientationY = t(this, b, x.orientationY, $a, Ks), this._orientationZ = t(this, b, x.orientationZ, $a, Ks), this._positionX = t(this, b, x.positionX, $a, Ks), this._positionY = t(this, b, x.positionY, $a, Ks), this._positionZ = t(this, b, x.positionZ, $a, Ks), u(this, 1);
  }
  get coneInnerAngle() {
    return this._nativePannerNode.coneInnerAngle;
  }
  set coneInnerAngle(f) {
    this._nativePannerNode.coneInnerAngle = f;
  }
  get coneOuterAngle() {
    return this._nativePannerNode.coneOuterAngle;
  }
  set coneOuterAngle(f) {
    this._nativePannerNode.coneOuterAngle = f;
  }
  get coneOuterGain() {
    return this._nativePannerNode.coneOuterGain;
  }
  set coneOuterGain(f) {
    this._nativePannerNode.coneOuterGain = f;
  }
  get distanceModel() {
    return this._nativePannerNode.distanceModel;
  }
  set distanceModel(f) {
    this._nativePannerNode.distanceModel = f;
  }
  get maxDistance() {
    return this._nativePannerNode.maxDistance;
  }
  set maxDistance(f) {
    this._nativePannerNode.maxDistance = f;
  }
  get orientationX() {
    return this._orientationX;
  }
  get orientationY() {
    return this._orientationY;
  }
  get orientationZ() {
    return this._orientationZ;
  }
  get panningModel() {
    return this._nativePannerNode.panningModel;
  }
  set panningModel(f) {
    this._nativePannerNode.panningModel = f;
  }
  get positionX() {
    return this._positionX;
  }
  get positionY() {
    return this._positionY;
  }
  get positionZ() {
    return this._positionZ;
  }
  get refDistance() {
    return this._nativePannerNode.refDistance;
  }
  set refDistance(f) {
    this._nativePannerNode.refDistance = f;
  }
  get rolloffFactor() {
    return this._nativePannerNode.rolloffFactor;
  }
  set rolloffFactor(f) {
    this._nativePannerNode.rolloffFactor = f;
  }
}, SB = (e, t, n, i, s, o, u, h, f, p) => () => {
  const g = /* @__PURE__ */ new WeakMap();
  let v = null;
  const x = async (b, _) => {
    let T = null, A = o(b);
    const O = {
      channelCount: A.channelCount,
      channelCountMode: A.channelCountMode,
      channelInterpretation: A.channelInterpretation
    }, M = {
      ...O,
      coneInnerAngle: A.coneInnerAngle,
      coneOuterAngle: A.coneOuterAngle,
      coneOuterGain: A.coneOuterGain,
      distanceModel: A.distanceModel,
      maxDistance: A.maxDistance,
      panningModel: A.panningModel,
      refDistance: A.refDistance,
      rolloffFactor: A.rolloffFactor
    }, E = za(A, _);
    if ("bufferSize" in A)
      T = i(_, { ...O, gain: 1 });
    else if (!E) {
      const R = {
        ...M,
        orientationX: A.orientationX.value,
        orientationY: A.orientationY.value,
        orientationZ: A.orientationZ.value,
        positionX: A.positionX.value,
        positionY: A.positionY.value,
        positionZ: A.positionZ.value
      };
      A = s(_, R);
    }
    if (g.set(_, T === null ? A : T), T !== null) {
      if (v === null) {
        if (u === null)
          throw new Error("Missing the native OfflineAudioContext constructor.");
        const G = new u(
          6,
          // Bug #17: Safari does not yet expose the length.
          b.context.length,
          _.sampleRate
        ), W = t(G, {
          channelCount: 1,
          channelCountMode: "explicit",
          channelInterpretation: "speakers",
          numberOfInputs: 6
        });
        W.connect(G.destination), v = (async () => {
          const P = await Promise.all([
            b.orientationX,
            b.orientationY,
            b.orientationZ,
            b.positionX,
            b.positionY,
            b.positionZ
          ].map(async (H, I) => {
            const K = n(G, {
              channelCount: 1,
              channelCountMode: "explicit",
              channelInterpretation: "discrete",
              offset: I === 0 ? 1 : 0
            });
            return await h(G, H, K.offset), K;
          }));
          for (let H = 0; H < 6; H += 1)
            P[H].connect(W, 0, H), P[H].start(0);
          return p(G);
        })();
      }
      const R = await v, N = i(_, { ...O, gain: 1 });
      await f(b, _, N);
      const U = [];
      for (let G = 0; G < R.numberOfChannels; G += 1)
        U.push(R.getChannelData(G));
      let q = [U[0][0], U[1][0], U[2][0]], j = [U[3][0], U[4][0], U[5][0]], V = i(_, { ...O, gain: 1 }), D = s(_, {
        ...M,
        orientationX: q[0],
        orientationY: q[1],
        orientationZ: q[2],
        positionX: j[0],
        positionY: j[1],
        positionZ: j[2]
      });
      N.connect(V).connect(D.inputs[0]), D.connect(T);
      for (let G = 128; G < R.length; G += 128) {
        const W = [U[0][G], U[1][G], U[2][G]], P = [U[3][G], U[4][G], U[5][G]];
        if (W.some((H, I) => H !== q[I]) || P.some((H, I) => H !== j[I])) {
          q = W, j = P;
          const H = G / _.sampleRate;
          V.gain.setValueAtTime(0, H), V = i(_, { ...O, gain: 0 }), D = s(_, {
            ...M,
            orientationX: q[0],
            orientationY: q[1],
            orientationZ: q[2],
            positionX: j[0],
            positionY: j[1],
            positionZ: j[2]
          }), V.gain.setValueAtTime(1, H), N.connect(V).connect(D.inputs[0]), D.connect(T);
        }
      }
      return T;
    }
    return E ? (await e(_, b.orientationX, A.orientationX), await e(_, b.orientationY, A.orientationY), await e(_, b.orientationZ, A.orientationZ), await e(_, b.positionX, A.positionX), await e(_, b.positionY, A.positionY), await e(_, b.positionZ, A.positionZ)) : (await h(_, b.orientationX, A.orientationX), await h(_, b.orientationY, A.orientationY), await h(_, b.orientationZ, A.orientationZ), await h(_, b.positionX, A.positionX), await h(_, b.positionY, A.positionY), await h(_, b.positionZ, A.positionZ)), fp(A) ? await f(b, _, A.inputs[0]) : await f(b, _, A), A;
  };
  return {
    render(b, _) {
      const T = g.get(_);
      return T !== void 0 ? Promise.resolve(T) : x(b, _);
    }
  };
}, xB = {
  disableNormalization: !1
}, TB = (e, t, n, i) => class WT {
  constructor(o, u) {
    const h = t(o), f = i({ ...xB, ...u }), p = e(h, f);
    return n.add(p), p;
  }
  static [Symbol.hasInstance](o) {
    return o !== null && typeof o == "object" && Object.getPrototypeOf(o) === WT.prototype || n.has(o);
  }
}, CB = (e, t) => (n, i, s) => (e(i).replay(s), t(i, n, s)), wB = (e, t, n) => async (i, s, o) => {
  const u = e(i);
  await Promise.all(u.activeInputs.map((h, f) => Array.from(h).map(async ([p, g]) => {
    const x = await t(p).render(p, s), b = i.context.destination;
    !n(p) && (i !== b || !n(i)) && x.connect(o, g, f);
  })).reduce((h, f) => [...h, ...f], []));
}, EB = (e, t, n) => async (i, s, o) => {
  const u = t(i);
  await Promise.all(Array.from(u.activeInputs).map(async ([h, f]) => {
    const g = await e(h).render(h, s);
    n(h) || g.connect(o, f);
  }));
}, AB = (e, t, n, i) => (s) => e(Bg, () => Bg(s)) ? Promise.resolve(e(i, i)).then((o) => {
  if (!o) {
    const u = n(s, 512, 0, 1);
    s.oncomplete = () => {
      u.onaudioprocess = null, u.disconnect();
    }, u.onaudioprocess = () => s.currentTime, u.connect(s.destination);
  }
  return s.startRendering();
}) : new Promise((o) => {
  const u = t(s, {
    channelCount: 1,
    channelCountMode: "explicit",
    channelInterpretation: "discrete",
    gain: 0
  });
  s.oncomplete = (h) => {
    u.disconnect(), o(h.renderedBuffer);
  }, u.connect(s.destination), s.startRendering();
}), MB = (e) => (t, n) => {
  e.set(t, n);
}, RB = (e) => (t, n) => e.set(t, n), OB = (e, t, n, i, s, o, u, h) => (f, p) => n(f).render(f, p).then(() => Promise.all(Array.from(i(p)).map((g) => n(g).render(g, p)))).then(() => s(p)).then((g) => (typeof g.copyFromChannel != "function" ? (u(g), c_(g)) : t(o, () => o(g)) || h(g), e.add(g), g)), NB = {
  channelCount: 2,
  /*
   * Bug #105: The channelCountMode should be 'clamped-max' according to the spec but is set to 'explicit' to achieve consistent
   * behavior.
   */
  channelCountMode: "explicit",
  channelInterpretation: "speakers",
  pan: 0
}, kB = (e, t, n, i, s, o) => class extends e {
  constructor(h, f) {
    const p = s(h), g = { ...NB, ...f }, v = n(p, g), x = o(p), b = x ? i() : null;
    super(h, !1, v, b), this._pan = t(this, x, v.pan);
  }
  get pan() {
    return this._pan;
  }
}, DB = (e, t, n, i, s) => () => {
  const o = /* @__PURE__ */ new WeakMap(), u = async (h, f) => {
    let p = n(h);
    const g = za(p, f);
    if (!g) {
      const v = {
        channelCount: p.channelCount,
        channelCountMode: p.channelCountMode,
        channelInterpretation: p.channelInterpretation,
        pan: p.pan.value
      };
      p = t(f, v);
    }
    return o.set(f, p), g ? await e(f, h.pan, p.pan) : await i(f, h.pan, p.pan), fp(p) ? await s(h, f, p.inputs[0]) : await s(h, f, p), p;
  };
  return {
    render(h, f) {
      const p = o.get(f);
      return p !== void 0 ? Promise.resolve(p) : u(h, f);
    }
  };
}, BB = (e) => () => {
  if (e === null)
    return !1;
  try {
    new e({ length: 1, sampleRate: 44100 });
  } catch {
    return !1;
  }
  return !0;
}, zB = (e, t) => async () => {
  if (e === null)
    return !0;
  if (t === null)
    return !1;
  const n = new Blob(['class A extends AudioWorkletProcessor{process(i){this.port.postMessage(i,[i[0][0].buffer])}}registerProcessor("a",A)'], {
    type: "application/javascript; charset=utf-8"
  }), i = new t(1, 128, 44100), s = URL.createObjectURL(n);
  let o = !1, u = !1;
  try {
    await i.audioWorklet.addModule(s);
    const h = new e(i, "a", { numberOfOutputs: 0 }), f = i.createOscillator();
    h.port.onmessage = () => o = !0, h.onprocessorerror = () => u = !0, f.connect(h), f.start(0), await i.startRendering(), await new Promise((p) => setTimeout(p));
  } catch {
  } finally {
    URL.revokeObjectURL(s);
  }
  return o && !u;
}, PB = (e, t) => () => {
  if (t === null)
    return Promise.resolve(!1);
  const n = new t(1, 1, 44100), i = e(n, {
    channelCount: 1,
    channelCountMode: "explicit",
    channelInterpretation: "discrete",
    gain: 0
  });
  return new Promise((s) => {
    n.oncomplete = () => {
      i.disconnect(), s(n.currentTime !== 0);
    }, n.startRendering();
  });
}, UB = () => new DOMException("", "UnknownError"), jB = {
  channelCount: 2,
  channelCountMode: "max",
  channelInterpretation: "speakers",
  curve: null,
  oversample: "none"
}, LB = (e, t, n, i, s, o, u) => class extends e {
  constructor(f, p) {
    const g = s(f), v = { ...jB, ...p }, x = n(g, v), _ = o(g) ? i() : null;
    super(f, !0, x, _), this._isCurveNullified = !1, this._nativeWaveShaperNode = x, u(this, 1);
  }
  get curve() {
    return this._isCurveNullified ? null : this._nativeWaveShaperNode.curve;
  }
  set curve(f) {
    if (f === null)
      this._isCurveNullified = !0, this._nativeWaveShaperNode.curve = new Float32Array([0, 0]);
    else {
      if (f.length < 2)
        throw t();
      this._isCurveNullified = !1, this._nativeWaveShaperNode.curve = f;
    }
  }
  get oversample() {
    return this._nativeWaveShaperNode.oversample;
  }
  set oversample(f) {
    this._nativeWaveShaperNode.oversample = f;
  }
}, VB = (e, t, n) => () => {
  const i = /* @__PURE__ */ new WeakMap(), s = async (o, u) => {
    let h = t(o);
    if (!za(h, u)) {
      const p = {
        channelCount: h.channelCount,
        channelCountMode: h.channelCountMode,
        channelInterpretation: h.channelInterpretation,
        curve: h.curve,
        oversample: h.oversample
      };
      h = e(u, p);
    }
    return i.set(u, h), fp(h) ? await n(o, u, h.inputs[0]) : await n(o, u, h), h;
  };
  return {
    render(o, u) {
      const h = i.get(u);
      return h !== void 0 ? Promise.resolve(h) : s(o, u);
    }
  };
}, IB = () => typeof window > "u" ? null : window, FB = (e, t) => (n) => {
  n.copyFromChannel = (i, s, o = 0) => {
    const u = e(o), h = e(s);
    if (h >= n.numberOfChannels)
      throw t();
    const f = n.length, p = n.getChannelData(h), g = i.length;
    for (let v = u < 0 ? -u : 0; v + u < f && v < g; v += 1)
      i[v] = p[v + u];
  }, n.copyToChannel = (i, s, o = 0) => {
    const u = e(o), h = e(s);
    if (h >= n.numberOfChannels)
      throw t();
    const f = n.length, p = n.getChannelData(h), g = i.length;
    for (let v = u < 0 ? -u : 0; v + u < f && v < g; v += 1)
      p[v + u] = i[v];
  };
}, qB = (e) => (t) => {
  t.copyFromChannel = /* @__PURE__ */ ((n) => (i, s, o = 0) => {
    const u = e(o), h = e(s);
    if (u < t.length)
      return n.call(t, i, h, u);
  })(t.copyFromChannel), t.copyToChannel = /* @__PURE__ */ ((n) => (i, s, o = 0) => {
    const u = e(o), h = e(s);
    if (u < t.length)
      return n.call(t, i, h, u);
  })(t.copyToChannel);
}, GB = (e) => (t, n) => {
  const i = n.createBuffer(1, 1, 44100);
  t.buffer === null && (t.buffer = i), e(t, "buffer", (s) => () => {
    const o = s.call(t);
    return o === i ? null : o;
  }, (s) => (o) => s.call(t, o === null ? i : o));
}, HB = (e, t) => (n, i) => {
  i.channelCount = 1, i.channelCountMode = "explicit", Object.defineProperty(i, "channelCount", {
    get: () => 1,
    set: () => {
      throw e();
    }
  }), Object.defineProperty(i, "channelCountMode", {
    get: () => "explicit",
    set: () => {
      throw e();
    }
  });
  const s = n.createBufferSource();
  t(i, () => {
    const h = i.numberOfInputs;
    for (let f = 0; f < h; f += 1)
      s.connect(i, 0, f);
  }, () => s.disconnect(i));
}, $T = (e, t, n) => e.copyFromChannel === void 0 ? e.getChannelData(n)[0] : (e.copyFromChannel(t, n), t[0]), QT = (e) => {
  if (e === null)
    return !1;
  const t = e.length;
  return t % 2 !== 0 ? e[Math.floor(t / 2)] !== 0 : e[t / 2 - 1] + e[t / 2] !== 0;
}, Zg = (e, t, n, i) => {
  let s = e;
  for (; !s.hasOwnProperty(t); )
    s = Object.getPrototypeOf(s);
  const { get: o, set: u } = Object.getOwnPropertyDescriptor(s, t);
  Object.defineProperty(e, t, { get: n(o), set: i(u) });
}, KB = (e) => ({
  ...e,
  outputChannelCount: e.outputChannelCount !== void 0 ? e.outputChannelCount : e.numberOfInputs === 1 && e.numberOfOutputs === 1 ? (
    /*
     * Bug #61: This should be the computedNumberOfChannels, but unfortunately that is almost impossible to fake. That's why
     * the channelCountMode is required to be 'explicit' as long as there is not a native implementation in every browser. That
     * makes sure the computedNumberOfChannels is equivilant to the channelCount which makes it much easier to compute.
     */
    [e.channelCount]
  ) : Array.from({ length: e.numberOfOutputs }, () => 1)
}), YB = (e) => ({ ...e, channelCount: e.numberOfOutputs }), XB = (e) => {
  const { imag: t, real: n } = e;
  return t === void 0 ? n === void 0 ? { ...e, imag: [0, 0], real: [0, 0] } : { ...e, imag: Array.from(n, () => 0), real: n } : n === void 0 ? { ...e, imag: t, real: Array.from(t, () => 0) } : { ...e, imag: t, real: n };
}, ZT = (e, t, n) => {
  try {
    e.setValueAtTime(t, n);
  } catch (i) {
    if (i.code !== 9)
      throw i;
    ZT(e, t, n + 1e-7);
  }
}, WB = (e) => {
  const t = e.createBufferSource();
  t.start();
  try {
    t.start();
  } catch {
    return !0;
  }
  return !1;
}, $B = (e) => {
  const t = e.createBufferSource(), n = e.createBuffer(1, 1, 44100);
  t.buffer = n;
  try {
    t.start(0, 1);
  } catch {
    return !1;
  }
  return !0;
}, QB = (e) => {
  const t = e.createBufferSource();
  t.start();
  try {
    t.stop();
  } catch {
    return !1;
  }
  return !0;
}, p_ = (e) => {
  const t = e.createOscillator();
  try {
    t.start(-1);
  } catch (n) {
    return n instanceof RangeError;
  }
  return !1;
}, JT = (e) => {
  const t = e.createBuffer(1, 1, 44100), n = e.createBufferSource();
  n.buffer = t, n.start(), n.stop();
  try {
    return n.stop(), !0;
  } catch {
    return !1;
  }
}, m_ = (e) => {
  const t = e.createOscillator();
  try {
    t.stop(-1);
  } catch (n) {
    return n instanceof RangeError;
  }
  return !1;
}, ZB = (e) => {
  const { port1: t, port2: n } = new MessageChannel();
  try {
    t.postMessage(e);
  } finally {
    t.close(), n.close();
  }
}, JB = (e) => {
  e.start = /* @__PURE__ */ ((t) => (n = 0, i = 0, s) => {
    const o = e.buffer, u = o === null ? i : Math.min(o.duration, i);
    o !== null && u > o.duration - 0.5 / e.context.sampleRate ? t.call(e, n, 0, 0) : t.call(e, n, u, s);
  })(e.start);
}, t6 = (e, t) => {
  const n = t.createGain();
  e.connect(n);
  const i = /* @__PURE__ */ ((s) => () => {
    s.call(e, n), e.removeEventListener("ended", i);
  })(e.disconnect);
  e.addEventListener("ended", i), pp(e, n), e.stop = /* @__PURE__ */ ((s) => {
    let o = !1;
    return (u = 0) => {
      if (o)
        try {
          s.call(e, u);
        } catch {
          n.gain.setValueAtTime(0, u);
        }
      else
        s.call(e, u), o = !0;
    };
  })(e.stop);
}, mp = (e, t) => (n) => {
  const i = { value: e };
  return Object.defineProperties(n, {
    currentTarget: i,
    target: i
  }), typeof t == "function" ? t.call(e, n) : t.handleEvent.call(e, n);
}, tz = _N(Vh), ez = EN(Vh), nz = jk(X1), e6 = /* @__PURE__ */ new WeakMap(), iz = nD(e6), xl = pk(/* @__PURE__ */ new Map(), /* @__PURE__ */ new WeakMap()), Rc = IB(), n6 = kD(xl, kc), g_ = eD(Qa), ya = wB(Qa, g_, Ph), rz = NN(n6, Ri, ya), Ti = aD(Y1), Lu = aB(Rc), ui = xD(Lu), i6 = /* @__PURE__ */ new WeakMap(), r6 = Xk(mp), Jg = PD(Rc), y_ = vD(Jg), v_ = bD(Rc), a6 = _D(Rc), zg = jD(Rc), vr = nk(SN(kT), wN(tz, ez, h1, nz, f1, Qa, iz, Kg, Ri, Vh, Du, Ph, Hy), xl, fD(s2, f1, Qa, Ri, Dg, Du), kc, W1, Ja, Bk(h1, s2, Qa, Ri, Dg, Ti, Du, ui), Ik(i6, Qa, Sl), r6, Ti, y_, v_, a6, ui, zg), az = ON(vr, rz, kc, n6, Ti, ui), b_ = /* @__PURE__ */ new WeakSet(), wx = DD(Rc), s6 = Ak(new Uint32Array(1)), __ = FB(s6, kc), S_ = qB(s6), o6 = DN(b_, xl, Ja, wx, Lu, BB(wx), __, S_), $1 = AN(ws), l6 = EB(g_, Xg, Ph), Dc = Sk(l6), gp = zD($1, xl, WB, $B, QB, p_, JT, m_, JB, GB(Zg), t6), Bc = CB(iD(Xg), l6), sz = PN(Dc, gp, Ri, Bc, ya), Tl = ik(xN(DT), i6, l_, rk, pN, mN, gN, yN, vN, i2, OT, Jg, ZT), oz = zN(vr, sz, Tl, Zr, gp, Ti, ui, mp), lz = HN(vr, KN, kc, Zr, UD(ws, Zg), Ti, ui, ya), cz = fk(Dc, YT, Ri, Bc, ya), Ih = RB(e6), uz = hk(vr, Tl, cz, W1, YT, Ti, ui, Ih), Vd = OD(Vh, v_), dz = HB(Zr, Vd), Id = HD(Jg, dz), hz = yk(Id, Ri, ya), fz = gk(vr, hz, Id, Ti, ui), pz = _k($g, Ri, ya), mz = bk(vr, pz, $g, Ti, ui, YB), gz = XD($1, gp, ws, Vd), yp = YD($1, xl, gz, p_, m_), yz = Ek(Dc, yp, Ri, Bc, ya), vz = wk(vr, Tl, yz, yp, Ti, ui, mp), c6 = WD(Ja, Zg), bz = Ok(c6, Ri, ya), _z = Rk(vr, bz, c6, Ti, ui, Ih), Sz = Uk(Dc, XT, Ri, Bc, ya), xz = Pk(vr, Tl, Sz, XT, Ti, ui, Ih), u6 = $D(Ja), Tz = Hk(Dc, u6, Ri, Bc, ya), Cz = Gk(vr, Tl, Tz, u6, Ja, Ti, ui, Ih), wz = Jk(Dc, ws, Ri, Bc, ya), Ez = Zk(vr, Tl, wz, ws, Ti, ui), Az = tB(W1, Zr, Qg, Ja), Q1 = AB(xl, ws, Qg, PB(ws, Lu)), Mz = hD(gp, Ri, Lu, ya, Q1), Rz = QD(Az), Oz = uD(vr, Rz, Mz, Ti, ui, Ih), Nz = YN(Tl, Id, yp, Qg, Ja, $T, ui, Zg), d6 = /* @__PURE__ */ new WeakMap(), kz = RD(lz, Nz, r6, ui, d6, mp), h6 = sB($1, xl, p_, JT, m_, t6), Dz = vB(Dc, h6, Ri, Bc, ya), Bz = yB(vr, Tl, h6, Dz, Ti, ui, mp), f6 = Tk(gp), zz = fB(f6, Zr, ws, QT, Vd), Z1 = hB(f6, Zr, zz, QT, Vd, Jg, Zg), Pz = lB(h1, Zr, Id, ws, Qg, Z1, Ja, f1, $T, Vd), p6 = oB(Pz), Uz = SB(Dc, Id, yp, ws, p6, Ri, Lu, Bc, ya, Q1), jz = _B(vr, Tl, p6, Uz, Ti, ui, Ih), Lz = cB(kc), Vz = TB(Lz, Ti, /* @__PURE__ */ new WeakSet(), XB), Iz = dB(Id, $g, ws, Z1, Ja, Vd), m6 = uB(Iz, Ja), Fz = DB(Dc, m6, Ri, Bc, ya), qz = kB(vr, Tl, m6, Fz, Ti, ui), Gz = VB(Z1, Ri, ya), Hz = LB(vr, Zr, Z1, Gz, Ti, ui, Ih), g6 = TD(Rc), x_ = Wk(Rc), y6 = /* @__PURE__ */ new WeakMap(), Kz = sD(y6, Lu), Yz = g6 ? CN(
  xl,
  Ja,
  Yk(Rc),
  x_,
  $k(bN),
  Ti,
  Kz,
  ui,
  zg,
  /* @__PURE__ */ new WeakMap(),
  /* @__PURE__ */ new WeakMap(),
  zB(zg, Lu),
  // @todo window is guaranteed to be defined because isSecureContext checks that as well.
  Rc
) : void 0, Xz = SD(y_, ui), Wz = Dk(b_, xl, kk, Kk, /* @__PURE__ */ new WeakSet(), Ti, Xz, u1, Bg, __, S_), v6 = uk(Yz, az, o6, oz, uz, fz, mz, vz, _z, Wz, xz, Cz, Ez, Oz, kz, Bz, jz, Vz, qz, Hz), $z = CD(vr, eB, Ti, ui), Qz = ED(vr, nB, Ti, ui), Zz = AD(vr, iB, Ti, ui), Jz = rB(Zr, ui), tP = MD(vr, Jz, Ti), eP = GN(v6, Zr, Ja, UB, $z, Qz, Zz, tP, Jg), T_ = oD(d6), nP = MN(T_), b6 = xk(kc), iP = Lk(T_), _6 = Fk(kc), S6 = /* @__PURE__ */ new WeakMap(), rP = tD(S6, Sl), aP = GD(b6, kc, Zr, Id, $g, yp, ws, Qg, Ja, _6, x_, rP, Vd), sP = VD(Zr, aP, ws, Ja, Vd), oP = ck(Dc, b6, gp, Id, $g, yp, ws, iP, _6, x_, Ri, zg, Lu, Bc, ya, Q1), lP = rD(y6), cP = MB(S6), Ex = g6 ? sk(nP, vr, Tl, oP, sP, Qa, lP, Ti, ui, zg, KB, cP, ZB, mp) : void 0, uP = Nk(Ja, Lu), dP = OB(b_, xl, g_, T_, Q1, u1, __, S_), hP = mB(v6, xl, Zr, uP, dP), fP = pD(Y1, y_), pP = mD(o_, v_), mP = gD(l_, a6), gP = yD(Y1, ui);
function $s(e) {
  return e === void 0;
}
function _n(e) {
  return e !== void 0;
}
function yP(e) {
  return typeof e == "function";
}
function Oc(e) {
  return typeof e == "number";
}
function Dd(e) {
  return Object.prototype.toString.call(e) === "[object Object]" && e.constructor === Object;
}
function x6(e) {
  return typeof e == "boolean";
}
function Ts(e) {
  return Array.isArray(e);
}
function ju(e) {
  return typeof e == "string";
}
function Dy(e) {
  return ju(e) && /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(e);
}
function nn(e, t) {
  if (!e)
    throw new Error(t);
}
function Ud(e, t, n = 1 / 0) {
  if (!(t <= e && e <= n))
    throw new RangeError(`Value must be within [${t}, ${n}], got: ${e}`);
}
function T6(e) {
  !e.isOffline && e.state !== "running" && J1('The AudioContext is "suspended". Invoke Tone.start() from a user action to start the audio.');
}
let C6 = !1, Ax = !1;
function Mx(e) {
  C6 = e;
}
function vP(e) {
  $s(e) && C6 && !Ax && (Ax = !0, J1("Events scheduled inside of scheduled callbacks should use the passed in scheduling time. See https://github.com/Tonejs/Tone.js/wiki/Accurate-Timing"));
}
let w6 = console;
function bP(...e) {
  w6.log(...e);
}
function J1(...e) {
  w6.warn(...e);
}
function _P(e) {
  return new eP(e);
}
function SP(e, t, n) {
  return new hP(e, t, n);
}
const Ys = typeof self == "object" ? self : null, xP = Ys && (Ys.hasOwnProperty("AudioContext") || Ys.hasOwnProperty("webkitAudioContext"));
function TP(e, t, n) {
  return nn(_n(Ex), "AudioWorkletNode only works in a secure context (https or localhost)"), new (e instanceof (Ys == null ? void 0 : Ys.BaseAudioContext) ? Ys == null ? void 0 : Ys.AudioWorkletNode : Ex)(e, t, n);
}
function Cl(e, t, n, i) {
  var s = arguments.length, o = s < 3 ? t : i === null ? i = Object.getOwnPropertyDescriptor(t, n) : i, u;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(e, t, n, i);
  else for (var h = e.length - 1; h >= 0; h--) (u = e[h]) && (o = (s < 3 ? u(o) : s > 3 ? u(t, n, o) : u(t, n)) || o);
  return s > 3 && o && Object.defineProperty(t, n, o), o;
}
function Nr(e, t, n, i) {
  function s(o) {
    return o instanceof n ? o : new n(function(u) {
      u(o);
    });
  }
  return new (n || (n = Promise))(function(o, u) {
    function h(g) {
      try {
        p(i.next(g));
      } catch (v) {
        u(v);
      }
    }
    function f(g) {
      try {
        p(i.throw(g));
      } catch (v) {
        u(v);
      }
    }
    function p(g) {
      g.done ? o(g.value) : s(g.value).then(h, f);
    }
    p((i = i.apply(e, t || [])).next());
  });
}
class CP {
  constructor(t, n, i, s) {
    this._callback = t, this._type = n, this._minimumUpdateInterval = Math.max(128 / (s || 44100), 1e-3), this.updateInterval = i, this._createClock();
  }
  /**
   * Generate a web worker
   */
  _createWorker() {
    const t = new Blob([
      /* javascript */
      `
			// the initial timeout time
			let timeoutTime =  ${(this._updateInterval * 1e3).toFixed(1)};
			// onmessage callback
			self.onmessage = function(msg){
				timeoutTime = parseInt(msg.data);
			};
			// the tick function which posts a message
			// and schedules a new tick
			function tick(){
				setTimeout(tick, timeoutTime);
				self.postMessage('tick');
			}
			// call tick initially
			tick();
			`
    ], { type: "text/javascript" }), n = URL.createObjectURL(t), i = new Worker(n);
    i.onmessage = this._callback.bind(this), this._worker = i;
  }
  /**
   * Create a timeout loop
   */
  _createTimeout() {
    this._timeout = setTimeout(() => {
      this._createTimeout(), this._callback();
    }, this._updateInterval * 1e3);
  }
  /**
   * Create the clock source.
   */
  _createClock() {
    if (this._type === "worker")
      try {
        this._createWorker();
      } catch {
        this._type = "timeout", this._createClock();
      }
    else this._type === "timeout" && this._createTimeout();
  }
  /**
   * Clean up the current clock source
   */
  _disposeClock() {
    this._timeout && clearTimeout(this._timeout), this._worker && (this._worker.terminate(), this._worker.onmessage = null);
  }
  /**
   * The rate in seconds the ticker will update
   */
  get updateInterval() {
    return this._updateInterval;
  }
  set updateInterval(t) {
    var n;
    this._updateInterval = Math.max(t, this._minimumUpdateInterval), this._type === "worker" && ((n = this._worker) === null || n === void 0 || n.postMessage(this._updateInterval * 1e3));
  }
  /**
   * The type of the ticker, either a worker or a timeout
   */
  get type() {
    return this._type;
  }
  set type(t) {
    this._disposeClock(), this._type = t, this._createClock();
  }
  /**
   * Clean up
   */
  dispose() {
    this._disposeClock();
  }
}
function Uh(e) {
  return mP(e);
}
function Bd(e) {
  return pP(e);
}
function Ky(e) {
  return gP(e);
}
function Pf(e) {
  return fP(e);
}
function wP(e) {
  return e instanceof o6;
}
function EP(e, t) {
  return e === "value" || Uh(t) || Bd(t) || wP(t);
}
function Bh(e, ...t) {
  if (!t.length)
    return e;
  const n = t.shift();
  if (Dd(e) && Dd(n))
    for (const i in n)
      EP(i, n[i]) ? e[i] = n[i] : Dd(n[i]) ? (e[i] || Object.assign(e, { [i]: {} }), Bh(e[i], n[i])) : Object.assign(e, { [i]: n[i] });
  return Bh(e, ...t);
}
function AP(e, t) {
  return e.length === t.length && e.every((n, i) => t[i] === n);
}
function on(e, t, n = [], i) {
  const s = {}, o = Array.from(t);
  if (Dd(o[0]) && i && !Reflect.has(o[0], i) && (Object.keys(o[0]).some((h) => Reflect.has(e, h)) || (Bh(s, { [i]: o[0] }), n.splice(n.indexOf(i), 1), o.shift())), o.length === 1 && Dd(o[0]))
    Bh(s, o[0]);
  else
    for (let u = 0; u < n.length; u++)
      _n(o[u]) && (s[n[u]] = o[u]);
  return Bh(e, s);
}
function MP(e) {
  return e.constructor.getDefaults();
}
function Ec(e, t) {
  return $s(e) ? t : e;
}
function d2(e, t) {
  return t.forEach((n) => {
    Reflect.has(e, n) && delete e[n];
  }), e;
}
/**
 * Tone.js
 * @author Yotam Mann
 * @license http://opensource.org/licenses/MIT MIT License
 * @copyright 2014-2024 Yotam Mann
 */
class Vu {
  constructor() {
    this.debug = !1, this._wasDisposed = !1;
  }
  /**
   * Returns all of the default options belonging to the class.
   */
  static getDefaults() {
    return {};
  }
  /**
   * Prints the outputs to the console log for debugging purposes.
   * Prints the contents only if either the object has a property
   * called `debug` set to true, or a variable called TONE_DEBUG_CLASS
   * is set to the name of the class.
   * @example
   * const osc = new Tone.Oscillator();
   * // prints all logs originating from this oscillator
   * osc.debug = true;
   * // calls to start/stop will print in the console
   * osc.start();
   */
  log(...t) {
    (this.debug || Ys && this.toString() === Ys.TONE_DEBUG_CLASS) && bP(this, ...t);
  }
  /**
   * disconnect and dispose.
   */
  dispose() {
    return this._wasDisposed = !0, this;
  }
  /**
   * Indicates if the instance was disposed. 'Disposing' an
   * instance means that all of the Web Audio nodes that were
   * created for the instance are disconnected and freed for garbage collection.
   */
  get disposed() {
    return this._wasDisposed;
  }
  /**
   * Convert the class to a string
   * @example
   * const osc = new Tone.Oscillator();
   * console.log(osc.toString());
   */
  toString() {
    return this.name;
  }
}
Vu.version = RT;
const C_ = 1e-6;
function ep(e, t) {
  return e > t + C_;
}
function h2(e, t) {
  return ep(e, t) || bl(e, t);
}
function y1(e, t) {
  return e + C_ < t;
}
function bl(e, t) {
  return Math.abs(e - t) < C_;
}
function RP(e, t, n) {
  return Math.max(Math.min(e, n), t);
}
let Ac = class E6 extends Vu {
  constructor() {
    super(), this.name = "Timeline", this._timeline = [];
    const t = on(E6.getDefaults(), arguments, ["memory"]);
    this.memory = t.memory, this.increasing = t.increasing;
  }
  static getDefaults() {
    return {
      memory: 1 / 0,
      increasing: !1
    };
  }
  /**
   * The number of items in the timeline.
   */
  get length() {
    return this._timeline.length;
  }
  /**
   * Insert an event object onto the timeline. Events must have a "time" attribute.
   * @param event  The event object to insert into the timeline.
   */
  add(t) {
    if (nn(Reflect.has(t, "time"), "Timeline: events must have a time attribute"), t.time = t.time.valueOf(), this.increasing && this.length) {
      const n = this._timeline[this.length - 1];
      nn(h2(t.time, n.time), "The time must be greater than or equal to the last scheduled time"), this._timeline.push(t);
    } else {
      const n = this._search(t.time);
      this._timeline.splice(n + 1, 0, t);
    }
    if (this.length > this.memory) {
      const n = this.length - this.memory;
      this._timeline.splice(0, n);
    }
    return this;
  }
  /**
   * Remove an event from the timeline.
   * @param  {Object}  event  The event object to remove from the list.
   * @returns {Timeline} this
   */
  remove(t) {
    const n = this._timeline.indexOf(t);
    return n !== -1 && this._timeline.splice(n, 1), this;
  }
  /**
   * Get the nearest event whose time is less than or equal to the given time.
   * @param  time  The time to query.
   */
  get(t, n = "time") {
    const i = this._search(t, n);
    return i !== -1 ? this._timeline[i] : null;
  }
  /**
   * Return the first event in the timeline without removing it
   * @returns {Object} The first event object
   */
  peek() {
    return this._timeline[0];
  }
  /**
   * Return the first event in the timeline and remove it
   */
  shift() {
    return this._timeline.shift();
  }
  /**
   * Get the event which is scheduled after the given time.
   * @param  time  The time to query.
   */
  getAfter(t, n = "time") {
    const i = this._search(t, n);
    return i + 1 < this._timeline.length ? this._timeline[i + 1] : null;
  }
  /**
   * Get the event before the event at the given time.
   * @param  time  The time to query.
   */
  getBefore(t) {
    const n = this._timeline.length;
    if (n > 0 && this._timeline[n - 1].time < t)
      return this._timeline[n - 1];
    const i = this._search(t);
    return i - 1 >= 0 ? this._timeline[i - 1] : null;
  }
  /**
   * Cancel events at and after the given time
   * @param  after  The time to query.
   */
  cancel(t) {
    if (this._timeline.length > 1) {
      let n = this._search(t);
      if (n >= 0)
        if (bl(this._timeline[n].time, t)) {
          for (let i = n; i >= 0 && bl(this._timeline[i].time, t); i--)
            n = i;
          this._timeline = this._timeline.slice(0, n);
        } else
          this._timeline = this._timeline.slice(0, n + 1);
      else
        this._timeline = [];
    } else this._timeline.length === 1 && h2(this._timeline[0].time, t) && (this._timeline = []);
    return this;
  }
  /**
   * Cancel events before or equal to the given time.
   * @param  time  The time to cancel before.
   */
  cancelBefore(t) {
    const n = this._search(t);
    return n >= 0 && (this._timeline = this._timeline.slice(n + 1)), this;
  }
  /**
   * Returns the previous event if there is one. null otherwise
   * @param  event The event to find the previous one of
   * @return The event right before the given event
   */
  previousEvent(t) {
    const n = this._timeline.indexOf(t);
    return n > 0 ? this._timeline[n - 1] : null;
  }
  /**
   * Does a binary search on the timeline array and returns the
   * nearest event index whose time is after or equal to the given time.
   * If a time is searched before the first index in the timeline, -1 is returned.
   * If the time is after the end, the index of the last item is returned.
   */
  _search(t, n = "time") {
    if (this._timeline.length === 0)
      return -1;
    let i = 0;
    const s = this._timeline.length;
    let o = s;
    if (s > 0 && this._timeline[s - 1][n] <= t)
      return s - 1;
    for (; i < o; ) {
      let u = Math.floor(i + (o - i) / 2);
      const h = this._timeline[u], f = this._timeline[u + 1];
      if (bl(h[n], t)) {
        for (let p = u; p < this._timeline.length; p++) {
          const g = this._timeline[p];
          if (bl(g[n], t))
            u = p;
          else
            break;
        }
        return u;
      } else {
        if (y1(h[n], t) && ep(f[n], t))
          return u;
        ep(h[n], t) ? o = u : i = u + 1;
      }
    }
    return -1;
  }
  /**
   * Internal iterator. Applies extra safety checks for
   * removing items from the array.
   */
  _iterate(t, n = 0, i = this._timeline.length - 1) {
    this._timeline.slice(n, i + 1).forEach(t);
  }
  /**
   * Iterate over everything in the array
   * @param  callback The callback to invoke with every item
   */
  forEach(t) {
    return this._iterate(t), this;
  }
  /**
   * Iterate over everything in the array at or before the given time.
   * @param  time The time to check if items are before
   * @param  callback The callback to invoke with every item
   */
  forEachBefore(t, n) {
    const i = this._search(t);
    return i !== -1 && this._iterate(n, 0, i), this;
  }
  /**
   * Iterate over everything in the array after the given time.
   * @param  time The time to check if items are before
   * @param  callback The callback to invoke with every item
   */
  forEachAfter(t, n) {
    const i = this._search(t);
    return this._iterate(n, i + 1), this;
  }
  /**
   * Iterate over everything in the array between the startTime and endTime.
   * The timerange is inclusive of the startTime, but exclusive of the endTime.
   * range = [startTime, endTime).
   * @param  startTime The time to check if items are before
   * @param  endTime The end of the test interval.
   * @param  callback The callback to invoke with every item
   */
  forEachBetween(t, n, i) {
    let s = this._search(t), o = this._search(n);
    return s !== -1 && o !== -1 ? (this._timeline[s].time !== t && (s += 1), this._timeline[o].time === n && (o -= 1), this._iterate(i, s, o)) : s === -1 && this._iterate(i, 0, o), this;
  }
  /**
   * Iterate over everything in the array at or after the given time. Similar to
   * forEachAfter, but includes the item(s) at the given time.
   * @param  time The time to check if items are before
   * @param  callback The callback to invoke with every item
   */
  forEachFrom(t, n) {
    let i = this._search(t);
    for (; i >= 0 && this._timeline[i].time >= t; )
      i--;
    return this._iterate(n, i + 1), this;
  }
  /**
   * Iterate over everything in the array at the given time
   * @param  time The time to check if items are before
   * @param  callback The callback to invoke with every item
   */
  forEachAtTime(t, n) {
    const i = this._search(t);
    if (i !== -1 && bl(this._timeline[i].time, t)) {
      let s = i;
      for (let o = i; o >= 0 && bl(this._timeline[o].time, t); o--)
        s = o;
      this._iterate((o) => {
        n(o);
      }, s, i);
    }
    return this;
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this._timeline = [], this;
  }
};
const A6 = [];
function tv(e) {
  A6.push(e);
}
function OP(e) {
  A6.forEach((t) => t(e));
}
const M6 = [];
function ev(e) {
  M6.push(e);
}
function NP(e) {
  M6.forEach((t) => t(e));
}
class t0 extends Vu {
  constructor() {
    super(...arguments), this.name = "Emitter";
  }
  /**
   * Bind a callback to a specific event.
   * @param  event     The name of the event to listen for.
   * @param  callback  The callback to invoke when the event is emitted
   */
  on(t, n) {
    return t.split(/\W+/).forEach((s) => {
      $s(this._events) && (this._events = {}), this._events.hasOwnProperty(s) || (this._events[s] = []), this._events[s].push(n);
    }), this;
  }
  /**
   * Bind a callback which is only invoked once
   * @param  event     The name of the event to listen for.
   * @param  callback  The callback to invoke when the event is emitted
   */
  once(t, n) {
    const i = (...s) => {
      n(...s), this.off(t, i);
    };
    return this.on(t, i), this;
  }
  /**
   * Remove the event listener.
   * @param  event     The event to stop listening to.
   * @param  callback  The callback which was bound to the event with Emitter.on.
   *                   If no callback is given, all callbacks events are removed.
   */
  off(t, n) {
    return t.split(/\W+/).forEach((s) => {
      if ($s(this._events) && (this._events = {}), this._events.hasOwnProperty(s))
        if ($s(n))
          this._events[s] = [];
        else {
          const o = this._events[s];
          for (let u = o.length - 1; u >= 0; u--)
            o[u] === n && o.splice(u, 1);
        }
    }), this;
  }
  /**
   * Invoke all of the callbacks bound to the event
   * with any arguments passed in.
   * @param  event  The name of the event.
   * @param args The arguments to pass to the functions listening.
   */
  emit(t, ...n) {
    if (this._events && this._events.hasOwnProperty(t)) {
      const i = this._events[t].slice(0);
      for (let s = 0, o = i.length; s < o; s++)
        i[s].apply(this, n);
    }
    return this;
  }
  /**
   * Add Emitter functions (on/off/emit) to the object
   */
  static mixin(t) {
    ["on", "once", "off", "emit"].forEach((n) => {
      const i = Object.getOwnPropertyDescriptor(t0.prototype, n);
      Object.defineProperty(t.prototype, n, i);
    });
  }
  /**
   * Clean up
   */
  dispose() {
    return super.dispose(), this._events = void 0, this;
  }
}
class R6 extends t0 {
  constructor() {
    super(...arguments), this.isOffline = !1;
  }
  /*
   * This is a placeholder so that JSON.stringify does not throw an error
   * This matches what JSON.stringify(audioContext) returns on a native
   * audioContext instance.
   */
  toJSON() {
    return {};
  }
}
let w_ = class O6 extends R6 {
  constructor() {
    var t, n;
    super(), this.name = "Context", this._constants = /* @__PURE__ */ new Map(), this._timeouts = new Ac(), this._timeoutIds = 0, this._initialized = !1, this._closeStarted = !1, this.isOffline = !1, this._workletPromise = null;
    const i = on(O6.getDefaults(), arguments, [
      "context"
    ]);
    i.context ? (this._context = i.context, this._latencyHint = ((t = arguments[0]) === null || t === void 0 ? void 0 : t.latencyHint) || "") : (this._context = _P({
      latencyHint: i.latencyHint
    }), this._latencyHint = i.latencyHint), this._ticker = new CP(this.emit.bind(this, "tick"), i.clockSource, i.updateInterval, this._context.sampleRate), this.on("tick", this._timeoutLoop.bind(this)), this._context.onstatechange = () => {
      this.emit("statechange", this.state);
    }, this[!((n = arguments[0]) === null || n === void 0) && n.hasOwnProperty("updateInterval") ? "_lookAhead" : "lookAhead"] = i.lookAhead;
  }
  static getDefaults() {
    return {
      clockSource: "worker",
      latencyHint: "interactive",
      lookAhead: 0.1,
      updateInterval: 0.05
    };
  }
  /**
   * Finish setting up the context. **You usually do not need to do this manually.**
   */
  initialize() {
    return this._initialized || (OP(this), this._initialized = !0), this;
  }
  //---------------------------
  // BASE AUDIO CONTEXT METHODS
  //---------------------------
  createAnalyser() {
    return this._context.createAnalyser();
  }
  createOscillator() {
    return this._context.createOscillator();
  }
  createBufferSource() {
    return this._context.createBufferSource();
  }
  createBiquadFilter() {
    return this._context.createBiquadFilter();
  }
  createBuffer(t, n, i) {
    return this._context.createBuffer(t, n, i);
  }
  createChannelMerger(t) {
    return this._context.createChannelMerger(t);
  }
  createChannelSplitter(t) {
    return this._context.createChannelSplitter(t);
  }
  createConstantSource() {
    return this._context.createConstantSource();
  }
  createConvolver() {
    return this._context.createConvolver();
  }
  createDelay(t) {
    return this._context.createDelay(t);
  }
  createDynamicsCompressor() {
    return this._context.createDynamicsCompressor();
  }
  createGain() {
    return this._context.createGain();
  }
  createIIRFilter(t, n) {
    return this._context.createIIRFilter(t, n);
  }
  createPanner() {
    return this._context.createPanner();
  }
  createPeriodicWave(t, n, i) {
    return this._context.createPeriodicWave(t, n, i);
  }
  createStereoPanner() {
    return this._context.createStereoPanner();
  }
  createWaveShaper() {
    return this._context.createWaveShaper();
  }
  createMediaStreamSource(t) {
    return nn(Pf(this._context), "Not available if OfflineAudioContext"), this._context.createMediaStreamSource(t);
  }
  createMediaElementSource(t) {
    return nn(Pf(this._context), "Not available if OfflineAudioContext"), this._context.createMediaElementSource(t);
  }
  createMediaStreamDestination() {
    return nn(Pf(this._context), "Not available if OfflineAudioContext"), this._context.createMediaStreamDestination();
  }
  decodeAudioData(t) {
    return this._context.decodeAudioData(t);
  }
  /**
   * The current time in seconds of the AudioContext.
   */
  get currentTime() {
    return this._context.currentTime;
  }
  /**
   * The current time in seconds of the AudioContext.
   */
  get state() {
    return this._context.state;
  }
  /**
   * The current time in seconds of the AudioContext.
   */
  get sampleRate() {
    return this._context.sampleRate;
  }
  /**
   * The listener
   */
  get listener() {
    return this.initialize(), this._listener;
  }
  set listener(t) {
    nn(!this._initialized, "The listener cannot be set after initialization."), this._listener = t;
  }
  /**
   * There is only one Transport per Context. It is created on initialization.
   */
  get transport() {
    return this.initialize(), this._transport;
  }
  set transport(t) {
    nn(!this._initialized, "The transport cannot be set after initialization."), this._transport = t;
  }
  /**
   * This is the Draw object for the context which is useful for synchronizing the draw frame with the Tone.js clock.
   */
  get draw() {
    return this.initialize(), this._draw;
  }
  set draw(t) {
    nn(!this._initialized, "Draw cannot be set after initialization."), this._draw = t;
  }
  /**
   * A reference to the Context's destination node.
   */
  get destination() {
    return this.initialize(), this._destination;
  }
  set destination(t) {
    nn(!this._initialized, "The destination cannot be set after initialization."), this._destination = t;
  }
  /**
   * Create an audio worklet node from a name and options. The module
   * must first be loaded using {@link addAudioWorkletModule}.
   */
  createAudioWorkletNode(t, n) {
    return TP(this.rawContext, t, n);
  }
  /**
   * Add an AudioWorkletProcessor module
   * @param url The url of the module
   */
  addAudioWorkletModule(t) {
    return Nr(this, void 0, void 0, function* () {
      nn(_n(this.rawContext.audioWorklet), "AudioWorkletNode is only available in a secure context (https or localhost)"), this._workletPromise || (this._workletPromise = this.rawContext.audioWorklet.addModule(t)), yield this._workletPromise;
    });
  }
  /**
   * Returns a promise which resolves when all of the worklets have been loaded on this context
   */
  workletsAreReady() {
    return Nr(this, void 0, void 0, function* () {
      (yield this._workletPromise) ? this._workletPromise : Promise.resolve();
    });
  }
  //---------------------------
  // TICKER
  //---------------------------
  /**
   * How often the interval callback is invoked.
   * This number corresponds to how responsive the scheduling
   * can be. Setting to 0 will result in the lowest practial interval
   * based on context properties. context.updateInterval + context.lookAhead
   * gives you the total latency between scheduling an event and hearing it.
   */
  get updateInterval() {
    return this._ticker.updateInterval;
  }
  set updateInterval(t) {
    this._ticker.updateInterval = t;
  }
  /**
   * What the source of the clock is, either "worker" (default),
   * "timeout", or "offline" (none).
   */
  get clockSource() {
    return this._ticker.type;
  }
  set clockSource(t) {
    this._ticker.type = t;
  }
  /**
   * The amount of time into the future events are scheduled. Giving Web Audio
   * a short amount of time into the future to schedule events can reduce clicks and
   * improve performance. This value can be set to 0 to get the lowest latency.
   * Adjusting this value also affects the {@link updateInterval}.
   */
  get lookAhead() {
    return this._lookAhead;
  }
  set lookAhead(t) {
    this._lookAhead = t, this.updateInterval = t ? t / 2 : 0.01;
  }
  /**
   * The type of playback, which affects tradeoffs between audio
   * output latency and responsiveness.
   * In addition to setting the value in seconds, the latencyHint also
   * accepts the strings "interactive" (prioritizes low latency),
   * "playback" (prioritizes sustained playback), "balanced" (balances
   * latency and performance).
   * @example
   * // prioritize sustained playback
   * const context = new Tone.Context({ latencyHint: "playback" });
   * // set this context as the global Context
   * Tone.setContext(context);
   * // the global context is gettable with Tone.getContext()
   * console.log(Tone.getContext().latencyHint);
   */
  get latencyHint() {
    return this._latencyHint;
  }
  /**
   * The unwrapped AudioContext or OfflineAudioContext
   */
  get rawContext() {
    return this._context;
  }
  /**
   * The current audio context time plus a short {@link lookAhead}.
   * @example
   * setInterval(() => {
   * 	console.log("now", Tone.now());
   * }, 100);
   */
  now() {
    return this._context.currentTime + this._lookAhead;
  }
  /**
   * The current audio context time without the {@link lookAhead}.
   * In most cases it is better to use {@link now} instead of {@link immediate} since
   * with {@link now} the {@link lookAhead} is applied equally to _all_ components including internal components,
   * to making sure that everything is scheduled in sync. Mixing {@link now} and {@link immediate}
   * can cause some timing issues. If no lookAhead is desired, you can set the {@link lookAhead} to `0`.
   */
  immediate() {
    return this._context.currentTime;
  }
  /**
   * Starts the audio context from a suspended state. This is required
   * to initially start the AudioContext.
   * @see {@link start}
   */
  resume() {
    return Pf(this._context) ? this._context.resume() : Promise.resolve();
  }
  /**
   * Close the context. Once closed, the context can no longer be used and
   * any AudioNodes created from the context will be silent.
   */
  close() {
    return Nr(this, void 0, void 0, function* () {
      Pf(this._context) && this.state !== "closed" && !this._closeStarted && (this._closeStarted = !0, yield this._context.close()), this._initialized && NP(this);
    });
  }
  /**
   * **Internal** Generate a looped buffer at some constant value.
   */
  getConstant(t) {
    if (this._constants.has(t))
      return this._constants.get(t);
    {
      const n = this._context.createBuffer(1, 128, this._context.sampleRate), i = n.getChannelData(0);
      for (let o = 0; o < i.length; o++)
        i[o] = t;
      const s = this._context.createBufferSource();
      return s.channelCount = 1, s.channelCountMode = "explicit", s.buffer = n, s.loop = !0, s.start(0), this._constants.set(t, s), s;
    }
  }
  /**
   * Clean up. Also closes the audio context.
   */
  dispose() {
    return super.dispose(), this._ticker.dispose(), this._timeouts.dispose(), Object.keys(this._constants).map((t) => this._constants[t].disconnect()), this.close(), this;
  }
  //---------------------------
  // TIMEOUTS
  //---------------------------
  /**
   * The private loop which keeps track of the context scheduled timeouts
   * Is invoked from the clock source
   */
  _timeoutLoop() {
    const t = this.now();
    let n = this._timeouts.peek();
    for (; this._timeouts.length && n && n.time <= t; )
      n.callback(), this._timeouts.shift(), n = this._timeouts.peek();
  }
  /**
   * A setTimeout which is guaranteed by the clock source.
   * Also runs in the offline context.
   * @param  fn       The callback to invoke
   * @param  timeout  The timeout in seconds
   * @returns ID to use when invoking Context.clearTimeout
   */
  setTimeout(t, n) {
    this._timeoutIds++;
    const i = this.now();
    return this._timeouts.add({
      callback: t,
      id: this._timeoutIds,
      time: i + n
    }), this._timeoutIds;
  }
  /**
   * Clears a previously scheduled timeout with Tone.context.setTimeout
   * @param  id  The ID returned from setTimeout
   */
  clearTimeout(t) {
    return this._timeouts.forEach((n) => {
      n.id === t && this._timeouts.remove(n);
    }), this;
  }
  /**
   * Clear the function scheduled by {@link setInterval}
   */
  clearInterval(t) {
    return this.clearTimeout(t);
  }
  /**
   * Adds a repeating event to the context's callback clock
   */
  setInterval(t, n) {
    const i = ++this._timeoutIds, s = () => {
      const o = this.now();
      this._timeouts.add({
        callback: () => {
          t(), s();
        },
        id: i,
        time: o + n
      });
    };
    return s(), i;
  }
};
class kP extends R6 {
  constructor() {
    super(...arguments), this.lookAhead = 0, this.latencyHint = 0, this.isOffline = !1;
  }
  //---------------------------
  // BASE AUDIO CONTEXT METHODS
  //---------------------------
  createAnalyser() {
    return {};
  }
  createOscillator() {
    return {};
  }
  createBufferSource() {
    return {};
  }
  createBiquadFilter() {
    return {};
  }
  createBuffer(t, n, i) {
    return {};
  }
  createChannelMerger(t) {
    return {};
  }
  createChannelSplitter(t) {
    return {};
  }
  createConstantSource() {
    return {};
  }
  createConvolver() {
    return {};
  }
  createDelay(t) {
    return {};
  }
  createDynamicsCompressor() {
    return {};
  }
  createGain() {
    return {};
  }
  createIIRFilter(t, n) {
    return {};
  }
  createPanner() {
    return {};
  }
  createPeriodicWave(t, n, i) {
    return {};
  }
  createStereoPanner() {
    return {};
  }
  createWaveShaper() {
    return {};
  }
  createMediaStreamSource(t) {
    return {};
  }
  createMediaElementSource(t) {
    return {};
  }
  createMediaStreamDestination() {
    return {};
  }
  decodeAudioData(t) {
    return Promise.resolve({});
  }
  //---------------------------
  // TONE AUDIO CONTEXT METHODS
  //---------------------------
  createAudioWorkletNode(t, n) {
    return {};
  }
  get rawContext() {
    return {};
  }
  addAudioWorkletModule(t) {
    return Nr(this, void 0, void 0, function* () {
      return Promise.resolve();
    });
  }
  resume() {
    return Promise.resolve();
  }
  setTimeout(t, n) {
    return 0;
  }
  clearTimeout(t) {
    return this;
  }
  setInterval(t, n) {
    return 0;
  }
  clearInterval(t) {
    return this;
  }
  getConstant(t) {
    return {};
  }
  get currentTime() {
    return 0;
  }
  get state() {
    return {};
  }
  get sampleRate() {
    return 0;
  }
  get listener() {
    return {};
  }
  get transport() {
    return {};
  }
  get draw() {
    return {};
  }
  set draw(t) {
  }
  get destination() {
    return {};
  }
  set destination(t) {
  }
  now() {
    return 0;
  }
  immediate() {
    return 0;
  }
}
function or(e, t) {
  Ts(t) ? t.forEach((n) => or(e, n)) : Object.defineProperty(e, t, {
    enumerable: !0,
    writable: !1
  });
}
function N6(e, t) {
  Ts(t) ? t.forEach((n) => N6(e, n)) : Object.defineProperty(e, t, {
    writable: !0
  });
}
const ei = () => {
};
class Si extends Vu {
  constructor() {
    super(), this.name = "ToneAudioBuffer", this.onload = ei;
    const t = on(Si.getDefaults(), arguments, ["url", "onload", "onerror"]);
    this.reverse = t.reverse, this.onload = t.onload, ju(t.url) ? this.load(t.url).catch(t.onerror) : t.url && this.set(t.url);
  }
  static getDefaults() {
    return {
      onerror: ei,
      onload: ei,
      reverse: !1
    };
  }
  /**
   * The sample rate of the AudioBuffer
   */
  get sampleRate() {
    return this._buffer ? this._buffer.sampleRate : Za().sampleRate;
  }
  /**
   * Pass in an AudioBuffer or ToneAudioBuffer to set the value of this buffer.
   */
  set(t) {
    return t instanceof Si ? t.loaded ? this._buffer = t.get() : t.onload = () => {
      this.set(t), this.onload(this);
    } : this._buffer = t, this._reversed && this._reverse(), this;
  }
  /**
   * The audio buffer stored in the object.
   */
  get() {
    return this._buffer;
  }
  /**
   * Makes an fetch request for the selected url then decodes the file as an audio buffer.
   * Invokes the callback once the audio buffer loads.
   * @param url The url of the buffer to load. filetype support depends on the browser.
   * @returns A Promise which resolves with this ToneAudioBuffer
   */
  load(t) {
    return Nr(this, void 0, void 0, function* () {
      const n = Si.load(t).then((i) => {
        this.set(i), this.onload(this);
      });
      Si.downloads.push(n);
      try {
        yield n;
      } finally {
        const i = Si.downloads.indexOf(n);
        Si.downloads.splice(i, 1);
      }
      return this;
    });
  }
  /**
   * clean up
   */
  dispose() {
    return super.dispose(), this._buffer = void 0, this;
  }
  /**
   * Set the audio buffer from the array.
   * To create a multichannel AudioBuffer, pass in a multidimensional array.
   * @param array The array to fill the audio buffer
   */
  fromArray(t) {
    const n = Ts(t) && t[0].length > 0, i = n ? t.length : 1, s = n ? t[0].length : t.length, o = Za(), u = o.createBuffer(i, s, o.sampleRate), h = !n && i === 1 ? [t] : t;
    for (let f = 0; f < i; f++)
      u.copyToChannel(h[f], f);
    return this._buffer = u, this;
  }
  /**
   * Sums multiple channels into 1 channel
   * @param chanNum Optionally only copy a single channel from the array.
   */
  toMono(t) {
    if (Oc(t))
      this.fromArray(this.toArray(t));
    else {
      let n = new Float32Array(this.length);
      const i = this.numberOfChannels;
      for (let s = 0; s < i; s++) {
        const o = this.toArray(s);
        for (let u = 0; u < o.length; u++)
          n[u] += o[u];
      }
      n = n.map((s) => s / i), this.fromArray(n);
    }
    return this;
  }
  /**
   * Get the buffer as an array. Single channel buffers will return a 1-dimensional
   * Float32Array, and multichannel buffers will return multidimensional arrays.
   * @param channel Optionally only copy a single channel from the array.
   */
  toArray(t) {
    if (Oc(t))
      return this.getChannelData(t);
    if (this.numberOfChannels === 1)
      return this.toArray(0);
    {
      const n = [];
      for (let i = 0; i < this.numberOfChannels; i++)
        n[i] = this.getChannelData(i);
      return n;
    }
  }
  /**
   * Returns the Float32Array representing the PCM audio data for the specific channel.
   * @param  channel  The channel number to return
   * @return The audio as a TypedArray
   */
  getChannelData(t) {
    return this._buffer ? this._buffer.getChannelData(t) : new Float32Array(0);
  }
  /**
   * Cut a subsection of the array and return a buffer of the
   * subsection. Does not modify the original buffer
   * @param start The time to start the slice
   * @param end The end time to slice. If none is given will default to the end of the buffer
   */
  slice(t, n = this.duration) {
    nn(this.loaded, "Buffer is not loaded");
    const i = Math.floor(t * this.sampleRate), s = Math.floor(n * this.sampleRate);
    nn(i < s, "The start time must be less than the end time");
    const o = s - i, u = Za().createBuffer(this.numberOfChannels, o, this.sampleRate);
    for (let h = 0; h < this.numberOfChannels; h++)
      u.copyToChannel(this.getChannelData(h).subarray(i, s), h);
    return new Si(u);
  }
  /**
   * Reverse the buffer.
   */
  _reverse() {
    if (this.loaded)
      for (let t = 0; t < this.numberOfChannels; t++)
        this.getChannelData(t).reverse();
    return this;
  }
  /**
   * If the buffer is loaded or not
   */
  get loaded() {
    return this.length > 0;
  }
  /**
   * The duration of the buffer in seconds.
   */
  get duration() {
    return this._buffer ? this._buffer.duration : 0;
  }
  /**
   * The length of the buffer in samples
   */
  get length() {
    return this._buffer ? this._buffer.length : 0;
  }
  /**
   * The number of discrete audio channels. Returns 0 if no buffer is loaded.
   */
  get numberOfChannels() {
    return this._buffer ? this._buffer.numberOfChannels : 0;
  }
  /**
   * Reverse the buffer.
   */
  get reverse() {
    return this._reversed;
  }
  set reverse(t) {
    this._reversed !== t && (this._reversed = t, this._reverse());
  }
  /**
   * Create a ToneAudioBuffer from the array. To create a multichannel AudioBuffer,
   * pass in a multidimensional array.
   * @param array The array to fill the audio buffer
   * @return A ToneAudioBuffer created from the array
   */
  static fromArray(t) {
    return new Si().fromArray(t);
  }
  /**
   * Creates a ToneAudioBuffer from a URL, returns a promise which resolves to a ToneAudioBuffer
   * @param  url The url to load.
   * @return A promise which resolves to a ToneAudioBuffer
   */
  static fromUrl(t) {
    return Nr(this, void 0, void 0, function* () {
      return yield new Si().load(t);
    });
  }
  /**
   * Loads a url using fetch and returns the AudioBuffer.
   */
  static load(t) {
    return Nr(this, void 0, void 0, function* () {
      const n = t.match(/\[([^\]\[]+\|.+)\]$/);
      if (n) {
        const f = n[1].split("|");
        let p = f[0];
        for (const g of f)
          if (Si.supportsType(g)) {
            p = g;
            break;
          }
        t = t.replace(n[0], p);
      }
      const i = Si.baseUrl === "" || Si.baseUrl.endsWith("/") ? Si.baseUrl : Si.baseUrl + "/", s = document.createElement("a");
      s.href = i + t, s.pathname = (s.pathname + s.hash).split("/").map(encodeURIComponent).join("/");
      const o = yield fetch(s.href);
      if (!o.ok)
        throw new Error(`could not load url: ${t}`);
      const u = yield o.arrayBuffer();
      return yield Za().decodeAudioData(u);
    });
  }
  /**
   * Checks a url's extension to see if the current browser can play that file type.
   * @param url The url/extension to test
   * @return If the file extension can be played
   * @static
   * @example
   * Tone.ToneAudioBuffer.supportsType("wav"); // returns true
   * Tone.ToneAudioBuffer.supportsType("path/to/file.wav"); // returns true
   */
  static supportsType(t) {
    const n = t.split("."), i = n[n.length - 1];
    return document.createElement("audio").canPlayType("audio/" + i) !== "";
  }
  /**
   * Returns a Promise which resolves when all of the buffers have loaded
   */
  static loaded() {
    return Nr(this, void 0, void 0, function* () {
      for (yield Promise.resolve(); Si.downloads.length; )
        yield Si.downloads[0];
    });
  }
}
Si.baseUrl = "";
Si.downloads = [];
class E_ extends w_ {
  constructor() {
    super({
      clockSource: "offline",
      context: Ky(arguments[0]) ? arguments[0] : SP(arguments[0], arguments[1] * arguments[2], arguments[2]),
      lookAhead: 0,
      updateInterval: Ky(arguments[0]) ? 128 / arguments[0].sampleRate : 128 / arguments[2]
    }), this.name = "OfflineContext", this._currentTime = 0, this.isOffline = !0, this._duration = Ky(arguments[0]) ? arguments[0].length / arguments[0].sampleRate : arguments[1];
  }
  /**
   * Override the now method to point to the internal clock time
   */
  now() {
    return this._currentTime;
  }
  /**
   * Same as this.now()
   */
  get currentTime() {
    return this._currentTime;
  }
  /**
   * Render just the clock portion of the audio context.
   */
  _renderClock(t) {
    return Nr(this, void 0, void 0, function* () {
      let n = 0;
      for (; this._duration - this._currentTime >= 0; ) {
        this.emit("tick"), this._currentTime += 128 / this.sampleRate, n++;
        const i = Math.floor(this.sampleRate / 128);
        t && n % i === 0 && (yield new Promise((s) => setTimeout(s, 1)));
      }
    });
  }
  /**
   * Render the output of the OfflineContext
   * @param asynchronous If the clock should be rendered asynchronously, which will not block the main thread, but be slightly slower.
   */
  render() {
    return Nr(this, arguments, void 0, function* (t = !0) {
      yield this.workletsAreReady(), yield this._renderClock(t);
      const n = yield this._context.startRendering();
      return new Si(n);
    });
  }
  /**
   * Close the context
   */
  close() {
    return Promise.resolve();
  }
}
const k6 = new kP();
let Oh = k6;
function Za() {
  return Oh === k6 && xP && DP(new w_()), Oh;
}
function DP(e, t = !1) {
  t && Oh.dispose(), Pf(e) ? Oh = new w_(e) : Ky(e) ? Oh = new E_(e) : Oh = e;
}
function D6() {
  return Oh.resume();
}
if (Ys && !Ys.TONE_SILENCE_LOGGING) {
  const t = ` * Tone.js v${RT} * `;
  console.log(`%c${t}`, "background: #000; color: #fff");
}
function BP(e) {
  return Math.pow(10, e / 20);
}
function zP(e) {
  return 20 * (Math.log(e) / Math.LN10);
}
function B6(e) {
  return Math.pow(2, e / 12);
}
let nv = 440;
function PP() {
  return nv;
}
function UP(e) {
  nv = e;
}
function Nh(e) {
  return Math.round(z6(e));
}
function z6(e) {
  return 69 + 12 * Math.log2(e / nv);
}
function P6(e) {
  return nv * Math.pow(2, (e - 69) / 12);
}
class A_ extends Vu {
  /**
   * @param context The context associated with the time value. Used to compute
   * Transport and context-relative timing.
   * @param  value  The time value as a number, string or object
   * @param  units  Unit values
   */
  constructor(t, n, i) {
    super(), this.defaultUnits = "s", this._val = n, this._units = i, this.context = t, this._expressions = this._getExpressions();
  }
  /**
   * All of the time encoding expressions
   */
  _getExpressions() {
    return {
      hz: {
        method: (t) => this._frequencyToUnits(parseFloat(t)),
        regexp: /^(\d+(?:\.\d+)?)hz$/i
      },
      i: {
        method: (t) => this._ticksToUnits(parseInt(t, 10)),
        regexp: /^(\d+)i$/i
      },
      m: {
        method: (t) => this._beatsToUnits(parseInt(t, 10) * this._getTimeSignature()),
        regexp: /^(\d+)m$/i
      },
      n: {
        method: (t, n) => {
          const i = parseInt(t, 10), s = n === "." ? 1.5 : 1;
          return i === 1 ? this._beatsToUnits(this._getTimeSignature()) * s : this._beatsToUnits(4 / i) * s;
        },
        regexp: /^(\d+)n(\.?)$/i
      },
      number: {
        method: (t) => this._expressions[this.defaultUnits].method.call(this, t),
        regexp: /^(\d+(?:\.\d+)?)$/
      },
      s: {
        method: (t) => this._secondsToUnits(parseFloat(t)),
        regexp: /^(\d+(?:\.\d+)?)s$/
      },
      samples: {
        method: (t) => parseInt(t, 10) / this.context.sampleRate,
        regexp: /^(\d+)samples$/
      },
      t: {
        method: (t) => {
          const n = parseInt(t, 10);
          return this._beatsToUnits(8 / (Math.floor(n) * 3));
        },
        regexp: /^(\d+)t$/i
      },
      tr: {
        method: (t, n, i) => {
          let s = 0;
          return t && t !== "0" && (s += this._beatsToUnits(this._getTimeSignature() * parseFloat(t))), n && n !== "0" && (s += this._beatsToUnits(parseFloat(n))), i && i !== "0" && (s += this._beatsToUnits(parseFloat(i) / 4)), s;
        },
        regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?$/
      }
    };
  }
  //-------------------------------------
  // 	VALUE OF
  //-------------------------------------
  /**
   * Evaluate the time value. Returns the time in seconds.
   */
  valueOf() {
    if (this._val instanceof A_ && this.fromType(this._val), $s(this._val))
      return this._noArg();
    if (ju(this._val) && $s(this._units)) {
      for (const t in this._expressions)
        if (this._expressions[t].regexp.test(this._val.trim())) {
          this._units = t;
          break;
        }
    } else if (Dd(this._val)) {
      let t = 0;
      for (const n in this._val)
        if (_n(this._val[n])) {
          const i = this._val[n], s = (
            // @ts-ignore
            new this.constructor(this.context, n).valueOf() * i
          );
          t += s;
        }
      return t;
    }
    if (_n(this._units)) {
      const t = this._expressions[this._units], n = this._val.toString().trim().match(t.regexp);
      return n ? t.method.apply(this, n.slice(1)) : t.method.call(this, this._val);
    } else return ju(this._val) ? parseFloat(this._val) : this._val;
  }
  //-------------------------------------
  // 	UNIT CONVERSIONS
  //-------------------------------------
  /**
   * Returns the value of a frequency in the current units
   */
  _frequencyToUnits(t) {
    return 1 / t;
  }
  /**
   * Return the value of the beats in the current units
   */
  _beatsToUnits(t) {
    return 60 / this._getBpm() * t;
  }
  /**
   * Returns the value of a second in the current units
   */
  _secondsToUnits(t) {
    return t;
  }
  /**
   * Returns the value of a tick in the current time units
   */
  _ticksToUnits(t) {
    return t * this._beatsToUnits(1) / this._getPPQ();
  }
  /**
   * With no arguments, return 'now'
   */
  _noArg() {
    return this._now();
  }
  //-------------------------------------
  // 	TEMPO CONVERSIONS
  //-------------------------------------
  /**
   * Return the bpm
   */
  _getBpm() {
    return this.context.transport.bpm.value;
  }
  /**
   * Return the timeSignature
   */
  _getTimeSignature() {
    return this.context.transport.timeSignature;
  }
  /**
   * Return the PPQ or 192 if Transport is not available
   */
  _getPPQ() {
    return this.context.transport.PPQ;
  }
  //-------------------------------------
  // 	CONVERSION INTERFACE
  //-------------------------------------
  /**
   * Coerce a time type into this units type.
   * @param type Any time type units
   */
  fromType(t) {
    switch (this._units = void 0, this.defaultUnits) {
      case "s":
        this._val = t.toSeconds();
        break;
      case "i":
        this._val = t.toTicks();
        break;
      case "hz":
        this._val = t.toFrequency();
        break;
      case "midi":
        this._val = t.toMidi();
        break;
    }
    return this;
  }
  /**
   * Return the value in hertz
   */
  toFrequency() {
    return 1 / this.toSeconds();
  }
  /**
   * Return the time in samples
   */
  toSamples() {
    return this.toSeconds() * this.context.sampleRate;
  }
  /**
   * Return the time in milliseconds.
   */
  toMilliseconds() {
    return this.toSeconds() * 1e3;
  }
}
class _l extends A_ {
  constructor() {
    super(...arguments), this.name = "TimeClass";
  }
  _getExpressions() {
    return Object.assign(super._getExpressions(), {
      now: {
        method: (t) => this._now() + new this.constructor(this.context, t).valueOf(),
        regexp: /^\+(.+)/
      },
      quantize: {
        method: (t) => {
          const n = new _l(this.context, t).valueOf();
          return this._secondsToUnits(this.context.transport.nextSubdivision(n));
        },
        regexp: /^@(.+)/
      }
    });
  }
  /**
   * Quantize the time by the given subdivision. Optionally add a
   * percentage which will move the time value towards the ideal
   * quantized value by that percentage.
   * @param  subdiv    The subdivision to quantize to
   * @param  percent  Move the time value towards the quantized value by a percentage.
   * @example
   * Tone.Time(21).quantize(2); // returns 22
   * Tone.Time(0.6).quantize("4n", 0.5); // returns 0.55
   */
  quantize(t, n = 1) {
    const i = new this.constructor(this.context, t).valueOf(), s = this.valueOf(), h = Math.round(s / i) * i - s;
    return s + h * n;
  }
  //-------------------------------------
  // CONVERSIONS
  //-------------------------------------
  /**
   * Convert a Time to Notation. The notation values are will be the
   * closest representation between 1m to 128th note.
   * @return {Notation}
   * @example
   * // if the Transport is at 120bpm:
   * Tone.Time(2).toNotation(); // returns "1m"
   */
  toNotation() {
    const t = this.toSeconds(), n = ["1m"];
    for (let o = 1; o < 9; o++) {
      const u = Math.pow(2, o);
      n.push(u + "n."), n.push(u + "n"), n.push(u + "t");
    }
    n.push("0");
    let i = n[0], s = new _l(this.context, n[0]).toSeconds();
    return n.forEach((o) => {
      const u = new _l(this.context, o).toSeconds();
      Math.abs(u - t) < Math.abs(s - t) && (i = o, s = u);
    }), i;
  }
  /**
   * Return the time encoded as Bars:Beats:Sixteenths.
   */
  toBarsBeatsSixteenths() {
    const t = this._beatsToUnits(1);
    let n = this.valueOf() / t;
    n = parseFloat(n.toFixed(4));
    const i = Math.floor(n / this._getTimeSignature());
    let s = n % 1 * 4;
    n = Math.floor(n) % this._getTimeSignature();
    const o = s.toString();
    return o.length > 3 && (s = parseFloat(parseFloat(o).toFixed(3))), [i, n, s].join(":");
  }
  /**
   * Return the time in ticks.
   */
  toTicks() {
    const t = this._beatsToUnits(1);
    return this.valueOf() / t * this._getPPQ();
  }
  /**
   * Return the time in seconds.
   */
  toSeconds() {
    return this.valueOf();
  }
  /**
   * Return the value as a midi note.
   */
  toMidi() {
    return Nh(this.toFrequency());
  }
  _now() {
    return this.context.now();
  }
}
class _s extends _l {
  constructor() {
    super(...arguments), this.name = "Frequency", this.defaultUnits = "hz";
  }
  /**
   * The [concert tuning pitch](https://en.wikipedia.org/wiki/Concert_pitch) which is used
   * to generate all the other pitch values from notes. A4's values in Hertz.
   */
  static get A4() {
    return PP();
  }
  static set A4(t) {
    UP(t);
  }
  //-------------------------------------
  // 	AUGMENT BASE EXPRESSIONS
  //-------------------------------------
  _getExpressions() {
    return Object.assign({}, super._getExpressions(), {
      midi: {
        regexp: /^(\d+(?:\.\d+)?midi)/,
        method(t) {
          return this.defaultUnits === "midi" ? t : _s.mtof(t);
        }
      },
      note: {
        regexp: /^([a-g]{1}(?:b|#|##|x|bb|###|#x|x#|bbb)?)(-?[0-9]+)/i,
        method(t, n) {
          const s = jP[t.toLowerCase()] + (parseInt(n, 10) + 1) * 12;
          return this.defaultUnits === "midi" ? s : _s.mtof(s);
        }
      },
      tr: {
        regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?/,
        method(t, n, i) {
          let s = 1;
          return t && t !== "0" && (s *= this._beatsToUnits(this._getTimeSignature() * parseFloat(t))), n && n !== "0" && (s *= this._beatsToUnits(parseFloat(n))), i && i !== "0" && (s *= this._beatsToUnits(parseFloat(i) / 4)), s;
        }
      }
    });
  }
  //-------------------------------------
  // 	EXPRESSIONS
  //-------------------------------------
  /**
   * Transposes the frequency by the given number of semitones.
   * @return  A new transposed frequency
   * @example
   * Tone.Frequency("A4").transpose(3); // "C5"
   */
  transpose(t) {
    return new _s(this.context, this.valueOf() * B6(t));
  }
  /**
   * Takes an array of semitone intervals and returns
   * an array of frequencies transposed by those intervals.
   * @return  Returns an array of Frequencies
   * @example
   * Tone.Frequency("A4").harmonize([0, 3, 7]); // ["A4", "C5", "E5"]
   */
  harmonize(t) {
    return t.map((n) => this.transpose(n));
  }
  //-------------------------------------
  // 	UNIT CONVERSIONS
  //-------------------------------------
  /**
   * Return the value of the frequency as a MIDI note
   * @example
   * Tone.Frequency("C4").toMidi(); // 60
   */
  toMidi() {
    return Nh(this.valueOf());
  }
  /**
   * Return the value of the frequency in Scientific Pitch Notation
   * @example
   * Tone.Frequency(69, "midi").toNote(); // "A4"
   */
  toNote() {
    const t = this.toFrequency(), n = Math.log2(t / _s.A4);
    let i = Math.round(12 * n) + 57;
    const s = Math.floor(i / 12);
    return s < 0 && (i += -12 * s), LP[i % 12] + s.toString();
  }
  /**
   * Return the duration of one cycle in seconds.
   */
  toSeconds() {
    return 1 / super.toSeconds();
  }
  /**
   * Return the duration of one cycle in ticks
   */
  toTicks() {
    const t = this._beatsToUnits(1), n = this.valueOf() / t;
    return Math.floor(n * this._getPPQ());
  }
  //-------------------------------------
  // 	UNIT CONVERSIONS HELPERS
  //-------------------------------------
  /**
   * With no arguments, return 0
   */
  _noArg() {
    return 0;
  }
  /**
   * Returns the value of a frequency in the current units
   */
  _frequencyToUnits(t) {
    return t;
  }
  /**
   * Returns the value of a tick in the current time units
   */
  _ticksToUnits(t) {
    return 1 / (t * 60 / (this._getBpm() * this._getPPQ()));
  }
  /**
   * Return the value of the beats in the current units
   */
  _beatsToUnits(t) {
    return 1 / super._beatsToUnits(t);
  }
  /**
   * Returns the value of a second in the current units
   */
  _secondsToUnits(t) {
    return 1 / t;
  }
  /**
   * Convert a MIDI note to frequency value.
   * @param  midi The midi number to convert.
   * @return The corresponding frequency value
   */
  static mtof(t) {
    return P6(t);
  }
  /**
   * Convert a frequency value to a MIDI note.
   * @param frequency The value to frequency value to convert.
   */
  static ftom(t) {
    return Nh(t);
  }
}
const jP = {
  cbbb: -3,
  cbb: -2,
  cb: -1,
  c: 0,
  "c#": 1,
  cx: 2,
  "c##": 2,
  "c###": 3,
  "cx#": 3,
  "c#x": 3,
  dbbb: -1,
  dbb: 0,
  db: 1,
  d: 2,
  "d#": 3,
  dx: 4,
  "d##": 4,
  "d###": 5,
  "dx#": 5,
  "d#x": 5,
  ebbb: 1,
  ebb: 2,
  eb: 3,
  e: 4,
  "e#": 5,
  ex: 6,
  "e##": 6,
  "e###": 7,
  "ex#": 7,
  "e#x": 7,
  fbbb: 2,
  fbb: 3,
  fb: 4,
  f: 5,
  "f#": 6,
  fx: 7,
  "f##": 7,
  "f###": 8,
  "fx#": 8,
  "f#x": 8,
  gbbb: 4,
  gbb: 5,
  gb: 6,
  g: 7,
  "g#": 8,
  gx: 9,
  "g##": 9,
  "g###": 10,
  "gx#": 10,
  "g#x": 10,
  abbb: 6,
  abb: 7,
  ab: 8,
  a: 9,
  "a#": 10,
  ax: 11,
  "a##": 11,
  "a###": 12,
  "ax#": 12,
  "a#x": 12,
  bbbb: 8,
  bbb: 9,
  bb: 10,
  b: 11,
  "b#": 12,
  bx: 13,
  "b##": 13,
  "b###": 14,
  "bx#": 14,
  "b#x": 14
}, LP = [
  "C",
  "C#",
  "D",
  "D#",
  "E",
  "F",
  "F#",
  "G",
  "G#",
  "A",
  "A#",
  "B"
];
function Rx(e, t) {
  return new _s(Za(), e, t);
}
class Hf extends _l {
  constructor() {
    super(...arguments), this.name = "TransportTime";
  }
  /**
   * Return the current time in whichever context is relevant
   */
  _now() {
    return this.context.transport.seconds;
  }
}
class ka extends Vu {
  constructor() {
    super();
    const t = on(ka.getDefaults(), arguments, ["context"]);
    this.defaultContext ? this.context = this.defaultContext : this.context = t.context;
  }
  static getDefaults() {
    return {
      context: Za()
    };
  }
  /**
   * Return the current time of the Context clock plus the lookAhead.
   * @example
   * setInterval(() => {
   * 	console.log(Tone.now());
   * }, 100);
   */
  now() {
    return this.context.currentTime + this.context.lookAhead;
  }
  /**
   * Return the current time of the Context clock without any lookAhead.
   * @example
   * setInterval(() => {
   * 	console.log(Tone.immediate());
   * }, 100);
   */
  immediate() {
    return this.context.currentTime;
  }
  /**
   * The duration in seconds of one sample.
   */
  get sampleTime() {
    return 1 / this.context.sampleRate;
  }
  /**
   * The number of seconds of 1 processing block (128 samples)
   * @example
   * console.log(Tone.Destination.blockTime);
   */
  get blockTime() {
    return 128 / this.context.sampleRate;
  }
  /**
   * Convert the incoming time to seconds.
   * This is calculated against the current {@link TransportClass} bpm
   * @example
   * const gain = new Tone.Gain();
   * setInterval(() => console.log(gain.toSeconds("4n")), 100);
   * // ramp the tempo to 60 bpm over 30 seconds
   * Tone.getTransport().bpm.rampTo(60, 30);
   */
  toSeconds(t) {
    return vP(t), new _l(this.context, t).toSeconds();
  }
  /**
   * Convert the input to a frequency number
   * @example
   * const gain = new Tone.Gain();
   * console.log(gain.toFrequency("4n"));
   */
  toFrequency(t) {
    return new _s(this.context, t).toFrequency();
  }
  /**
   * Convert the input time into ticks
   * @example
   * const gain = new Tone.Gain();
   * console.log(gain.toTicks("4n"));
   */
  toTicks(t) {
    return new Hf(this.context, t).toTicks();
  }
  //-------------------------------------
  // 	GET/SET
  //-------------------------------------
  /**
   * Get a subset of the properties which are in the partial props
   */
  _getPartialProperties(t) {
    const n = this.get();
    return Object.keys(n).forEach((i) => {
      $s(t[i]) && delete n[i];
    }), n;
  }
  /**
   * Get the object's attributes.
   * @example
   * const osc = new Tone.Oscillator();
   * console.log(osc.get());
   */
  get() {
    const t = MP(this);
    return Object.keys(t).forEach((n) => {
      if (Reflect.has(this, n)) {
        const i = this[n];
        _n(i) && _n(i.value) && _n(i.setValueAtTime) ? t[n] = i.value : i instanceof ka ? t[n] = i._getPartialProperties(t[n]) : Ts(i) || Oc(i) || ju(i) || x6(i) ? t[n] = i : delete t[n];
      }
    }), t;
  }
  /**
   * Set multiple properties at once with an object.
   * @example
   * const filter = new Tone.Filter().toDestination();
   * // set values using an object
   * filter.set({
   * 	frequency: "C6",
   * 	type: "highpass"
   * });
   * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/Analogsynth_octaves_highmid.mp3").connect(filter);
   * player.autostart = true;
   */
  set(t) {
    return Object.keys(t).forEach((n) => {
      Reflect.has(this, n) && _n(this[n]) && (this[n] && _n(this[n].value) && _n(this[n].setValueAtTime) ? this[n].value !== t[n] && (this[n].value = t[n]) : this[n] instanceof ka ? this[n].set(t[n]) : this[n] = t[n]);
    }), this;
  }
}
class e0 extends Ac {
  constructor(t = "stopped") {
    super(), this.name = "StateTimeline", this._initial = t, this.setStateAtTime(this._initial, 0);
  }
  /**
   * Returns the scheduled state scheduled before or at
   * the given time.
   * @param  time  The time to query.
   * @return  The name of the state input in setStateAtTime.
   */
  getValueAtTime(t) {
    const n = this.get(t);
    return n !== null ? n.state : this._initial;
  }
  /**
   * Add a state to the timeline.
   * @param  state The name of the state to set.
   * @param  time  The time to query.
   * @param options Any additional options that are needed in the timeline.
   */
  setStateAtTime(t, n, i) {
    return Ud(n, 0), this.add(Object.assign({}, i, {
      state: t,
      time: n
    })), this;
  }
  /**
   * Return the event before the time with the given state
   * @param  state The state to look for
   * @param  time  When to check before
   * @return  The event with the given state before the time
   */
  getLastState(t, n) {
    const i = this._search(n);
    for (let s = i; s >= 0; s--) {
      const o = this._timeline[s];
      if (o.state === t)
        return o;
    }
  }
  /**
   * Return the event after the time with the given state
   * @param  state The state to look for
   * @param  time  When to check from
   * @return  The event with the given state after the time
   */
  getNextState(t, n) {
    const i = this._search(n);
    if (i !== -1)
      for (let s = i; s < this._timeline.length; s++) {
        const o = this._timeline[s];
        if (o.state === t)
          return o;
      }
  }
}
class Yi extends ka {
  constructor() {
    const t = on(Yi.getDefaults(), arguments, [
      "param",
      "units",
      "convert"
    ]);
    for (super(t), this.name = "Param", this.overridden = !1, this._minOutput = 1e-7, nn(_n(t.param) && (Uh(t.param) || t.param instanceof Yi), "param must be an AudioParam"); !Uh(t.param); )
      t.param = t.param._param;
    this._swappable = _n(t.swappable) ? t.swappable : !1, this._swappable ? (this.input = this.context.createGain(), this._param = t.param, this.input.connect(this._param)) : this._param = this.input = t.param, this._events = new Ac(1e3), this._initialValue = this._param.defaultValue, this.units = t.units, this.convert = t.convert, this._minValue = t.minValue, this._maxValue = t.maxValue, _n(t.value) && t.value !== this._toType(this._initialValue) && this.setValueAtTime(t.value, 0);
  }
  static getDefaults() {
    return Object.assign(ka.getDefaults(), {
      convert: !0,
      units: "number"
    });
  }
  get value() {
    const t = this.now();
    return this.getValueAtTime(t);
  }
  set value(t) {
    this.cancelScheduledValues(this.now()), this.setValueAtTime(t, this.now());
  }
  get minValue() {
    return _n(this._minValue) ? this._minValue : this.units === "time" || this.units === "frequency" || this.units === "normalRange" || this.units === "positive" || this.units === "transportTime" || this.units === "ticks" || this.units === "bpm" || this.units === "hertz" || this.units === "samples" ? 0 : this.units === "audioRange" ? -1 : this.units === "decibels" ? -1 / 0 : this._param.minValue;
  }
  get maxValue() {
    return _n(this._maxValue) ? this._maxValue : this.units === "normalRange" || this.units === "audioRange" ? 1 : this._param.maxValue;
  }
  /**
   * Type guard based on the unit name
   */
  _is(t, n) {
    return this.units === n;
  }
  /**
   * Make sure the value is always in the defined range
   */
  _assertRange(t) {
    return _n(this.maxValue) && _n(this.minValue) && Ud(t, this._fromType(this.minValue), this._fromType(this.maxValue)), t;
  }
  /**
   * Convert the given value from the type specified by Param.units
   * into the destination value (such as Gain or Frequency).
   */
  _fromType(t) {
    return this.convert && !this.overridden ? this._is(t, "time") ? this.toSeconds(t) : this._is(t, "decibels") ? BP(t) : this._is(t, "frequency") ? this.toFrequency(t) : t : this.overridden ? 0 : t;
  }
  /**
   * Convert the parameters value into the units specified by Param.units.
   */
  _toType(t) {
    return this.convert && this.units === "decibels" ? zP(t) : t;
  }
  //-------------------------------------
  // ABSTRACT PARAM INTERFACE
  // all docs are generated from ParamInterface.ts
  //-------------------------------------
  setValueAtTime(t, n) {
    const i = this.toSeconds(n), s = this._fromType(t);
    return nn(isFinite(s) && isFinite(i), `Invalid argument(s) to setValueAtTime: ${JSON.stringify(t)}, ${JSON.stringify(n)}`), this._assertRange(s), this.log(this.units, "setValueAtTime", t, i), this._events.add({
      time: i,
      type: "setValueAtTime",
      value: s
    }), this._param.setValueAtTime(s, i), this;
  }
  getValueAtTime(t) {
    const n = Math.max(this.toSeconds(t), 0), i = this._events.getAfter(n), s = this._events.get(n);
    let o = this._initialValue;
    if (s === null)
      o = this._initialValue;
    else if (s.type === "setTargetAtTime" && (i === null || i.type === "setValueAtTime")) {
      const u = this._events.getBefore(s.time);
      let h;
      u === null ? h = this._initialValue : h = u.value, s.type === "setTargetAtTime" && (o = this._exponentialApproach(s.time, h, s.value, s.constant, n));
    } else if (i === null)
      o = s.value;
    else if (i.type === "linearRampToValueAtTime" || i.type === "exponentialRampToValueAtTime") {
      let u = s.value;
      if (s.type === "setTargetAtTime") {
        const h = this._events.getBefore(s.time);
        h === null ? u = this._initialValue : u = h.value;
      }
      i.type === "linearRampToValueAtTime" ? o = this._linearInterpolate(s.time, u, i.time, i.value, n) : o = this._exponentialInterpolate(s.time, u, i.time, i.value, n);
    } else
      o = s.value;
    return this._toType(o);
  }
  setRampPoint(t) {
    t = this.toSeconds(t);
    let n = this.getValueAtTime(t);
    return this.cancelAndHoldAtTime(t), this._fromType(n) === 0 && (n = this._toType(this._minOutput)), this.setValueAtTime(n, t), this;
  }
  linearRampToValueAtTime(t, n) {
    const i = this._fromType(t), s = this.toSeconds(n);
    return nn(isFinite(i) && isFinite(s), `Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(t)}, ${JSON.stringify(n)}`), this._assertRange(i), this._events.add({
      time: s,
      type: "linearRampToValueAtTime",
      value: i
    }), this.log(this.units, "linearRampToValueAtTime", t, s), this._param.linearRampToValueAtTime(i, s), this;
  }
  exponentialRampToValueAtTime(t, n) {
    let i = this._fromType(t);
    i = bl(i, 0) ? this._minOutput : i, this._assertRange(i);
    const s = this.toSeconds(n);
    return nn(isFinite(i) && isFinite(s), `Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(t)}, ${JSON.stringify(n)}`), this._events.add({
      time: s,
      type: "exponentialRampToValueAtTime",
      value: i
    }), this.log(this.units, "exponentialRampToValueAtTime", t, s), this._param.exponentialRampToValueAtTime(i, s), this;
  }
  exponentialRampTo(t, n, i) {
    return i = this.toSeconds(i), this.setRampPoint(i), this.exponentialRampToValueAtTime(t, i + this.toSeconds(n)), this;
  }
  linearRampTo(t, n, i) {
    return i = this.toSeconds(i), this.setRampPoint(i), this.linearRampToValueAtTime(t, i + this.toSeconds(n)), this;
  }
  targetRampTo(t, n, i) {
    return i = this.toSeconds(i), this.setRampPoint(i), this.exponentialApproachValueAtTime(t, i, n), this;
  }
  exponentialApproachValueAtTime(t, n, i) {
    n = this.toSeconds(n), i = this.toSeconds(i);
    const s = Math.log(i + 1) / Math.log(200);
    return this.setTargetAtTime(t, n, s), this.cancelAndHoldAtTime(n + i * 0.9), this.linearRampToValueAtTime(t, n + i), this;
  }
  setTargetAtTime(t, n, i) {
    const s = this._fromType(t);
    nn(isFinite(i) && i > 0, "timeConstant must be a number greater than 0");
    const o = this.toSeconds(n);
    return this._assertRange(s), nn(isFinite(s) && isFinite(o), `Invalid argument(s) to setTargetAtTime: ${JSON.stringify(t)}, ${JSON.stringify(n)}`), this._events.add({
      constant: i,
      time: o,
      type: "setTargetAtTime",
      value: s
    }), this.log(this.units, "setTargetAtTime", t, o, i), this._param.setTargetAtTime(s, o, i), this;
  }
  setValueCurveAtTime(t, n, i, s = 1) {
    i = this.toSeconds(i), n = this.toSeconds(n);
    const o = this._fromType(t[0]) * s;
    this.setValueAtTime(this._toType(o), n);
    const u = i / (t.length - 1);
    for (let h = 1; h < t.length; h++) {
      const f = this._fromType(t[h]) * s;
      this.linearRampToValueAtTime(this._toType(f), n + h * u);
    }
    return this;
  }
  cancelScheduledValues(t) {
    const n = this.toSeconds(t);
    return nn(isFinite(n), `Invalid argument to cancelScheduledValues: ${JSON.stringify(t)}`), this._events.cancel(n), this._param.cancelScheduledValues(n), this.log(this.units, "cancelScheduledValues", n), this;
  }
  cancelAndHoldAtTime(t) {
    const n = this.toSeconds(t), i = this._fromType(this.getValueAtTime(n));
    nn(isFinite(n), `Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(t)}`), this.log(this.units, "cancelAndHoldAtTime", n, "value=" + i);
    const s = this._events.get(n), o = this._events.getAfter(n);
    return s && bl(s.time, n) ? o ? (this._param.cancelScheduledValues(o.time), this._events.cancel(o.time)) : (this._param.cancelAndHoldAtTime(n), this._events.cancel(n + this.sampleTime)) : o && (this._param.cancelScheduledValues(o.time), this._events.cancel(o.time), o.type === "linearRampToValueAtTime" ? this.linearRampToValueAtTime(this._toType(i), n) : o.type === "exponentialRampToValueAtTime" && this.exponentialRampToValueAtTime(this._toType(i), n)), this._events.add({
      time: n,
      type: "setValueAtTime",
      value: i
    }), this._param.setValueAtTime(i, n), this;
  }
  rampTo(t, n = 0.1, i) {
    return this.units === "frequency" || this.units === "bpm" || this.units === "decibels" ? this.exponentialRampTo(t, n, i) : this.linearRampTo(t, n, i), this;
  }
  /**
   * Apply all of the previously scheduled events to the passed in Param or AudioParam.
   * The applied values will start at the context's current time and schedule
   * all of the events which are scheduled on this Param onto the passed in param.
   */
  apply(t) {
    const n = this.context.currentTime;
    t.setValueAtTime(this.getValueAtTime(n), n);
    const i = this._events.get(n);
    if (i && i.type === "setTargetAtTime") {
      const s = this._events.getAfter(i.time), o = s ? s.time : n + 2, u = (o - n) / 10;
      for (let h = n; h < o; h += u)
        t.linearRampToValueAtTime(this.getValueAtTime(h), h);
    }
    return this._events.forEachAfter(this.context.currentTime, (s) => {
      s.type === "cancelScheduledValues" ? t.cancelScheduledValues(s.time) : s.type === "setTargetAtTime" ? t.setTargetAtTime(s.value, s.time, s.constant) : t[s.type](s.value, s.time);
    }), this;
  }
  /**
   * Replace the Param's internal AudioParam. Will apply scheduled curves
   * onto the parameter and replace the connections.
   */
  setParam(t) {
    nn(this._swappable, "The Param must be assigned as 'swappable' in the constructor");
    const n = this.input;
    return n.disconnect(this._param), this.apply(t), this._param = t, n.connect(this._param), this;
  }
  dispose() {
    return super.dispose(), this._events.dispose(), this;
  }
  get defaultValue() {
    return this._toType(this._param.defaultValue);
  }
  //-------------------------------------
  // 	AUTOMATION CURVE CALCULATIONS
  // 	MIT License, copyright (c) 2014 Jordan Santell
  //-------------------------------------
  // Calculates the the value along the curve produced by setTargetAtTime
  _exponentialApproach(t, n, i, s, o) {
    return i + (n - i) * Math.exp(-(o - t) / s);
  }
  // Calculates the the value along the curve produced by linearRampToValueAtTime
  _linearInterpolate(t, n, i, s, o) {
    return n + (s - n) * ((o - t) / (i - t));
  }
  // Calculates the the value along the curve produced by exponentialRampToValueAtTime
  _exponentialInterpolate(t, n, i, s, o) {
    return n * Math.pow(s / n, (o - t) / (i - t));
  }
}
class wn extends ka {
  constructor() {
    super(...arguments), this._internalChannels = [];
  }
  /**
   * The number of inputs feeding into the AudioNode.
   * For source nodes, this will be 0.
   * @example
   * const node = new Tone.Gain();
   * console.log(node.numberOfInputs);
   */
  get numberOfInputs() {
    return _n(this.input) ? Uh(this.input) || this.input instanceof Yi ? 1 : this.input.numberOfInputs : 0;
  }
  /**
   * The number of outputs of the AudioNode.
   * @example
   * const node = new Tone.Gain();
   * console.log(node.numberOfOutputs);
   */
  get numberOfOutputs() {
    return _n(this.output) ? this.output.numberOfOutputs : 0;
  }
  //-------------------------------------
  // AUDIO PROPERTIES
  //-------------------------------------
  /**
   * Used to decide which nodes to get/set properties on
   */
  _isAudioNode(t) {
    return _n(t) && (t instanceof wn || Bd(t));
  }
  /**
   * Get all of the audio nodes (either internal or input/output) which together
   * make up how the class node responds to channel input/output
   */
  _getInternalNodes() {
    const t = this._internalChannels.slice(0);
    return this._isAudioNode(this.input) && t.push(this.input), this._isAudioNode(this.output) && this.input !== this.output && t.push(this.output), t;
  }
  /**
   * Set the audio options for this node such as channelInterpretation
   * channelCount, etc.
   * @param options
   */
  _setChannelProperties(t) {
    this._getInternalNodes().forEach((i) => {
      i.channelCount = t.channelCount, i.channelCountMode = t.channelCountMode, i.channelInterpretation = t.channelInterpretation;
    });
  }
  /**
   * Get the current audio options for this node such as channelInterpretation
   * channelCount, etc.
   */
  _getChannelProperties() {
    const t = this._getInternalNodes();
    nn(t.length > 0, "ToneAudioNode does not have any internal nodes");
    const n = t[0];
    return {
      channelCount: n.channelCount,
      channelCountMode: n.channelCountMode,
      channelInterpretation: n.channelInterpretation
    };
  }
  /**
   * channelCount is the number of channels used when up-mixing and down-mixing
   * connections to any inputs to the node. The default value is 2 except for
   * specific nodes where its value is specially determined.
   */
  get channelCount() {
    return this._getChannelProperties().channelCount;
  }
  set channelCount(t) {
    const n = this._getChannelProperties();
    this._setChannelProperties(Object.assign(n, { channelCount: t }));
  }
  /**
   * channelCountMode determines how channels will be counted when up-mixing and
   * down-mixing connections to any inputs to the node.
   * The default value is "max". This attribute has no effect for nodes with no inputs.
   * * "max" - computedNumberOfChannels is the maximum of the number of channels of all connections to an input. In this mode channelCount is ignored.
   * * "clamped-max" - computedNumberOfChannels is determined as for "max" and then clamped to a maximum value of the given channelCount.
   * * "explicit" - computedNumberOfChannels is the exact value as specified by the channelCount.
   */
  get channelCountMode() {
    return this._getChannelProperties().channelCountMode;
  }
  set channelCountMode(t) {
    const n = this._getChannelProperties();
    this._setChannelProperties(Object.assign(n, { channelCountMode: t }));
  }
  /**
   * channelInterpretation determines how individual channels will be treated
   * when up-mixing and down-mixing connections to any inputs to the node.
   * The default value is "speakers".
   */
  get channelInterpretation() {
    return this._getChannelProperties().channelInterpretation;
  }
  set channelInterpretation(t) {
    const n = this._getChannelProperties();
    this._setChannelProperties(Object.assign(n, { channelInterpretation: t }));
  }
  //-------------------------------------
  // CONNECTIONS
  //-------------------------------------
  /**
   * connect the output of a ToneAudioNode to an AudioParam, AudioNode, or ToneAudioNode
   * @param destination The output to connect to
   * @param outputNum The output to connect from
   * @param inputNum The input to connect to
   */
  connect(t, n = 0, i = 0) {
    return vp(this, t, n, i), this;
  }
  /**
   * Connect the output to the context's destination node.
   * @example
   * const osc = new Tone.Oscillator("C2").start();
   * osc.toDestination();
   */
  toDestination() {
    return this.connect(this.context.destination), this;
  }
  /**
   * Connect the output to the context's destination node.
   * @see {@link toDestination}
   * @deprecated
   */
  toMaster() {
    return J1("toMaster() has been renamed toDestination()"), this.toDestination();
  }
  /**
   * disconnect the output
   */
  disconnect(t, n = 0, i = 0) {
    return VP(this, t, n, i), this;
  }
  /**
   * Connect the output of this node to the rest of the nodes in series.
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/drum-samples/handdrum-loop.mp3");
   * player.autostart = true;
   * const filter = new Tone.AutoFilter(4).start();
   * const distortion = new Tone.Distortion(0.5);
   * // connect the player to the filter, distortion and then to the master output
   * player.chain(filter, distortion, Tone.Destination);
   */
  chain(...t) {
    return f2(this, ...t), this;
  }
  /**
   * connect the output of this node to the rest of the nodes in parallel.
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/drum-samples/conga-rhythm.mp3");
   * player.autostart = true;
   * const pitchShift = new Tone.PitchShift(4).toDestination();
   * const filter = new Tone.Filter("G5").toDestination();
   * // connect a node to the pitch shift and filter in parallel
   * player.fan(pitchShift, filter);
   */
  fan(...t) {
    return t.forEach((n) => this.connect(n)), this;
  }
  /**
   * Dispose and disconnect
   */
  dispose() {
    return super.dispose(), _n(this.input) && (this.input instanceof wn ? this.input.dispose() : Bd(this.input) && this.input.disconnect()), _n(this.output) && (this.output instanceof wn ? this.output.dispose() : Bd(this.output) && this.output.disconnect()), this._internalChannels = [], this;
  }
}
function f2(...e) {
  const t = e.shift();
  e.reduce((n, i) => (n instanceof wn ? n.connect(i) : Bd(n) && vp(n, i), i), t);
}
function vp(e, t, n = 0, i = 0) {
  for (nn(_n(e), "Cannot connect from undefined node"), nn(_n(t), "Cannot connect to undefined node"), (t instanceof wn || Bd(t)) && nn(t.numberOfInputs > 0, "Cannot connect to node with no inputs"), nn(e.numberOfOutputs > 0, "Cannot connect from node with no outputs"); t instanceof wn || t instanceof Yi; )
    _n(t.input) && (t = t.input);
  for (; e instanceof wn; )
    _n(e.output) && (e = e.output);
  Uh(t) ? e.connect(t, n) : e.connect(t, n, i);
}
function VP(e, t, n = 0, i = 0) {
  if (_n(t))
    for (; t instanceof wn; )
      t = t.input;
  for (; !Bd(e); )
    _n(e.output) && (e = e.output);
  Uh(t) ? e.disconnect(t, n) : Bd(t) ? e.disconnect(t, n, i) : e.disconnect();
}
class Da extends wn {
  constructor() {
    const t = on(Da.getDefaults(), arguments, [
      "gain",
      "units"
    ]);
    super(t), this.name = "Gain", this._gainNode = this.context.createGain(), this.input = this._gainNode, this.output = this._gainNode, this.gain = new Yi({
      context: this.context,
      convert: t.convert,
      param: this._gainNode.gain,
      units: t.units,
      value: t.gain,
      minValue: t.minValue,
      maxValue: t.maxValue
    }), or(this, "gain");
  }
  static getDefaults() {
    return Object.assign(wn.getDefaults(), {
      convert: !0,
      gain: 1,
      units: "gain"
    });
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this._gainNode.disconnect(), this.gain.dispose(), this;
  }
}
class np extends wn {
  constructor(t) {
    super(t), this.onended = ei, this._startTime = -1, this._stopTime = -1, this._timeout = -1, this.output = new Da({
      context: this.context,
      gain: 0
    }), this._gainNode = this.output, this.getStateAtTime = function(n) {
      const i = this.toSeconds(n);
      return this._startTime !== -1 && i >= this._startTime && (this._stopTime === -1 || i <= this._stopTime) ? "started" : "stopped";
    }, this._fadeIn = t.fadeIn, this._fadeOut = t.fadeOut, this._curve = t.curve, this.onended = t.onended;
  }
  static getDefaults() {
    return Object.assign(wn.getDefaults(), {
      curve: "linear",
      fadeIn: 0,
      fadeOut: 0,
      onended: ei
    });
  }
  /**
   * Start the source at the given time
   * @param  time When to start the source
   */
  _startGain(t, n = 1) {
    nn(this._startTime === -1, "Source cannot be started more than once");
    const i = this.toSeconds(this._fadeIn);
    return this._startTime = t + i, this._startTime = Math.max(this._startTime, this.context.currentTime), i > 0 ? (this._gainNode.gain.setValueAtTime(0, t), this._curve === "linear" ? this._gainNode.gain.linearRampToValueAtTime(n, t + i) : this._gainNode.gain.exponentialApproachValueAtTime(n, t, i)) : this._gainNode.gain.setValueAtTime(n, t), this;
  }
  /**
   * Stop the source node at the given time.
   * @param time When to stop the source
   */
  stop(t) {
    return this.log("stop", t), this._stopGain(this.toSeconds(t)), this;
  }
  /**
   * Stop the source at the given time
   * @param  time When to stop the source
   */
  _stopGain(t) {
    nn(this._startTime !== -1, "'start' must be called before 'stop'"), this.cancelStop();
    const n = this.toSeconds(this._fadeOut);
    return this._stopTime = this.toSeconds(t) + n, this._stopTime = Math.max(this._stopTime, this.now()), n > 0 ? this._curve === "linear" ? this._gainNode.gain.linearRampTo(0, n, t) : this._gainNode.gain.targetRampTo(0, n, t) : (this._gainNode.gain.cancelAndHoldAtTime(t), this._gainNode.gain.setValueAtTime(0, t)), this.context.clearTimeout(this._timeout), this._timeout = this.context.setTimeout(() => {
      const i = this._curve === "exponential" ? n * 2 : 0;
      this._stopSource(this.now() + i), this._onended();
    }, this._stopTime - this.context.currentTime), this;
  }
  /**
   * Invoke the onended callback
   */
  _onended() {
    if (this.onended !== ei && (this.onended(this), this.onended = ei, !this.context.isOffline)) {
      const t = () => this.dispose();
      typeof window.requestIdleCallback < "u" ? window.requestIdleCallback(t) : setTimeout(t, 1e3);
    }
  }
  /**
   * Get the playback state at the current time
   */
  get state() {
    return this.getStateAtTime(this.now());
  }
  /**
   * Cancel a scheduled stop event
   */
  cancelStop() {
    return this.log("cancelStop"), nn(this._startTime !== -1, "Source is not started"), this._gainNode.gain.cancelScheduledValues(this._startTime + this.sampleTime), this.context.clearTimeout(this._timeout), this._stopTime = -1, this;
  }
  dispose() {
    return super.dispose(), this._gainNode.dispose(), this.onended = ei, this;
  }
}
class M_ extends np {
  constructor() {
    const t = on(M_.getDefaults(), arguments, ["offset"]);
    super(t), this.name = "ToneConstantSource", this._source = this.context.createConstantSource(), vp(this._source, this._gainNode), this.offset = new Yi({
      context: this.context,
      convert: t.convert,
      param: this._source.offset,
      units: t.units,
      value: t.offset,
      minValue: t.minValue,
      maxValue: t.maxValue
    });
  }
  static getDefaults() {
    return Object.assign(np.getDefaults(), {
      convert: !0,
      offset: 1,
      units: "number"
    });
  }
  /**
   * Start the source node at the given time
   * @param  time When to start the source
   */
  start(t) {
    const n = this.toSeconds(t);
    return this.log("start", n), this._startGain(n), this._source.start(n), this;
  }
  _stopSource(t) {
    this._source.stop(t);
  }
  dispose() {
    return super.dispose(), this.state === "started" && this.stop(), this._source.disconnect(), this.offset.dispose(), this;
  }
}
class Jr extends wn {
  constructor() {
    const t = on(Jr.getDefaults(), arguments, [
      "value",
      "units"
    ]);
    super(t), this.name = "Signal", this.override = !0, this.output = this._constantSource = new M_({
      context: this.context,
      convert: t.convert,
      offset: t.value,
      units: t.units,
      minValue: t.minValue,
      maxValue: t.maxValue
    }), this._constantSource.start(0), this.input = this._param = this._constantSource.offset;
  }
  static getDefaults() {
    return Object.assign(wn.getDefaults(), {
      convert: !0,
      units: "number",
      value: 0
    });
  }
  connect(t, n = 0, i = 0) {
    return R_(this, t, n, i), this;
  }
  dispose() {
    return super.dispose(), this._param.dispose(), this._constantSource.dispose(), this;
  }
  //-------------------------------------
  // ABSTRACT PARAM INTERFACE
  // just a proxy for the ConstantSourceNode's offset AudioParam
  // all docs are generated from AbstractParam.ts
  //-------------------------------------
  setValueAtTime(t, n) {
    return this._param.setValueAtTime(t, n), this;
  }
  getValueAtTime(t) {
    return this._param.getValueAtTime(t);
  }
  setRampPoint(t) {
    return this._param.setRampPoint(t), this;
  }
  linearRampToValueAtTime(t, n) {
    return this._param.linearRampToValueAtTime(t, n), this;
  }
  exponentialRampToValueAtTime(t, n) {
    return this._param.exponentialRampToValueAtTime(t, n), this;
  }
  exponentialRampTo(t, n, i) {
    return this._param.exponentialRampTo(t, n, i), this;
  }
  linearRampTo(t, n, i) {
    return this._param.linearRampTo(t, n, i), this;
  }
  targetRampTo(t, n, i) {
    return this._param.targetRampTo(t, n, i), this;
  }
  exponentialApproachValueAtTime(t, n, i) {
    return this._param.exponentialApproachValueAtTime(t, n, i), this;
  }
  setTargetAtTime(t, n, i) {
    return this._param.setTargetAtTime(t, n, i), this;
  }
  setValueCurveAtTime(t, n, i, s) {
    return this._param.setValueCurveAtTime(t, n, i, s), this;
  }
  cancelScheduledValues(t) {
    return this._param.cancelScheduledValues(t), this;
  }
  cancelAndHoldAtTime(t) {
    return this._param.cancelAndHoldAtTime(t), this;
  }
  rampTo(t, n, i) {
    return this._param.rampTo(t, n, i), this;
  }
  get value() {
    return this._param.value;
  }
  set value(t) {
    this._param.value = t;
  }
  get convert() {
    return this._param.convert;
  }
  set convert(t) {
    this._param.convert = t;
  }
  get units() {
    return this._param.units;
  }
  get overridden() {
    return this._param.overridden;
  }
  set overridden(t) {
    this._param.overridden = t;
  }
  get maxValue() {
    return this._param.maxValue;
  }
  get minValue() {
    return this._param.minValue;
  }
  /**
   * @see {@link Param.apply}.
   */
  apply(t) {
    return this._param.apply(t), this;
  }
}
function R_(e, t, n, i) {
  (t instanceof Yi || Uh(t) || t instanceof Jr && t.override) && (t.cancelScheduledValues(0), t.setValueAtTime(0, 0), t instanceof Jr && (t.overridden = !0)), vp(e, t, n, i);
}
class O_ extends Yi {
  constructor() {
    const t = on(O_.getDefaults(), arguments, ["value"]);
    super(t), this.name = "TickParam", this._events = new Ac(1 / 0), this._multiplier = 1, this._multiplier = t.multiplier, this._events.cancel(0), this._events.add({
      ticks: 0,
      time: 0,
      type: "setValueAtTime",
      value: this._fromType(t.value)
    }), this.setValueAtTime(t.value, 0);
  }
  static getDefaults() {
    return Object.assign(Yi.getDefaults(), {
      multiplier: 1,
      units: "hertz",
      value: 1
    });
  }
  setTargetAtTime(t, n, i) {
    n = this.toSeconds(n), this.setRampPoint(n);
    const s = this._fromType(t), o = this._events.get(n), u = Math.round(Math.max(1 / i, 1));
    for (let h = 0; h <= u; h++) {
      const f = i * h + n, p = this._exponentialApproach(o.time, o.value, s, i, f);
      this.linearRampToValueAtTime(this._toType(p), f);
    }
    return this;
  }
  setValueAtTime(t, n) {
    const i = this.toSeconds(n);
    super.setValueAtTime(t, n);
    const s = this._events.get(i), o = this._events.previousEvent(s), u = this._getTicksUntilEvent(o, i);
    return s.ticks = Math.max(u, 0), this;
  }
  linearRampToValueAtTime(t, n) {
    const i = this.toSeconds(n);
    super.linearRampToValueAtTime(t, n);
    const s = this._events.get(i), o = this._events.previousEvent(s), u = this._getTicksUntilEvent(o, i);
    return s.ticks = Math.max(u, 0), this;
  }
  exponentialRampToValueAtTime(t, n) {
    n = this.toSeconds(n);
    const i = this._fromType(t), s = this._events.get(n), o = Math.round(Math.max((n - s.time) * 10, 1)), u = (n - s.time) / o;
    for (let h = 0; h <= o; h++) {
      const f = u * h + s.time, p = this._exponentialInterpolate(s.time, s.value, n, i, f);
      this.linearRampToValueAtTime(this._toType(p), f);
    }
    return this;
  }
  /**
   * Returns the tick value at the time. Takes into account
   * any automation curves scheduled on the signal.
   * @param  event The time to get the tick count at
   * @return The number of ticks which have elapsed at the time given any automations.
   */
  _getTicksUntilEvent(t, n) {
    if (t === null)
      t = {
        ticks: 0,
        time: 0,
        type: "setValueAtTime",
        value: 0
      };
    else if ($s(t.ticks)) {
      const u = this._events.previousEvent(t);
      t.ticks = this._getTicksUntilEvent(u, t.time);
    }
    const i = this._fromType(this.getValueAtTime(t.time));
    let s = this._fromType(this.getValueAtTime(n));
    const o = this._events.get(n);
    return o && o.time === n && o.type === "setValueAtTime" && (s = this._fromType(this.getValueAtTime(n - this.sampleTime))), 0.5 * (n - t.time) * (i + s) + t.ticks;
  }
  /**
   * Returns the tick value at the time. Takes into account
   * any automation curves scheduled on the signal.
   * @param  time The time to get the tick count at
   * @return The number of ticks which have elapsed at the time given any automations.
   */
  getTicksAtTime(t) {
    const n = this.toSeconds(t), i = this._events.get(n);
    return Math.max(this._getTicksUntilEvent(i, n), 0);
  }
  /**
   * Return the elapsed time of the number of ticks from the given time
   * @param ticks The number of ticks to calculate
   * @param  time The time to get the next tick from
   * @return The duration of the number of ticks from the given time in seconds
   */
  getDurationOfTicks(t, n) {
    const i = this.toSeconds(n), s = this.getTicksAtTime(n);
    return this.getTimeOfTick(s + t) - i;
  }
  /**
   * Given a tick, returns the time that tick occurs at.
   * @return The time that the tick occurs.
   */
  getTimeOfTick(t) {
    const n = this._events.get(t, "ticks"), i = this._events.getAfter(t, "ticks");
    if (n && n.ticks === t)
      return n.time;
    if (n && i && i.type === "linearRampToValueAtTime" && n.value !== i.value) {
      const s = this._fromType(this.getValueAtTime(n.time)), u = (this._fromType(this.getValueAtTime(i.time)) - s) / (i.time - n.time), h = Math.sqrt(Math.pow(s, 2) - 2 * u * (n.ticks - t)), f = (-s + h) / u, p = (-s - h) / u;
      return (f > 0 ? f : p) + n.time;
    } else return n ? n.value === 0 ? 1 / 0 : n.time + (t - n.ticks) / n.value : t / this._initialValue;
  }
  /**
   * Convert some number of ticks their the duration in seconds accounting
   * for any automation curves starting at the given time.
   * @param  ticks The number of ticks to convert to seconds.
   * @param  when  When along the automation timeline to convert the ticks.
   * @return The duration in seconds of the ticks.
   */
  ticksToTime(t, n) {
    return this.getDurationOfTicks(t, n);
  }
  /**
   * The inverse of {@link ticksToTime}. Convert a duration in
   * seconds to the corresponding number of ticks accounting for any
   * automation curves starting at the given time.
   * @param  duration The time interval to convert to ticks.
   * @param  when When along the automation timeline to convert the ticks.
   * @return The duration in ticks.
   */
  timeToTicks(t, n) {
    const i = this.toSeconds(n), s = this.toSeconds(t), o = this.getTicksAtTime(i);
    return this.getTicksAtTime(i + s) - o;
  }
  /**
   * Convert from the type when the unit value is BPM
   */
  _fromType(t) {
    return this.units === "bpm" && this.multiplier ? 1 / (60 / t / this.multiplier) : super._fromType(t);
  }
  /**
   * Special case of type conversion where the units === "bpm"
   */
  _toType(t) {
    return this.units === "bpm" && this.multiplier ? t / this.multiplier * 60 : super._toType(t);
  }
  /**
   * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.
   */
  get multiplier() {
    return this._multiplier;
  }
  set multiplier(t) {
    const n = this.value;
    this._multiplier = t, this.cancelScheduledValues(0), this.setValueAtTime(n, 0);
  }
}
class N_ extends Jr {
  constructor() {
    const t = on(N_.getDefaults(), arguments, ["value"]);
    super(t), this.name = "TickSignal", this.input = this._param = new O_({
      context: this.context,
      convert: t.convert,
      multiplier: t.multiplier,
      param: this._constantSource.offset,
      units: t.units,
      value: t.value
    });
  }
  static getDefaults() {
    return Object.assign(Jr.getDefaults(), {
      multiplier: 1,
      units: "hertz",
      value: 1
    });
  }
  ticksToTime(t, n) {
    return this._param.ticksToTime(t, n);
  }
  timeToTicks(t, n) {
    return this._param.timeToTicks(t, n);
  }
  getTimeOfTick(t) {
    return this._param.getTimeOfTick(t);
  }
  getDurationOfTicks(t, n) {
    return this._param.getDurationOfTicks(t, n);
  }
  getTicksAtTime(t) {
    return this._param.getTicksAtTime(t);
  }
  /**
   * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.
   */
  get multiplier() {
    return this._param.multiplier;
  }
  set multiplier(t) {
    this._param.multiplier = t;
  }
  dispose() {
    return super.dispose(), this._param.dispose(), this;
  }
}
class k_ extends ka {
  constructor() {
    const t = on(k_.getDefaults(), arguments, ["frequency"]);
    super(t), this.name = "TickSource", this._state = new e0(), this._tickOffset = new Ac(), this._ticksAtTime = new Ac(), this._secondsAtTime = new Ac(), this.frequency = new N_({
      context: this.context,
      units: t.units,
      value: t.frequency
    }), or(this, "frequency"), this._state.setStateAtTime("stopped", 0), this.setTicksAtTime(0, 0);
  }
  static getDefaults() {
    return Object.assign({
      frequency: 1,
      units: "hertz"
    }, ka.getDefaults());
  }
  /**
   * Returns the playback state of the source, either "started", "stopped" or "paused".
   */
  get state() {
    return this.getStateAtTime(this.now());
  }
  /**
   * Start the clock at the given time. Optionally pass in an offset
   * of where to start the tick counter from.
   * @param  time    The time the clock should start
   * @param offset The number of ticks to start the source at
   */
  start(t, n) {
    const i = this.toSeconds(t);
    return this._state.getValueAtTime(i) !== "started" && (this._state.setStateAtTime("started", i), _n(n) && this.setTicksAtTime(n, i), this._ticksAtTime.cancel(i), this._secondsAtTime.cancel(i)), this;
  }
  /**
   * Stop the clock. Stopping the clock resets the tick counter to 0.
   * @param time The time when the clock should stop.
   */
  stop(t) {
    const n = this.toSeconds(t);
    if (this._state.getValueAtTime(n) === "stopped") {
      const i = this._state.get(n);
      i && i.time > 0 && (this._tickOffset.cancel(i.time), this._state.cancel(i.time));
    }
    return this._state.cancel(n), this._state.setStateAtTime("stopped", n), this.setTicksAtTime(0, n), this._ticksAtTime.cancel(n), this._secondsAtTime.cancel(n), this;
  }
  /**
   * Pause the clock. Pausing does not reset the tick counter.
   * @param time The time when the clock should stop.
   */
  pause(t) {
    const n = this.toSeconds(t);
    return this._state.getValueAtTime(n) === "started" && (this._state.setStateAtTime("paused", n), this._ticksAtTime.cancel(n), this._secondsAtTime.cancel(n)), this;
  }
  /**
   * Cancel start/stop/pause and setTickAtTime events scheduled after the given time.
   * @param time When to clear the events after
   */
  cancel(t) {
    return t = this.toSeconds(t), this._state.cancel(t), this._tickOffset.cancel(t), this._ticksAtTime.cancel(t), this._secondsAtTime.cancel(t), this;
  }
  /**
   * Get the elapsed ticks at the given time
   * @param  time  When to get the tick value
   * @return The number of ticks
   */
  getTicksAtTime(t) {
    const n = this.toSeconds(t), i = this._state.getLastState("stopped", n), s = this._ticksAtTime.get(n), o = {
      state: "paused",
      time: n
    };
    this._state.add(o);
    let u = s || i, h = s ? s.ticks : 0, f = null;
    return this._state.forEachBetween(u.time, n + this.sampleTime, (p) => {
      let g = u.time;
      const v = this._tickOffset.get(p.time);
      v && v.time >= u.time && (h = v.ticks, g = v.time), u.state === "started" && p.state !== "started" && (h += this.frequency.getTicksAtTime(p.time) - this.frequency.getTicksAtTime(g), p.time !== o.time && (f = {
        state: p.state,
        time: p.time,
        ticks: h
      })), u = p;
    }), this._state.remove(o), f && this._ticksAtTime.add(f), h;
  }
  /**
   * The number of times the callback was invoked. Starts counting at 0
   * and increments after the callback was invoked. Returns -1 when stopped.
   */
  get ticks() {
    return this.getTicksAtTime(this.now());
  }
  set ticks(t) {
    this.setTicksAtTime(t, this.now());
  }
  /**
   * The time since ticks=0 that the TickSource has been running. Accounts
   * for tempo curves
   */
  get seconds() {
    return this.getSecondsAtTime(this.now());
  }
  set seconds(t) {
    const n = this.now(), i = this.frequency.timeToTicks(t, n);
    this.setTicksAtTime(i, n);
  }
  /**
   * Return the elapsed seconds at the given time.
   * @param  time  When to get the elapsed seconds
   * @return  The number of elapsed seconds
   */
  getSecondsAtTime(t) {
    t = this.toSeconds(t);
    const n = this._state.getLastState("stopped", t), i = { state: "paused", time: t };
    this._state.add(i);
    const s = this._secondsAtTime.get(t);
    let o = s || n, u = s ? s.seconds : 0, h = null;
    return this._state.forEachBetween(o.time, t + this.sampleTime, (f) => {
      let p = o.time;
      const g = this._tickOffset.get(f.time);
      g && g.time >= o.time && (u = g.seconds, p = g.time), o.state === "started" && f.state !== "started" && (u += f.time - p, f.time !== i.time && (h = {
        state: f.state,
        time: f.time,
        seconds: u
      })), o = f;
    }), this._state.remove(i), h && this._secondsAtTime.add(h), u;
  }
  /**
   * Set the clock's ticks at the given time.
   * @param  ticks The tick value to set
   * @param  time  When to set the tick value
   */
  setTicksAtTime(t, n) {
    return n = this.toSeconds(n), this._tickOffset.cancel(n), this._tickOffset.add({
      seconds: this.frequency.getDurationOfTicks(t, n),
      ticks: t,
      time: n
    }), this._ticksAtTime.cancel(n), this._secondsAtTime.cancel(n), this;
  }
  /**
   * Returns the scheduled state at the given time.
   * @param  time  The time to query.
   */
  getStateAtTime(t) {
    return t = this.toSeconds(t), this._state.getValueAtTime(t);
  }
  /**
   * Get the time of the given tick. The second argument
   * is when to test before. Since ticks can be set (with setTicksAtTime)
   * there may be multiple times for a given tick value.
   * @param  tick The tick number.
   * @param  before When to measure the tick value from.
   * @return The time of the tick
   */
  getTimeOfTick(t, n = this.now()) {
    const i = this._tickOffset.get(n), s = this._state.get(n), o = Math.max(i.time, s.time), u = this.frequency.getTicksAtTime(o) + t - i.ticks;
    return this.frequency.getTimeOfTick(u);
  }
  /**
   * Invoke the callback event at all scheduled ticks between the
   * start time and the end time
   * @param  startTime  The beginning of the search range
   * @param  endTime    The end of the search range
   * @param  callback   The callback to invoke with each tick
   */
  forEachTickBetween(t, n, i) {
    let s = this._state.get(t);
    this._state.forEachBetween(t, n, (u) => {
      s && s.state === "started" && u.state !== "started" && this.forEachTickBetween(Math.max(s.time, t), u.time - this.sampleTime, i), s = u;
    });
    let o = null;
    if (s && s.state === "started") {
      const u = Math.max(s.time, t), h = this.frequency.getTicksAtTime(u), f = this.frequency.getTicksAtTime(s.time), p = h - f;
      let g = Math.ceil(p) - p;
      g = bl(g, 1) ? 0 : g;
      let v = this.frequency.getTimeOfTick(h + g);
      for (; v < n; ) {
        try {
          i(v, Math.round(this.getTicksAtTime(v)));
        } catch (x) {
          o = x;
          break;
        }
        v += this.frequency.getDurationOfTicks(1, v);
      }
    }
    if (o)
      throw o;
    return this;
  }
  /**
   * Clean up
   */
  dispose() {
    return super.dispose(), this._state.dispose(), this._tickOffset.dispose(), this._ticksAtTime.dispose(), this._secondsAtTime.dispose(), this.frequency.dispose(), this;
  }
}
class iv extends ka {
  constructor() {
    const t = on(iv.getDefaults(), arguments, [
      "callback",
      "frequency"
    ]);
    super(t), this.name = "Clock", this.callback = ei, this._lastUpdate = 0, this._state = new e0("stopped"), this._boundLoop = this._loop.bind(this), this.callback = t.callback, this._tickSource = new k_({
      context: this.context,
      frequency: t.frequency,
      units: t.units
    }), this._lastUpdate = 0, this.frequency = this._tickSource.frequency, or(this, "frequency"), this._state.setStateAtTime("stopped", 0), this.context.on("tick", this._boundLoop);
  }
  static getDefaults() {
    return Object.assign(ka.getDefaults(), {
      callback: ei,
      frequency: 1,
      units: "hertz"
    });
  }
  /**
   * Returns the playback state of the source, either "started", "stopped" or "paused".
   */
  get state() {
    return this._state.getValueAtTime(this.now());
  }
  /**
   * Start the clock at the given time. Optionally pass in an offset
   * of where to start the tick counter from.
   * @param  time    The time the clock should start
   * @param offset  Where the tick counter starts counting from.
   */
  start(t, n) {
    T6(this.context);
    const i = this.toSeconds(t);
    return this.log("start", i), this._state.getValueAtTime(i) !== "started" && (this._state.setStateAtTime("started", i), this._tickSource.start(i, n), i < this._lastUpdate && this.emit("start", i, n)), this;
  }
  /**
   * Stop the clock. Stopping the clock resets the tick counter to 0.
   * @param time The time when the clock should stop.
   * @example
   * const clock = new Tone.Clock(time => {
   * 	console.log(time);
   * }, 1);
   * clock.start();
   * // stop the clock after 10 seconds
   * clock.stop("+10");
   */
  stop(t) {
    const n = this.toSeconds(t);
    return this.log("stop", n), this._state.cancel(n), this._state.setStateAtTime("stopped", n), this._tickSource.stop(n), n < this._lastUpdate && this.emit("stop", n), this;
  }
  /**
   * Pause the clock. Pausing does not reset the tick counter.
   * @param time The time when the clock should stop.
   */
  pause(t) {
    const n = this.toSeconds(t);
    return this._state.getValueAtTime(n) === "started" && (this._state.setStateAtTime("paused", n), this._tickSource.pause(n), n < this._lastUpdate && this.emit("pause", n)), this;
  }
  /**
   * The number of times the callback was invoked. Starts counting at 0
   * and increments after the callback was invoked.
   */
  get ticks() {
    return Math.ceil(this.getTicksAtTime(this.now()));
  }
  set ticks(t) {
    this._tickSource.ticks = t;
  }
  /**
   * The time since ticks=0 that the Clock has been running. Accounts for tempo curves
   */
  get seconds() {
    return this._tickSource.seconds;
  }
  set seconds(t) {
    this._tickSource.seconds = t;
  }
  /**
   * Return the elapsed seconds at the given time.
   * @param  time  When to get the elapsed seconds
   * @return  The number of elapsed seconds
   */
  getSecondsAtTime(t) {
    return this._tickSource.getSecondsAtTime(t);
  }
  /**
   * Set the clock's ticks at the given time.
   * @param  ticks The tick value to set
   * @param  time  When to set the tick value
   */
  setTicksAtTime(t, n) {
    return this._tickSource.setTicksAtTime(t, n), this;
  }
  /**
   * Get the time of the given tick. The second argument
   * is when to test before. Since ticks can be set (with setTicksAtTime)
   * there may be multiple times for a given tick value.
   * @param  tick The tick number.
   * @param  before When to measure the tick value from.
   * @return The time of the tick
   */
  getTimeOfTick(t, n = this.now()) {
    return this._tickSource.getTimeOfTick(t, n);
  }
  /**
   * Get the clock's ticks at the given time.
   * @param  time  When to get the tick value
   * @return The tick value at the given time.
   */
  getTicksAtTime(t) {
    return this._tickSource.getTicksAtTime(t);
  }
  /**
   * Get the time of the next tick
   * @param  offset The tick number.
   */
  nextTickTime(t, n) {
    const i = this.toSeconds(n), s = this.getTicksAtTime(i);
    return this._tickSource.getTimeOfTick(s + t, i);
  }
  /**
   * The scheduling loop.
   */
  _loop() {
    const t = this._lastUpdate, n = this.now();
    this._lastUpdate = n, this.log("loop", t, n), t !== n && (this._state.forEachBetween(t, n, (i) => {
      switch (i.state) {
        case "started":
          const s = this._tickSource.getTicksAtTime(i.time);
          this.emit("start", i.time, s);
          break;
        case "stopped":
          i.time !== 0 && this.emit("stop", i.time);
          break;
        case "paused":
          this.emit("pause", i.time);
          break;
      }
    }), this._tickSource.forEachTickBetween(t, n, (i, s) => {
      this.callback(i, s);
    }));
  }
  /**
   * Returns the scheduled state at the given time.
   * @param  time  The time to query.
   * @return  The name of the state input in setStateAtTime.
   * @example
   * const clock = new Tone.Clock();
   * clock.start("+0.1");
   * clock.getStateAtTime("+0.1"); // returns "started"
   */
  getStateAtTime(t) {
    const n = this.toSeconds(t);
    return this._state.getValueAtTime(n);
  }
  /**
   * Clean up
   */
  dispose() {
    return super.dispose(), this.context.off("tick", this._boundLoop), this._tickSource.dispose(), this._state.dispose(), this;
  }
}
t0.mixin(iv);
class bp extends wn {
  constructor() {
    const t = on(bp.getDefaults(), arguments, [
      "volume"
    ]);
    super(t), this.name = "Volume", this.input = this.output = new Da({
      context: this.context,
      gain: t.volume,
      units: "decibels"
    }), this.volume = this.output.gain, or(this, "volume"), this._unmutedVolume = t.volume, this.mute = t.mute;
  }
  static getDefaults() {
    return Object.assign(wn.getDefaults(), {
      mute: !1,
      volume: 0
    });
  }
  /**
   * Mute the output.
   * @example
   * const vol = new Tone.Volume(-12).toDestination();
   * const osc = new Tone.Oscillator().connect(vol).start();
   * // mute the output
   * vol.mute = true;
   */
  get mute() {
    return this.volume.value === -1 / 0;
  }
  set mute(t) {
    !this.mute && t ? (this._unmutedVolume = this.volume.value, this.volume.value = -1 / 0) : this.mute && !t && (this.volume.value = this._unmutedVolume);
  }
  /**
   * clean up
   */
  dispose() {
    return super.dispose(), this.input.dispose(), this.volume.dispose(), this;
  }
}
class D_ extends wn {
  constructor() {
    const t = on(D_.getDefaults(), arguments);
    super(t), this.name = "Destination", this.input = new bp({ context: this.context }), this.output = new Da({ context: this.context }), this.volume = this.input.volume, f2(this.input, this.output, this.context.rawContext.destination), this.mute = t.mute, this._internalChannels = [
      this.input,
      this.context.rawContext.destination,
      this.output
    ];
  }
  static getDefaults() {
    return Object.assign(wn.getDefaults(), {
      mute: !1,
      volume: 0
    });
  }
  /**
   * Mute the output.
   * @example
   * const oscillator = new Tone.Oscillator().start().toDestination();
   * setTimeout(() => {
   * 	// mute the output
   * 	Tone.Destination.mute = true;
   * }, 1000);
   */
  get mute() {
    return this.input.mute;
  }
  set mute(t) {
    this.input.mute = t;
  }
  /**
   * Add a master effects chain. NOTE: this will disconnect any nodes which were previously
   * chained in the master effects chain.
   * @param args All arguments will be connected in a row and the Master will be routed through it.
   * @example
   * // route all audio through a filter and compressor
   * const lowpass = new Tone.Filter(800, "lowpass");
   * const compressor = new Tone.Compressor(-18);
   * Tone.Destination.chain(lowpass, compressor);
   */
  chain(...t) {
    return this.input.disconnect(), t.unshift(this.input), t.push(this.output), f2(...t), this;
  }
  /**
   * The maximum number of channels the system can output
   * @example
   * console.log(Tone.Destination.maxChannelCount);
   */
  get maxChannelCount() {
    return this.context.rawContext.destination.maxChannelCount;
  }
  /**
   * Clean up
   */
  dispose() {
    return super.dispose(), this.volume.dispose(), this;
  }
}
tv((e) => {
  e.destination = new D_({ context: e });
});
ev((e) => {
  e.destination.dispose();
});
class IP extends wn {
  constructor() {
    super(...arguments), this.name = "Listener", this.positionX = new Yi({
      context: this.context,
      param: this.context.rawContext.listener.positionX
    }), this.positionY = new Yi({
      context: this.context,
      param: this.context.rawContext.listener.positionY
    }), this.positionZ = new Yi({
      context: this.context,
      param: this.context.rawContext.listener.positionZ
    }), this.forwardX = new Yi({
      context: this.context,
      param: this.context.rawContext.listener.forwardX
    }), this.forwardY = new Yi({
      context: this.context,
      param: this.context.rawContext.listener.forwardY
    }), this.forwardZ = new Yi({
      context: this.context,
      param: this.context.rawContext.listener.forwardZ
    }), this.upX = new Yi({
      context: this.context,
      param: this.context.rawContext.listener.upX
    }), this.upY = new Yi({
      context: this.context,
      param: this.context.rawContext.listener.upY
    }), this.upZ = new Yi({
      context: this.context,
      param: this.context.rawContext.listener.upZ
    });
  }
  static getDefaults() {
    return Object.assign(wn.getDefaults(), {
      positionX: 0,
      positionY: 0,
      positionZ: 0,
      forwardX: 0,
      forwardY: 0,
      forwardZ: -1,
      upX: 0,
      upY: 1,
      upZ: 0
    });
  }
  dispose() {
    return super.dispose(), this.positionX.dispose(), this.positionY.dispose(), this.positionZ.dispose(), this.forwardX.dispose(), this.forwardY.dispose(), this.forwardZ.dispose(), this.upX.dispose(), this.upY.dispose(), this.upZ.dispose(), this;
  }
}
tv((e) => {
  e.listener = new IP({ context: e });
});
ev((e) => {
  e.listener.dispose();
});
class B_ extends Vu {
  constructor() {
    super(), this.name = "ToneAudioBuffers", this._buffers = /* @__PURE__ */ new Map(), this._loadingCount = 0;
    const t = on(B_.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls");
    this.baseUrl = t.baseUrl, Object.keys(t.urls).forEach((n) => {
      this._loadingCount++;
      const i = t.urls[n];
      this.add(n, i, this._bufferLoaded.bind(this, t.onload), t.onerror);
    });
  }
  static getDefaults() {
    return {
      baseUrl: "",
      onerror: ei,
      onload: ei,
      urls: {}
    };
  }
  /**
   * True if the buffers object has a buffer by that name.
   * @param  name  The key or index of the buffer.
   */
  has(t) {
    return this._buffers.has(t.toString());
  }
  /**
   * Get a buffer by name. If an array was loaded,
   * then use the array index.
   * @param  name  The key or index of the buffer.
   */
  get(t) {
    return nn(this.has(t), `ToneAudioBuffers has no buffer named: ${t}`), this._buffers.get(t.toString());
  }
  /**
   * A buffer was loaded. decrement the counter.
   */
  _bufferLoaded(t) {
    this._loadingCount--, this._loadingCount === 0 && t && t();
  }
  /**
   * If the buffers are loaded or not
   */
  get loaded() {
    return Array.from(this._buffers).every(([t, n]) => n.loaded);
  }
  /**
   * Add a buffer by name and url to the Buffers
   * @param  name      A unique name to give the buffer
   * @param  url  Either the url of the bufer, or a buffer which will be added with the given name.
   * @param  callback  The callback to invoke when the url is loaded.
   * @param  onerror  Invoked if the buffer can't be loaded
   */
  add(t, n, i = ei, s = ei) {
    return ju(n) ? (this.baseUrl && n.trim().substring(0, 11).toLowerCase() === "data:audio/" && (this.baseUrl = ""), this._buffers.set(t.toString(), new Si(this.baseUrl + n, i, s))) : this._buffers.set(t.toString(), new Si(n, i, s)), this;
  }
  dispose() {
    return super.dispose(), this._buffers.forEach((t) => t.dispose()), this._buffers.clear(), this;
  }
}
class v1 extends _s {
  constructor() {
    super(...arguments), this.name = "MidiClass", this.defaultUnits = "midi";
  }
  /**
   * Returns the value of a frequency in the current units
   */
  _frequencyToUnits(t) {
    return Nh(super._frequencyToUnits(t));
  }
  /**
   * Returns the value of a tick in the current time units
   */
  _ticksToUnits(t) {
    return Nh(super._ticksToUnits(t));
  }
  /**
   * Return the value of the beats in the current units
   */
  _beatsToUnits(t) {
    return Nh(super._beatsToUnits(t));
  }
  /**
   * Returns the value of a second in the current units
   */
  _secondsToUnits(t) {
    return Nh(super._secondsToUnits(t));
  }
  /**
   * Return the value of the frequency as a MIDI note
   * @example
   * Tone.Midi(60).toMidi(); // 60
   */
  toMidi() {
    return this.valueOf();
  }
  /**
   * Return the value of the frequency as a MIDI note
   * @example
   * Tone.Midi(60).toFrequency(); // 261.6255653005986
   */
  toFrequency() {
    return P6(this.toMidi());
  }
  /**
   * Transposes the frequency by the given number of semitones.
   * @return A new transposed MidiClass
   * @example
   * Tone.Midi("A4").transpose(3); // "C5"
   */
  transpose(t) {
    return new v1(this.context, this.toMidi() + t);
  }
}
class Ur extends Hf {
  constructor() {
    super(...arguments), this.name = "Ticks", this.defaultUnits = "i";
  }
  /**
   * Get the current time in the given units
   */
  _now() {
    return this.context.transport.ticks;
  }
  /**
   * Return the value of the beats in the current units
   */
  _beatsToUnits(t) {
    return this._getPPQ() * t;
  }
  /**
   * Returns the value of a second in the current units
   */
  _secondsToUnits(t) {
    return Math.floor(t / (60 / this._getBpm()) * this._getPPQ());
  }
  /**
   * Returns the value of a tick in the current time units
   */
  _ticksToUnits(t) {
    return t;
  }
  /**
   * Return the time in ticks
   */
  toTicks() {
    return this.valueOf();
  }
  /**
   * Return the time in seconds
   */
  toSeconds() {
    return this.valueOf() / this._getPPQ() * (60 / this._getBpm());
  }
}
class FP extends ka {
  constructor() {
    super(...arguments), this.name = "Draw", this.expiration = 0.25, this.anticipation = 8e-3, this._events = new Ac(), this._boundDrawLoop = this._drawLoop.bind(this), this._animationFrame = -1;
  }
  /**
   * Schedule a function at the given time to be invoked
   * on the nearest animation frame.
   * @param  callback  Callback is invoked at the given time.
   * @param  time      The time relative to the AudioContext time to invoke the callback.
   * @example
   * Tone.Transport.scheduleRepeat(time => {
   * 	Tone.Draw.schedule(() => console.log(time), time);
   * }, 1);
   * Tone.Transport.start();
   */
  schedule(t, n) {
    return this._events.add({
      callback: t,
      time: this.toSeconds(n)
    }), this._events.length === 1 && (this._animationFrame = requestAnimationFrame(this._boundDrawLoop)), this;
  }
  /**
   * Cancel events scheduled after the given time
   * @param  after  Time after which scheduled events will be removed from the scheduling timeline.
   */
  cancel(t) {
    return this._events.cancel(this.toSeconds(t)), this;
  }
  /**
   * The draw loop
   */
  _drawLoop() {
    const t = this.context.currentTime;
    for (; this._events.length && this._events.peek().time - this.anticipation <= t; ) {
      const n = this._events.shift();
      n && t - n.time <= this.expiration && n.callback();
    }
    this._events.length > 0 && (this._animationFrame = requestAnimationFrame(this._boundDrawLoop));
  }
  dispose() {
    return super.dispose(), this._events.dispose(), cancelAnimationFrame(this._animationFrame), this;
  }
}
tv((e) => {
  e.draw = new FP({ context: e });
});
ev((e) => {
  e.draw.dispose();
});
class qP extends Vu {
  constructor() {
    super(...arguments), this.name = "IntervalTimeline", this._root = null, this._length = 0;
  }
  /**
   * The event to add to the timeline. All events must
   * have a time and duration value
   * @param  event  The event to add to the timeline
   */
  add(t) {
    nn(_n(t.time), "Events must have a time property"), nn(_n(t.duration), "Events must have a duration parameter"), t.time = t.time.valueOf();
    let n = new GP(t.time, t.time + t.duration, t);
    for (this._root === null ? this._root = n : this._root.insert(n), this._length++; n !== null; )
      n.updateHeight(), n.updateMax(), this._rebalance(n), n = n.parent;
    return this;
  }
  /**
   * Remove an event from the timeline.
   * @param  event  The event to remove from the timeline
   */
  remove(t) {
    if (this._root !== null) {
      const n = [];
      this._root.search(t.time, n);
      for (const i of n)
        if (i.event === t) {
          this._removeNode(i), this._length--;
          break;
        }
    }
    return this;
  }
  /**
   * The number of items in the timeline.
   * @readOnly
   */
  get length() {
    return this._length;
  }
  /**
   * Remove events whose time time is after the given time
   * @param  after  The time to query.
   */
  cancel(t) {
    return this.forEachFrom(t, (n) => this.remove(n)), this;
  }
  /**
   * Set the root node as the given node
   */
  _setRoot(t) {
    this._root = t, this._root !== null && (this._root.parent = null);
  }
  /**
   * Replace the references to the node in the node's parent
   * with the replacement node.
   */
  _replaceNodeInParent(t, n) {
    t.parent !== null ? (t.isLeftChild() ? t.parent.left = n : t.parent.right = n, this._rebalance(t.parent)) : this._setRoot(n);
  }
  /**
   * Remove the node from the tree and replace it with
   * a successor which follows the schema.
   */
  _removeNode(t) {
    if (t.left === null && t.right === null)
      this._replaceNodeInParent(t, null);
    else if (t.right === null)
      this._replaceNodeInParent(t, t.left);
    else if (t.left === null)
      this._replaceNodeInParent(t, t.right);
    else {
      const n = t.getBalance();
      let i, s = null;
      if (n > 0)
        if (t.left.right === null)
          i = t.left, i.right = t.right, s = i;
        else {
          for (i = t.left.right; i.right !== null; )
            i = i.right;
          i.parent && (i.parent.right = i.left, s = i.parent, i.left = t.left, i.right = t.right);
        }
      else if (t.right.left === null)
        i = t.right, i.left = t.left, s = i;
      else {
        for (i = t.right.left; i.left !== null; )
          i = i.left;
        i.parent && (i.parent.left = i.right, s = i.parent, i.left = t.left, i.right = t.right);
      }
      t.parent !== null ? t.isLeftChild() ? t.parent.left = i : t.parent.right = i : this._setRoot(i), s && this._rebalance(s);
    }
    t.dispose();
  }
  /**
   * Rotate the tree to the left
   */
  _rotateLeft(t) {
    const n = t.parent, i = t.isLeftChild(), s = t.right;
    s && (t.right = s.left, s.left = t), n !== null ? i ? n.left = s : n.right = s : this._setRoot(s);
  }
  /**
   * Rotate the tree to the right
   */
  _rotateRight(t) {
    const n = t.parent, i = t.isLeftChild(), s = t.left;
    s && (t.left = s.right, s.right = t), n !== null ? i ? n.left = s : n.right = s : this._setRoot(s);
  }
  /**
   * Balance the BST
   */
  _rebalance(t) {
    const n = t.getBalance();
    n > 1 && t.left ? t.left.getBalance() < 0 ? this._rotateLeft(t.left) : this._rotateRight(t) : n < -1 && t.right && (t.right.getBalance() > 0 ? this._rotateRight(t.right) : this._rotateLeft(t));
  }
  /**
   * Get an event whose time and duration span the give time. Will
   * return the match whose "time" value is closest to the given time.
   * @return  The event which spans the desired time
   */
  get(t) {
    if (this._root !== null) {
      const n = [];
      if (this._root.search(t, n), n.length > 0) {
        let i = n[0];
        for (let s = 1; s < n.length; s++)
          n[s].low > i.low && (i = n[s]);
        return i.event;
      }
    }
    return null;
  }
  /**
   * Iterate over everything in the timeline.
   * @param  callback The callback to invoke with every item
   */
  forEach(t) {
    if (this._root !== null) {
      const n = [];
      this._root.traverse((i) => n.push(i)), n.forEach((i) => {
        i.event && t(i.event);
      });
    }
    return this;
  }
  /**
   * Iterate over everything in the array in which the given time
   * overlaps with the time and duration time of the event.
   * @param  time The time to check if items are overlapping
   * @param  callback The callback to invoke with every item
   */
  forEachAtTime(t, n) {
    if (this._root !== null) {
      const i = [];
      this._root.search(t, i), i.forEach((s) => {
        s.event && n(s.event);
      });
    }
    return this;
  }
  /**
   * Iterate over everything in the array in which the time is greater
   * than or equal to the given time.
   * @param  time The time to check if items are before
   * @param  callback The callback to invoke with every item
   */
  forEachFrom(t, n) {
    if (this._root !== null) {
      const i = [];
      this._root.searchAfter(t, i), i.forEach((s) => {
        s.event && n(s.event);
      });
    }
    return this;
  }
  /**
   * Clean up
   */
  dispose() {
    return super.dispose(), this._root !== null && this._root.traverse((t) => t.dispose()), this._root = null, this;
  }
}
class GP {
  constructor(t, n, i) {
    this._left = null, this._right = null, this.parent = null, this.height = 0, this.event = i, this.low = t, this.high = n, this.max = this.high;
  }
  /**
   * Insert a node into the correct spot in the tree
   */
  insert(t) {
    t.low <= this.low ? this.left === null ? this.left = t : this.left.insert(t) : this.right === null ? this.right = t : this.right.insert(t);
  }
  /**
   * Search the tree for nodes which overlap
   * with the given point
   * @param  point  The point to query
   * @param  results  The array to put the results
   */
  search(t, n) {
    t > this.max || (this.left !== null && this.left.search(t, n), this.low <= t && this.high > t && n.push(this), !(this.low > t) && this.right !== null && this.right.search(t, n));
  }
  /**
   * Search the tree for nodes which are less
   * than the given point
   * @param  point  The point to query
   * @param  results  The array to put the results
   */
  searchAfter(t, n) {
    this.low >= t && (n.push(this), this.left !== null && this.left.searchAfter(t, n)), this.right !== null && this.right.searchAfter(t, n);
  }
  /**
   * Invoke the callback on this element and both it's branches
   * @param  {Function}  callback
   */
  traverse(t) {
    t(this), this.left !== null && this.left.traverse(t), this.right !== null && this.right.traverse(t);
  }
  /**
   * Update the height of the node
   */
  updateHeight() {
    this.left !== null && this.right !== null ? this.height = Math.max(this.left.height, this.right.height) + 1 : this.right !== null ? this.height = this.right.height + 1 : this.left !== null ? this.height = this.left.height + 1 : this.height = 0;
  }
  /**
   * Update the height of the node
   */
  updateMax() {
    this.max = this.high, this.left !== null && (this.max = Math.max(this.max, this.left.max)), this.right !== null && (this.max = Math.max(this.max, this.right.max));
  }
  /**
   * The balance is how the leafs are distributed on the node
   * @return  Negative numbers are balanced to the right
   */
  getBalance() {
    let t = 0;
    return this.left !== null && this.right !== null ? t = this.left.height - this.right.height : this.left !== null ? t = this.left.height + 1 : this.right !== null && (t = -(this.right.height + 1)), t;
  }
  /**
   * @returns true if this node is the left child of its parent
   */
  isLeftChild() {
    return this.parent !== null && this.parent.left === this;
  }
  /**
   * get/set the left node
   */
  get left() {
    return this._left;
  }
  set left(t) {
    this._left = t, t !== null && (t.parent = this), this.updateHeight(), this.updateMax();
  }
  /**
   * get/set the right node
   */
  get right() {
    return this._right;
  }
  set right(t) {
    this._right = t, t !== null && (t.parent = this), this.updateHeight(), this.updateMax();
  }
  /**
   * null out references.
   */
  dispose() {
    this.parent = null, this._left = null, this._right = null, this.event = null;
  }
}
class HP extends Vu {
  /**
   * @param initialValue The value to return if there is no scheduled values
   */
  constructor(t) {
    super(), this.name = "TimelineValue", this._timeline = new Ac({
      memory: 10
    }), this._initialValue = t;
  }
  /**
   * Set the value at the given time
   */
  set(t, n) {
    return this._timeline.add({
      value: t,
      time: n
    }), this;
  }
  /**
   * Get the value at the given time
   */
  get(t) {
    const n = this._timeline.get(t);
    return n ? n.value : this._initialValue;
  }
}
class ip extends wn {
  constructor() {
    super(on(ip.getDefaults(), arguments, [
      "context"
    ]));
  }
  connect(t, n = 0, i = 0) {
    return R_(this, t, n, i), this;
  }
}
class n0 extends ip {
  constructor() {
    const t = on(n0.getDefaults(), arguments, ["mapping", "length"]);
    super(t), this.name = "WaveShaper", this._shaper = this.context.createWaveShaper(), this.input = this._shaper, this.output = this._shaper, Ts(t.mapping) || t.mapping instanceof Float32Array ? this.curve = Float32Array.from(t.mapping) : yP(t.mapping) && this.setMap(t.mapping, t.length);
  }
  static getDefaults() {
    return Object.assign(Jr.getDefaults(), {
      length: 1024
    });
  }
  /**
   * Uses a mapping function to set the value of the curve.
   * @param mapping The function used to define the values.
   *                The mapping function take two arguments:
   *                the first is the value at the current position
   *                which goes from -1 to 1 over the number of elements
   *                in the curve array. The second argument is the array position.
   * @example
   * const shaper = new Tone.WaveShaper();
   * // map the input signal from [-1, 1] to [0, 10]
   * shaper.setMap((val, index) => (val + 1) * 5);
   */
  setMap(t, n = 1024) {
    const i = new Float32Array(n);
    for (let s = 0, o = n; s < o; s++) {
      const u = s / (o - 1) * 2 - 1;
      i[s] = t(u, s);
    }
    return this.curve = i, this;
  }
  /**
   * The array to set as the waveshaper curve. For linear curves
   * array length does not make much difference, but for complex curves
   * longer arrays will provide smoother interpolation.
   */
  get curve() {
    return this._shaper.curve;
  }
  set curve(t) {
    this._shaper.curve = t;
  }
  /**
   * Specifies what type of oversampling (if any) should be used when
   * applying the shaping curve. Can either be "none", "2x" or "4x".
   */
  get oversample() {
    return this._shaper.oversample;
  }
  set oversample(t) {
    const n = ["none", "2x", "4x"].some((i) => i.includes(t));
    nn(n, "oversampling must be either 'none', '2x', or '4x'"), this._shaper.oversample = t;
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this._shaper.disconnect(), this;
  }
}
class z_ extends ip {
  constructor() {
    const t = on(z_.getDefaults(), arguments, [
      "value"
    ]);
    super(t), this.name = "Pow", this._exponentScaler = this.input = this.output = new n0({
      context: this.context,
      mapping: this._expFunc(t.value),
      length: 8192
    }), this._exponent = t.value;
  }
  static getDefaults() {
    return Object.assign(ip.getDefaults(), {
      value: 1
    });
  }
  /**
   * the function which maps the waveshaper
   * @param exponent exponent value
   */
  _expFunc(t) {
    return (n) => Math.pow(Math.abs(n), t);
  }
  /**
   * The value of the exponent.
   */
  get value() {
    return this._exponent;
  }
  set value(t) {
    this._exponent = t, this._exponentScaler.setMap(this._expFunc(this._exponent));
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this._exponentScaler.dispose(), this;
  }
}
class jd {
  /**
   * @param transport The transport object which the event belongs to
   */
  constructor(t, n) {
    this.id = jd._eventId++, this._remainderTime = 0;
    const i = Object.assign(jd.getDefaults(), n);
    this.transport = t, this.callback = i.callback, this._once = i.once, this.time = Math.floor(i.time), this._remainderTime = i.time - this.time;
  }
  static getDefaults() {
    return {
      callback: ei,
      once: !1,
      time: 0
    };
  }
  /**
   * Get the time and remainder time.
   */
  get floatTime() {
    return this.time + this._remainderTime;
  }
  /**
   * Invoke the event callback.
   * @param  time  The AudioContext time in seconds of the event
   */
  invoke(t) {
    if (this.callback) {
      const n = this.transport.bpm.getDurationOfTicks(1, t);
      this.callback(t + this._remainderTime * n), this._once && this.transport.clear(this.id);
    }
  }
  /**
   * Clean up
   */
  dispose() {
    return this.callback = void 0, this;
  }
}
jd._eventId = 0;
class P_ extends jd {
  /**
   * @param transport The transport object which the event belongs to
   */
  constructor(t, n) {
    super(t, n), this._currentId = -1, this._nextId = -1, this._nextTick = this.time, this._boundRestart = this._restart.bind(this);
    const i = Object.assign(P_.getDefaults(), n);
    this.duration = i.duration, this._interval = i.interval, this._nextTick = i.time, this.transport.on("start", this._boundRestart), this.transport.on("loopStart", this._boundRestart), this.transport.on("ticks", this._boundRestart), this.context = this.transport.context, this._restart();
  }
  static getDefaults() {
    return Object.assign({}, jd.getDefaults(), {
      duration: 1 / 0,
      interval: 1,
      once: !1
    });
  }
  /**
   * Invoke the callback. Returns the tick time which
   * the next event should be scheduled at.
   * @param  time  The AudioContext time in seconds of the event
   */
  invoke(t) {
    this._createEvents(t), super.invoke(t);
  }
  /**
   * Create an event on the transport on the nextTick
   */
  _createEvent() {
    return y1(this._nextTick, this.floatTime + this.duration) ? this.transport.scheduleOnce(this.invoke.bind(this), new Ur(this.context, this._nextTick).toSeconds()) : -1;
  }
  /**
   * Push more events onto the timeline to keep up with the position of the timeline
   */
  _createEvents(t) {
    y1(this._nextTick + this._interval, this.floatTime + this.duration) && (this._nextTick += this._interval, this._currentId = this._nextId, this._nextId = this.transport.scheduleOnce(this.invoke.bind(this), new Ur(this.context, this._nextTick).toSeconds()));
  }
  /**
   * Re-compute the events when the transport time has changed from a start/ticks/loopStart event
   */
  _restart(t) {
    this.transport.clear(this._currentId), this.transport.clear(this._nextId), this._nextTick = this.floatTime;
    const n = this.transport.getTicksAtTime(t);
    ep(n, this.time) && (this._nextTick = this.floatTime + Math.ceil((n - this.floatTime) / this._interval) * this._interval), this._currentId = this._createEvent(), this._nextTick += this._interval, this._nextId = this._createEvent();
  }
  /**
   * Clean up
   */
  dispose() {
    return super.dispose(), this.transport.clear(this._currentId), this.transport.clear(this._nextId), this.transport.off("start", this._boundRestart), this.transport.off("loopStart", this._boundRestart), this.transport.off("ticks", this._boundRestart), this;
  }
}
class rv extends ka {
  constructor() {
    const t = on(rv.getDefaults(), arguments);
    super(t), this.name = "Transport", this._loop = new HP(!1), this._loopStart = 0, this._loopEnd = 0, this._scheduledEvents = {}, this._timeline = new Ac(), this._repeatedEvents = new qP(), this._syncedSignals = [], this._swingAmount = 0, this._ppq = t.ppq, this._clock = new iv({
      callback: this._processTick.bind(this),
      context: this.context,
      frequency: 0,
      units: "bpm"
    }), this._bindClockEvents(), this.bpm = this._clock.frequency, this._clock.frequency.multiplier = t.ppq, this.bpm.setValueAtTime(t.bpm, 0), or(this, "bpm"), this._timeSignature = t.timeSignature, this._swingTicks = t.ppq / 2;
  }
  static getDefaults() {
    return Object.assign(ka.getDefaults(), {
      bpm: 120,
      loopEnd: "4m",
      loopStart: 0,
      ppq: 192,
      swing: 0,
      swingSubdivision: "8n",
      timeSignature: 4
    });
  }
  //-------------------------------------
  // 	TICKS
  //-------------------------------------
  /**
   * called on every tick
   * @param  tickTime clock relative tick time
   */
  _processTick(t, n) {
    if (this._loop.get(t) && n >= this._loopEnd && (this.emit("loopEnd", t), this._clock.setTicksAtTime(this._loopStart, t), n = this._loopStart, this.emit("loopStart", t, this._clock.getSecondsAtTime(t)), this.emit("loop", t)), this._swingAmount > 0 && n % this._ppq !== 0 && // not on a downbeat
    n % (this._swingTicks * 2) !== 0) {
      const i = n % (this._swingTicks * 2) / (this._swingTicks * 2), s = Math.sin(i * Math.PI) * this._swingAmount;
      t += new Ur(this.context, this._swingTicks * 2 / 3).toSeconds() * s;
    }
    Mx(!0), this._timeline.forEachAtTime(n, (i) => i.invoke(t)), Mx(!1);
  }
  //-------------------------------------
  // 	SCHEDULABLE EVENTS
  //-------------------------------------
  /**
   * Schedule an event along the timeline.
   * @param callback The callback to be invoked at the time.
   * @param time The time to invoke the callback at.
   * @return The id of the event which can be used for canceling the event.
   * @example
   * // schedule an event on the 16th measure
   * Tone.getTransport().schedule((time) => {
   * 	// invoked on measure 16
   * 	console.log("measure 16!");
   * }, "16:0:0");
   */
  schedule(t, n) {
    const i = new jd(this, {
      callback: t,
      time: new Hf(this.context, n).toTicks()
    });
    return this._addEvent(i, this._timeline);
  }
  /**
   * Schedule a repeated event along the timeline. The event will fire
   * at the `interval` starting at the `startTime` and for the specified
   * `duration`.
   * @param  callback   The callback to invoke.
   * @param  interval   The duration between successive callbacks. Must be a positive number.
   * @param  startTime  When along the timeline the events should start being invoked.
   * @param  duration How long the event should repeat.
   * @return  The ID of the scheduled event. Use this to cancel the event.
   * @example
   * const osc = new Tone.Oscillator().toDestination().start();
   * // a callback invoked every eighth note after the first measure
   * Tone.getTransport().scheduleRepeat((time) => {
   * 	osc.start(time).stop(time + 0.1);
   * }, "8n", "1m");
   */
  scheduleRepeat(t, n, i, s = 1 / 0) {
    const o = new P_(this, {
      callback: t,
      duration: new _l(this.context, s).toTicks(),
      interval: new _l(this.context, n).toTicks(),
      time: new Hf(this.context, i).toTicks()
    });
    return this._addEvent(o, this._repeatedEvents);
  }
  /**
   * Schedule an event that will be removed after it is invoked.
   * @param callback The callback to invoke once.
   * @param time The time the callback should be invoked.
   * @returns The ID of the scheduled event.
   */
  scheduleOnce(t, n) {
    const i = new jd(this, {
      callback: t,
      once: !0,
      time: new Hf(this.context, n).toTicks()
    });
    return this._addEvent(i, this._timeline);
  }
  /**
   * Clear the passed in event id from the timeline
   * @param eventId The id of the event.
   */
  clear(t) {
    if (this._scheduledEvents.hasOwnProperty(t)) {
      const n = this._scheduledEvents[t.toString()];
      n.timeline.remove(n.event), n.event.dispose(), delete this._scheduledEvents[t.toString()];
    }
    return this;
  }
  /**
   * Add an event to the correct timeline. Keep track of the
   * timeline it was added to.
   * @returns the event id which was just added
   */
  _addEvent(t, n) {
    return this._scheduledEvents[t.id.toString()] = {
      event: t,
      timeline: n
    }, n.add(t), t.id;
  }
  /**
   * Remove scheduled events from the timeline after
   * the given time. Repeated events will be removed
   * if their startTime is after the given time
   * @param after Clear all events after this time.
   */
  cancel(t = 0) {
    const n = this.toTicks(t);
    return this._timeline.forEachFrom(n, (i) => this.clear(i.id)), this._repeatedEvents.forEachFrom(n, (i) => this.clear(i.id)), this;
  }
  //-------------------------------------
  // 	START/STOP/PAUSE
  //-------------------------------------
  /**
   * Bind start/stop/pause events from the clock and emit them.
   */
  _bindClockEvents() {
    this._clock.on("start", (t, n) => {
      n = new Ur(this.context, n).toSeconds(), this.emit("start", t, n);
    }), this._clock.on("stop", (t) => {
      this.emit("stop", t);
    }), this._clock.on("pause", (t) => {
      this.emit("pause", t);
    });
  }
  /**
   * Returns the playback state of the source, either "started", "stopped", or "paused"
   */
  get state() {
    return this._clock.getStateAtTime(this.now());
  }
  /**
   * Start the transport and all sources synced to the transport.
   * @param  time The time when the transport should start.
   * @param  offset The timeline offset to start the transport.
   * @example
   * // start the transport in one second starting at beginning of the 5th measure.
   * Tone.getTransport().start("+1", "4:0:0");
   */
  start(t, n) {
    this.context.resume();
    let i;
    return _n(n) && (i = this.toTicks(n)), this._clock.start(t, i), this;
  }
  /**
   * Stop the transport and all sources synced to the transport.
   * @param time The time when the transport should stop.
   * @example
   * Tone.getTransport().stop();
   */
  stop(t) {
    return this._clock.stop(t), this;
  }
  /**
   * Pause the transport and all sources synced to the transport.
   */
  pause(t) {
    return this._clock.pause(t), this;
  }
  /**
   * Toggle the current state of the transport. If it is
   * started, it will stop it, otherwise it will start the Transport.
   * @param  time The time of the event
   */
  toggle(t) {
    return t = this.toSeconds(t), this._clock.getStateAtTime(t) !== "started" ? this.start(t) : this.stop(t), this;
  }
  //-------------------------------------
  // 	SETTERS/GETTERS
  //-------------------------------------
  /**
   * The time signature as just the numerator over 4.
   * For example 4/4 would be just 4 and 6/8 would be 3.
   * @example
   * // common time
   * Tone.getTransport().timeSignature = 4;
   * // 7/8
   * Tone.getTransport().timeSignature = [7, 8];
   * // this will be reduced to a single number
   * Tone.getTransport().timeSignature; // returns 3.5
   */
  get timeSignature() {
    return this._timeSignature;
  }
  set timeSignature(t) {
    Ts(t) && (t = t[0] / t[1] * 4), this._timeSignature = t;
  }
  /**
   * When the Transport.loop = true, this is the starting position of the loop.
   */
  get loopStart() {
    return new _l(this.context, this._loopStart, "i").toSeconds();
  }
  set loopStart(t) {
    this._loopStart = this.toTicks(t);
  }
  /**
   * When the Transport.loop = true, this is the ending position of the loop.
   */
  get loopEnd() {
    return new _l(this.context, this._loopEnd, "i").toSeconds();
  }
  set loopEnd(t) {
    this._loopEnd = this.toTicks(t);
  }
  /**
   * If the transport loops or not.
   */
  get loop() {
    return this._loop.get(this.now());
  }
  set loop(t) {
    this._loop.set(t, this.now());
  }
  /**
   * Set the loop start and stop at the same time.
   * @example
   * // loop over the first measure
   * Tone.getTransport().setLoopPoints(0, "1m");
   * Tone.getTransport().loop = true;
   */
  setLoopPoints(t, n) {
    return this.loopStart = t, this.loopEnd = n, this;
  }
  /**
   * The swing value. Between 0-1 where 1 equal to the note + half the subdivision.
   */
  get swing() {
    return this._swingAmount;
  }
  set swing(t) {
    this._swingAmount = t;
  }
  /**
   * Set the subdivision which the swing will be applied to.
   * The default value is an 8th note. Value must be less
   * than a quarter note.
   */
  get swingSubdivision() {
    return new Ur(this.context, this._swingTicks).toNotation();
  }
  set swingSubdivision(t) {
    this._swingTicks = this.toTicks(t);
  }
  /**
   * The Transport's position in Bars:Beats:Sixteenths.
   * Setting the value will jump to that position right away.
   */
  get position() {
    const t = this.now(), n = this._clock.getTicksAtTime(t);
    return new Ur(this.context, n).toBarsBeatsSixteenths();
  }
  set position(t) {
    const n = this.toTicks(t);
    this.ticks = n;
  }
  /**
   * The Transport's position in seconds.
   * Setting the value will jump to that position right away.
   */
  get seconds() {
    return this._clock.seconds;
  }
  set seconds(t) {
    const n = this.now(), i = this._clock.frequency.timeToTicks(t, n);
    this.ticks = i;
  }
  /**
   * The Transport's loop position as a normalized value. Always
   * returns 0 if the Transport.loop = false.
   */
  get progress() {
    if (this.loop) {
      const t = this.now();
      return (this._clock.getTicksAtTime(t) - this._loopStart) / (this._loopEnd - this._loopStart);
    } else
      return 0;
  }
  /**
   * The Transport's current tick position.
   */
  get ticks() {
    return this._clock.ticks;
  }
  set ticks(t) {
    if (this._clock.ticks !== t) {
      const n = this.now();
      if (this.state === "started") {
        const i = this._clock.getTicksAtTime(n), s = this._clock.frequency.getDurationOfTicks(Math.ceil(i) - i, n), o = n + s;
        this.emit("stop", o), this._clock.setTicksAtTime(t, o), this.emit("start", o, this._clock.getSecondsAtTime(o));
      } else
        this.emit("ticks", n), this._clock.setTicksAtTime(t, n);
    }
  }
  /**
   * Get the clock's ticks at the given time.
   * @param  time  When to get the tick value
   * @return The tick value at the given time.
   */
  getTicksAtTime(t) {
    return this._clock.getTicksAtTime(t);
  }
  /**
   * Return the elapsed seconds at the given time.
   * @param  time  When to get the elapsed seconds
   * @return  The number of elapsed seconds
   */
  getSecondsAtTime(t) {
    return this._clock.getSecondsAtTime(t);
  }
  /**
   * Pulses Per Quarter note. This is the smallest resolution
   * the Transport timing supports. This should be set once
   * on initialization and not set again. Changing this value
   * after other objects have been created can cause problems.
   */
  get PPQ() {
    return this._clock.frequency.multiplier;
  }
  set PPQ(t) {
    this._clock.frequency.multiplier = t;
  }
  //-------------------------------------
  // 	SYNCING
  //-------------------------------------
  /**
   * Returns the time aligned to the next subdivision
   * of the Transport. If the Transport is not started,
   * it will return 0.
   * Note: this will not work precisely during tempo ramps.
   * @param  subdivision  The subdivision to quantize to
   * @return  The context time of the next subdivision.
   * @example
   * // the transport must be started, otherwise returns 0
   * Tone.getTransport().start();
   * Tone.getTransport().nextSubdivision("4n");
   */
  nextSubdivision(t) {
    if (t = this.toTicks(t), this.state !== "started")
      return 0;
    {
      const n = this.now(), i = this.getTicksAtTime(n), s = t - i % t;
      return this._clock.nextTickTime(s, n);
    }
  }
  /**
   * Attaches the signal to the tempo control signal so that
   * any changes in the tempo will change the signal in the same
   * ratio.
   *
   * @param signal
   * @param ratio Optionally pass in the ratio between the two signals.
   * 			Otherwise it will be computed based on their current values.
   */
  syncSignal(t, n) {
    const i = this.now();
    let s = this.bpm, o = 1 / (60 / s.getValueAtTime(i) / this.PPQ), u = [];
    if (t.units === "time") {
      const f = 0.015625 / o, p = new Da(f), g = new z_(-1), v = new Da(f);
      s.chain(p, g, v), s = v, o = 1 / o, u = [p, g, v];
    }
    n || (t.getValueAtTime(i) !== 0 ? n = t.getValueAtTime(i) / o : n = 0);
    const h = new Da(n);
    return s.connect(h), h.connect(t._param), u.push(h), this._syncedSignals.push({
      initial: t.value,
      nodes: u,
      signal: t
    }), t.value = 0, this;
  }
  /**
   * Unsyncs a previously synced signal from the transport's control.
   * @see {@link syncSignal}.
   */
  unsyncSignal(t) {
    for (let n = this._syncedSignals.length - 1; n >= 0; n--) {
      const i = this._syncedSignals[n];
      i.signal === t && (i.nodes.forEach((s) => s.dispose()), i.signal.value = i.initial, this._syncedSignals.splice(n, 1));
    }
    return this;
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this._clock.dispose(), N6(this, "bpm"), this._timeline.dispose(), this._repeatedEvents.dispose(), this;
  }
}
t0.mixin(rv);
tv((e) => {
  e.transport = new rv({ context: e });
});
ev((e) => {
  e.transport.dispose();
});
class Js extends wn {
  constructor(t) {
    super(t), this.input = void 0, this._state = new e0("stopped"), this._synced = !1, this._scheduled = [], this._syncedStart = ei, this._syncedStop = ei, this._state.memory = 100, this._state.increasing = !0, this._volume = this.output = new bp({
      context: this.context,
      mute: t.mute,
      volume: t.volume
    }), this.volume = this._volume.volume, or(this, "volume"), this.onstop = t.onstop;
  }
  static getDefaults() {
    return Object.assign(wn.getDefaults(), {
      mute: !1,
      onstop: ei,
      volume: 0
    });
  }
  /**
   * Returns the playback state of the source, either "started" or "stopped".
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/ahntone_c3.mp3", () => {
   * 	player.start();
   * 	console.log(player.state);
   * }).toDestination();
   */
  get state() {
    return this._synced ? this.context.transport.state === "started" ? this._state.getValueAtTime(this.context.transport.seconds) : "stopped" : this._state.getValueAtTime(this.now());
  }
  /**
   * Mute the output.
   * @example
   * const osc = new Tone.Oscillator().toDestination().start();
   * // mute the output
   * osc.mute = true;
   */
  get mute() {
    return this._volume.mute;
  }
  set mute(t) {
    this._volume.mute = t;
  }
  /**
   * Ensure that the scheduled time is not before the current time.
   * Should only be used when scheduled unsynced.
   */
  _clampToCurrentTime(t) {
    return this._synced ? t : Math.max(t, this.context.currentTime);
  }
  /**
   * Start the source at the specified time. If no time is given,
   * start the source now.
   * @param  time When the source should be started.
   * @example
   * const source = new Tone.Oscillator().toDestination();
   * source.start("+0.5"); // starts the source 0.5 seconds from now
   */
  start(t, n, i) {
    let s = $s(t) && this._synced ? this.context.transport.seconds : this.toSeconds(t);
    if (s = this._clampToCurrentTime(s), !this._synced && this._state.getValueAtTime(s) === "started")
      nn(ep(s, this._state.get(s).time), "Start time must be strictly greater than previous start time"), this._state.cancel(s), this._state.setStateAtTime("started", s), this.log("restart", s), this.restart(s, n, i);
    else if (this.log("start", s), this._state.setStateAtTime("started", s), this._synced) {
      const o = this._state.get(s);
      o && (o.offset = this.toSeconds(Ec(n, 0)), o.duration = i ? this.toSeconds(i) : void 0);
      const u = this.context.transport.schedule((h) => {
        this._start(h, n, i);
      }, s);
      this._scheduled.push(u), this.context.transport.state === "started" && this.context.transport.getSecondsAtTime(this.immediate()) > s && this._syncedStart(this.now(), this.context.transport.seconds);
    } else
      T6(this.context), this._start(s, n, i);
    return this;
  }
  /**
   * Stop the source at the specified time. If no time is given,
   * stop the source now.
   * @param  time When the source should be stopped.
   * @example
   * const source = new Tone.Oscillator().toDestination();
   * source.start();
   * source.stop("+0.5"); // stops the source 0.5 seconds from now
   */
  stop(t) {
    let n = $s(t) && this._synced ? this.context.transport.seconds : this.toSeconds(t);
    if (n = this._clampToCurrentTime(n), this._state.getValueAtTime(n) === "started" || _n(this._state.getNextState("started", n))) {
      if (this.log("stop", n), !this._synced)
        this._stop(n);
      else {
        const i = this.context.transport.schedule(this._stop.bind(this), n);
        this._scheduled.push(i);
      }
      this._state.cancel(n), this._state.setStateAtTime("stopped", n);
    }
    return this;
  }
  /**
   * Restart the source.
   */
  restart(t, n, i) {
    return t = this.toSeconds(t), this._state.getValueAtTime(t) === "started" && (this._state.cancel(t), this._restart(t, n, i)), this;
  }
  /**
   * Sync the source to the Transport so that all subsequent
   * calls to `start` and `stop` are synced to the TransportTime
   * instead of the AudioContext time.
   *
   * @example
   * const osc = new Tone.Oscillator().toDestination();
   * // sync the source so that it plays between 0 and 0.3 on the Transport's timeline
   * osc.sync().start(0).stop(0.3);
   * // start the transport.
   * Tone.Transport.start();
   * // set it to loop once a second
   * Tone.Transport.loop = true;
   * Tone.Transport.loopEnd = 1;
   */
  sync() {
    return this._synced || (this._synced = !0, this._syncedStart = (t, n) => {
      if (ep(n, 0)) {
        const i = this._state.get(n);
        if (i && i.state === "started" && i.time !== n) {
          const s = n - this.toSeconds(i.time);
          let o;
          i.duration && (o = this.toSeconds(i.duration) - s), this._start(t, this.toSeconds(i.offset) + s, o);
        }
      }
    }, this._syncedStop = (t) => {
      const n = this.context.transport.getSecondsAtTime(Math.max(t - this.sampleTime, 0));
      this._state.getValueAtTime(n) === "started" && this._stop(t);
    }, this.context.transport.on("start", this._syncedStart), this.context.transport.on("loopStart", this._syncedStart), this.context.transport.on("stop", this._syncedStop), this.context.transport.on("pause", this._syncedStop), this.context.transport.on("loopEnd", this._syncedStop)), this;
  }
  /**
   * Unsync the source to the Transport.
   * @see {@link sync}
   */
  unsync() {
    return this._synced && (this.context.transport.off("stop", this._syncedStop), this.context.transport.off("pause", this._syncedStop), this.context.transport.off("loopEnd", this._syncedStop), this.context.transport.off("start", this._syncedStart), this.context.transport.off("loopStart", this._syncedStart)), this._synced = !1, this._scheduled.forEach((t) => this.context.transport.clear(t)), this._scheduled = [], this._state.cancel(0), this._stop(0), this;
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this.onstop = ei, this.unsync(), this._volume.dispose(), this._state.dispose(), this;
  }
}
class av extends np {
  constructor() {
    const t = on(av.getDefaults(), arguments, ["url", "onload"]);
    super(t), this.name = "ToneBufferSource", this._source = this.context.createBufferSource(), this._internalChannels = [this._source], this._sourceStarted = !1, this._sourceStopped = !1, vp(this._source, this._gainNode), this._source.onended = () => this._stopSource(), this.playbackRate = new Yi({
      context: this.context,
      param: this._source.playbackRate,
      units: "positive",
      value: t.playbackRate
    }), this.loop = t.loop, this.loopStart = t.loopStart, this.loopEnd = t.loopEnd, this._buffer = new Si(t.url, t.onload, t.onerror), this._internalChannels.push(this._source);
  }
  static getDefaults() {
    return Object.assign(np.getDefaults(), {
      url: new Si(),
      loop: !1,
      loopEnd: 0,
      loopStart: 0,
      onload: ei,
      onerror: ei,
      playbackRate: 1
    });
  }
  /**
   * The fadeIn time of the amplitude envelope.
   */
  get fadeIn() {
    return this._fadeIn;
  }
  set fadeIn(t) {
    this._fadeIn = t;
  }
  /**
   * The fadeOut time of the amplitude envelope.
   */
  get fadeOut() {
    return this._fadeOut;
  }
  set fadeOut(t) {
    this._fadeOut = t;
  }
  /**
   * The curve applied to the fades, either "linear" or "exponential"
   */
  get curve() {
    return this._curve;
  }
  set curve(t) {
    this._curve = t;
  }
  /**
   * Start the buffer
   * @param  time When the player should start.
   * @param  offset The offset from the beginning of the sample to start at.
   * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)
   * @param  gain  The gain to play the buffer back at.
   */
  start(t, n, i, s = 1) {
    nn(this.buffer.loaded, "buffer is either not set or not loaded");
    const o = this.toSeconds(t);
    this._startGain(o, s), this.loop ? n = Ec(n, this.loopStart) : n = Ec(n, 0);
    let u = Math.max(this.toSeconds(n), 0);
    if (this.loop) {
      const h = this.toSeconds(this.loopEnd) || this.buffer.duration, f = this.toSeconds(this.loopStart), p = h - f;
      h2(u, h) && (u = (u - f) % p + f), bl(u, this.buffer.duration) && (u = 0);
    }
    if (this._source.buffer = this.buffer.get(), this._source.loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration, y1(u, this.buffer.duration) && (this._sourceStarted = !0, this._source.start(o, u)), _n(i)) {
      let h = this.toSeconds(i);
      h = Math.max(h, 0), this.stop(o + h);
    }
    return this;
  }
  _stopSource(t) {
    !this._sourceStopped && this._sourceStarted && (this._sourceStopped = !0, this._source.stop(this.toSeconds(t)), this._onended());
  }
  /**
   * If loop is true, the loop will start at this position.
   */
  get loopStart() {
    return this._source.loopStart;
  }
  set loopStart(t) {
    this._source.loopStart = this.toSeconds(t);
  }
  /**
   * If loop is true, the loop will end at this position.
   */
  get loopEnd() {
    return this._source.loopEnd;
  }
  set loopEnd(t) {
    this._source.loopEnd = this.toSeconds(t);
  }
  /**
   * The audio buffer belonging to the player.
   */
  get buffer() {
    return this._buffer;
  }
  set buffer(t) {
    this._buffer.set(t);
  }
  /**
   * If the buffer should loop once it's over.
   */
  get loop() {
    return this._source.loop;
  }
  set loop(t) {
    this._source.loop = t, this._sourceStarted && this.cancelStop();
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this._source.onended = null, this._source.disconnect(), this._buffer.dispose(), this.playbackRate.dispose(), this;
  }
}
function Fh(e, t) {
  return Nr(this, void 0, void 0, function* () {
    const n = t / e.context.sampleRate, i = new E_(1, n, e.context.sampleRate);
    return new e.constructor(Object.assign(e.get(), {
      // should do 2 iterations
      frequency: 2 / n,
      // zero out the detune
      detune: 0,
      context: i
    })).toDestination().start(0), (yield i.render()).getChannelData(0);
  });
}
class U_ extends np {
  constructor() {
    const t = on(U_.getDefaults(), arguments, ["frequency", "type"]);
    super(t), this.name = "ToneOscillatorNode", this._oscillator = this.context.createOscillator(), this._internalChannels = [this._oscillator], vp(this._oscillator, this._gainNode), this.type = t.type, this.frequency = new Yi({
      context: this.context,
      param: this._oscillator.frequency,
      units: "frequency",
      value: t.frequency
    }), this.detune = new Yi({
      context: this.context,
      param: this._oscillator.detune,
      units: "cents",
      value: t.detune
    }), or(this, ["frequency", "detune"]);
  }
  static getDefaults() {
    return Object.assign(np.getDefaults(), {
      detune: 0,
      frequency: 440,
      type: "sine"
    });
  }
  /**
   * Start the oscillator node at the given time
   * @param  time When to start the oscillator
   */
  start(t) {
    const n = this.toSeconds(t);
    return this.log("start", n), this._startGain(n), this._oscillator.start(n), this;
  }
  _stopSource(t) {
    this._oscillator.stop(t);
  }
  /**
   * Sets an arbitrary custom periodic waveform given a PeriodicWave.
   * @param  periodicWave PeriodicWave should be created with context.createPeriodicWave
   */
  setPeriodicWave(t) {
    return this._oscillator.setPeriodicWave(t), this;
  }
  /**
   * The oscillator type. Either 'sine', 'sawtooth', 'square', or 'triangle'
   */
  get type() {
    return this._oscillator.type;
  }
  set type(t) {
    this._oscillator.type = t;
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this.state === "started" && this.stop(), this._oscillator.disconnect(), this.frequency.dispose(), this.detune.dispose(), this;
  }
}
class Or extends Js {
  constructor() {
    const t = on(Or.getDefaults(), arguments, ["frequency", "type"]);
    super(t), this.name = "Oscillator", this._oscillator = null, this.frequency = new Jr({
      context: this.context,
      units: "frequency",
      value: t.frequency
    }), or(this, "frequency"), this.detune = new Jr({
      context: this.context,
      units: "cents",
      value: t.detune
    }), or(this, "detune"), this._partials = t.partials, this._partialCount = t.partialCount, this._type = t.type, t.partialCount && t.type !== "custom" && (this._type = this.baseType + t.partialCount.toString()), this.phase = t.phase;
  }
  static getDefaults() {
    return Object.assign(Js.getDefaults(), {
      detune: 0,
      frequency: 440,
      partialCount: 0,
      partials: [],
      phase: 0,
      type: "sine"
    });
  }
  /**
   * start the oscillator
   */
  _start(t) {
    const n = this.toSeconds(t), i = new U_({
      context: this.context,
      onended: () => this.onstop(this)
    });
    this._oscillator = i, this._wave ? this._oscillator.setPeriodicWave(this._wave) : this._oscillator.type = this._type, this._oscillator.connect(this.output), this.frequency.connect(this._oscillator.frequency), this.detune.connect(this._oscillator.detune), this._oscillator.start(n);
  }
  /**
   * stop the oscillator
   */
  _stop(t) {
    const n = this.toSeconds(t);
    this._oscillator && this._oscillator.stop(n);
  }
  /**
   * Restart the oscillator. Does not stop the oscillator, but instead
   * just cancels any scheduled 'stop' from being invoked.
   */
  _restart(t) {
    const n = this.toSeconds(t);
    return this.log("restart", n), this._oscillator && this._oscillator.cancelStop(), this._state.cancel(n), this;
  }
  /**
   * Sync the signal to the Transport's bpm. Any changes to the transports bpm,
   * will also affect the oscillators frequency.
   * @example
   * const osc = new Tone.Oscillator().toDestination().start();
   * osc.frequency.value = 440;
   * // the ratio between the bpm and the frequency will be maintained
   * osc.syncFrequency();
   * // double the tempo
   * Tone.Transport.bpm.value *= 2;
   * // the frequency of the oscillator is doubled to 880
   */
  syncFrequency() {
    return this.context.transport.syncSignal(this.frequency), this;
  }
  /**
   * Unsync the oscillator's frequency from the Transport.
   * @see {@link syncFrequency}
   */
  unsyncFrequency() {
    return this.context.transport.unsyncSignal(this.frequency), this;
  }
  /**
   * Get a cached periodic wave. Avoids having to recompute
   * the oscillator values when they have already been computed
   * with the same values.
   */
  _getCachedPeriodicWave() {
    if (this._type === "custom")
      return Or._periodicWaveCache.find((n) => n.phase === this._phase && AP(n.partials, this._partials));
    {
      const t = Or._periodicWaveCache.find((n) => n.type === this._type && n.phase === this._phase);
      return this._partialCount = t ? t.partialCount : this._partialCount, t;
    }
  }
  get type() {
    return this._type;
  }
  set type(t) {
    this._type = t;
    const n = ["sine", "square", "sawtooth", "triangle"].indexOf(t) !== -1;
    if (this._phase === 0 && n)
      this._wave = void 0, this._partialCount = 0, this._oscillator !== null && (this._oscillator.type = t);
    else {
      const i = this._getCachedPeriodicWave();
      if (_n(i)) {
        const { partials: s, wave: o } = i;
        this._wave = o, this._partials = s, this._oscillator !== null && this._oscillator.setPeriodicWave(this._wave);
      } else {
        const [s, o] = this._getRealImaginary(t, this._phase), u = this.context.createPeriodicWave(s, o);
        this._wave = u, this._oscillator !== null && this._oscillator.setPeriodicWave(this._wave), Or._periodicWaveCache.push({
          imag: o,
          partialCount: this._partialCount,
          partials: this._partials,
          phase: this._phase,
          real: s,
          type: this._type,
          wave: this._wave
        }), Or._periodicWaveCache.length > 100 && Or._periodicWaveCache.shift();
      }
    }
  }
  get baseType() {
    return this._type.replace(this.partialCount.toString(), "");
  }
  set baseType(t) {
    this.partialCount && this._type !== "custom" && t !== "custom" ? this.type = t + this.partialCount : this.type = t;
  }
  get partialCount() {
    return this._partialCount;
  }
  set partialCount(t) {
    Ud(t, 0);
    let n = this._type;
    const i = /^(sine|triangle|square|sawtooth)(\d+)$/.exec(this._type);
    if (i && (n = i[1]), this._type !== "custom")
      t === 0 ? this.type = n : this.type = n + t.toString();
    else {
      const s = new Float32Array(t);
      this._partials.forEach((o, u) => s[u] = o), this._partials = Array.from(s), this.type = this._type;
    }
  }
  /**
   * Returns the real and imaginary components based
   * on the oscillator type.
   * @returns [real: Float32Array, imaginary: Float32Array]
   */
  _getRealImaginary(t, n) {
    let s = 2048;
    const o = new Float32Array(s), u = new Float32Array(s);
    let h = 1;
    if (t === "custom") {
      if (h = this._partials.length + 1, this._partialCount = this._partials.length, s = h, this._partials.length === 0)
        return [o, u];
    } else {
      const f = /^(sine|triangle|square|sawtooth)(\d+)$/.exec(t);
      f ? (h = parseInt(f[2], 10) + 1, this._partialCount = parseInt(f[2], 10), t = f[1], h = Math.max(h, 2), s = h) : this._partialCount = 0, this._partials = [];
    }
    for (let f = 1; f < s; ++f) {
      const p = 2 / (f * Math.PI);
      let g;
      switch (t) {
        case "sine":
          g = f <= h ? 1 : 0, this._partials[f - 1] = g;
          break;
        case "square":
          g = f & 1 ? 2 * p : 0, this._partials[f - 1] = g;
          break;
        case "sawtooth":
          g = p * (f & 1 ? 1 : -1), this._partials[f - 1] = g;
          break;
        case "triangle":
          f & 1 ? g = 2 * (p * p) * (f - 1 >> 1 & 1 ? -1 : 1) : g = 0, this._partials[f - 1] = g;
          break;
        case "custom":
          g = this._partials[f - 1];
          break;
        default:
          throw new TypeError("Oscillator: invalid type: " + t);
      }
      g !== 0 ? (o[f] = -g * Math.sin(n * f), u[f] = g * Math.cos(n * f)) : (o[f] = 0, u[f] = 0);
    }
    return [o, u];
  }
  /**
   * Compute the inverse FFT for a given phase.
   */
  _inverseFFT(t, n, i) {
    let s = 0;
    const o = t.length;
    for (let u = 0; u < o; u++)
      s += t[u] * Math.cos(u * i) + n[u] * Math.sin(u * i);
    return s;
  }
  /**
   * Returns the initial value of the oscillator when stopped.
   * E.g. a "sine" oscillator with phase = 90 would return an initial value of -1.
   */
  getInitialValue() {
    const [t, n] = this._getRealImaginary(this._type, 0);
    let i = 0;
    const s = Math.PI * 2, o = 32;
    for (let u = 0; u < o; u++)
      i = Math.max(this._inverseFFT(t, n, u / o * s), i);
    return RP(-this._inverseFFT(t, n, this._phase) / i, -1, 1);
  }
  get partials() {
    return this._partials.slice(0, this.partialCount);
  }
  set partials(t) {
    this._partials = t, this._partialCount = this._partials.length, t.length && (this.type = "custom");
  }
  get phase() {
    return this._phase * (180 / Math.PI);
  }
  set phase(t) {
    this._phase = t * Math.PI / 180, this.type = this._type;
  }
  asArray() {
    return Nr(this, arguments, void 0, function* (t = 1024) {
      return Fh(this, t);
    });
  }
  dispose() {
    return super.dispose(), this._oscillator !== null && this._oscillator.dispose(), this._wave = void 0, this.frequency.dispose(), this.detune.dispose(), this;
  }
}
Or._periodicWaveCache = [];
class KP extends ip {
  constructor() {
    super(...arguments), this.name = "AudioToGain", this._norm = new n0({
      context: this.context,
      mapping: (t) => (t + 1) / 2
    }), this.input = this._norm, this.output = this._norm;
  }
  /**
   * clean up
   */
  dispose() {
    return super.dispose(), this._norm.dispose(), this;
  }
}
class rp extends Jr {
  constructor() {
    const t = on(rp.getDefaults(), arguments, ["value"]);
    super(t), this.name = "Multiply", this.override = !1, this._mult = this.input = this.output = new Da({
      context: this.context,
      minValue: t.minValue,
      maxValue: t.maxValue
    }), this.factor = this._param = this._mult.gain, this.factor.setValueAtTime(t.value, 0);
  }
  static getDefaults() {
    return Object.assign(Jr.getDefaults(), {
      value: 0
    });
  }
  dispose() {
    return super.dispose(), this._mult.dispose(), this;
  }
}
class sv extends Js {
  constructor() {
    const t = on(sv.getDefaults(), arguments, ["frequency", "type", "modulationType"]);
    super(t), this.name = "AMOscillator", this._modulationScale = new KP({ context: this.context }), this._modulationNode = new Da({
      context: this.context
    }), this._carrier = new Or({
      context: this.context,
      detune: t.detune,
      frequency: t.frequency,
      onstop: () => this.onstop(this),
      phase: t.phase,
      type: t.type
    }), this.frequency = this._carrier.frequency, this.detune = this._carrier.detune, this._modulator = new Or({
      context: this.context,
      phase: t.phase,
      type: t.modulationType
    }), this.harmonicity = new rp({
      context: this.context,
      units: "positive",
      value: t.harmonicity
    }), this.frequency.chain(this.harmonicity, this._modulator.frequency), this._modulator.chain(this._modulationScale, this._modulationNode.gain), this._carrier.chain(this._modulationNode, this.output), or(this, ["frequency", "detune", "harmonicity"]);
  }
  static getDefaults() {
    return Object.assign(Or.getDefaults(), {
      harmonicity: 1,
      modulationType: "square"
    });
  }
  /**
   * start the oscillator
   */
  _start(t) {
    this._modulator.start(t), this._carrier.start(t);
  }
  /**
   * stop the oscillator
   */
  _stop(t) {
    this._modulator.stop(t), this._carrier.stop(t);
  }
  _restart(t) {
    this._modulator.restart(t), this._carrier.restart(t);
  }
  /**
   * The type of the carrier oscillator
   */
  get type() {
    return this._carrier.type;
  }
  set type(t) {
    this._carrier.type = t;
  }
  get baseType() {
    return this._carrier.baseType;
  }
  set baseType(t) {
    this._carrier.baseType = t;
  }
  get partialCount() {
    return this._carrier.partialCount;
  }
  set partialCount(t) {
    this._carrier.partialCount = t;
  }
  /**
   * The type of the modulator oscillator
   */
  get modulationType() {
    return this._modulator.type;
  }
  set modulationType(t) {
    this._modulator.type = t;
  }
  get phase() {
    return this._carrier.phase;
  }
  set phase(t) {
    this._carrier.phase = t, this._modulator.phase = t;
  }
  get partials() {
    return this._carrier.partials;
  }
  set partials(t) {
    this._carrier.partials = t;
  }
  asArray() {
    return Nr(this, arguments, void 0, function* (t = 1024) {
      return Fh(this, t);
    });
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this.frequency.dispose(), this.detune.dispose(), this.harmonicity.dispose(), this._carrier.dispose(), this._modulator.dispose(), this._modulationNode.dispose(), this._modulationScale.dispose(), this;
  }
}
class ov extends Js {
  constructor() {
    const t = on(ov.getDefaults(), arguments, ["frequency", "type", "modulationType"]);
    super(t), this.name = "FMOscillator", this._modulationNode = new Da({
      context: this.context,
      gain: 0
    }), this._carrier = new Or({
      context: this.context,
      detune: t.detune,
      frequency: 0,
      onstop: () => this.onstop(this),
      phase: t.phase,
      type: t.type
    }), this.detune = this._carrier.detune, this.frequency = new Jr({
      context: this.context,
      units: "frequency",
      value: t.frequency
    }), this._modulator = new Or({
      context: this.context,
      phase: t.phase,
      type: t.modulationType
    }), this.harmonicity = new rp({
      context: this.context,
      units: "positive",
      value: t.harmonicity
    }), this.modulationIndex = new rp({
      context: this.context,
      units: "positive",
      value: t.modulationIndex
    }), this.frequency.connect(this._carrier.frequency), this.frequency.chain(this.harmonicity, this._modulator.frequency), this.frequency.chain(this.modulationIndex, this._modulationNode), this._modulator.connect(this._modulationNode.gain), this._modulationNode.connect(this._carrier.frequency), this._carrier.connect(this.output), this.detune.connect(this._modulator.detune), or(this, [
      "modulationIndex",
      "frequency",
      "detune",
      "harmonicity"
    ]);
  }
  static getDefaults() {
    return Object.assign(Or.getDefaults(), {
      harmonicity: 1,
      modulationIndex: 2,
      modulationType: "square"
    });
  }
  /**
   * start the oscillator
   */
  _start(t) {
    this._modulator.start(t), this._carrier.start(t);
  }
  /**
   * stop the oscillator
   */
  _stop(t) {
    this._modulator.stop(t), this._carrier.stop(t);
  }
  _restart(t) {
    return this._modulator.restart(t), this._carrier.restart(t), this;
  }
  get type() {
    return this._carrier.type;
  }
  set type(t) {
    this._carrier.type = t;
  }
  get baseType() {
    return this._carrier.baseType;
  }
  set baseType(t) {
    this._carrier.baseType = t;
  }
  get partialCount() {
    return this._carrier.partialCount;
  }
  set partialCount(t) {
    this._carrier.partialCount = t;
  }
  /**
   * The type of the modulator oscillator
   */
  get modulationType() {
    return this._modulator.type;
  }
  set modulationType(t) {
    this._modulator.type = t;
  }
  get phase() {
    return this._carrier.phase;
  }
  set phase(t) {
    this._carrier.phase = t, this._modulator.phase = t;
  }
  get partials() {
    return this._carrier.partials;
  }
  set partials(t) {
    this._carrier.partials = t;
  }
  asArray() {
    return Nr(this, arguments, void 0, function* (t = 1024) {
      return Fh(this, t);
    });
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this.frequency.dispose(), this.harmonicity.dispose(), this._carrier.dispose(), this._modulator.dispose(), this._modulationNode.dispose(), this.modulationIndex.dispose(), this;
  }
}
class i0 extends Js {
  constructor() {
    const t = on(i0.getDefaults(), arguments, ["frequency", "width"]);
    super(t), this.name = "PulseOscillator", this._widthGate = new Da({
      context: this.context,
      gain: 0
    }), this._thresh = new n0({
      context: this.context,
      mapping: (n) => n <= 0 ? -1 : 1
    }), this.width = new Jr({
      context: this.context,
      units: "audioRange",
      value: t.width
    }), this._triangle = new Or({
      context: this.context,
      detune: t.detune,
      frequency: t.frequency,
      onstop: () => this.onstop(this),
      phase: t.phase,
      type: "triangle"
    }), this.frequency = this._triangle.frequency, this.detune = this._triangle.detune, this._triangle.chain(this._thresh, this.output), this.width.chain(this._widthGate, this._thresh), or(this, ["width", "frequency", "detune"]);
  }
  static getDefaults() {
    return Object.assign(Js.getDefaults(), {
      detune: 0,
      frequency: 440,
      phase: 0,
      type: "pulse",
      width: 0.2
    });
  }
  /**
   * start the oscillator
   */
  _start(t) {
    t = this.toSeconds(t), this._triangle.start(t), this._widthGate.gain.setValueAtTime(1, t);
  }
  /**
   * stop the oscillator
   */
  _stop(t) {
    t = this.toSeconds(t), this._triangle.stop(t), this._widthGate.gain.cancelScheduledValues(t), this._widthGate.gain.setValueAtTime(0, t);
  }
  _restart(t) {
    this._triangle.restart(t), this._widthGate.gain.cancelScheduledValues(t), this._widthGate.gain.setValueAtTime(1, t);
  }
  /**
   * The phase of the oscillator in degrees.
   */
  get phase() {
    return this._triangle.phase;
  }
  set phase(t) {
    this._triangle.phase = t;
  }
  /**
   * The type of the oscillator. Always returns "pulse".
   */
  get type() {
    return "pulse";
  }
  /**
   * The baseType of the oscillator. Always returns "pulse".
   */
  get baseType() {
    return "pulse";
  }
  /**
   * The partials of the waveform. Cannot set partials for this waveform type
   */
  get partials() {
    return [];
  }
  /**
   * No partials for this waveform type.
   */
  get partialCount() {
    return 0;
  }
  /**
   * *Internal use* The carrier oscillator type is fed through the
   * waveshaper node to create the pulse. Using different carrier oscillators
   * changes oscillator's behavior.
   */
  set carrierType(t) {
    this._triangle.type = t;
  }
  asArray() {
    return Nr(this, arguments, void 0, function* (t = 1024) {
      return Fh(this, t);
    });
  }
  /**
   * Clean up method.
   */
  dispose() {
    return super.dispose(), this._triangle.dispose(), this.width.dispose(), this._widthGate.dispose(), this._thresh.dispose(), this;
  }
}
class lv extends Js {
  constructor() {
    const t = on(lv.getDefaults(), arguments, ["frequency", "type", "spread"]);
    super(t), this.name = "FatOscillator", this._oscillators = [], this.frequency = new Jr({
      context: this.context,
      units: "frequency",
      value: t.frequency
    }), this.detune = new Jr({
      context: this.context,
      units: "cents",
      value: t.detune
    }), this._spread = t.spread, this._type = t.type, this._phase = t.phase, this._partials = t.partials, this._partialCount = t.partialCount, this.count = t.count, or(this, ["frequency", "detune"]);
  }
  static getDefaults() {
    return Object.assign(Or.getDefaults(), {
      count: 3,
      spread: 20,
      type: "sawtooth"
    });
  }
  /**
   * start the oscillator
   */
  _start(t) {
    t = this.toSeconds(t), this._forEach((n) => n.start(t));
  }
  /**
   * stop the oscillator
   */
  _stop(t) {
    t = this.toSeconds(t), this._forEach((n) => n.stop(t));
  }
  _restart(t) {
    this._forEach((n) => n.restart(t));
  }
  /**
   * Iterate over all of the oscillators
   */
  _forEach(t) {
    for (let n = 0; n < this._oscillators.length; n++)
      t(this._oscillators[n], n);
  }
  /**
   * The type of the oscillator
   */
  get type() {
    return this._type;
  }
  set type(t) {
    this._type = t, this._forEach((n) => n.type = t);
  }
  /**
   * The detune spread between the oscillators. If "count" is
   * set to 3 oscillators and the "spread" is set to 40,
   * the three oscillators would be detuned like this: [-20, 0, 20]
   * for a total detune spread of 40 cents.
   * @example
   * const fatOsc = new Tone.FatOscillator().toDestination().start();
   * fatOsc.spread = 70;
   */
  get spread() {
    return this._spread;
  }
  set spread(t) {
    if (this._spread = t, this._oscillators.length > 1) {
      const n = -t / 2, i = t / (this._oscillators.length - 1);
      this._forEach((s, o) => s.detune.value = n + i * o);
    }
  }
  /**
   * The number of detuned oscillators. Must be an integer greater than 1.
   * @example
   * const fatOsc = new Tone.FatOscillator("C#3", "sawtooth").toDestination().start();
   * // use 4 sawtooth oscillators
   * fatOsc.count = 4;
   */
  get count() {
    return this._oscillators.length;
  }
  set count(t) {
    if (Ud(t, 1), this._oscillators.length !== t) {
      this._forEach((n) => n.dispose()), this._oscillators = [];
      for (let n = 0; n < t; n++) {
        const i = new Or({
          context: this.context,
          volume: -6 - t * 1.1,
          type: this._type,
          phase: this._phase + n / t * 360,
          partialCount: this._partialCount,
          onstop: n === 0 ? () => this.onstop(this) : ei
        });
        this.type === "custom" && (i.partials = this._partials), this.frequency.connect(i.frequency), this.detune.connect(i.detune), i.detune.overridden = !1, i.connect(this.output), this._oscillators[n] = i;
      }
      this.spread = this._spread, this.state === "started" && this._forEach((n) => n.start());
    }
  }
  get phase() {
    return this._phase;
  }
  set phase(t) {
    this._phase = t, this._forEach((n, i) => n.phase = this._phase + i / this.count * 360);
  }
  get baseType() {
    return this._oscillators[0].baseType;
  }
  set baseType(t) {
    this._forEach((n) => n.baseType = t), this._type = this._oscillators[0].type;
  }
  get partials() {
    return this._oscillators[0].partials;
  }
  set partials(t) {
    this._partials = t, this._partialCount = this._partials.length, t.length && (this._type = "custom", this._forEach((n) => n.partials = t));
  }
  get partialCount() {
    return this._oscillators[0].partialCount;
  }
  set partialCount(t) {
    this._partialCount = t, this._forEach((n) => n.partialCount = t), this._type = this._oscillators[0].type;
  }
  asArray() {
    return Nr(this, arguments, void 0, function* (t = 1024) {
      return Fh(this, t);
    });
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this.frequency.dispose(), this.detune.dispose(), this._forEach((t) => t.dispose()), this;
  }
}
class cv extends Js {
  constructor() {
    const t = on(cv.getDefaults(), arguments, ["frequency", "modulationFrequency"]);
    super(t), this.name = "PWMOscillator", this.sourceType = "pwm", this._scale = new rp({
      context: this.context,
      value: 2
    }), this._pulse = new i0({
      context: this.context,
      frequency: t.modulationFrequency
    }), this._pulse.carrierType = "sine", this.modulationFrequency = this._pulse.frequency, this._modulator = new Or({
      context: this.context,
      detune: t.detune,
      frequency: t.frequency,
      onstop: () => this.onstop(this),
      phase: t.phase
    }), this.frequency = this._modulator.frequency, this.detune = this._modulator.detune, this._modulator.chain(this._scale, this._pulse.width), this._pulse.connect(this.output), or(this, ["modulationFrequency", "frequency", "detune"]);
  }
  static getDefaults() {
    return Object.assign(Js.getDefaults(), {
      detune: 0,
      frequency: 440,
      modulationFrequency: 0.4,
      phase: 0,
      type: "pwm"
    });
  }
  /**
   * start the oscillator
   */
  _start(t) {
    t = this.toSeconds(t), this._modulator.start(t), this._pulse.start(t);
  }
  /**
   * stop the oscillator
   */
  _stop(t) {
    t = this.toSeconds(t), this._modulator.stop(t), this._pulse.stop(t);
  }
  /**
   * restart the oscillator
   */
  _restart(t) {
    this._modulator.restart(t), this._pulse.restart(t);
  }
  /**
   * The type of the oscillator. Always returns "pwm".
   */
  get type() {
    return "pwm";
  }
  /**
   * The baseType of the oscillator. Always returns "pwm".
   */
  get baseType() {
    return "pwm";
  }
  /**
   * The partials of the waveform. Cannot set partials for this waveform type
   */
  get partials() {
    return [];
  }
  /**
   * No partials for this waveform type.
   */
  get partialCount() {
    return 0;
  }
  /**
   * The phase of the oscillator in degrees.
   */
  get phase() {
    return this._modulator.phase;
  }
  set phase(t) {
    this._modulator.phase = t;
  }
  asArray() {
    return Nr(this, arguments, void 0, function* (t = 1024) {
      return Fh(this, t);
    });
  }
  /**
   * Clean up.
   */
  dispose() {
    return super.dispose(), this._pulse.dispose(), this._scale.dispose(), this._modulator.dispose(), this;
  }
}
const Ox = {
  am: sv,
  fat: lv,
  fm: ov,
  oscillator: Or,
  pulse: i0,
  pwm: cv
};
class b1 extends Js {
  constructor() {
    const t = on(b1.getDefaults(), arguments, ["frequency", "type"]);
    super(t), this.name = "OmniOscillator", this.frequency = new Jr({
      context: this.context,
      units: "frequency",
      value: t.frequency
    }), this.detune = new Jr({
      context: this.context,
      units: "cents",
      value: t.detune
    }), or(this, ["frequency", "detune"]), this.set(t);
  }
  static getDefaults() {
    return Object.assign(Or.getDefaults(), ov.getDefaults(), sv.getDefaults(), lv.getDefaults(), i0.getDefaults(), cv.getDefaults());
  }
  /**
   * start the oscillator
   */
  _start(t) {
    this._oscillator.start(t);
  }
  /**
   * start the oscillator
   */
  _stop(t) {
    this._oscillator.stop(t);
  }
  _restart(t) {
    return this._oscillator.restart(t), this;
  }
  /**
   * The type of the oscillator. Can be any of the basic types: sine, square, triangle, sawtooth. Or
   * prefix the basic types with "fm", "am", or "fat" to use the FMOscillator, AMOscillator or FatOscillator
   * types. The oscillator could also be set to "pwm" or "pulse". All of the parameters of the
   * oscillator's class are accessible when the oscillator is set to that type, but throws an error
   * when it's not.
   * @example
   * const omniOsc = new Tone.OmniOscillator().toDestination().start();
   * omniOsc.type = "pwm";
   * // modulationFrequency is parameter which is available
   * // only when the type is "pwm".
   * omniOsc.modulationFrequency.value = 0.5;
   */
  get type() {
    let t = "";
    return ["am", "fm", "fat"].some((n) => this._sourceType === n) && (t = this._sourceType), t + this._oscillator.type;
  }
  set type(t) {
    t.substr(0, 2) === "fm" ? (this._createNewOscillator("fm"), this._oscillator = this._oscillator, this._oscillator.type = t.substr(2)) : t.substr(0, 2) === "am" ? (this._createNewOscillator("am"), this._oscillator = this._oscillator, this._oscillator.type = t.substr(2)) : t.substr(0, 3) === "fat" ? (this._createNewOscillator("fat"), this._oscillator = this._oscillator, this._oscillator.type = t.substr(3)) : t === "pwm" ? (this._createNewOscillator("pwm"), this._oscillator = this._oscillator) : t === "pulse" ? this._createNewOscillator("pulse") : (this._createNewOscillator("oscillator"), this._oscillator = this._oscillator, this._oscillator.type = t);
  }
  /**
   * The value is an empty array when the type is not "custom".
   * This is not available on "pwm" and "pulse" oscillator types.
   * @see {@link Oscillator.partials}
   */
  get partials() {
    return this._oscillator.partials;
  }
  set partials(t) {
    !this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm") && (this._oscillator.partials = t);
  }
  get partialCount() {
    return this._oscillator.partialCount;
  }
  set partialCount(t) {
    !this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm") && (this._oscillator.partialCount = t);
  }
  set(t) {
    return Reflect.has(t, "type") && t.type && (this.type = t.type), super.set(t), this;
  }
  /**
   * connect the oscillator to the frequency and detune signals
   */
  _createNewOscillator(t) {
    if (t !== this._sourceType) {
      this._sourceType = t;
      const n = Ox[t], i = this.now();
      if (this._oscillator) {
        const s = this._oscillator;
        s.stop(i), this.context.setTimeout(() => s.dispose(), this.blockTime);
      }
      this._oscillator = new n({
        context: this.context
      }), this.frequency.connect(this._oscillator.frequency), this.detune.connect(this._oscillator.detune), this._oscillator.connect(this.output), this._oscillator.onstop = () => this.onstop(this), this.state === "started" && this._oscillator.start(i);
    }
  }
  get phase() {
    return this._oscillator.phase;
  }
  set phase(t) {
    this._oscillator.phase = t;
  }
  /**
   * The source type of the oscillator.
   * @example
   * const omniOsc = new Tone.OmniOscillator(440, "fmsquare");
   * console.log(omniOsc.sourceType); // 'fm'
   */
  get sourceType() {
    return this._sourceType;
  }
  set sourceType(t) {
    let n = "sine";
    this._oscillator.type !== "pwm" && this._oscillator.type !== "pulse" && (n = this._oscillator.type), t === "fm" ? this.type = "fm" + n : t === "am" ? this.type = "am" + n : t === "fat" ? this.type = "fat" + n : t === "oscillator" ? this.type = n : t === "pulse" ? this.type = "pulse" : t === "pwm" && (this.type = "pwm");
  }
  _getOscType(t, n) {
    return t instanceof Ox[n];
  }
  /**
   * The base type of the oscillator.
   * @see {@link Oscillator.baseType}
   * @example
   * const omniOsc = new Tone.OmniOscillator(440, "fmsquare4");
   * console.log(omniOsc.sourceType, omniOsc.baseType, omniOsc.partialCount);
   */
  get baseType() {
    return this._oscillator.baseType;
  }
  set baseType(t) {
    !this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm") && t !== "pulse" && t !== "pwm" && (this._oscillator.baseType = t);
  }
  /**
   * The width of the oscillator when sourceType === "pulse".
   * @see {@link PWMOscillator}
   */
  get width() {
    if (this._getOscType(this._oscillator, "pulse"))
      return this._oscillator.width;
  }
  /**
   * The number of detuned oscillators when sourceType === "fat".
   * @see {@link FatOscillator.count}
   */
  get count() {
    if (this._getOscType(this._oscillator, "fat"))
      return this._oscillator.count;
  }
  set count(t) {
    this._getOscType(this._oscillator, "fat") && Oc(t) && (this._oscillator.count = t);
  }
  /**
   * The detune spread between the oscillators when sourceType === "fat".
   * @see {@link FatOscillator.count}
   */
  get spread() {
    if (this._getOscType(this._oscillator, "fat"))
      return this._oscillator.spread;
  }
  set spread(t) {
    this._getOscType(this._oscillator, "fat") && Oc(t) && (this._oscillator.spread = t);
  }
  /**
   * The type of the modulator oscillator. Only if the oscillator is set to "am" or "fm" types.
   * @see {@link AMOscillator} or {@link FMOscillator}
   */
  get modulationType() {
    if (this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am"))
      return this._oscillator.modulationType;
  }
  set modulationType(t) {
    (this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am")) && ju(t) && (this._oscillator.modulationType = t);
  }
  /**
   * The modulation index when the sourceType === "fm"
   * @see {@link FMOscillator}.
   */
  get modulationIndex() {
    if (this._getOscType(this._oscillator, "fm"))
      return this._oscillator.modulationIndex;
  }
  /**
   * Harmonicity is the frequency ratio between the carrier and the modulator oscillators.
   * @see {@link AMOscillator} or {@link FMOscillator}
   */
  get harmonicity() {
    if (this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am"))
      return this._oscillator.harmonicity;
  }
  /**
   * The modulationFrequency Signal of the oscillator when sourceType === "pwm"
   * see {@link PWMOscillator}
   * @min 0.1
   * @max 5
   */
  get modulationFrequency() {
    if (this._getOscType(this._oscillator, "pwm"))
      return this._oscillator.modulationFrequency;
  }
  asArray() {
    return Nr(this, arguments, void 0, function* (t = 1024) {
      return Fh(this, t);
    });
  }
  dispose() {
    return super.dispose(), this.detune.dispose(), this.frequency.dispose(), this._oscillator.dispose(), this;
  }
}
function U6(e, t = 1 / 0) {
  const n = /* @__PURE__ */ new WeakMap();
  return function(i, s) {
    Reflect.defineProperty(i, s, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        return n.get(this);
      },
      set: function(o) {
        Ud(o, e, t), n.set(this, o);
      }
    });
  };
}
function Iu(e, t = 1 / 0) {
  const n = /* @__PURE__ */ new WeakMap();
  return function(i, s) {
    Reflect.defineProperty(i, s, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        return n.get(this);
      },
      set: function(o) {
        Ud(this.toSeconds(o), e, t), n.set(this, o);
      }
    });
  };
}
class r0 extends Js {
  constructor() {
    const t = on(r0.getDefaults(), arguments, [
      "url",
      "onload"
    ]);
    super(t), this.name = "Player", this._activeSources = /* @__PURE__ */ new Set(), this._buffer = new Si({
      onload: this._onload.bind(this, t.onload),
      onerror: t.onerror,
      reverse: t.reverse,
      url: t.url
    }), this.autostart = t.autostart, this._loop = t.loop, this._loopStart = t.loopStart, this._loopEnd = t.loopEnd, this._playbackRate = t.playbackRate, this.fadeIn = t.fadeIn, this.fadeOut = t.fadeOut;
  }
  static getDefaults() {
    return Object.assign(Js.getDefaults(), {
      autostart: !1,
      fadeIn: 0,
      fadeOut: 0,
      loop: !1,
      loopEnd: 0,
      loopStart: 0,
      onload: ei,
      onerror: ei,
      playbackRate: 1,
      reverse: !1
    });
  }
  /**
   * Load the audio file as an audio buffer.
   * Decodes the audio asynchronously and invokes
   * the callback once the audio buffer loads.
   * Note: this does not need to be called if a url
   * was passed in to the constructor. Only use this
   * if you want to manually load a new url.
   * @param url The url of the buffer to load. Filetype support depends on the browser.
   */
  load(t) {
    return Nr(this, void 0, void 0, function* () {
      return yield this._buffer.load(t), this._onload(), this;
    });
  }
  /**
   * Internal callback when the buffer is loaded.
   */
  _onload(t = ei) {
    t(), this.autostart && this.start();
  }
  /**
   * Internal callback when the buffer is done playing.
   */
  _onSourceEnd(t) {
    this.onstop(this), this._activeSources.delete(t), this._activeSources.size === 0 && !this._synced && this._state.getValueAtTime(this.now()) === "started" && (this._state.cancel(this.now()), this._state.setStateAtTime("stopped", this.now()));
  }
  /**
   * Play the buffer at the given startTime. Optionally add an offset
   * and/or duration which will play the buffer from a position
   * within the buffer for the given duration.
   *
   * @param  time When the player should start.
   * @param  offset The offset from the beginning of the sample to start at.
   * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)
   */
  start(t, n, i) {
    return super.start(t, n, i), this;
  }
  /**
   * Internal start method
   */
  _start(t, n, i) {
    this._loop ? n = Ec(n, this._loopStart) : n = Ec(n, 0);
    const s = this.toSeconds(n), o = i;
    i = Ec(i, Math.max(this._buffer.duration - s, 0));
    let u = this.toSeconds(i);
    u = u / this._playbackRate, t = this.toSeconds(t);
    const h = new av({
      url: this._buffer,
      context: this.context,
      fadeIn: this.fadeIn,
      fadeOut: this.fadeOut,
      loop: this._loop,
      loopEnd: this._loopEnd,
      loopStart: this._loopStart,
      onended: this._onSourceEnd.bind(this),
      playbackRate: this._playbackRate
    }).connect(this.output);
    !this._loop && !this._synced && (this._state.cancel(t + u), this._state.setStateAtTime("stopped", t + u, {
      implicitEnd: !0
    })), this._activeSources.add(h), this._loop && $s(o) ? h.start(t, s) : h.start(t, s, u - this.toSeconds(this.fadeOut));
  }
  /**
   * Stop playback.
   */
  _stop(t) {
    const n = this.toSeconds(t);
    this._activeSources.forEach((i) => i.stop(n));
  }
  /**
   * Stop and then restart the player from the beginning (or offset)
   * @param  time When the player should start.
   * @param  offset The offset from the beginning of the sample to start at.
   * @param  duration How long the sample should play. If no duration is given,
   * 					it will default to the full length of the sample (minus any offset)
   */
  restart(t, n, i) {
    return super.restart(t, n, i), this;
  }
  _restart(t, n, i) {
    var s;
    (s = [...this._activeSources].pop()) === null || s === void 0 || s.stop(t), this._start(t, n, i);
  }
  /**
   * Seek to a specific time in the player's buffer. If the
   * source is no longer playing at that time, it will stop.
   * @param offset The time to seek to.
   * @param when The time for the seek event to occur.
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/gurgling_theremin_1.mp3", () => {
   * 	player.start();
   * 	// seek to the offset in 1 second from now
   * 	player.seek(0.4, "+1");
   * }).toDestination();
   */
  seek(t, n) {
    const i = this.toSeconds(n);
    if (this._state.getValueAtTime(i) === "started") {
      const s = this.toSeconds(t);
      this._stop(i), this._start(i, s);
    }
    return this;
  }
  /**
   * Set the loop start and end. Will only loop if loop is set to true.
   * @param loopStart The loop start time
   * @param loopEnd The loop end time
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/malevoices_aa2_F3.mp3").toDestination();
   * // loop between the given points
   * player.setLoopPoints(0.2, 0.3);
   * player.loop = true;
   * player.autostart = true;
   */
  setLoopPoints(t, n) {
    return this.loopStart = t, this.loopEnd = n, this;
  }
  /**
   * If loop is true, the loop will start at this position.
   */
  get loopStart() {
    return this._loopStart;
  }
  set loopStart(t) {
    this._loopStart = t, this.buffer.loaded && Ud(this.toSeconds(t), 0, this.buffer.duration), this._activeSources.forEach((n) => {
      n.loopStart = t;
    });
  }
  /**
   * If loop is true, the loop will end at this position.
   */
  get loopEnd() {
    return this._loopEnd;
  }
  set loopEnd(t) {
    this._loopEnd = t, this.buffer.loaded && Ud(this.toSeconds(t), 0, this.buffer.duration), this._activeSources.forEach((n) => {
      n.loopEnd = t;
    });
  }
  /**
   * The audio buffer belonging to the player.
   */
  get buffer() {
    return this._buffer;
  }
  set buffer(t) {
    this._buffer.set(t);
  }
  /**
   * If the buffer should loop once it's over.
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/drum-samples/breakbeat.mp3").toDestination();
   * player.loop = true;
   * player.autostart = true;
   */
  get loop() {
    return this._loop;
  }
  set loop(t) {
    if (this._loop !== t && (this._loop = t, this._activeSources.forEach((n) => {
      n.loop = t;
    }), t)) {
      const n = this._state.getNextState("stopped", this.now());
      n && this._state.cancel(n.time);
    }
  }
  /**
   * Normal speed is 1. The pitch will change with the playback rate.
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/femalevoices_aa2_A5.mp3").toDestination();
   * // play at 1/4 speed
   * player.playbackRate = 0.25;
   * // play as soon as the buffer is loaded
   * player.autostart = true;
   */
  get playbackRate() {
    return this._playbackRate;
  }
  set playbackRate(t) {
    this._playbackRate = t;
    const n = this.now(), i = this._state.getNextState("stopped", n);
    i && i.implicitEnd && (this._state.cancel(i.time), this._activeSources.forEach((s) => s.cancelStop())), this._activeSources.forEach((s) => {
      s.playbackRate.setValueAtTime(t, n);
    });
  }
  /**
   * If the buffer should be reversed. Note that this sets the underlying {@link ToneAudioBuffer.reverse}, so
   * if multiple players are pointing at the same ToneAudioBuffer, they will all be reversed.
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/chime_1.mp3").toDestination();
   * player.autostart = true;
   * player.reverse = true;
   */
  get reverse() {
    return this._buffer.reverse;
  }
  set reverse(t) {
    this._buffer.reverse = t;
  }
  /**
   * If the buffer is loaded
   */
  get loaded() {
    return this._buffer.loaded;
  }
  dispose() {
    return super.dispose(), this._activeSources.forEach((t) => t.dispose()), this._activeSources.clear(), this._buffer.dispose(), this;
  }
}
Cl([
  Iu(0)
], r0.prototype, "fadeIn", void 0);
Cl([
  Iu(0)
], r0.prototype, "fadeOut", void 0);
class Fd extends wn {
  constructor() {
    const t = on(Fd.getDefaults(), arguments, ["attack", "decay", "sustain", "release"]);
    super(t), this.name = "Envelope", this._sig = new Jr({
      context: this.context,
      value: 0
    }), this.output = this._sig, this.input = void 0, this.attack = t.attack, this.decay = t.decay, this.sustain = t.sustain, this.release = t.release, this.attackCurve = t.attackCurve, this.releaseCurve = t.releaseCurve, this.decayCurve = t.decayCurve;
  }
  static getDefaults() {
    return Object.assign(wn.getDefaults(), {
      attack: 0.01,
      attackCurve: "linear",
      decay: 0.1,
      decayCurve: "exponential",
      release: 1,
      releaseCurve: "exponential",
      sustain: 0.5
    });
  }
  /**
   * Read the current value of the envelope. Useful for
   * synchronizing visual output to the envelope.
   */
  get value() {
    return this.getValueAtTime(this.now());
  }
  /**
   * Get the curve
   * @param  curve
   * @param  direction  In/Out
   * @return The curve name
   */
  _getCurve(t, n) {
    if (ju(t))
      return t;
    {
      let i;
      for (i in By)
        if (By[i][n] === t)
          return i;
      return t;
    }
  }
  /**
   * Assign a the curve to the given name using the direction
   * @param  name
   * @param  direction In/Out
   * @param  curve
   */
  _setCurve(t, n, i) {
    if (ju(i) && Reflect.has(By, i)) {
      const s = By[i];
      Dd(s) ? t !== "_decayCurve" && (this[t] = s[n]) : this[t] = s;
    } else if (Ts(i) && t !== "_decayCurve")
      this[t] = i;
    else
      throw new Error("Envelope: invalid curve: " + i);
  }
  /**
   * The shape of the attack.
   * Can be any of these strings:
   * * "linear"
   * * "exponential"
   * * "sine"
   * * "cosine"
   * * "bounce"
   * * "ripple"
   * * "step"
   *
   * Can also be an array which describes the curve. Values
   * in the array are evenly subdivided and linearly
   * interpolated over the duration of the attack.
   * @example
   * return Tone.Offline(() => {
   * 	const env = new Tone.Envelope(0.4).toDestination();
   * 	env.attackCurve = "linear";
   * 	env.triggerAttack();
   * }, 1, 1);
   */
  get attackCurve() {
    return this._getCurve(this._attackCurve, "In");
  }
  set attackCurve(t) {
    this._setCurve("_attackCurve", "In", t);
  }
  /**
   * The shape of the release. See the attack curve types.
   * @example
   * return Tone.Offline(() => {
   * 	const env = new Tone.Envelope({
   * 		release: 0.8
   * 	}).toDestination();
   * 	env.triggerAttack();
   * 	// release curve could also be defined by an array
   * 	env.releaseCurve = [1, 0.3, 0.4, 0.2, 0.7, 0];
   * 	env.triggerRelease(0.2);
   * }, 1, 1);
   */
  get releaseCurve() {
    return this._getCurve(this._releaseCurve, "Out");
  }
  set releaseCurve(t) {
    this._setCurve("_releaseCurve", "Out", t);
  }
  /**
   * The shape of the decay either "linear" or "exponential"
   * @example
   * return Tone.Offline(() => {
   * 	const env = new Tone.Envelope({
   * 		sustain: 0.1,
   * 		decay: 0.5
   * 	}).toDestination();
   * 	env.decayCurve = "linear";
   * 	env.triggerAttack();
   * }, 1, 1);
   */
  get decayCurve() {
    return this._getCurve(this._decayCurve, "Out");
  }
  set decayCurve(t) {
    this._setCurve("_decayCurve", "Out", t);
  }
  /**
   * Trigger the attack/decay portion of the ADSR envelope.
   * @param  time When the attack should start.
   * @param velocity The velocity of the envelope scales the vales.
   *                             number between 0-1
   * @example
   * const env = new Tone.AmplitudeEnvelope().toDestination();
   * const osc = new Tone.Oscillator().connect(env).start();
   * // trigger the attack 0.5 seconds from now with a velocity of 0.2
   * env.triggerAttack("+0.5", 0.2);
   */
  triggerAttack(t, n = 1) {
    this.log("triggerAttack", t, n), t = this.toSeconds(t);
    let s = this.toSeconds(this.attack);
    const o = this.toSeconds(this.decay), u = this.getValueAtTime(t);
    if (u > 0) {
      const h = 1 / s;
      s = (1 - u) / h;
    }
    if (s < this.sampleTime)
      this._sig.cancelScheduledValues(t), this._sig.setValueAtTime(n, t);
    else if (this._attackCurve === "linear")
      this._sig.linearRampTo(n, s, t);
    else if (this._attackCurve === "exponential")
      this._sig.targetRampTo(n, s, t);
    else {
      this._sig.cancelAndHoldAtTime(t);
      let h = this._attackCurve;
      for (let f = 1; f < h.length; f++)
        if (h[f - 1] <= u && u <= h[f]) {
          h = this._attackCurve.slice(f), h[0] = u;
          break;
        }
      this._sig.setValueCurveAtTime(h, t, s, n);
    }
    if (o && this.sustain < 1) {
      const h = n * this.sustain, f = t + s;
      this.log("decay", f), this._decayCurve === "linear" ? this._sig.linearRampToValueAtTime(h, o + f) : this._sig.exponentialApproachValueAtTime(h, f, o);
    }
    return this;
  }
  /**
   * Triggers the release of the envelope.
   * @param  time When the release portion of the envelope should start.
   * @example
   * const env = new Tone.AmplitudeEnvelope().toDestination();
   * const osc = new Tone.Oscillator({
   * 	type: "sawtooth"
   * }).connect(env).start();
   * env.triggerAttack();
   * // trigger the release half a second after the attack
   * env.triggerRelease("+0.5");
   */
  triggerRelease(t) {
    this.log("triggerRelease", t), t = this.toSeconds(t);
    const n = this.getValueAtTime(t);
    if (n > 0) {
      const i = this.toSeconds(this.release);
      i < this.sampleTime ? this._sig.setValueAtTime(0, t) : this._releaseCurve === "linear" ? this._sig.linearRampTo(0, i, t) : this._releaseCurve === "exponential" ? this._sig.targetRampTo(0, i, t) : (nn(Ts(this._releaseCurve), "releaseCurve must be either 'linear', 'exponential' or an array"), this._sig.cancelAndHoldAtTime(t), this._sig.setValueCurveAtTime(this._releaseCurve, t, i, n));
    }
    return this;
  }
  /**
   * Get the scheduled value at the given time. This will
   * return the unconverted (raw) value.
   * @example
   * const env = new Tone.Envelope(0.5, 1, 0.4, 2);
   * env.triggerAttackRelease(2);
   * setInterval(() => console.log(env.getValueAtTime(Tone.now())), 100);
   */
  getValueAtTime(t) {
    return this._sig.getValueAtTime(t);
  }
  /**
   * triggerAttackRelease is shorthand for triggerAttack, then waiting
   * some duration, then triggerRelease.
   * @param duration The duration of the sustain.
   * @param time When the attack should be triggered.
   * @param velocity The velocity of the envelope.
   * @example
   * const env = new Tone.AmplitudeEnvelope().toDestination();
   * const osc = new Tone.Oscillator().connect(env).start();
   * // trigger the release 0.5 seconds after the attack
   * env.triggerAttackRelease(0.5);
   */
  triggerAttackRelease(t, n, i = 1) {
    return n = this.toSeconds(n), this.triggerAttack(n, i), this.triggerRelease(n + this.toSeconds(t)), this;
  }
  /**
   * Cancels all scheduled envelope changes after the given time.
   */
  cancel(t) {
    return this._sig.cancelScheduledValues(this.toSeconds(t)), this;
  }
  /**
   * Connect the envelope to a destination node.
   */
  connect(t, n = 0, i = 0) {
    return R_(this, t, n, i), this;
  }
  /**
   * Render the envelope curve to an array of the given length.
   * Good for visualizing the envelope curve. Rescales the duration of the
   * envelope to fit the length.
   */
  asArray() {
    return Nr(this, arguments, void 0, function* (t = 1024) {
      const n = t / this.context.sampleRate, i = new E_(1, n, this.context.sampleRate), s = this.toSeconds(this.attack) + this.toSeconds(this.decay), o = s + this.toSeconds(this.release), u = o * 0.1, h = o + u, f = new this.constructor(Object.assign(this.get(), {
        attack: n * this.toSeconds(this.attack) / h,
        decay: n * this.toSeconds(this.decay) / h,
        release: n * this.toSeconds(this.release) / h,
        context: i
      }));
      return f._sig.toDestination(), f.triggerAttackRelease(n * (s + u) / h, 0), (yield i.render()).getChannelData(0);
    });
  }
  dispose() {
    return super.dispose(), this._sig.dispose(), this;
  }
}
Cl([
  Iu(0)
], Fd.prototype, "attack", void 0);
Cl([
  Iu(0)
], Fd.prototype, "decay", void 0);
Cl([
  U6(0, 1)
], Fd.prototype, "sustain", void 0);
Cl([
  Iu(0)
], Fd.prototype, "release", void 0);
const By = (() => {
  let t, n;
  const i = [];
  for (t = 0; t < 128; t++)
    i[t] = Math.sin(t / 127 * (Math.PI / 2));
  const s = [], o = 6.4;
  for (t = 0; t < 127; t++) {
    n = t / 127;
    const x = Math.sin(n * (Math.PI * 2) * o - Math.PI / 2) + 1;
    s[t] = x / 10 + n * 0.83;
  }
  s[127] = 1;
  const u = [], h = 5;
  for (t = 0; t < 128; t++)
    u[t] = Math.ceil(t / 127 * h) / h;
  const f = [];
  for (t = 0; t < 128; t++)
    n = t / 127, f[t] = 0.5 * (1 - Math.cos(Math.PI * n));
  const p = [];
  for (t = 0; t < 128; t++) {
    n = t / 127;
    const x = Math.pow(n, 3) * 4 + 0.2, b = Math.cos(x * Math.PI * 2 * n);
    p[t] = Math.abs(b * (1 - n));
  }
  function g(x) {
    const b = new Array(x.length);
    for (let _ = 0; _ < x.length; _++)
      b[_] = 1 - x[_];
    return b;
  }
  function v(x) {
    return x.slice(0).reverse();
  }
  return {
    bounce: {
      In: g(p),
      Out: p
    },
    cosine: {
      In: i,
      Out: v(i)
    },
    exponential: "exponential",
    linear: "linear",
    ripple: {
      In: s,
      Out: g(s)
    },
    sine: {
      In: f,
      Out: g(f)
    },
    step: {
      In: u,
      Out: g(u)
    }
  };
})();
let ap = class j6 extends wn {
  constructor() {
    const t = on(j6.getDefaults(), arguments);
    super(t), this._scheduledEvents = [], this._synced = !1, this._original_triggerAttack = this.triggerAttack, this._original_triggerRelease = this.triggerRelease, this._syncedRelease = (n) => this._original_triggerRelease(n), this._volume = this.output = new bp({
      context: this.context,
      volume: t.volume
    }), this.volume = this._volume.volume, or(this, "volume");
  }
  static getDefaults() {
    return Object.assign(wn.getDefaults(), {
      volume: 0
    });
  }
  /**
   * Sync the instrument to the Transport. All subsequent calls of
   * {@link triggerAttack} and {@link triggerRelease} will be scheduled along the transport.
   * @example
   * const fmSynth = new Tone.FMSynth().toDestination();
   * fmSynth.volume.value = -6;
   * fmSynth.sync();
   * // schedule 3 notes when the transport first starts
   * fmSynth.triggerAttackRelease("C4", "8n", 0);
   * fmSynth.triggerAttackRelease("E4", "8n", "8n");
   * fmSynth.triggerAttackRelease("G4", "8n", "4n");
   * // start the transport to hear the notes
   * Tone.Transport.start();
   */
  sync() {
    return this._syncState() && (this._syncMethod("triggerAttack", 1), this._syncMethod("triggerRelease", 0), this.context.transport.on("stop", this._syncedRelease), this.context.transport.on("pause", this._syncedRelease), this.context.transport.on("loopEnd", this._syncedRelease)), this;
  }
  /**
   * set _sync
   */
  _syncState() {
    let t = !1;
    return this._synced || (this._synced = !0, t = !0), t;
  }
  /**
   * Wrap the given method so that it can be synchronized
   * @param method Which method to wrap and sync
   * @param  timePosition What position the time argument appears in
   */
  _syncMethod(t, n) {
    const i = this["_original_" + t] = this[t];
    this[t] = (...s) => {
      const o = s[n], u = this.context.transport.schedule((h) => {
        s[n] = h, i.apply(this, s);
      }, o);
      this._scheduledEvents.push(u);
    };
  }
  /**
   * Unsync the instrument from the Transport
   */
  unsync() {
    return this._scheduledEvents.forEach((t) => this.context.transport.clear(t)), this._scheduledEvents = [], this._synced && (this._synced = !1, this.triggerAttack = this._original_triggerAttack, this.triggerRelease = this._original_triggerRelease, this.context.transport.off("stop", this._syncedRelease), this.context.transport.off("pause", this._syncedRelease), this.context.transport.off("loopEnd", this._syncedRelease)), this;
  }
  /**
   * Trigger the attack and then the release after the duration.
   * @param  note     The note to trigger.
   * @param  duration How long the note should be held for before
   *                         triggering the release. This value must be greater than 0.
   * @param time  When the note should be triggered.
   * @param  velocity The velocity the note should be triggered at.
   * @example
   * const synth = new Tone.Synth().toDestination();
   * // trigger "C4" for the duration of an 8th note
   * synth.triggerAttackRelease("C4", "8n");
   */
  triggerAttackRelease(t, n, i, s) {
    const o = this.toSeconds(i), u = this.toSeconds(n);
    return this.triggerAttack(t, o, s), this.triggerRelease(o + u), this;
  }
  /**
   * clean up
   * @returns {Instrument} this
   */
  dispose() {
    return super.dispose(), this._volume.dispose(), this.unsync(), this._scheduledEvents = [], this;
  }
};
class jh extends ap {
  constructor() {
    const t = on(jh.getDefaults(), arguments);
    super(t), this.portamento = t.portamento, this.onsilence = t.onsilence;
  }
  static getDefaults() {
    return Object.assign(ap.getDefaults(), {
      detune: 0,
      onsilence: ei,
      portamento: 0
    });
  }
  /**
   * Trigger the attack of the note optionally with a given velocity.
   * @param  note The note to trigger.
   * @param  time When the note should start.
   * @param  velocity The velocity determines how "loud" the note will be.
   * @example
   * const synth = new Tone.Synth().toDestination();
   * // trigger the note a half second from now at half velocity
   * synth.triggerAttack("C4", "+0.5", 0.5);
   */
  triggerAttack(t, n, i = 1) {
    this.log("triggerAttack", t, n, i);
    const s = this.toSeconds(n);
    return this._triggerEnvelopeAttack(s, i), this.setNote(t, s), this;
  }
  /**
   * Trigger the release portion of the envelope.
   * @param  time If no time is given, the release happens immediately.
   * @example
   * const synth = new Tone.Synth().toDestination();
   * synth.triggerAttack("C4");
   * // trigger the release a second from now
   * synth.triggerRelease("+1");
   */
  triggerRelease(t) {
    this.log("triggerRelease", t);
    const n = this.toSeconds(t);
    return this._triggerEnvelopeRelease(n), this;
  }
  /**
   * Set the note at the given time. If no time is given, the note
   * will set immediately.
   * @param note The note to change to.
   * @param  time The time when the note should be set.
   * @example
   * const synth = new Tone.Synth().toDestination();
   * synth.triggerAttack("C4");
   * // change to F#6 in one quarter note from now.
   * synth.setNote("F#6", "+4n");
   */
  setNote(t, n) {
    const i = this.toSeconds(n), s = t instanceof _s ? t.toFrequency() : t;
    if (this.portamento > 0 && this.getLevelAtTime(i) > 0.05) {
      const o = this.toSeconds(this.portamento);
      this.frequency.exponentialRampTo(s, o, i);
    } else
      this.frequency.setValueAtTime(s, i);
    return this;
  }
}
Cl([
  Iu(0)
], jh.prototype, "portamento", void 0);
class j_ extends Fd {
  constructor() {
    super(on(j_.getDefaults(), arguments, [
      "attack",
      "decay",
      "sustain",
      "release"
    ])), this.name = "AmplitudeEnvelope", this._gainNode = new Da({
      context: this.context,
      gain: 0
    }), this.output = this._gainNode, this.input = this._gainNode, this._sig.connect(this._gainNode.gain), this.output = this._gainNode, this.input = this._gainNode;
  }
  /**
   * Clean up
   */
  dispose() {
    return super.dispose(), this._gainNode.dispose(), this;
  }
}
class sp extends jh {
  constructor() {
    const t = on(sp.getDefaults(), arguments);
    super(t), this.name = "Synth", this.oscillator = new b1(Object.assign({
      context: this.context,
      detune: t.detune,
      onstop: () => this.onsilence(this)
    }, t.oscillator)), this.frequency = this.oscillator.frequency, this.detune = this.oscillator.detune, this.envelope = new j_(Object.assign({
      context: this.context
    }, t.envelope)), this.oscillator.chain(this.envelope, this.output), or(this, ["oscillator", "frequency", "detune", "envelope"]);
  }
  static getDefaults() {
    return Object.assign(jh.getDefaults(), {
      envelope: Object.assign(d2(Fd.getDefaults(), Object.keys(wn.getDefaults())), {
        attack: 5e-3,
        decay: 0.1,
        release: 1,
        sustain: 0.3
      }),
      oscillator: Object.assign(d2(b1.getDefaults(), [
        ...Object.keys(Js.getDefaults()),
        "frequency",
        "detune"
      ]), {
        type: "triangle"
      })
    });
  }
  /**
   * start the attack portion of the envelope
   * @param time the time the attack should start
   * @param velocity the velocity of the note (0-1)
   */
  _triggerEnvelopeAttack(t, n) {
    if (this.envelope.triggerAttack(t, n), this.oscillator.start(t), this.envelope.sustain === 0) {
      const i = this.toSeconds(this.envelope.attack), s = this.toSeconds(this.envelope.decay);
      this.oscillator.stop(t + i + s);
    }
  }
  /**
   * start the release portion of the envelope
   * @param time the time the release should start
   */
  _triggerEnvelopeRelease(t) {
    this.envelope.triggerRelease(t), this.oscillator.stop(t + this.toSeconds(this.envelope.release));
  }
  getLevelAtTime(t) {
    return t = this.toSeconds(t), this.envelope.getValueAtTime(t);
  }
  /**
   * clean up
   */
  dispose() {
    return super.dispose(), this.oscillator.dispose(), this.envelope.dispose(), this;
  }
}
class uv extends sp {
  constructor() {
    const t = on(uv.getDefaults(), arguments);
    super(t), this.name = "MembraneSynth", this.portamento = 0, this.pitchDecay = t.pitchDecay, this.octaves = t.octaves, or(this, ["oscillator", "envelope"]);
  }
  static getDefaults() {
    return Bh(jh.getDefaults(), sp.getDefaults(), {
      envelope: {
        attack: 1e-3,
        attackCurve: "exponential",
        decay: 0.4,
        release: 1.4,
        sustain: 0.01
      },
      octaves: 10,
      oscillator: {
        type: "sine"
      },
      pitchDecay: 0.05
    });
  }
  setNote(t, n) {
    const i = this.toSeconds(n), s = this.toFrequency(t instanceof _s ? t.toFrequency() : t), o = s * this.octaves;
    return this.oscillator.frequency.setValueAtTime(o, i), this.oscillator.frequency.exponentialRampToValueAtTime(s, i + this.toSeconds(this.pitchDecay)), this;
  }
  dispose() {
    return super.dispose(), this;
  }
}
Cl([
  U6(0)
], uv.prototype, "octaves", void 0);
Cl([
  Iu(0)
], uv.prototype, "pitchDecay", void 0);
const L6 = /* @__PURE__ */ new Set();
function L_(e) {
  L6.add(e);
}
function V6(e, t) {
  const n = (
    /* javascript */
    `registerProcessor("${e}", ${t})`
  );
  L6.add(n);
}
const YP = (
  /* javascript */
  `
	/**
	 * The base AudioWorkletProcessor for use in Tone.js. Works with the {@link ToneAudioWorklet}. 
	 */
	class ToneAudioWorkletProcessor extends AudioWorkletProcessor {

		constructor(options) {
			
			super(options);
			/**
			 * If the processor was disposed or not. Keep alive until it's disposed.
			 */
			this.disposed = false;
		   	/** 
			 * The number of samples in the processing block
			 */
			this.blockSize = 128;
			/**
			 * the sample rate
			 */
			this.sampleRate = sampleRate;

			this.port.onmessage = (event) => {
				// when it receives a dispose 
				if (event.data === "dispose") {
					this.disposed = true;
				}
			};
		}
	}
`
);
L_(YP);
const XP = (
  /* javascript */
  `
	/**
	 * Abstract class for a single input/output processor. 
	 * has a 'generate' function which processes one sample at a time
	 */
	class SingleIOProcessor extends ToneAudioWorkletProcessor {

		constructor(options) {
			super(Object.assign(options, {
				numberOfInputs: 1,
				numberOfOutputs: 1
			}));
			/**
			 * Holds the name of the parameter and a single value of that
			 * parameter at the current sample
			 * @type { [name: string]: number }
			 */
			this.params = {}
		}

		/**
		 * Generate an output sample from the input sample and parameters
		 * @abstract
		 * @param input number
		 * @param channel number
		 * @param parameters { [name: string]: number }
		 * @returns number
		 */
		generate(){}

		/**
		 * Update the private params object with the 
		 * values of the parameters at the given index
		 * @param parameters { [name: string]: Float32Array },
		 * @param index number
		 */
		updateParams(parameters, index) {
			for (const paramName in parameters) {
				const param = parameters[paramName];
				if (param.length > 1) {
					this.params[paramName] = parameters[paramName][index];
				} else {
					this.params[paramName] = parameters[paramName][0];
				}
			}
		}

		/**
		 * Process a single frame of the audio
		 * @param inputs Float32Array[][]
		 * @param outputs Float32Array[][]
		 */
		process(inputs, outputs, parameters) {
			const input = inputs[0];
			const output = outputs[0];
			// get the parameter values
			const channelCount = Math.max(input && input.length || 0, output.length);
			for (let sample = 0; sample < this.blockSize; sample++) {
				this.updateParams(parameters, sample);
				for (let channel = 0; channel < channelCount; channel++) {
					const inputSample = input && input.length ? input[channel][sample] : 0;
					output[channel][sample] = this.generate(inputSample, channel, this.params);
				}
			}
			return !this.disposed;
		}
	};
`
);
L_(XP);
const WP = (
  /* javascript */
  `
	/**
	 * A multichannel buffer for use within an AudioWorkletProcessor as a delay line
	 */
	class DelayLine {
		
		constructor(size, channels) {
			this.buffer = [];
			this.writeHead = []
			this.size = size;

			// create the empty channels
			for (let i = 0; i < channels; i++) {
				this.buffer[i] = new Float32Array(this.size);
				this.writeHead[i] = 0;
			}
		}

		/**
		 * Push a value onto the end
		 * @param channel number
		 * @param value number
		 */
		push(channel, value) {
			this.writeHead[channel] += 1;
			if (this.writeHead[channel] > this.size) {
				this.writeHead[channel] = 0;
			}
			this.buffer[channel][this.writeHead[channel]] = value;
		}

		/**
		 * Get the recorded value of the channel given the delay
		 * @param channel number
		 * @param delay number delay samples
		 */
		get(channel, delay) {
			let readHead = this.writeHead[channel] - Math.floor(delay);
			if (readHead < 0) {
				readHead += this.size;
			}
			return this.buffer[channel][readHead];
		}
	}
`
);
L_(WP);
const $P = "feedback-comb-filter", QP = (
  /* javascript */
  `
	class FeedbackCombFilterWorklet extends SingleIOProcessor {

		constructor(options) {
			super(options);
			this.delayLine = new DelayLine(this.sampleRate, options.channelCount || 2);
		}

		static get parameterDescriptors() {
			return [{
				name: "delayTime",
				defaultValue: 0.1,
				minValue: 0,
				maxValue: 1,
				automationRate: "k-rate"
			}, {
				name: "feedback",
				defaultValue: 0.5,
				minValue: 0,
				maxValue: 0.9999,
				automationRate: "k-rate"
			}];
		}

		generate(input, channel, parameters) {
			const delayedSample = this.delayLine.get(channel, parameters.delayTime * this.sampleRate);
			this.delayLine.push(channel, input + delayedSample * parameters.feedback);
			return delayedSample;
		}
	}
`
);
V6($P, QP);
class V_ extends ap {
  constructor() {
    const t = on(V_.getDefaults(), arguments, ["voice", "options"]);
    super(t), this.name = "PolySynth", this._availableVoices = [], this._activeVoices = [], this._voices = [], this._gcTimeout = -1, this._averageActiveVoices = 0, this._syncedRelease = (s) => this.releaseAll(s), nn(!Oc(t.voice), "DEPRECATED: The polyphony count is no longer the first argument.");
    const n = t.voice.getDefaults();
    this.options = Object.assign(n, t.options), this.voice = t.voice, this.maxPolyphony = t.maxPolyphony, this._dummyVoice = this._getNextAvailableVoice();
    const i = this._voices.indexOf(this._dummyVoice);
    this._voices.splice(i, 1), this._gcTimeout = this.context.setInterval(this._collectGarbage.bind(this), 1);
  }
  static getDefaults() {
    return Object.assign(ap.getDefaults(), {
      maxPolyphony: 32,
      options: {},
      voice: sp
    });
  }
  /**
   * The number of active voices.
   */
  get activeVoices() {
    return this._activeVoices.length;
  }
  /**
   * Invoked when the source is done making sound, so that it can be
   * readded to the pool of available voices
   */
  _makeVoiceAvailable(t) {
    this._availableVoices.push(t);
    const n = this._activeVoices.findIndex((i) => i.voice === t);
    this._activeVoices.splice(n, 1);
  }
  /**
   * Get an available voice from the pool of available voices.
   * If one is not available and the maxPolyphony limit is reached,
   * steal a voice, otherwise return null.
   */
  _getNextAvailableVoice() {
    if (this._availableVoices.length)
      return this._availableVoices.shift();
    if (this._voices.length < this.maxPolyphony) {
      const t = new this.voice(Object.assign(this.options, {
        context: this.context,
        onsilence: this._makeVoiceAvailable.bind(this)
      }));
      return nn(t instanceof jh, "Voice must extend Monophonic class"), t.connect(this.output), this._voices.push(t), t;
    } else
      J1("Max polyphony exceeded. Note dropped.");
  }
  /**
   * Occasionally check if there are any allocated voices which can be cleaned up.
   */
  _collectGarbage() {
    if (this._averageActiveVoices = Math.max(this._averageActiveVoices * 0.95, this.activeVoices), this._availableVoices.length && this._voices.length > Math.ceil(this._averageActiveVoices + 1)) {
      const t = this._availableVoices.shift(), n = this._voices.indexOf(t);
      this._voices.splice(n, 1), this.context.isOffline || t.dispose();
    }
  }
  /**
   * Internal method which triggers the attack
   */
  _triggerAttack(t, n, i) {
    t.forEach((s) => {
      const o = new v1(this.context, s).toMidi(), u = this._getNextAvailableVoice();
      u && (u.triggerAttack(s, n, i), this._activeVoices.push({
        midi: o,
        voice: u,
        released: !1
      }), this.log("triggerAttack", s, n));
    });
  }
  /**
   * Internal method which triggers the release
   */
  _triggerRelease(t, n) {
    t.forEach((i) => {
      const s = new v1(this.context, i).toMidi(), o = this._activeVoices.find(({ midi: u, released: h }) => u === s && !h);
      o && (o.voice.triggerRelease(n), o.released = !0, this.log("triggerRelease", i, n));
    });
  }
  /**
   * Schedule the attack/release events. If the time is in the future, then it should set a timeout
   * to wait for just-in-time scheduling
   */
  _scheduleEvent(t, n, i, s) {
    nn(!this.disposed, "Synth was already disposed"), i <= this.now() ? t === "attack" ? this._triggerAttack(n, i, s) : this._triggerRelease(n, i) : this.context.setTimeout(() => {
      this.disposed || this._scheduleEvent(t, n, i, s);
    }, i - this.now());
  }
  /**
   * Trigger the attack portion of the note
   * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.
   * @param  time  The start time of the note.
   * @param velocity The velocity of the note.
   * @example
   * const synth = new Tone.PolySynth(Tone.FMSynth).toDestination();
   * // trigger a chord immediately with a velocity of 0.2
   * synth.triggerAttack(["Ab3", "C4", "F5"], Tone.now(), 0.2);
   */
  triggerAttack(t, n, i) {
    Array.isArray(t) || (t = [t]);
    const s = this.toSeconds(n);
    return this._scheduleEvent("attack", t, s, i), this;
  }
  /**
   * Trigger the release of the note. Unlike monophonic instruments,
   * a note (or array of notes) needs to be passed in as the first argument.
   * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.
   * @param  time  When the release will be triggered.
   * @example
   * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();
   * poly.triggerAttack(["Ab3", "C4", "F5"]);
   * // trigger the release of the given notes.
   * poly.triggerRelease(["Ab3", "C4"], "+1");
   * poly.triggerRelease("F5", "+3");
   */
  triggerRelease(t, n) {
    Array.isArray(t) || (t = [t]);
    const i = this.toSeconds(n);
    return this._scheduleEvent("release", t, i), this;
  }
  /**
   * Trigger the attack and release after the specified duration
   * @param  notes The notes to play. Accepts a single  Frequency or an array of frequencies.
   * @param  duration the duration of the note
   * @param  time  if no time is given, defaults to now
   * @param  velocity the velocity of the attack (0-1)
   * @example
   * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();
   * // can pass in an array of durations as well
   * poly.triggerAttackRelease(["Eb3", "G4", "Bb4", "D5"], [4, 3, 2, 1]);
   */
  triggerAttackRelease(t, n, i, s) {
    const o = this.toSeconds(i);
    if (this.triggerAttack(t, o, s), Ts(n)) {
      nn(Ts(t), "If the duration is an array, the notes must also be an array"), t = t;
      for (let u = 0; u < t.length; u++) {
        const h = n[Math.min(u, n.length - 1)], f = this.toSeconds(h);
        nn(f > 0, "The duration must be greater than 0"), this.triggerRelease(t[u], o + f);
      }
    } else {
      const u = this.toSeconds(n);
      nn(u > 0, "The duration must be greater than 0"), this.triggerRelease(t, o + u);
    }
    return this;
  }
  sync() {
    return this._syncState() && (this._syncMethod("triggerAttack", 1), this._syncMethod("triggerRelease", 1), this.context.transport.on("stop", this._syncedRelease), this.context.transport.on("pause", this._syncedRelease), this.context.transport.on("loopEnd", this._syncedRelease)), this;
  }
  /**
   * Set a member/attribute of the voices
   * @example
   * const poly = new Tone.PolySynth().toDestination();
   * // set all of the voices using an options object for the synth type
   * poly.set({
   * 	envelope: {
   * 		attack: 0.25
   * 	}
   * });
   * poly.triggerAttackRelease("Bb3", 0.2);
   */
  set(t) {
    const n = d2(t, [
      "onsilence",
      "context"
    ]);
    return this.options = Bh(this.options, n), this._voices.forEach((i) => i.set(n)), this._dummyVoice.set(n), this;
  }
  get() {
    return this._dummyVoice.get();
  }
  /**
   * Trigger the release portion of all the currently active voices immediately.
   * Useful for silencing the synth.
   */
  releaseAll(t) {
    const n = this.toSeconds(t);
    return this._activeVoices.forEach(({ voice: i }) => {
      i.triggerRelease(n);
    }), this;
  }
  dispose() {
    return super.dispose(), this._dummyVoice.dispose(), this._voices.forEach((t) => t.dispose()), this._activeVoices = [], this._availableVoices = [], this.context.clearInterval(this._gcTimeout), this;
  }
}
class a0 extends ap {
  constructor() {
    const t = on(a0.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls");
    super(t), this.name = "Sampler", this._activeSources = /* @__PURE__ */ new Map();
    const n = {};
    Object.keys(t.urls).forEach((i) => {
      const s = parseInt(i, 10);
      if (nn(Dy(i) || Oc(s) && isFinite(s), `url key is neither a note or midi pitch: ${i}`), Dy(i)) {
        const o = new _s(this.context, i).toMidi();
        n[o] = t.urls[i];
      } else Oc(s) && isFinite(s) && (n[s] = t.urls[s]);
    }), this._buffers = new B_({
      urls: n,
      onload: t.onload,
      baseUrl: t.baseUrl,
      onerror: t.onerror
    }), this.attack = t.attack, this.release = t.release, this.curve = t.curve, this._buffers.loaded && Promise.resolve().then(t.onload);
  }
  static getDefaults() {
    return Object.assign(ap.getDefaults(), {
      attack: 0,
      baseUrl: "",
      curve: "exponential",
      onload: ei,
      onerror: ei,
      release: 0.1,
      urls: {}
    });
  }
  /**
   * Returns the difference in steps between the given midi note at the closets sample.
   */
  _findClosest(t) {
    let i = 0;
    for (; i < 96; ) {
      if (this._buffers.has(t + i))
        return -i;
      if (this._buffers.has(t - i))
        return i;
      i++;
    }
    throw new Error(`No available buffers for note: ${t}`);
  }
  /**
   * @param  notes	The note to play, or an array of notes.
   * @param  time     When to play the note
   * @param  velocity The velocity to play the sample back.
   */
  triggerAttack(t, n, i = 1) {
    return this.log("triggerAttack", t, n, i), Array.isArray(t) || (t = [t]), t.forEach((s) => {
      const o = z6(new _s(this.context, s).toFrequency()), u = Math.round(o), h = o - u, f = this._findClosest(u), p = u - f, g = this._buffers.get(p), v = B6(f + h), x = new av({
        url: g,
        context: this.context,
        curve: this.curve,
        fadeIn: this.attack,
        fadeOut: this.release,
        playbackRate: v
      }).connect(this.output);
      x.start(n, 0, g.duration / v, i), Ts(this._activeSources.get(u)) || this._activeSources.set(u, []), this._activeSources.get(u).push(x), x.onended = () => {
        if (this._activeSources && this._activeSources.has(u)) {
          const b = this._activeSources.get(u), _ = b.indexOf(x);
          _ !== -1 && b.splice(_, 1);
        }
      };
    }), this;
  }
  /**
   * @param  notes	The note to release, or an array of notes.
   * @param  time     	When to release the note.
   */
  triggerRelease(t, n) {
    return this.log("triggerRelease", t, n), Array.isArray(t) || (t = [t]), t.forEach((i) => {
      const s = new _s(this.context, i).toMidi();
      if (this._activeSources.has(s) && this._activeSources.get(s).length) {
        const o = this._activeSources.get(s);
        n = this.toSeconds(n), o.forEach((u) => {
          u.stop(n);
        }), this._activeSources.set(s, []);
      }
    }), this;
  }
  /**
   * Release all currently active notes.
   * @param  time     	When to release the notes.
   */
  releaseAll(t) {
    const n = this.toSeconds(t);
    return this._activeSources.forEach((i) => {
      for (; i.length; )
        i.shift().stop(n);
    }), this;
  }
  sync() {
    return this._syncState() && (this._syncMethod("triggerAttack", 1), this._syncMethod("triggerRelease", 1)), this;
  }
  /**
   * Invoke the attack phase, then after the duration, invoke the release.
   * @param  notes	The note to play and release, or an array of notes.
   * @param  duration The time the note should be held
   * @param  time     When to start the attack
   * @param  velocity The velocity of the attack
   */
  triggerAttackRelease(t, n, i, s = 1) {
    const o = this.toSeconds(i);
    return this.triggerAttack(t, o, s), Ts(n) ? (nn(Ts(t), "notes must be an array when duration is array"), t.forEach((u, h) => {
      const f = n[Math.min(h, n.length - 1)];
      this.triggerRelease(u, o + this.toSeconds(f));
    })) : this.triggerRelease(t, o + this.toSeconds(n)), this;
  }
  /**
   * Add a note to the sampler.
   * @param  note      The buffer's pitch.
   * @param  url  Either the url of the buffer, or a buffer which will be added with the given name.
   * @param  callback  The callback to invoke when the url is loaded.
   */
  add(t, n, i) {
    if (nn(Dy(t) || isFinite(t), `note must be a pitch or midi: ${t}`), Dy(t)) {
      const s = new _s(this.context, t).toMidi();
      this._buffers.add(s, n, i);
    } else
      this._buffers.add(t, n, i);
    return this;
  }
  /**
   * If the buffers are loaded or not
   */
  get loaded() {
    return this._buffers.loaded;
  }
  /**
   * Clean up
   */
  dispose() {
    return super.dispose(), this._buffers.dispose(), this._activeSources.forEach((t) => {
      t.forEach((n) => n.dispose());
    }), this._activeSources.clear(), this;
  }
}
Cl([
  Iu(0)
], a0.prototype, "attack", void 0);
Cl([
  Iu(0)
], a0.prototype, "release", void 0);
class If extends ka {
  constructor() {
    const t = on(If.getDefaults(), arguments, ["callback", "value"]);
    super(t), this.name = "ToneEvent", this._state = new e0("stopped"), this._startOffset = 0, this._loop = t.loop, this.callback = t.callback, this.value = t.value, this._loopStart = this.toTicks(t.loopStart), this._loopEnd = this.toTicks(t.loopEnd), this._playbackRate = t.playbackRate, this._probability = t.probability, this._humanize = t.humanize, this.mute = t.mute, this._playbackRate = t.playbackRate, this._state.increasing = !0, this._rescheduleEvents();
  }
  static getDefaults() {
    return Object.assign(ka.getDefaults(), {
      callback: ei,
      humanize: !1,
      loop: !1,
      loopEnd: "1m",
      loopStart: 0,
      mute: !1,
      playbackRate: 1,
      probability: 1,
      value: null
    });
  }
  /**
   * Reschedule all of the events along the timeline
   * with the updated values.
   * @param after Only reschedules events after the given time.
   */
  _rescheduleEvents(t = -1) {
    this._state.forEachFrom(t, (n) => {
      let i;
      if (n.state === "started") {
        n.id !== -1 && this.context.transport.clear(n.id);
        const s = n.time + Math.round(this.startOffset / this._playbackRate);
        if (this._loop === !0 || Oc(this._loop) && this._loop > 1) {
          i = 1 / 0, Oc(this._loop) && (i = this._loop * this._getLoopDuration());
          const o = this._state.getAfter(s);
          o !== null && (i = Math.min(i, o.time - s)), i !== 1 / 0 && (i = new Ur(this.context, i));
          const u = new Ur(this.context, this._getLoopDuration());
          n.id = this.context.transport.scheduleRepeat(this._tick.bind(this), u, new Ur(this.context, s), i);
        } else
          n.id = this.context.transport.schedule(this._tick.bind(this), new Ur(this.context, s));
      }
    });
  }
  /**
   * Returns the playback state of the note, either "started" or "stopped".
   */
  get state() {
    return this._state.getValueAtTime(this.context.transport.ticks);
  }
  /**
   * The start from the scheduled start time.
   */
  get startOffset() {
    return this._startOffset;
  }
  set startOffset(t) {
    this._startOffset = t;
  }
  /**
   * The probability of the notes being triggered.
   */
  get probability() {
    return this._probability;
  }
  set probability(t) {
    this._probability = t;
  }
  /**
   * If set to true, will apply small random variation
   * to the callback time. If the value is given as a time, it will randomize
   * by that amount.
   * @example
   * const event = new Tone.ToneEvent();
   * event.humanize = true;
   */
  get humanize() {
    return this._humanize;
  }
  set humanize(t) {
    this._humanize = t;
  }
  /**
   * Start the note at the given time.
   * @param  time  When the event should start.
   */
  start(t) {
    const n = this.toTicks(t);
    return this._state.getValueAtTime(n) === "stopped" && (this._state.add({
      id: -1,
      state: "started",
      time: n
    }), this._rescheduleEvents(n)), this;
  }
  /**
   * Stop the Event at the given time.
   * @param  time  When the event should stop.
   */
  stop(t) {
    this.cancel(t);
    const n = this.toTicks(t);
    if (this._state.getValueAtTime(n) === "started") {
      this._state.setStateAtTime("stopped", n, { id: -1 });
      const i = this._state.getBefore(n);
      let s = n;
      i !== null && (s = i.time), this._rescheduleEvents(s);
    }
    return this;
  }
  /**
   * Cancel all scheduled events greater than or equal to the given time
   * @param  time  The time after which events will be cancel.
   */
  cancel(t) {
    t = Ec(t, -1 / 0);
    const n = this.toTicks(t);
    return this._state.forEachFrom(n, (i) => {
      this.context.transport.clear(i.id);
    }), this._state.cancel(n), this;
  }
  /**
   * The callback function invoker. Also
   * checks if the Event is done playing
   * @param  time  The time of the event in seconds
   */
  _tick(t) {
    const n = this.context.transport.getTicksAtTime(t);
    if (!this.mute && this._state.getValueAtTime(n) === "started") {
      if (this.probability < 1 && Math.random() > this.probability)
        return;
      if (this.humanize) {
        let i = 0.02;
        x6(this.humanize) || (i = this.toSeconds(this.humanize)), t += (Math.random() * 2 - 1) * i;
      }
      this.callback(t, this.value);
    }
  }
  /**
   * Get the duration of the loop.
   */
  _getLoopDuration() {
    return (this._loopEnd - this._loopStart) / this._playbackRate;
  }
  /**
   * If the note should loop or not
   * between ToneEvent.loopStart and
   * ToneEvent.loopEnd. If set to true,
   * the event will loop indefinitely,
   * if set to a number greater than 1
   * it will play a specific number of
   * times, if set to false, 0 or 1, the
   * part will only play once.
   */
  get loop() {
    return this._loop;
  }
  set loop(t) {
    this._loop = t, this._rescheduleEvents();
  }
  /**
   * The playback rate of the event. Defaults to 1.
   * @example
   * const note = new Tone.ToneEvent();
   * note.loop = true;
   * // repeat the note twice as fast
   * note.playbackRate = 2;
   */
  get playbackRate() {
    return this._playbackRate;
  }
  set playbackRate(t) {
    this._playbackRate = t, this._rescheduleEvents();
  }
  /**
   * The loopEnd point is the time the event will loop
   * if ToneEvent.loop is true.
   */
  get loopEnd() {
    return new Ur(this.context, this._loopEnd).toSeconds();
  }
  set loopEnd(t) {
    this._loopEnd = this.toTicks(t), this._loop && this._rescheduleEvents();
  }
  /**
   * The time when the loop should start.
   */
  get loopStart() {
    return new Ur(this.context, this._loopStart).toSeconds();
  }
  set loopStart(t) {
    this._loopStart = this.toTicks(t), this._loop && this._rescheduleEvents();
  }
  /**
   * The current progress of the loop interval.
   * Returns 0 if the event is not started yet or
   * it is not set to loop.
   */
  get progress() {
    if (this._loop) {
      const t = this.context.transport.ticks, n = this._state.get(t);
      if (n !== null && n.state === "started") {
        const i = this._getLoopDuration();
        return (t - n.time) % i / i;
      } else
        return 0;
    } else
      return 0;
  }
  dispose() {
    return super.dispose(), this.cancel(), this._state.dispose(), this;
  }
}
class _1 extends If {
  constructor() {
    const t = on(_1.getDefaults(), arguments, [
      "callback",
      "events"
    ]);
    super(t), this.name = "Part", this._state = new e0("stopped"), this._events = /* @__PURE__ */ new Set(), this._state.increasing = !0, t.events.forEach((n) => {
      Ts(n) ? this.add(n[0], n[1]) : this.add(n);
    });
  }
  static getDefaults() {
    return Object.assign(If.getDefaults(), {
      events: []
    });
  }
  /**
   * Start the part at the given time.
   * @param  time    When to start the part.
   * @param  offset  The offset from the start of the part to begin playing at.
   */
  start(t, n) {
    const i = this.toTicks(t);
    if (this._state.getValueAtTime(i) !== "started") {
      n = Ec(n, this._loop ? this._loopStart : 0), this._loop ? n = Ec(n, this._loopStart) : n = Ec(n, 0);
      const s = this.toTicks(n);
      this._state.add({
        id: -1,
        offset: s,
        state: "started",
        time: i
      }), this._forEach((o) => {
        this._startNote(o, i, s);
      });
    }
    return this;
  }
  /**
   * Start the event in the given event at the correct time given
   * the ticks and offset and looping.
   * @param  event
   * @param  ticks
   * @param  offset
   */
  _startNote(t, n, i) {
    n -= i, this._loop ? t.startOffset >= this._loopStart && t.startOffset < this._loopEnd ? (t.startOffset < i && (n += this._getLoopDuration()), t.start(new Ur(this.context, n))) : t.startOffset < this._loopStart && t.startOffset >= i && (t.loop = !1, t.start(new Ur(this.context, n))) : t.startOffset >= i && t.start(new Ur(this.context, n));
  }
  get startOffset() {
    return this._startOffset;
  }
  set startOffset(t) {
    this._startOffset = t, this._forEach((n) => {
      n.startOffset += this._startOffset;
    });
  }
  /**
   * Stop the part at the given time.
   * @param  time  When to stop the part.
   */
  stop(t) {
    const n = this.toTicks(t);
    return this._state.cancel(n), this._state.setStateAtTime("stopped", n), this._forEach((i) => {
      i.stop(t);
    }), this;
  }
  /**
   * Get/Set an Event's value at the given time.
   * If a value is passed in and no event exists at
   * the given time, one will be created with that value.
   * If two events are at the same time, the first one will
   * be returned.
   * @example
   * const part = new Tone.Part();
   * part.at("1m"); // returns the part at the first measure
   * part.at("2m", "C2"); // set the value at "2m" to C2.
   * // if an event didn't exist at that time, it will be created.
   * @param time The time of the event to get or set.
   * @param value If a value is passed in, the value of the event at the given time will be set to it.
   */
  at(t, n) {
    const i = new Hf(this.context, t).toTicks(), s = new Ur(this.context, 1).toSeconds(), o = this._events.values();
    let u = o.next();
    for (; !u.done; ) {
      const h = u.value;
      if (Math.abs(i - h.startOffset) < s)
        return _n(n) && (h.value = n), h;
      u = o.next();
    }
    return _n(n) ? (this.add(t, n), this.at(t)) : null;
  }
  add(t, n) {
    t instanceof Object && Reflect.has(t, "time") && (n = t, t = n.time);
    const i = this.toTicks(t);
    let s;
    return n instanceof If ? (s = n, s.callback = this._tick.bind(this)) : s = new If({
      callback: this._tick.bind(this),
      context: this.context,
      value: n
    }), s.startOffset = i, s.set({
      humanize: this.humanize,
      loop: this.loop,
      loopEnd: this.loopEnd,
      loopStart: this.loopStart,
      playbackRate: this.playbackRate,
      probability: this.probability
    }), this._events.add(s), this._restartEvent(s), this;
  }
  /**
   * Restart the given event
   */
  _restartEvent(t) {
    this._state.forEach((n) => {
      n.state === "started" ? this._startNote(t, n.time, n.offset) : t.stop(new Ur(this.context, n.time));
    });
  }
  remove(t, n) {
    return Dd(t) && t.hasOwnProperty("time") && (n = t, t = n.time), t = this.toTicks(t), this._events.forEach((i) => {
      i.startOffset === t && ($s(n) || _n(n) && i.value === n) && (this._events.delete(i), i.dispose());
    }), this;
  }
  /**
   * Remove all of the notes from the group.
   */
  clear() {
    return this._forEach((t) => t.dispose()), this._events.clear(), this;
  }
  /**
   * Cancel scheduled state change events: i.e. "start" and "stop".
   * @param after The time after which to cancel the scheduled events.
   */
  cancel(t) {
    return this._forEach((n) => n.cancel(t)), this._state.cancel(this.toTicks(t)), this;
  }
  /**
   * Iterate over all of the events
   */
  _forEach(t) {
    return this._events && this._events.forEach((n) => {
      n instanceof _1 ? n._forEach(t) : t(n);
    }), this;
  }
  /**
   * Set the attribute of all of the events
   * @param  attr  the attribute to set
   * @param  value      The value to set it to
   */
  _setAll(t, n) {
    this._forEach((i) => {
      i[t] = n;
    });
  }
  /**
   * Internal tick method
   * @param  time  The time of the event in seconds
   */
  _tick(t, n) {
    this.mute || this.callback(t, n);
  }
  /**
   * Determine if the event should be currently looping
   * given the loop boundries of this Part.
   * @param  event  The event to test
   */
  _testLoopBoundries(t) {
    this._loop && (t.startOffset < this._loopStart || t.startOffset >= this._loopEnd) ? t.cancel(0) : t.state === "stopped" && this._restartEvent(t);
  }
  get probability() {
    return this._probability;
  }
  set probability(t) {
    this._probability = t, this._setAll("probability", t);
  }
  get humanize() {
    return this._humanize;
  }
  set humanize(t) {
    this._humanize = t, this._setAll("humanize", t);
  }
  /**
   * If the part should loop or not
   * between Part.loopStart and
   * Part.loopEnd. If set to true,
   * the part will loop indefinitely,
   * if set to a number greater than 1
   * it will play a specific number of
   * times, if set to false, 0 or 1, the
   * part will only play once.
   * @example
   * const part = new Tone.Part();
   * // loop the part 8 times
   * part.loop = 8;
   */
  get loop() {
    return this._loop;
  }
  set loop(t) {
    this._loop = t, this._forEach((n) => {
      n.loopStart = this.loopStart, n.loopEnd = this.loopEnd, n.loop = t, this._testLoopBoundries(n);
    });
  }
  /**
   * The loopEnd point determines when it will
   * loop if Part.loop is true.
   */
  get loopEnd() {
    return new Ur(this.context, this._loopEnd).toSeconds();
  }
  set loopEnd(t) {
    this._loopEnd = this.toTicks(t), this._loop && this._forEach((n) => {
      n.loopEnd = t, this._testLoopBoundries(n);
    });
  }
  /**
   * The loopStart point determines when it will
   * loop if Part.loop is true.
   */
  get loopStart() {
    return new Ur(this.context, this._loopStart).toSeconds();
  }
  set loopStart(t) {
    this._loopStart = this.toTicks(t), this._loop && this._forEach((n) => {
      n.loopStart = this.loopStart, this._testLoopBoundries(n);
    });
  }
  /**
   * The playback rate of the part
   */
  get playbackRate() {
    return this._playbackRate;
  }
  set playbackRate(t) {
    this._playbackRate = t, this._setAll("playbackRate", t);
  }
  /**
   * The number of scheduled notes in the part.
   */
  get length() {
    return this._events.size;
  }
  dispose() {
    return super.dispose(), this.clear(), this;
  }
}
class I_ extends wn {
  constructor() {
    const t = on(I_.getDefaults(), arguments, [
      "pan"
    ]);
    super(t), this.name = "Panner", this._panner = this.context.createStereoPanner(), this.input = this._panner, this.output = this._panner, this.pan = new Yi({
      context: this.context,
      param: this._panner.pan,
      value: t.pan,
      minValue: -1,
      maxValue: 1
    }), this._panner.channelCount = t.channelCount, this._panner.channelCountMode = "explicit", or(this, "pan");
  }
  static getDefaults() {
    return Object.assign(wn.getDefaults(), {
      pan: 0,
      channelCount: 1
    });
  }
  dispose() {
    return super.dispose(), this._panner.disconnect(), this.pan.dispose(), this;
  }
}
const ZP = "bit-crusher", JP = (
  /* javascript */
  `
	class BitCrusherWorklet extends SingleIOProcessor {

		static get parameterDescriptors() {
			return [{
				name: "bits",
				defaultValue: 12,
				minValue: 1,
				maxValue: 16,
				automationRate: 'k-rate'
			}];
		}

		generate(input, _channel, parameters) {
			const step = Math.pow(0.5, parameters.bits - 1);
			const val = step * Math.floor(input / step + 0.5);
			return val;
		}
	}
`
);
V6(ZP, JP);
class Mr extends wn {
  constructor() {
    const t = on(Mr.getDefaults(), arguments, [
      "solo"
    ]);
    super(t), this.name = "Solo", this.input = this.output = new Da({
      context: this.context
    }), Mr._allSolos.has(this.context) || Mr._allSolos.set(this.context, /* @__PURE__ */ new Set()), Mr._allSolos.get(this.context).add(this), this.solo = t.solo;
  }
  static getDefaults() {
    return Object.assign(wn.getDefaults(), {
      solo: !1
    });
  }
  /**
   * Isolates this instance and mutes all other instances of Solo.
   * Only one instance can be soloed at a time. A soloed
   * instance will report `solo=false` when another instance is soloed.
   */
  get solo() {
    return this._isSoloed();
  }
  set solo(t) {
    t ? this._addSolo() : this._removeSolo(), Mr._allSolos.get(this.context).forEach((n) => n._updateSolo());
  }
  /**
   * If the current instance is muted, i.e. another instance is soloed
   */
  get muted() {
    return this.input.gain.value === 0;
  }
  /**
   * Add this to the soloed array
   */
  _addSolo() {
    Mr._soloed.has(this.context) || Mr._soloed.set(this.context, /* @__PURE__ */ new Set()), Mr._soloed.get(this.context).add(this);
  }
  /**
   * Remove this from the soloed array
   */
  _removeSolo() {
    Mr._soloed.has(this.context) && Mr._soloed.get(this.context).delete(this);
  }
  /**
   * Is this on the soloed array
   */
  _isSoloed() {
    return Mr._soloed.has(this.context) && Mr._soloed.get(this.context).has(this);
  }
  /**
   * Returns true if no one is soloed
   */
  _noSolos() {
    return !Mr._soloed.has(this.context) || // or has a solo set but doesn't include any items
    Mr._soloed.has(this.context) && Mr._soloed.get(this.context).size === 0;
  }
  /**
   * Solo the current instance and unsolo all other instances.
   */
  _updateSolo() {
    this._isSoloed() ? this.input.gain.value = 1 : this._noSolos() ? this.input.gain.value = 1 : this.input.gain.value = 0;
  }
  dispose() {
    return super.dispose(), Mr._allSolos.get(this.context).delete(this), this._removeSolo(), this;
  }
}
Mr._allSolos = /* @__PURE__ */ new Map();
Mr._soloed = /* @__PURE__ */ new Map();
class F_ extends wn {
  constructor() {
    const t = on(F_.getDefaults(), arguments, [
      "pan",
      "volume"
    ]);
    super(t), this.name = "PanVol", this._panner = this.input = new I_({
      context: this.context,
      pan: t.pan,
      channelCount: t.channelCount
    }), this.pan = this._panner.pan, this._volume = this.output = new bp({
      context: this.context,
      volume: t.volume
    }), this.volume = this._volume.volume, this._panner.connect(this._volume), this.mute = t.mute, or(this, ["pan", "volume"]);
  }
  static getDefaults() {
    return Object.assign(wn.getDefaults(), {
      mute: !1,
      pan: 0,
      volume: 0,
      channelCount: 1
    });
  }
  /**
   * Mute/unmute the volume
   */
  get mute() {
    return this._volume.mute;
  }
  set mute(t) {
    this._volume.mute = t;
  }
  dispose() {
    return super.dispose(), this._panner.dispose(), this.pan.dispose(), this._volume.dispose(), this.volume.dispose(), this;
  }
}
class Nu extends wn {
  constructor() {
    const t = on(Nu.getDefaults(), arguments, [
      "volume",
      "pan"
    ]);
    super(t), this.name = "Channel", this._solo = this.input = new Mr({
      solo: t.solo,
      context: this.context
    }), this._panVol = this.output = new F_({
      context: this.context,
      pan: t.pan,
      volume: t.volume,
      mute: t.mute,
      channelCount: t.channelCount
    }), this.pan = this._panVol.pan, this.volume = this._panVol.volume, this._solo.connect(this._panVol), or(this, ["pan", "volume"]);
  }
  static getDefaults() {
    return Object.assign(wn.getDefaults(), {
      pan: 0,
      volume: 0,
      mute: !1,
      solo: !1,
      channelCount: 1
    });
  }
  /**
   * Solo/unsolo the channel. Soloing is only relative to other {@link Channel}s and {@link Solo} instances
   */
  get solo() {
    return this._solo.solo;
  }
  set solo(t) {
    this._solo.solo = t;
  }
  /**
   * If the current instance is muted, i.e. another instance is soloed,
   * or the channel is muted
   */
  get muted() {
    return this._solo.muted || this.mute;
  }
  /**
   * Mute/unmute the volume
   */
  get mute() {
    return this._panVol.mute;
  }
  set mute(t) {
    this._panVol.mute = t;
  }
  /**
   * Get the gain node belonging to the bus name. Create it if
   * it doesn't exist
   * @param name The bus name
   */
  _getBus(t) {
    return Nu.buses.has(t) || Nu.buses.set(t, new Da({ context: this.context })), Nu.buses.get(t);
  }
  /**
   * Send audio to another channel using a string. `send` is a lot like
   * {@link connect}, except it uses a string instead of an object. This can
   * be useful in large applications to decouple sections since {@link send}
   * and {@link receive} can be invoked separately in order to connect an object
   * @param name The channel name to send the audio
   * @param volume The amount of the signal to send.
   * 	Defaults to 0db, i.e. send the entire signal
   * @returns Returns the gain node of this connection.
   */
  send(t, n = 0) {
    const i = this._getBus(t), s = new Da({
      context: this.context,
      units: "decibels",
      gain: n
    });
    return this.connect(s), s.connect(i), s;
  }
  /**
   * Receive audio from a channel which was connected with {@link send}.
   * @param name The channel name to receive audio from.
   */
  receive(t) {
    return this._getBus(t).connect(this), this;
  }
  dispose() {
    return super.dispose(), this._panVol.dispose(), this.pan.dispose(), this.volume.dispose(), this._solo.dispose(), this;
  }
}
Nu.buses = /* @__PURE__ */ new Map();
function Nx() {
  return Za().now();
}
const Lh = Za().transport;
function Mi() {
  return Za().transport;
}
Za().destination;
Za().destination;
Za().listener;
Za().draw;
Za();
function tU() {
  return Si.loaded();
}
class eU {
  constructor() {
    Qe(this, "currentProject");
  }
  createProject(t) {
    return this.currentProject = {
      id: crypto.randomUUID(),
      name: t,
      tempo: 120,
      timeSignature: [4, 4],
      key: "C",
      tracks: []
    }, this.currentProject;
  }
  setProjectName(t) {
    this.currentProject && (this.currentProject.name = t);
  }
  getCurrentProject() {
    return this.currentProject;
  }
  addTrack(t, n = "audio") {
    if (!this.currentProject)
      throw new Error("No project loaded");
    const i = {
      id: crypto.randomUUID(),
      name: t,
      type: n,
      volume: 80,
      pan: 0,
      muted: !1,
      soloed: !1
    };
    return this.currentProject.tracks.push(i), i;
  }
  /**
   * Add a track with a specific ID and properties (for loading saved projects)
   * This ensures track IDs and settings are preserved across saves
   */
  addTrackWithProperties(t) {
    if (!this.currentProject)
      throw new Error("No project loaded");
    const n = {
      id: t.id,
      name: t.name,
      type: t.type,
      volume: t.volume ?? 80,
      pan: t.pan ?? 0,
      muted: t.muted ?? !1,
      soloed: t.soloed ?? !1
    };
    return this.currentProject.tracks.push(n), n;
  }
  getTrackById(t) {
    var n;
    return (n = this.currentProject) == null ? void 0 : n.tracks.find((i) => i.id === t);
  }
  removeTrack(t) {
    this.currentProject && (this.currentProject.tracks = this.currentProject.tracks.filter(
      (n) => n.id !== t
    ));
  }
  setTempo(t) {
    this.currentProject && (this.currentProject.tempo = t);
  }
  setTimeSignature(t, n) {
    this.currentProject && (this.currentProject.timeSignature = [t, n]);
  }
  setKey(t) {
    this.currentProject && (this.currentProject.key = t);
  }
}
function kd(e, t = !1) {
  if (t || e <= 0) return -1 / 0;
  const n = Math.max(0, Math.min(100, e));
  if (n === 80) return 0;
  if (n > 80)
    return (n - 80) / 20 * 6;
  {
    const i = n / 80;
    return i === 0 ? -1 / 0 : -60 * (1 - i * i * i);
  }
}
const Eh = class Eh {
  constructor() {
    Qe(this, "mainOutput");
    Qe(this, "tracks");
    this.mainOutput = new Nu().toDestination(), this.tracks = /* @__PURE__ */ new Map();
  }
  static getInstance() {
    return Eh.instance || (Eh.instance = new Eh()), Eh.instance;
  }
  async initialize() {
    try {
      console.log("AudioEngine: Starting Tone.js"), await D6(), Za().resume(), console.log("AudioEngine: Tone.js started successfully");
    } catch (t) {
      throw console.error("AudioEngine: Failed to start Tone.js:", t), t;
    }
  }
  async createTrack(t, n, i) {
    console.log(`Creating track ${t}, cleaning up existing...`), this.removeTrack(t);
    const s = new Nu().connect(this.mainOutput), o = 80;
    s.volume.value = kd(o, !1), i && i.name.split(".")[0];
    const u = {
      id: t,
      name: n,
      channel: s,
      volume: o,
      pan: 0,
      muted: !1,
      soloed: !1
    };
    if (i) {
      console.log(`Loading audio file for track ${t}`);
      const h = await i.arrayBuffer(), f = new r0({
        url: URL.createObjectURL(new Blob([h])),
        loop: !1,
        autostart: !1
      }).connect(s);
      u.player = f, await tU(), console.log(`Audio loaded for track ${t}`);
    }
    return this.tracks.set(t, u), u;
  }
  removeTrack(t) {
    const n = this.tracks.get(t);
    n && (n.player && (n.player.stop(), n.player.dispose()), n.channel.dispose(), this.tracks.delete(t));
  }
  setTrackVolume(t, n) {
    const i = this.tracks.get(t);
    if (i) {
      i.volume = n;
      const s = kd(n, i.muted);
      i.channel.volume.value = s, i.player && (i.player.volume.value = s);
    }
  }
  setTrackPan(t, n) {
    const i = this.tracks.get(t);
    if (i) {
      i.pan = n;
      const s = n / 100;
      i.channel.pan.value = s;
    }
  }
  setTrackMute(t, n) {
    const i = this.tracks.get(t);
    i && (i.muted = n, i.channel.volume.value = kd(i.volume, n), i.player && (i.player.volume.value = kd(i.volume, n)));
  }
  getAllTracks() {
    return Array.from(this.tracks.values());
  }
  setMasterVolume(t) {
    this.mainOutput.volume.value = t;
  }
  // Stops all playback and should only be used for full stop, not pause
  stopAllPlayback() {
    console.log("Stopping all playback (full stop)"), this.tracks.forEach((t, n) => {
      t.player && (console.log(`Stopping player for track ${n}`), t.player.state === "started" && t.player.stop());
    });
  }
  // Add a method specifically for pausing (doesn't actually stop the players)
  pauseAllPlayback() {
    console.log("Pausing all playback (maintain position)"), this.tracks.forEach((t, n) => {
      t.player && t.player.state === "started" && console.log(`Track ${n} player synced with paused transport`);
    });
  }
  // Add method to update track name
  setTrackName(t, n) {
    const i = this.tracks.get(t);
    i && (i.name = n);
  }
  // Set a track's position on the timeline
  setTrackPosition(t, n, i) {
    const s = this.tracks.get(t);
    s && (s.position = { x: n, y: i }, console.log(`AudioEngine: Set track ${t} position to x:${n}, y:${i}`));
  }
  // Set a track's solo state
  setTrackSolo(t, n) {
    const i = this.tracks.get(t);
    i && (i.soloed = n, n ? this.tracks.forEach((s) => {
      s.id !== t && !s.soloed && (s.channel.volume.value = -1 / 0);
    }) : this.tracks.forEach((s) => {
      !s.muted && !s.soloed && (s.channel.volume.value = kd(s.volume, !1));
    }));
  }
};
Qe(Eh, "instance");
let S1 = Eh;
const Ah = class Ah {
  // 10ms fade
  constructor() {
    Qe(this, "audioEngine");
    Qe(this, "isStarting", !1);
    Qe(this, "maxPosition", 3600);
    // Track the IDs of scheduled events so we can clean them up
    Qe(this, "scheduledEvents", []);
    this.audioEngine = S1.getInstance(), Mi().bpm.value = 120;
  }
  get position() {
    return Mi().seconds;
  }
  get isPlaying() {
    return Mi().state === "started";
  }
  get tempo() {
    return Mi().bpm.value;
  }
  /**
   * Converts a track's UI position (in pixels) to a time offset (in seconds)
   * This is crucial for properly aligning tracks on the timeline
   */
  getTrackTimeOffset(t) {
    return r_(t, Mi().bpm.value);
  }
  /**
   * Calculates the correct playback time for a track based on:
   * 1. Current transport position
   * 2. Track's position on the timeline
   * 
   * @param transportTime Global transport time
   * @param trackX The track's X position in pixels
   * @returns The adjusted playback position in seconds
   */
  calculateTrackPlayPosition(t, n) {
    const i = this.getTrackTimeOffset(n);
    return t < i ? -1 : t - i;
  }
  async play() {
    if (!this.isStarting) {
      this.isStarting = !0;
      try {
        await D6(), this.clearScheduledEvents();
        let t = Mi().seconds;
        console.log(`Starting playback at transport position: ${t}s`), this.audioEngine.getAllTracks().forEach((i) => {
          i.player && (i.player.state === "started" && i.player.stop(), i.player.unsync(), i.player.volume.cancelScheduledValues(Nx()));
        }), this.audioEngine.getAllTracks().forEach((i) => {
          var h;
          if (!i.player) return;
          const s = ((h = i.position) == null ? void 0 : h.x) || 0, o = this.getTrackTimeOffset(s);
          t = Mi().seconds;
          const u = t - o;
          if (console.log(`URGENT DEBUG - Track ${i.id} position calculation:`, {
            formula: `transportPosition (${t}s) - trackOffset (${o}s) = trackPlayTime (${u}s)`,
            trackX: s,
            transportPositionSource: "direct from Tone.Transport.seconds",
            trackPlayTimeExplanation: u >= 0 ? `Play track from ${u}s offset` : `Schedule track to start in ${Math.abs(u)}s`
          }), console.log(`Track ${i.id} timing calculations:`, {
            transportPosition: t,
            trackX: s,
            trackOffset: o,
            trackPlayTime: u,
            formula: `${t}s - ${o}s = ${u}s`
          }), u >= 0) {
            console.log(`Track ${i.id} starting now from position ${u}s (offset: ${o}s)`);
            try {
              i.player.state === "started" && i.player.stop(), i.player.unsync(), i.player.volume.value = kd(i.volume, i.muted), console.log(`REVISED APPROACH: Starting track ${i.id} from ${u}s`), i.player.start("+0", u), i.player.sync(), console.log(`Successfully started track ${i.id} at offset ${u}s`);
            } catch (f) {
              console.error(`Error starting track ${i.id}:`, f);
            }
          } else {
            const f = Math.abs(u);
            console.log(`Track ${i.id} will start in ${f}s (at transport time ${o}s)`);
            try {
              i.player.unsync();
              const g = `+${f + 0.01}`;
              console.log(`Scheduling track ${i.id} to start in ${g} seconds`);
              const v = Lh.schedule((x) => {
                var b, _, T, A;
                try {
                  console.log(`EXECUTING SCHEDULE: Track ${i.id} at time ${x}`), ((b = i.player) == null ? void 0 : b.state) === "started" && i.player.stop(), (_ = i.player) == null || _.unsync(), i.player.volume.value = kd(i.volume, i.muted), (T = i.player) == null || T.start(x, 0), (A = i.player) == null || A.sync(), console.log(`Track ${i.id} started at scheduled time ${x}`);
                } catch (O) {
                  console.error(`Error starting scheduled track ${i.id}:`, O);
                }
              }, g);
              this.scheduledEvents.push(v);
            } catch (p) {
              console.error(`Error scheduling track ${i.id}:`, p);
            }
          }
          console.log(`Prepared player for track ${i.id}, position: ${s}px`);
        }), Mi().state === "started" && (console.log("Transport was already running, pausing before restart"), Mi().pause()), console.log(`Transport position before start: ${Mi().seconds}s`), Mi().start(), console.log("Transport started, state:", Mi().state);
      } catch (t) {
        console.error("Error starting playback:", t), this.stop();
      } finally {
        this.isStarting = !1;
      }
    }
  }
  // Clear any scheduled events (called when stopping, seeking, or starting playback)
  clearScheduledEvents() {
    console.log(`Clearing all scheduled events (${this.scheduledEvents.length})`), this.scheduledEvents.forEach((t) => {
      Lh.clear(t);
    }), this.scheduledEvents = [];
  }
  pause() {
    console.log("Pausing playback at position:", this.position), this.clearScheduledEvents(), this.audioEngine.getAllTracks().forEach((n) => {
      n.player && n.player.volume.rampTo(-1 / 0, Ah.FADE_TIME);
    });
    const t = this.position;
    setTimeout(() => {
      Mi().pause(), this.audioEngine.getAllTracks().forEach((n) => {
        n.player && n.player.state === "started" && (n.player.stop(), n.player.unsync());
      }), console.log("Transport: Paused at position", t);
    }, Ah.FADE_TIME * 1e3);
  }
  stop() {
    console.log("Stopping transport and resetting position to 0"), this.isStarting = !1, this.clearScheduledEvents(), this.audioEngine.getAllTracks().forEach((t) => {
      t.player && t.player.volume.rampTo(-1 / 0, Ah.FADE_TIME);
    }), setTimeout(() => {
      Mi().stop(), Mi().seconds = 0, this.audioEngine.stopAllPlayback(), this.audioEngine.getAllTracks().forEach((t) => {
        t.player && (t.player.unsync(), console.log(`Reset player for track ${t.id}`));
      }), console.log("Transport: Successfully reset to position 0");
    }, Ah.FADE_TIME * 1e3);
  }
  seek(t) {
    t = Math.max(0, Math.min(t, this.maxPosition));
    const n = this.isPlaying, i = this.position;
    console.log(`SEEKING: From ${i}s to ${t}s (delta: ${t - i}s)`), Mi().stop(), this.clearScheduledEvents(), this.audioEngine.getAllTracks().forEach((s) => {
      s.player && (s.player.state === "started" && s.player.stop(), s.player.unsync(), s.player.volume.cancelScheduledValues(Nx()), s.player.volume.value = kd(s.volume, s.muted));
    }), Mi().seconds = t, console.log(`Transport position set to ${t}s, verified: ${Mi().seconds}s`), Math.abs(Mi().seconds - t) > 1e-3 && (console.warn("Transport position didn't set properly - forcing again"), Mi().seconds = t), n && setTimeout(() => {
      console.log(`Restarting playback from position: ${Mi().seconds}s`), this.play();
    }, 30);
  }
  setTempo(t) {
    const n = Math.max(20, Math.min(t, 300));
    Mi().bpm.value = n;
  }
  dispose() {
    this.stop(), Mi().dispose();
  }
  async loadAudioFile(t, n) {
    var i;
    try {
      await this.audioEngine.createTrack(t, n.name, n);
      const s = this.audioEngine.getAllTracks().find((u) => u.id === t);
      if (!(s != null && s.player))
        throw new Error(`Failed to create player for track ${t}`);
      const o = ((i = s.player.buffer) == null ? void 0 : i.duration) ?? 0;
      this.maxPosition = Math.max(this.maxPosition, o);
    } catch (s) {
      throw console.error(`Failed to load audio file for track ${t}:`, s), s;
    }
  }
  removeTrack(t) {
    this.maxPosition = Math.max(
      0,
      ...this.audioEngine.getAllTracks().filter((n) => n.id !== t).map((n) => {
        var i, s;
        return ((s = (i = n.player) == null ? void 0 : i.buffer) == null ? void 0 : s.duration) ?? 0;
      })
    );
  }
  setPosition(t) {
    this.seek(t);
  }
  /**
   * Handle track position changes during playback
   * This recalculates and adjusts the playback for a specific track that was moved
   */
  handleTrackPositionChange(t, n) {
    if (!this.isPlaying) {
      console.log(`Track ${t} position changed, but not playing - no action needed`);
      return;
    }
    const i = this.audioEngine.getAllTracks().find((u) => u.id === t);
    if (!i || !i.player) {
      console.log(`Track ${t} not found or has no player`);
      return;
    }
    console.log(`Handling position change for track ${t} to x:${n}px during playback`);
    const s = this.position;
    console.log(`Pausing playback at ${s}s and recalculating all tracks`);
    const o = this.isPlaying;
    this.clearScheduledEvents(), this.audioEngine.getAllTracks().forEach((u) => {
      u.player && (u.player.state === "started" && u.player.stop(), u.player.unsync());
    }), Mi().pause(), Mi().seconds = s, o && setTimeout(() => {
      console.log(`Restarting playback at position ${s}s with new track positions`), this.play();
    }, 20);
  }
};
// Default to 1 hour (3600 seconds) as safety
Qe(Ah, "FADE_TIME", 0.01);
let p2 = Ah;
var _h = {}, zy = {}, gb, kx;
function nU() {
  if (kx) return gb;
  kx = 1;
  function e(s) {
    var o = new i(s), u = o.readChunk();
    if (u.id != "MThd")
      throw "Bad MIDI file.  Expected 'MHdr', got: '" + u.id + "'";
    for (var h = t(u.data), f = [], p = 0; !o.eof() && p < h.numTracks; p++) {
      var g = o.readChunk();
      if (g.id != "MTrk")
        throw "Bad MIDI file.  Expected 'MTrk', got: '" + g.id + "'";
      var v = n(g.data);
      f.push(v);
    }
    return {
      header: h,
      tracks: f
    };
  }
  function t(s) {
    var o = new i(s), u = o.readUInt16(), h = o.readUInt16(), f = {
      format: u,
      numTracks: h
    }, p = o.readUInt16();
    return p & 32768 ? (f.framesPerSecond = 256 - (p >> 8), f.ticksPerFrame = p & 255) : f.ticksPerBeat = p, f;
  }
  function n(s) {
    for (var o = new i(s), u = []; !o.eof(); ) {
      var h = p();
      u.push(h);
    }
    return u;
    var f;
    function p() {
      var g = {};
      g.deltaTime = o.readVarInt();
      var v = o.readUInt8();
      if ((v & 240) === 240)
        if (v === 255) {
          g.meta = !0;
          var x = o.readUInt8(), b = o.readVarInt();
          switch (x) {
            case 0:
              if (g.type = "sequenceNumber", b !== 2) throw "Expected length for sequenceNumber event is 2, got " + b;
              return g.number = o.readUInt16(), g;
            case 1:
              return g.type = "text", g.text = o.readString(b), g;
            case 2:
              return g.type = "copyrightNotice", g.text = o.readString(b), g;
            case 3:
              return g.type = "trackName", g.text = o.readString(b), g;
            case 4:
              return g.type = "instrumentName", g.text = o.readString(b), g;
            case 5:
              return g.type = "lyrics", g.text = o.readString(b), g;
            case 6:
              return g.type = "marker", g.text = o.readString(b), g;
            case 7:
              return g.type = "cuePoint", g.text = o.readString(b), g;
            case 32:
              if (g.type = "channelPrefix", b != 1) throw "Expected length for channelPrefix event is 1, got " + b;
              return g.channel = o.readUInt8(), g;
            case 33:
              if (g.type = "portPrefix", b != 1) throw "Expected length for portPrefix event is 1, got " + b;
              return g.port = o.readUInt8(), g;
            case 47:
              if (g.type = "endOfTrack", b != 0) throw "Expected length for endOfTrack event is 0, got " + b;
              return g;
            case 81:
              if (g.type = "setTempo", b != 3) throw "Expected length for setTempo event is 3, got " + b;
              return g.microsecondsPerBeat = o.readUInt24(), g;
            case 84:
              if (g.type = "smpteOffset", b != 5) throw "Expected length for smpteOffset event is 5, got " + b;
              var _ = o.readUInt8(), T = { 0: 24, 32: 25, 64: 29, 96: 30 };
              return g.frameRate = T[_ & 96], g.hour = _ & 31, g.min = o.readUInt8(), g.sec = o.readUInt8(), g.frame = o.readUInt8(), g.subFrame = o.readUInt8(), g;
            case 88:
              if (g.type = "timeSignature", b != 2 && b != 4) throw "Expected length for timeSignature event is 4 or 2, got " + b;
              return g.numerator = o.readUInt8(), g.denominator = 1 << o.readUInt8(), b === 4 ? (g.metronome = o.readUInt8(), g.thirtyseconds = o.readUInt8()) : (g.metronome = 36, g.thirtyseconds = 8), g;
            case 89:
              if (g.type = "keySignature", b != 2) throw "Expected length for keySignature event is 2, got " + b;
              return g.key = o.readInt8(), g.scale = o.readUInt8(), g;
            case 127:
              return g.type = "sequencerSpecific", g.data = o.readBytes(b), g;
            default:
              return g.type = "unknownMeta", g.data = o.readBytes(b), g.metatypeByte = x, g;
          }
        } else if (v == 240) {
          g.type = "sysEx";
          var b = o.readVarInt();
          return g.data = o.readBytes(b), g;
        } else if (v == 247) {
          g.type = "endSysEx";
          var b = o.readVarInt();
          return g.data = o.readBytes(b), g;
        } else
          throw "Unrecognised MIDI event type byte: " + v;
      else {
        var A;
        if ((v & 128) === 0) {
          if (f === null)
            throw "Running status byte encountered before status byte";
          A = v, v = f, g.running = !0;
        } else
          A = o.readUInt8(), f = v;
        var O = v >> 4;
        switch (g.channel = v & 15, O) {
          case 8:
            return g.type = "noteOff", g.noteNumber = A, g.velocity = o.readUInt8(), g;
          case 9:
            var M = o.readUInt8();
            return g.type = M === 0 ? "noteOff" : "noteOn", g.noteNumber = A, g.velocity = M, M === 0 && (g.byte9 = !0), g;
          case 10:
            return g.type = "noteAftertouch", g.noteNumber = A, g.amount = o.readUInt8(), g;
          case 11:
            return g.type = "controller", g.controllerType = A, g.value = o.readUInt8(), g;
          case 12:
            return g.type = "programChange", g.programNumber = A, g;
          case 13:
            return g.type = "channelAftertouch", g.amount = A, g;
          case 14:
            return g.type = "pitchBend", g.value = A + (o.readUInt8() << 7) - 8192, g;
          default:
            throw "Unrecognised MIDI event type: " + O;
        }
      }
    }
  }
  function i(s) {
    this.buffer = s, this.bufferLen = this.buffer.length, this.pos = 0;
  }
  return i.prototype.eof = function() {
    return this.pos >= this.bufferLen;
  }, i.prototype.readUInt8 = function() {
    var s = this.buffer[this.pos];
    return this.pos += 1, s;
  }, i.prototype.readInt8 = function() {
    var s = this.readUInt8();
    return s & 128 ? s - 256 : s;
  }, i.prototype.readUInt16 = function() {
    var s = this.readUInt8(), o = this.readUInt8();
    return (s << 8) + o;
  }, i.prototype.readInt16 = function() {
    var s = this.readUInt16();
    return s & 32768 ? s - 65536 : s;
  }, i.prototype.readUInt24 = function() {
    var s = this.readUInt8(), o = this.readUInt8(), u = this.readUInt8();
    return (s << 16) + (o << 8) + u;
  }, i.prototype.readInt24 = function() {
    var s = this.readUInt24();
    return s & 8388608 ? s - 16777216 : s;
  }, i.prototype.readUInt32 = function() {
    var s = this.readUInt8(), o = this.readUInt8(), u = this.readUInt8(), h = this.readUInt8();
    return (s << 24) + (o << 16) + (u << 8) + h;
  }, i.prototype.readBytes = function(s) {
    var o = this.buffer.slice(this.pos, this.pos + s);
    return this.pos += s, o;
  }, i.prototype.readString = function(s) {
    var o = this.readBytes(s);
    return String.fromCharCode.apply(null, o);
  }, i.prototype.readVarInt = function() {
    for (var s = 0; !this.eof(); ) {
      var o = this.readUInt8();
      if (o & 128)
        s += o & 127, s <<= 7;
      else
        return s + o;
    }
    return s;
  }, i.prototype.readChunk = function() {
    var s = this.readString(4), o = this.readUInt32(), u = this.readBytes(o);
    return {
      id: s,
      length: o,
      data: u
    };
  }, gb = e, gb;
}
var yb, Dx;
function iU() {
  if (Dx) return yb;
  Dx = 1;
  function e(o, u) {
    if (typeof o != "object")
      throw "Invalid MIDI data";
    u = u || {};
    var h = o.header || {}, f = o.tracks || [], p, g = f.length, v = new s();
    for (t(v, h, g), p = 0; p < g; p++)
      n(v, f[p], u);
    return v.buffer;
  }
  function t(o, u, h) {
    var f = u.format == null ? 1 : u.format, p = 128;
    u.timeDivision ? p = u.timeDivision : u.ticksPerFrame && u.framesPerSecond ? p = -(u.framesPerSecond & 255) << 8 | u.ticksPerFrame & 255 : u.ticksPerBeat && (p = u.ticksPerBeat & 32767);
    var g = new s();
    g.writeUInt16(f), g.writeUInt16(h), g.writeUInt16(p), o.writeChunk("MThd", g.buffer);
  }
  function n(o, u, h) {
    var f = new s(), p, g = u.length, v = null;
    for (p = 0; p < g; p++)
      (h.running === !1 || !h.running && !u[p].running) && (v = null), v = i(f, u[p], v, h.useByte9ForNoteOff);
    o.writeChunk("MTrk", f.buffer);
  }
  function i(o, u, h, f) {
    var p = u.type, g = u.deltaTime, v = u.text || "", x = u.data || [], b = null;
    switch (o.writeVarInt(g), p) {
      // meta events
      case "sequenceNumber":
        o.writeUInt8(255), o.writeUInt8(0), o.writeVarInt(2), o.writeUInt16(u.number);
        break;
      case "text":
        o.writeUInt8(255), o.writeUInt8(1), o.writeVarInt(v.length), o.writeString(v);
        break;
      case "copyrightNotice":
        o.writeUInt8(255), o.writeUInt8(2), o.writeVarInt(v.length), o.writeString(v);
        break;
      case "trackName":
        o.writeUInt8(255), o.writeUInt8(3), o.writeVarInt(v.length), o.writeString(v);
        break;
      case "instrumentName":
        o.writeUInt8(255), o.writeUInt8(4), o.writeVarInt(v.length), o.writeString(v);
        break;
      case "lyrics":
        o.writeUInt8(255), o.writeUInt8(5), o.writeVarInt(v.length), o.writeString(v);
        break;
      case "marker":
        o.writeUInt8(255), o.writeUInt8(6), o.writeVarInt(v.length), o.writeString(v);
        break;
      case "cuePoint":
        o.writeUInt8(255), o.writeUInt8(7), o.writeVarInt(v.length), o.writeString(v);
        break;
      case "channelPrefix":
        o.writeUInt8(255), o.writeUInt8(32), o.writeVarInt(1), o.writeUInt8(u.channel);
        break;
      case "portPrefix":
        o.writeUInt8(255), o.writeUInt8(33), o.writeVarInt(1), o.writeUInt8(u.port);
        break;
      case "endOfTrack":
        o.writeUInt8(255), o.writeUInt8(47), o.writeVarInt(0);
        break;
      case "setTempo":
        o.writeUInt8(255), o.writeUInt8(81), o.writeVarInt(3), o.writeUInt24(u.microsecondsPerBeat);
        break;
      case "smpteOffset":
        o.writeUInt8(255), o.writeUInt8(84), o.writeVarInt(5);
        var _ = { 24: 0, 25: 32, 29: 64, 30: 96 }, T = u.hour & 31 | _[u.frameRate];
        o.writeUInt8(T), o.writeUInt8(u.min), o.writeUInt8(u.sec), o.writeUInt8(u.frame), o.writeUInt8(u.subFrame);
        break;
      case "timeSignature":
        o.writeUInt8(255), o.writeUInt8(88), o.writeVarInt(4), o.writeUInt8(u.numerator);
        var A = Math.floor(Math.log(u.denominator) / Math.LN2) & 255;
        o.writeUInt8(A), o.writeUInt8(u.metronome), o.writeUInt8(u.thirtyseconds || 8);
        break;
      case "keySignature":
        o.writeUInt8(255), o.writeUInt8(89), o.writeVarInt(2), o.writeInt8(u.key), o.writeUInt8(u.scale);
        break;
      case "sequencerSpecific":
        o.writeUInt8(255), o.writeUInt8(127), o.writeVarInt(x.length), o.writeBytes(x);
        break;
      case "unknownMeta":
        u.metatypeByte != null && (o.writeUInt8(255), o.writeUInt8(u.metatypeByte), o.writeVarInt(x.length), o.writeBytes(x));
        break;
      // system-exclusive
      case "sysEx":
        o.writeUInt8(240), o.writeVarInt(x.length), o.writeBytes(x);
        break;
      case "endSysEx":
        o.writeUInt8(247), o.writeVarInt(x.length), o.writeBytes(x);
        break;
      // channel events
      case "noteOff":
        var O = f !== !1 && u.byte9 || f && u.velocity == 0 ? 144 : 128;
        b = O | u.channel, b !== h && o.writeUInt8(b), o.writeUInt8(u.noteNumber), o.writeUInt8(u.velocity);
        break;
      case "noteOn":
        b = 144 | u.channel, b !== h && o.writeUInt8(b), o.writeUInt8(u.noteNumber), o.writeUInt8(u.velocity);
        break;
      case "noteAftertouch":
        b = 160 | u.channel, b !== h && o.writeUInt8(b), o.writeUInt8(u.noteNumber), o.writeUInt8(u.amount);
        break;
      case "controller":
        b = 176 | u.channel, b !== h && o.writeUInt8(b), o.writeUInt8(u.controllerType), o.writeUInt8(u.value);
        break;
      case "programChange":
        b = 192 | u.channel, b !== h && o.writeUInt8(b), o.writeUInt8(u.programNumber);
        break;
      case "channelAftertouch":
        b = 208 | u.channel, b !== h && o.writeUInt8(b), o.writeUInt8(u.amount);
        break;
      case "pitchBend":
        b = 224 | u.channel, b !== h && o.writeUInt8(b);
        var M = 8192 + u.value, E = M & 127, R = M >> 7 & 127;
        o.writeUInt8(E), o.writeUInt8(R);
        break;
      default:
        throw "Unrecognized event type: " + p;
    }
    return b;
  }
  function s() {
    this.buffer = [];
  }
  return s.prototype.writeUInt8 = function(o) {
    this.buffer.push(o & 255);
  }, s.prototype.writeInt8 = s.prototype.writeUInt8, s.prototype.writeUInt16 = function(o) {
    var u = o >> 8 & 255, h = o & 255;
    this.writeUInt8(u), this.writeUInt8(h);
  }, s.prototype.writeInt16 = s.prototype.writeUInt16, s.prototype.writeUInt24 = function(o) {
    var u = o >> 16 & 255, h = o >> 8 & 255, f = o & 255;
    this.writeUInt8(u), this.writeUInt8(h), this.writeUInt8(f);
  }, s.prototype.writeInt24 = s.prototype.writeUInt24, s.prototype.writeUInt32 = function(o) {
    var u = o >> 24 & 255, h = o >> 16 & 255, f = o >> 8 & 255, p = o & 255;
    this.writeUInt8(u), this.writeUInt8(h), this.writeUInt8(f), this.writeUInt8(p);
  }, s.prototype.writeInt32 = s.prototype.writeUInt32, s.prototype.writeBytes = function(o) {
    this.buffer = this.buffer.concat(Array.prototype.slice.call(o, 0));
  }, s.prototype.writeString = function(o) {
    var u, h = o.length, f = [];
    for (u = 0; u < h; u++)
      f.push(o.codePointAt(u));
    this.writeBytes(f);
  }, s.prototype.writeVarInt = function(o) {
    if (o < 0) throw "Cannot write negative variable-length integer";
    if (o <= 127)
      this.writeUInt8(o);
    else {
      var u = o, h = [];
      for (h.push(u & 127), u >>= 7; u; ) {
        var f = u & 127 | 128;
        h.push(f), u >>= 7;
      }
      this.writeBytes(h.reverse());
    }
  }, s.prototype.writeChunk = function(o, u) {
    this.writeString(o), this.writeUInt32(u.length), this.writeBytes(u);
  }, yb = e, yb;
}
var Bx;
function I6() {
  return Bx || (Bx = 1, zy.parseMidi = nU(), zy.writeMidi = iU()), zy;
}
var vb = {}, Sh = {}, zx;
function F6() {
  if (zx) return Sh;
  zx = 1, Object.defineProperty(Sh, "__esModule", { value: !0 }), Sh.insert = Sh.search = void 0;
  function e(n, i, s) {
    s === void 0 && (s = "ticks");
    var o = 0, u = n.length, h = u;
    if (u > 0 && n[u - 1][s] <= i)
      return u - 1;
    for (; o < h; ) {
      var f = Math.floor(o + (h - o) / 2), p = n[f], g = n[f + 1];
      if (p[s] === i) {
        for (var v = f; v < n.length; v++) {
          var x = n[v];
          x[s] === i && (f = v);
        }
        return f;
      } else {
        if (p[s] < i && g[s] > i)
          return f;
        p[s] > i ? h = f : p[s] < i && (o = f + 1);
      }
    }
    return -1;
  }
  Sh.search = e;
  function t(n, i, s) {
    if (s === void 0 && (s = "ticks"), n.length) {
      var o = e(n, i[s], s);
      n.splice(o + 1, 0, i);
    } else
      n.push(i);
  }
  return Sh.insert = t, Sh;
}
var Px;
function m2() {
  return Px || (Px = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.Header = e.keySignatureKeys = void 0;
    var t = F6(), n = /* @__PURE__ */ new WeakMap();
    e.keySignatureKeys = [
      "Cb",
      "Gb",
      "Db",
      "Ab",
      "Eb",
      "Bb",
      "F",
      "C",
      "G",
      "D",
      "A",
      "E",
      "B",
      "F#",
      "C#"
    ];
    var i = (
      /** @class */
      function() {
        function s(o) {
          var u = this;
          if (this.tempos = [], this.timeSignatures = [], this.keySignatures = [], this.meta = [], this.name = "", n.set(this, 480), o) {
            n.set(this, o.header.ticksPerBeat), o.tracks.forEach(function(f) {
              f.forEach(function(p) {
                p.meta && (p.type === "timeSignature" ? u.timeSignatures.push({
                  ticks: p.absoluteTime,
                  timeSignature: [
                    p.numerator,
                    p.denominator
                  ]
                }) : p.type === "setTempo" ? u.tempos.push({
                  bpm: 6e7 / p.microsecondsPerBeat,
                  ticks: p.absoluteTime
                }) : p.type === "keySignature" && u.keySignatures.push({
                  key: e.keySignatureKeys[p.key + 7],
                  scale: p.scale === 0 ? "major" : "minor",
                  ticks: p.absoluteTime
                }));
              });
            });
            var h = 0;
            o.tracks[0].forEach(function(f) {
              h += f.deltaTime, f.meta && (f.type === "trackName" ? u.name = f.text : (f.type === "text" || f.type === "cuePoint" || f.type === "marker" || f.type === "lyrics") && u.meta.push({
                text: f.text,
                ticks: h,
                type: f.type
              }));
            }), this.update();
          }
        }
        return s.prototype.update = function() {
          var o = this, u = 0, h = 0;
          this.tempos.sort(function(f, p) {
            return f.ticks - p.ticks;
          }), this.tempos.forEach(function(f, p) {
            var g = p > 0 ? o.tempos[p - 1].bpm : o.tempos[0].bpm, v = f.ticks / o.ppq - h, x = 60 / g * v;
            f.time = x + u, u = f.time, h += v;
          }), this.timeSignatures.sort(function(f, p) {
            return f.ticks - p.ticks;
          }), this.timeSignatures.forEach(function(f, p) {
            var g = p > 0 ? o.timeSignatures[p - 1] : o.timeSignatures[0], v = (f.ticks - g.ticks) / o.ppq, x = v / g.timeSignature[0] / (g.timeSignature[1] / 4);
            g.measures = g.measures || 0, f.measures = x + g.measures;
          });
        }, s.prototype.ticksToSeconds = function(o) {
          var u = (0, t.search)(this.tempos, o);
          if (u !== -1) {
            var h = this.tempos[u], f = h.time, p = (o - h.ticks) / this.ppq;
            return f + 60 / h.bpm * p;
          } else {
            var g = o / this.ppq;
            return 60 / 120 * g;
          }
        }, s.prototype.ticksToMeasures = function(o) {
          var u = (0, t.search)(this.timeSignatures, o);
          if (u !== -1) {
            var h = this.timeSignatures[u], f = (o - h.ticks) / this.ppq;
            return h.measures + f / (h.timeSignature[0] / h.timeSignature[1]) / 4;
          } else
            return o / this.ppq / 4;
        }, Object.defineProperty(s.prototype, "ppq", {
          /**
           * The number of ticks per quarter note.
           */
          get: function() {
            return n.get(this);
          },
          enumerable: !1,
          configurable: !0
        }), s.prototype.secondsToTicks = function(o) {
          var u = (0, t.search)(this.tempos, o, "time");
          if (u !== -1) {
            var h = this.tempos[u], f = h.time, p = o - f, g = p / (60 / h.bpm);
            return Math.round(h.ticks + g * this.ppq);
          } else {
            var v = o / 0.5;
            return Math.round(v * this.ppq);
          }
        }, s.prototype.toJSON = function() {
          return {
            keySignatures: this.keySignatures,
            meta: this.meta,
            name: this.name,
            ppq: this.ppq,
            tempos: this.tempos.map(function(o) {
              return {
                bpm: o.bpm,
                ticks: o.ticks
              };
            }),
            timeSignatures: this.timeSignatures
          };
        }, s.prototype.fromJSON = function(o) {
          this.name = o.name, this.tempos = o.tempos.map(function(u) {
            return Object.assign({}, u);
          }), this.timeSignatures = o.timeSignatures.map(function(u) {
            return Object.assign({}, u);
          }), this.keySignatures = o.keySignatures.map(function(u) {
            return Object.assign({}, u);
          }), this.meta = o.meta.map(function(u) {
            return Object.assign({}, u);
          }), n.set(this, o.ppq), this.update();
        }, s.prototype.setTempo = function(o) {
          this.tempos = [
            {
              bpm: o,
              ticks: 0
            }
          ], this.update();
        }, s;
      }()
    );
    e.Header = i;
  }(vb)), vb;
}
var _m = {}, bb = {}, Ux;
function q6() {
  return Ux || (Ux = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ControlChange = e.controlChangeIds = e.controlChangeNames = void 0, e.controlChangeNames = {
      1: "modulationWheel",
      2: "breath",
      4: "footController",
      5: "portamentoTime",
      7: "volume",
      8: "balance",
      10: "pan",
      64: "sustain",
      65: "portamentoTime",
      66: "sostenuto",
      67: "softPedal",
      68: "legatoFootswitch",
      84: "portamentoControl"
    }, e.controlChangeIds = Object.keys(e.controlChangeNames).reduce(function(s, o) {
      return s[e.controlChangeNames[o]] = o, s;
    }, {});
    var t = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap(), i = (
      /** @class */
      function() {
        function s(o, u) {
          t.set(this, u), n.set(this, o.controllerType), this.ticks = o.absoluteTime, this.value = o.value;
        }
        return Object.defineProperty(s.prototype, "number", {
          /**
           * The controller number
           */
          get: function() {
            return n.get(this);
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(s.prototype, "name", {
          /**
           * return the common name of the control number if it exists
           */
          get: function() {
            return e.controlChangeNames[this.number] ? e.controlChangeNames[this.number] : null;
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(s.prototype, "time", {
          /**
           * The time of the event in seconds
           */
          get: function() {
            var o = t.get(this);
            return o.ticksToSeconds(this.ticks);
          },
          set: function(o) {
            var u = t.get(this);
            this.ticks = u.secondsToTicks(o);
          },
          enumerable: !1,
          configurable: !0
        }), s.prototype.toJSON = function() {
          return {
            number: this.number,
            ticks: this.ticks,
            time: this.time,
            value: this.value
          };
        }, s;
      }()
    );
    e.ControlChange = i;
  }(bb)), bb;
}
var Sm = {}, jx;
function rU() {
  if (jx) return Sm;
  jx = 1, Object.defineProperty(Sm, "__esModule", { value: !0 }), Sm.createControlChanges = void 0;
  var e = q6();
  function t() {
    return new Proxy({}, {
      // tslint:disable-next-line: typedef
      get: function(n, i) {
        if (n[i])
          return n[i];
        if (e.controlChangeIds.hasOwnProperty(i))
          return n[e.controlChangeIds[i]];
      },
      // tslint:disable-next-line: typedef
      set: function(n, i, s) {
        return e.controlChangeIds.hasOwnProperty(i) ? n[e.controlChangeIds[i]] = s : n[i] = s, !0;
      }
    });
  }
  return Sm.createControlChanges = t, Sm;
}
var xm = {}, Lx;
function aU() {
  if (Lx) return xm;
  Lx = 1, Object.defineProperty(xm, "__esModule", { value: !0 }), xm.PitchBend = void 0;
  var e = /* @__PURE__ */ new WeakMap(), t = (
    /** @class */
    function() {
      function n(i, s) {
        e.set(this, s), this.ticks = i.absoluteTime, this.value = i.value;
      }
      return Object.defineProperty(n.prototype, "time", {
        /**
         * The time of the event in seconds
         */
        get: function() {
          var i = e.get(this);
          return i.ticksToSeconds(this.ticks);
        },
        set: function(i) {
          var s = e.get(this);
          this.ticks = s.secondsToTicks(i);
        },
        enumerable: !1,
        configurable: !0
      }), n.prototype.toJSON = function() {
        return {
          ticks: this.ticks,
          time: this.time,
          value: this.value
        };
      }, n;
    }()
  );
  return xm.PitchBend = t, xm;
}
var Tm = {}, Eu = {}, Vx;
function sU() {
  return Vx || (Vx = 1, Object.defineProperty(Eu, "__esModule", { value: !0 }), Eu.DrumKitByPatchID = Eu.InstrumentFamilyByID = Eu.instrumentByPatchID = void 0, Eu.instrumentByPatchID = [
    "acoustic grand piano",
    "bright acoustic piano",
    "electric grand piano",
    "honky-tonk piano",
    "electric piano 1",
    "electric piano 2",
    "harpsichord",
    "clavi",
    "celesta",
    "glockenspiel",
    "music box",
    "vibraphone",
    "marimba",
    "xylophone",
    "tubular bells",
    "dulcimer",
    "drawbar organ",
    "percussive organ",
    "rock organ",
    "church organ",
    "reed organ",
    "accordion",
    "harmonica",
    "tango accordion",
    "acoustic guitar (nylon)",
    "acoustic guitar (steel)",
    "electric guitar (jazz)",
    "electric guitar (clean)",
    "electric guitar (muted)",
    "overdriven guitar",
    "distortion guitar",
    "guitar harmonics",
    "acoustic bass",
    "electric bass (finger)",
    "electric bass (pick)",
    "fretless bass",
    "slap bass 1",
    "slap bass 2",
    "synth bass 1",
    "synth bass 2",
    "violin",
    "viola",
    "cello",
    "contrabass",
    "tremolo strings",
    "pizzicato strings",
    "orchestral harp",
    "timpani",
    "string ensemble 1",
    "string ensemble 2",
    "synthstrings 1",
    "synthstrings 2",
    "choir aahs",
    "voice oohs",
    "synth voice",
    "orchestra hit",
    "trumpet",
    "trombone",
    "tuba",
    "muted trumpet",
    "french horn",
    "brass section",
    "synthbrass 1",
    "synthbrass 2",
    "soprano sax",
    "alto sax",
    "tenor sax",
    "baritone sax",
    "oboe",
    "english horn",
    "bassoon",
    "clarinet",
    "piccolo",
    "flute",
    "recorder",
    "pan flute",
    "blown bottle",
    "shakuhachi",
    "whistle",
    "ocarina",
    "lead 1 (square)",
    "lead 2 (sawtooth)",
    "lead 3 (calliope)",
    "lead 4 (chiff)",
    "lead 5 (charang)",
    "lead 6 (voice)",
    "lead 7 (fifths)",
    "lead 8 (bass + lead)",
    "pad 1 (new age)",
    "pad 2 (warm)",
    "pad 3 (polysynth)",
    "pad 4 (choir)",
    "pad 5 (bowed)",
    "pad 6 (metallic)",
    "pad 7 (halo)",
    "pad 8 (sweep)",
    "fx 1 (rain)",
    "fx 2 (soundtrack)",
    "fx 3 (crystal)",
    "fx 4 (atmosphere)",
    "fx 5 (brightness)",
    "fx 6 (goblins)",
    "fx 7 (echoes)",
    "fx 8 (sci-fi)",
    "sitar",
    "banjo",
    "shamisen",
    "koto",
    "kalimba",
    "bag pipe",
    "fiddle",
    "shanai",
    "tinkle bell",
    "agogo",
    "steel drums",
    "woodblock",
    "taiko drum",
    "melodic tom",
    "synth drum",
    "reverse cymbal",
    "guitar fret noise",
    "breath noise",
    "seashore",
    "bird tweet",
    "telephone ring",
    "helicopter",
    "applause",
    "gunshot"
  ], Eu.InstrumentFamilyByID = [
    "piano",
    "chromatic percussion",
    "organ",
    "guitar",
    "bass",
    "strings",
    "ensemble",
    "brass",
    "reed",
    "pipe",
    "synth lead",
    "synth pad",
    "synth effects",
    "world",
    "percussive",
    "sound effects"
  ], Eu.DrumKitByPatchID = {
    0: "standard kit",
    8: "room kit",
    16: "power kit",
    24: "electronic kit",
    25: "tr-808 kit",
    32: "jazz kit",
    40: "brush kit",
    48: "orchestra kit",
    56: "sound fx kit"
  }), Eu;
}
var Ix;
function oU() {
  if (Ix) return Tm;
  Ix = 1, Object.defineProperty(Tm, "__esModule", { value: !0 }), Tm.Instrument = void 0;
  var e = sU(), t = /* @__PURE__ */ new WeakMap(), n = (
    /** @class */
    function() {
      function i(s, o) {
        if (this.number = 0, t.set(this, o), this.number = 0, s) {
          var u = s.find(function(h) {
            return h.type === "programChange";
          });
          u && (this.number = u.programNumber);
        }
      }
      return Object.defineProperty(i.prototype, "name", {
        /**
         * The common name of the instrument.
         */
        get: function() {
          return this.percussion ? e.DrumKitByPatchID[this.number] : e.instrumentByPatchID[this.number];
        },
        set: function(s) {
          var o = e.instrumentByPatchID.indexOf(s);
          o !== -1 && (this.number = o);
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(i.prototype, "family", {
        /**
         * The instrument family, e.g. "piano".
         */
        get: function() {
          return this.percussion ? "drums" : e.InstrumentFamilyByID[Math.floor(this.number / 8)];
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(i.prototype, "percussion", {
        /**
         * If the instrument is a percussion instrument.
         */
        get: function() {
          var s = t.get(this);
          return s.channel === 9;
        },
        enumerable: !1,
        configurable: !0
      }), i.prototype.toJSON = function() {
        return {
          family: this.family,
          number: this.number,
          name: this.name
        };
      }, i.prototype.fromJSON = function(s) {
        this.number = s.number;
      }, i;
    }()
  );
  return Tm.Instrument = n, Tm;
}
var Cm = {}, Fx;
function lU() {
  if (Fx) return Cm;
  Fx = 1, Object.defineProperty(Cm, "__esModule", { value: !0 }), Cm.Note = void 0;
  function e(u) {
    var h = Math.floor(u / 12) - 1;
    return t(u) + h.toString();
  }
  function t(u) {
    var h = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"], f = u % 12;
    return h[f];
  }
  function n(u) {
    var h = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
    return h.indexOf(u);
  }
  var i = /* @__PURE__ */ function() {
    var u = /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i, h = {
      // tslint:disable-next-line: object-literal-sort-keys
      cbb: -2,
      cb: -1,
      c: 0,
      "c#": 1,
      cx: 2,
      dbb: 0,
      db: 1,
      d: 2,
      "d#": 3,
      dx: 4,
      ebb: 2,
      eb: 3,
      e: 4,
      "e#": 5,
      ex: 6,
      fbb: 3,
      fb: 4,
      f: 5,
      "f#": 6,
      fx: 7,
      gbb: 5,
      gb: 6,
      g: 7,
      "g#": 8,
      gx: 9,
      abb: 7,
      ab: 8,
      a: 9,
      "a#": 10,
      ax: 11,
      bbb: 9,
      bb: 10,
      b: 11,
      "b#": 12,
      bx: 13
    };
    return function(f) {
      var p = u.exec(f), g = p[1], v = p[2], x = h[g.toLowerCase()];
      return x + (parseInt(v, 10) + 1) * 12;
    };
  }(), s = /* @__PURE__ */ new WeakMap(), o = (
    /** @class */
    function() {
      function u(h, f, p) {
        s.set(this, p), this.midi = h.midi, this.velocity = h.velocity, this.noteOffVelocity = f.velocity, this.ticks = h.ticks, this.durationTicks = f.ticks - h.ticks;
      }
      return Object.defineProperty(u.prototype, "name", {
        /**
         * The note name and octave in scientific pitch notation, e.g. "C4".
         */
        get: function() {
          return e(this.midi);
        },
        set: function(h) {
          this.midi = i(h);
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(u.prototype, "octave", {
        /**
         * The notes octave number.
         */
        get: function() {
          return Math.floor(this.midi / 12) - 1;
        },
        set: function(h) {
          var f = h - this.octave;
          this.midi += f * 12;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(u.prototype, "pitch", {
        /**
         * The pitch class name. e.g. "A".
         */
        get: function() {
          return t(this.midi);
        },
        set: function(h) {
          this.midi = 12 * (this.octave + 1) + n(h);
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(u.prototype, "duration", {
        /**
         * The duration of the segment in seconds.
         */
        get: function() {
          var h = s.get(this);
          return h.ticksToSeconds(this.ticks + this.durationTicks) - h.ticksToSeconds(this.ticks);
        },
        set: function(h) {
          var f = s.get(this), p = f.secondsToTicks(this.time + h);
          this.durationTicks = p - this.ticks;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(u.prototype, "time", {
        /**
         * The time of the event in seconds.
         */
        get: function() {
          var h = s.get(this);
          return h.ticksToSeconds(this.ticks);
        },
        set: function(h) {
          var f = s.get(this);
          this.ticks = f.secondsToTicks(h);
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(u.prototype, "bars", {
        /**
         * The number of measures (and partial measures) to this beat.
         * Takes into account time signature changes.
         * @readonly
         */
        get: function() {
          var h = s.get(this);
          return h.ticksToMeasures(this.ticks);
        },
        enumerable: !1,
        configurable: !0
      }), u.prototype.toJSON = function() {
        return {
          duration: this.duration,
          durationTicks: this.durationTicks,
          midi: this.midi,
          name: this.name,
          ticks: this.ticks,
          time: this.time,
          velocity: this.velocity
        };
      }, u;
    }()
  );
  return Cm.Note = o, Cm;
}
var qx;
function Gx() {
  if (qx) return _m;
  qx = 1, Object.defineProperty(_m, "__esModule", { value: !0 }), _m.Track = void 0;
  var e = F6(), t = q6(), n = rU(), i = aU(), s = oU(), o = lU(), u = /* @__PURE__ */ new WeakMap(), h = (
    /** @class */
    function() {
      function f(p, g) {
        var v = this;
        if (this.name = "", this.notes = [], this.controlChanges = (0, n.createControlChanges)(), this.pitchBends = [], u.set(this, g), p) {
          var x = p.find(function(R) {
            return R.type === "trackName";
          });
          this.name = x ? x.text : "";
        }
        if (this.instrument = new s.Instrument(p, this), this.channel = 0, p) {
          for (var b = p.filter(function(R) {
            return R.type === "noteOn";
          }), _ = p.filter(function(R) {
            return R.type === "noteOff";
          }), T = function() {
            var R = b.shift();
            A.channel = R.channel;
            var N = _.findIndex(function(q) {
              return q.noteNumber === R.noteNumber && q.absoluteTime >= R.absoluteTime;
            });
            if (N !== -1) {
              var U = _.splice(N, 1)[0];
              A.addNote({
                durationTicks: U.absoluteTime - R.absoluteTime,
                midi: R.noteNumber,
                noteOffVelocity: U.velocity / 127,
                ticks: R.absoluteTime,
                velocity: R.velocity / 127
              });
            }
          }, A = this; b.length; )
            T();
          var O = p.filter(function(R) {
            return R.type === "controller";
          });
          O.forEach(function(R) {
            v.addCC({
              number: R.controllerType,
              ticks: R.absoluteTime,
              value: R.value / 127
            });
          });
          var M = p.filter(function(R) {
            return R.type === "pitchBend";
          });
          M.forEach(function(R) {
            v.addPitchBend({
              ticks: R.absoluteTime,
              // Scale the value between -2^13 to 2^13 to -2 to 2.
              value: R.value / Math.pow(2, 13)
            });
          });
          var E = p.find(function(R) {
            return R.type === "endOfTrack";
          });
          this.endOfTrackTicks = E !== void 0 ? E.absoluteTime : void 0;
        }
      }
      return f.prototype.addNote = function(p) {
        var g = u.get(this), v = new o.Note({
          midi: 0,
          ticks: 0,
          velocity: 1
        }, {
          ticks: 0,
          velocity: 0
        }, g);
        return Object.assign(v, p), (0, e.insert)(this.notes, v, "ticks"), this;
      }, f.prototype.addCC = function(p) {
        var g = u.get(this), v = new t.ControlChange({
          controllerType: p.number
        }, g);
        return delete p.number, Object.assign(v, p), Array.isArray(this.controlChanges[v.number]) || (this.controlChanges[v.number] = []), (0, e.insert)(this.controlChanges[v.number], v, "ticks"), this;
      }, f.prototype.addPitchBend = function(p) {
        var g = u.get(this), v = new i.PitchBend({}, g);
        return Object.assign(v, p), (0, e.insert)(this.pitchBends, v, "ticks"), this;
      }, Object.defineProperty(f.prototype, "duration", {
        /**
         * The end time of the last event in the track.
         */
        get: function() {
          if (!this.notes.length)
            return 0;
          for (var p = this.notes[this.notes.length - 1].time + this.notes[this.notes.length - 1].duration, g = 0; g < this.notes.length - 1; g++) {
            var v = this.notes[g].time + this.notes[g].duration;
            p < v && (p = v);
          }
          return p;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(f.prototype, "durationTicks", {
        /**
         * The end time of the last event in the track in ticks.
         */
        get: function() {
          if (!this.notes.length)
            return 0;
          for (var p = this.notes[this.notes.length - 1].ticks + this.notes[this.notes.length - 1].durationTicks, g = 0; g < this.notes.length - 1; g++) {
            var v = this.notes[g].ticks + this.notes[g].durationTicks;
            p < v && (p = v);
          }
          return p;
        },
        enumerable: !1,
        configurable: !0
      }), f.prototype.fromJSON = function(p) {
        var g = this;
        this.name = p.name, this.channel = p.channel, this.instrument = new s.Instrument(void 0, this), this.instrument.fromJSON(p.instrument), p.endOfTrackTicks !== void 0 && (this.endOfTrackTicks = p.endOfTrackTicks);
        for (var v in p.controlChanges)
          p.controlChanges[v] && p.controlChanges[v].forEach(function(x) {
            g.addCC({
              number: x.number,
              ticks: x.ticks,
              value: x.value
            });
          });
        p.notes.forEach(function(x) {
          g.addNote({
            durationTicks: x.durationTicks,
            midi: x.midi,
            ticks: x.ticks,
            velocity: x.velocity
          });
        });
      }, f.prototype.toJSON = function() {
        for (var p = {}, g = 0; g < 127; g++)
          this.controlChanges.hasOwnProperty(g) && (p[g] = this.controlChanges[g].map(function(x) {
            return x.toJSON();
          }));
        var v = {
          channel: this.channel,
          controlChanges: p,
          pitchBends: this.pitchBends.map(function(x) {
            return x.toJSON();
          }),
          instrument: this.instrument.toJSON(),
          name: this.name,
          notes: this.notes.map(function(x) {
            return x.toJSON();
          })
        };
        return this.endOfTrackTicks !== void 0 && (v.endOfTrackTicks = this.endOfTrackTicks), v;
      }, f;
    }()
  );
  return _m.Track = h, _m;
}
var xh = {};
function cU(e) {
  var t = [];
  return G6(e, t), t;
}
function G6(e, t) {
  for (var n = 0; n < e.length; n++) {
    var i = e[n];
    Array.isArray(i) ? G6(i, t) : t.push(i);
  }
}
const uU = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  flatten: cU
}, Symbol.toStringTag, { value: "Module" })), dU = /* @__PURE__ */ WC(uU);
var Hx;
function hU() {
  if (Hx) return xh;
  Hx = 1;
  var e = xh && xh.__spreadArray || function(O, M, E) {
    if (E || arguments.length === 2) for (var R = 0, N = M.length, U; R < N; R++)
      (U || !(R in M)) && (U || (U = Array.prototype.slice.call(M, 0, R)), U[R] = M[R]);
    return O.concat(U || Array.prototype.slice.call(M));
  };
  Object.defineProperty(xh, "__esModule", { value: !0 }), xh.encode = void 0;
  var t = I6(), n = m2(), i = dU;
  function s(O, M) {
    return [
      {
        absoluteTime: O.ticks,
        channel: M,
        deltaTime: 0,
        noteNumber: O.midi,
        type: "noteOn",
        velocity: Math.floor(O.velocity * 127)
      },
      {
        absoluteTime: O.ticks + O.durationTicks,
        channel: M,
        deltaTime: 0,
        noteNumber: O.midi,
        type: "noteOff",
        velocity: Math.floor(O.noteOffVelocity * 127)
      }
    ];
  }
  function o(O) {
    return (0, i.flatten)(O.notes.map(function(M) {
      return s(M, O.channel);
    }));
  }
  function u(O, M) {
    return {
      absoluteTime: O.ticks,
      channel: M,
      controllerType: O.number,
      deltaTime: 0,
      type: "controller",
      value: Math.floor(O.value * 127)
    };
  }
  function h(O) {
    for (var M = [], E = 0; E < 127; E++)
      O.controlChanges.hasOwnProperty(E) && O.controlChanges[E].forEach(function(R) {
        M.push(u(R, O.channel));
      });
    return M;
  }
  function f(O, M) {
    return {
      absoluteTime: O.ticks,
      channel: M,
      deltaTime: 0,
      type: "pitchBend",
      value: O.value
    };
  }
  function p(O) {
    var M = [];
    return O.pitchBends.forEach(function(E) {
      M.push(f(E, O.channel));
    }), M;
  }
  function g(O) {
    return {
      absoluteTime: 0,
      channel: O.channel,
      deltaTime: 0,
      programNumber: O.instrument.number,
      type: "programChange"
    };
  }
  function v(O) {
    return {
      absoluteTime: 0,
      deltaTime: 0,
      meta: !0,
      text: O,
      type: "trackName"
    };
  }
  function x(O) {
    return {
      absoluteTime: O.ticks,
      deltaTime: 0,
      meta: !0,
      microsecondsPerBeat: Math.floor(6e7 / O.bpm),
      type: "setTempo"
    };
  }
  function b(O) {
    return {
      absoluteTime: O.ticks,
      deltaTime: 0,
      denominator: O.timeSignature[1],
      meta: !0,
      metronome: 24,
      numerator: O.timeSignature[0],
      thirtyseconds: 8,
      type: "timeSignature"
    };
  }
  function _(O) {
    var M = n.keySignatureKeys.indexOf(O.key);
    return {
      absoluteTime: O.ticks,
      deltaTime: 0,
      key: M + 7,
      meta: !0,
      scale: O.scale === "major" ? 0 : 1,
      type: "keySignature"
    };
  }
  function T(O) {
    return {
      absoluteTime: O.ticks,
      deltaTime: 0,
      meta: !0,
      text: O.text,
      type: O.type
    };
  }
  function A(O) {
    var M = {
      header: {
        format: 1,
        numTracks: O.tracks.length + 1,
        ticksPerBeat: O.header.ppq
      },
      tracks: e([
        e(e(e(e([
          // The name data.
          {
            absoluteTime: 0,
            deltaTime: 0,
            meta: !0,
            text: O.header.name,
            type: "trackName"
          }
        ], O.header.keySignatures.map(function(E) {
          return _(E);
        }), !0), O.header.meta.map(function(E) {
          return T(E);
        }), !0), O.header.tempos.map(function(E) {
          return x(E);
        }), !0), O.header.timeSignatures.map(function(E) {
          return b(E);
        }), !0)
      ], O.tracks.map(function(E) {
        return e(e(e([
          // Add the name
          v(E.name),
          // the instrument
          g(E)
        ], o(E), !0), h(E), !0), p(E), !0);
      }), !0)
    };
    return M.tracks = M.tracks.map(function(E) {
      E = E.sort(function(N, U) {
        return N.absoluteTime - U.absoluteTime;
      });
      var R = 0;
      return E.forEach(function(N) {
        N.deltaTime = N.absoluteTime - R, R = N.absoluteTime, delete N.absoluteTime;
      }), E.push({
        deltaTime: 0,
        meta: !0,
        type: "endOfTrack"
      }), E;
    }), new Uint8Array((0, t.writeMidi)(M));
  }
  return xh.encode = A, xh;
}
var Kx;
function fU() {
  return Kx || (Kx = 1, function(e) {
    var t = _h && _h.__awaiter || function(v, x, b, _) {
      function T(A) {
        return A instanceof b ? A : new b(function(O) {
          O(A);
        });
      }
      return new (b || (b = Promise))(function(A, O) {
        function M(N) {
          try {
            R(_.next(N));
          } catch (U) {
            O(U);
          }
        }
        function E(N) {
          try {
            R(_.throw(N));
          } catch (U) {
            O(U);
          }
        }
        function R(N) {
          N.done ? A(N.value) : T(N.value).then(M, E);
        }
        R((_ = _.apply(v, x || [])).next());
      });
    }, n = _h && _h.__generator || function(v, x) {
      var b = { label: 0, sent: function() {
        if (A[0] & 1) throw A[1];
        return A[1];
      }, trys: [], ops: [] }, _, T, A, O;
      return O = { next: M(0), throw: M(1), return: M(2) }, typeof Symbol == "function" && (O[Symbol.iterator] = function() {
        return this;
      }), O;
      function M(R) {
        return function(N) {
          return E([R, N]);
        };
      }
      function E(R) {
        if (_) throw new TypeError("Generator is already executing.");
        for (; b; ) try {
          if (_ = 1, T && (A = R[0] & 2 ? T.return : R[0] ? T.throw || ((A = T.return) && A.call(T), 0) : T.next) && !(A = A.call(T, R[1])).done) return A;
          switch (T = 0, A && (R = [R[0] & 2, A.value]), R[0]) {
            case 0:
            case 1:
              A = R;
              break;
            case 4:
              return b.label++, { value: R[1], done: !1 };
            case 5:
              b.label++, T = R[1], R = [0];
              continue;
            case 7:
              R = b.ops.pop(), b.trys.pop();
              continue;
            default:
              if (A = b.trys, !(A = A.length > 0 && A[A.length - 1]) && (R[0] === 6 || R[0] === 2)) {
                b = 0;
                continue;
              }
              if (R[0] === 3 && (!A || R[1] > A[0] && R[1] < A[3])) {
                b.label = R[1];
                break;
              }
              if (R[0] === 6 && b.label < A[1]) {
                b.label = A[1], A = R;
                break;
              }
              if (A && b.label < A[2]) {
                b.label = A[2], b.ops.push(R);
                break;
              }
              A[2] && b.ops.pop(), b.trys.pop();
              continue;
          }
          R = x.call(v, b);
        } catch (N) {
          R = [6, N], T = 0;
        } finally {
          _ = A = 0;
        }
        if (R[0] & 5) throw R[1];
        return { value: R[0] ? R[1] : void 0, done: !0 };
      }
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), e.Header = e.Track = e.Midi = void 0;
    var i = I6(), s = m2(), o = Gx(), u = hU(), h = (
      /** @class */
      function() {
        function v(x) {
          var b = this, _ = null;
          if (x) {
            var T = x instanceof ArrayBuffer ? new Uint8Array(x) : x;
            _ = (0, i.parseMidi)(T), _.tracks.forEach(function(A) {
              var O = 0;
              A.forEach(function(M) {
                O += M.deltaTime, M.absoluteTime = O;
              });
            }), _.tracks = g(_.tracks);
          }
          this.header = new s.Header(_), this.tracks = [], x && (this.tracks = _.tracks.map(function(A) {
            return new o.Track(A, b.header);
          }), _.header.format === 1 && this.tracks[0].duration === 0 && this.tracks.shift());
        }
        return v.fromUrl = function(x) {
          return t(this, void 0, void 0, function() {
            var b, _;
            return n(this, function(T) {
              switch (T.label) {
                case 0:
                  return [4, fetch(x)];
                case 1:
                  return b = T.sent(), b.ok ? [4, b.arrayBuffer()] : [3, 3];
                case 2:
                  return _ = T.sent(), [2, new v(_)];
                case 3:
                  throw new Error("Could not load '".concat(x, "'"));
              }
            });
          });
        }, Object.defineProperty(v.prototype, "name", {
          /**
           * The name of the midi file, taken from the first track.
           */
          get: function() {
            return this.header.name;
          },
          set: function(x) {
            this.header.name = x;
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(v.prototype, "duration", {
          /**
           * The total length of the file in seconds.
           */
          get: function() {
            var x = this.tracks.map(function(b) {
              return b.duration;
            });
            return Math.max.apply(Math, x);
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(v.prototype, "durationTicks", {
          /**
           * The total length of the file in ticks.
           */
          get: function() {
            var x = this.tracks.map(function(b) {
              return b.durationTicks;
            });
            return Math.max.apply(Math, x);
          },
          enumerable: !1,
          configurable: !0
        }), v.prototype.addTrack = function() {
          var x = new o.Track(void 0, this.header);
          return this.tracks.push(x), x;
        }, v.prototype.toArray = function() {
          return (0, u.encode)(this);
        }, v.prototype.toJSON = function() {
          return {
            header: this.header.toJSON(),
            tracks: this.tracks.map(function(x) {
              return x.toJSON();
            })
          };
        }, v.prototype.fromJSON = function(x) {
          var b = this;
          this.header = new s.Header(), this.header.fromJSON(x.header), this.tracks = x.tracks.map(function(_) {
            var T = new o.Track(void 0, b.header);
            return T.fromJSON(_), T;
          });
        }, v.prototype.clone = function() {
          var x = new v();
          return x.fromJSON(this.toJSON()), x;
        }, v;
      }()
    );
    e.Midi = h;
    var f = Gx();
    Object.defineProperty(e, "Track", { enumerable: !0, get: function() {
      return f.Track;
    } });
    var p = m2();
    Object.defineProperty(e, "Header", { enumerable: !0, get: function() {
      return p.Header;
    } });
    function g(v) {
      for (var x = [], b = 0; b < v.length; b++)
        for (var _ = x.length, T = /* @__PURE__ */ new Map(), A = Array(16).fill(0), O = 0, M = v[b]; O < M.length; O++) {
          var E = M[O], R = _, N = E.channel;
          if (N !== void 0) {
            E.type === "programChange" && (A[N] = E.programNumber);
            var U = A[N], q = "".concat(U, " ").concat(N);
            T.has(q) ? R = T.get(q) : (R = _ + T.size, T.set(q, R));
          }
          x[R] || x.push([]), x[R].push(E);
        }
      return x;
    }
  }(_h)), _h;
}
var Yx = fU(), Py, pU = new Uint8Array(16);
function mU() {
  if (!Py && (Py = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto), !Py))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return Py(pU);
}
const gU = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function yU(e) {
  return typeof e == "string" && gU.test(e);
}
var pa = [];
for (var _b = 0; _b < 256; ++_b)
  pa.push((_b + 256).toString(16).substr(1));
function vU(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = (pa[e[t + 0]] + pa[e[t + 1]] + pa[e[t + 2]] + pa[e[t + 3]] + "-" + pa[e[t + 4]] + pa[e[t + 5]] + "-" + pa[e[t + 6]] + pa[e[t + 7]] + "-" + pa[e[t + 8]] + pa[e[t + 9]] + "-" + pa[e[t + 10]] + pa[e[t + 11]] + pa[e[t + 12]] + pa[e[t + 13]] + pa[e[t + 14]] + pa[e[t + 15]]).toLowerCase();
  if (!yU(n))
    throw TypeError("Stringified UUID is invalid");
  return n;
}
function Sb(e, t, n) {
  e = e || {};
  var i = e.random || (e.rng || mU)();
  return i[6] = i[6] & 15 | 64, i[8] = i[8] & 63 | 128, vU(i);
}
var Yy = { exports: {} }, bU = Yy.exports, Xx;
function _U() {
  return Xx || (Xx = 1, function(e, t) {
    (function(n, i) {
      e.exports = i();
    })(bU, function() {
      var n = function(S, k) {
        return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(L, Y) {
          L.__proto__ = Y;
        } || function(L, Y) {
          for (var Z in Y) Object.prototype.hasOwnProperty.call(Y, Z) && (L[Z] = Y[Z]);
        })(S, k);
      }, i = function() {
        return (i = Object.assign || function(S) {
          for (var k, L = 1, Y = arguments.length; L < Y; L++) for (var Z in k = arguments[L]) Object.prototype.hasOwnProperty.call(k, Z) && (S[Z] = k[Z]);
          return S;
        }).apply(this, arguments);
      };
      function s(S, k, L) {
        for (var Y, Z = 0, et = k.length; Z < et; Z++) !Y && Z in k || ((Y = Y || Array.prototype.slice.call(k, 0, Z))[Z] = k[Z]);
        return S.concat(Y || Array.prototype.slice.call(k));
      }
      var o = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : Pb, u = Object.keys, h = Array.isArray;
      function f(S, k) {
        return typeof k != "object" || u(k).forEach(function(L) {
          S[L] = k[L];
        }), S;
      }
      typeof Promise > "u" || o.Promise || (o.Promise = Promise);
      var p = Object.getPrototypeOf, g = {}.hasOwnProperty;
      function v(S, k) {
        return g.call(S, k);
      }
      function x(S, k) {
        typeof k == "function" && (k = k(p(S))), (typeof Reflect > "u" ? u : Reflect.ownKeys)(k).forEach(function(L) {
          _(S, L, k[L]);
        });
      }
      var b = Object.defineProperty;
      function _(S, k, L, Y) {
        b(S, k, f(L && v(L, "get") && typeof L.get == "function" ? { get: L.get, set: L.set, configurable: !0 } : { value: L, configurable: !0, writable: !0 }, Y));
      }
      function T(S) {
        return { from: function(k) {
          return S.prototype = Object.create(k.prototype), _(S.prototype, "constructor", S), { extend: x.bind(null, S.prototype) };
        } };
      }
      var A = Object.getOwnPropertyDescriptor, O = [].slice;
      function M(S, k, L) {
        return O.call(S, k, L);
      }
      function E(S, k) {
        return k(S);
      }
      function R(S) {
        if (!S) throw new Error("Assertion Failed");
      }
      function N(S) {
        o.setImmediate ? setImmediate(S) : setTimeout(S, 0);
      }
      function U(S, k) {
        if (typeof k == "string" && v(S, k)) return S[k];
        if (!k) return S;
        if (typeof k != "string") {
          for (var L = [], Y = 0, Z = k.length; Y < Z; ++Y) {
            var et = U(S, k[Y]);
            L.push(et);
          }
          return L;
        }
        var ut = k.indexOf(".");
        if (ut !== -1) {
          var mt = S[k.substr(0, ut)];
          return mt == null ? void 0 : U(mt, k.substr(ut + 1));
        }
      }
      function q(S, k, L) {
        if (S && k !== void 0 && !("isFrozen" in Object && Object.isFrozen(S))) if (typeof k != "string" && "length" in k) {
          R(typeof L != "string" && "length" in L);
          for (var Y = 0, Z = k.length; Y < Z; ++Y) q(S, k[Y], L[Y]);
        } else {
          var et, ut, mt = k.indexOf(".");
          mt !== -1 ? (et = k.substr(0, mt), (ut = k.substr(mt + 1)) === "" ? L === void 0 ? h(S) && !isNaN(parseInt(et)) ? S.splice(et, 1) : delete S[et] : S[et] = L : q(mt = !(mt = S[et]) || !v(S, et) ? S[et] = {} : mt, ut, L)) : L === void 0 ? h(S) && !isNaN(parseInt(k)) ? S.splice(k, 1) : delete S[k] : S[k] = L;
        }
      }
      function j(S) {
        var k, L = {};
        for (k in S) v(S, k) && (L[k] = S[k]);
        return L;
      }
      var V = [].concat;
      function D(S) {
        return V.apply([], S);
      }
      var te = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(D([8, 16, 32, 64].map(function(S) {
        return ["Int", "Uint", "Float"].map(function(k) {
          return k + S + "Array";
        });
      }))).filter(function(S) {
        return o[S];
      }), G = new Set(te.map(function(S) {
        return o[S];
      })), W = null;
      function P(S) {
        return W = /* @__PURE__ */ new WeakMap(), S = function k(L) {
          if (!L || typeof L != "object") return L;
          var Y = W.get(L);
          if (Y) return Y;
          if (h(L)) {
            Y = [], W.set(L, Y);
            for (var Z = 0, et = L.length; Z < et; ++Z) Y.push(k(L[Z]));
          } else if (G.has(L.constructor)) Y = L;
          else {
            var ut, mt = p(L);
            for (ut in Y = mt === Object.prototype ? {} : Object.create(mt), W.set(L, Y), L) v(L, ut) && (Y[ut] = k(L[ut]));
          }
          return Y;
        }(S), W = null, S;
      }
      var H = {}.toString;
      function I(S) {
        return H.call(S).slice(8, -1);
      }
      var K = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", Q = typeof K == "symbol" ? function(S) {
        var k;
        return S != null && (k = S[K]) && k.apply(S);
      } : function() {
        return null;
      };
      function it(S, k) {
        return k = S.indexOf(k), 0 <= k && S.splice(k, 1), 0 <= k;
      }
      var nt = {};
      function X(S) {
        var k, L, Y, Z;
        if (arguments.length === 1) {
          if (h(S)) return S.slice();
          if (this === nt && typeof S == "string") return [S];
          if (Z = Q(S)) {
            for (L = []; !(Y = Z.next()).done; ) L.push(Y.value);
            return L;
          }
          if (S == null) return [S];
          if (typeof (k = S.length) != "number") return [S];
          for (L = new Array(k); k--; ) L[k] = S[k];
          return L;
        }
        for (k = arguments.length, L = new Array(k); k--; ) L[k] = arguments[k];
        return L;
      }
      var rt = typeof Symbol < "u" ? function(S) {
        return S[Symbol.toStringTag] === "AsyncFunction";
      } : function() {
        return !1;
      }, Kt = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], hr = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(Kt), vt = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
      function ct(S, k) {
        this.name = S, this.message = k;
      }
      function dt(S, k) {
        return S + ". Errors: " + Object.keys(k).map(function(L) {
          return k[L].toString();
        }).filter(function(L, Y, Z) {
          return Z.indexOf(L) === Y;
        }).join(`
`);
      }
      function ht(S, k, L, Y) {
        this.failures = k, this.failedKeys = Y, this.successCount = L, this.message = dt(S, k);
      }
      function Et(S, k) {
        this.name = "BulkError", this.failures = Object.keys(k).map(function(L) {
          return k[L];
        }), this.failuresByPos = k, this.message = dt(S, this.failures);
      }
      T(ct).from(Error).extend({ toString: function() {
        return this.name + ": " + this.message;
      } }), T(ht).from(ct), T(Et).from(ct);
      var ot = hr.reduce(function(S, k) {
        return S[k] = k + "Error", S;
      }, {}), lt = ct, ft = hr.reduce(function(S, k) {
        var L = k + "Error";
        function Y(Z, et) {
          this.name = L, Z ? typeof Z == "string" ? (this.message = "".concat(Z).concat(et ? `
 ` + et : ""), this.inner = et || null) : typeof Z == "object" && (this.message = "".concat(Z.name, " ").concat(Z.message), this.inner = Z) : (this.message = vt[k] || L, this.inner = null);
        }
        return T(Y).from(lt), S[k] = Y, S;
      }, {});
      ft.Syntax = SyntaxError, ft.Type = TypeError, ft.Range = RangeError;
      var Tt = Kt.reduce(function(S, k) {
        return S[k + "Error"] = ft[k], S;
      }, {}), Bt = hr.reduce(function(S, k) {
        return ["Syntax", "Type", "Range"].indexOf(k) === -1 && (S[k + "Error"] = ft[k]), S;
      }, {});
      function Ot() {
      }
      function ie(S) {
        return S;
      }
      function ce(S, k) {
        return S == null || S === ie ? k : function(L) {
          return k(S(L));
        };
      }
      function Ut(S, k) {
        return function() {
          S.apply(this, arguments), k.apply(this, arguments);
        };
      }
      function se(S, k) {
        return S === Ot ? k : function() {
          var L = S.apply(this, arguments);
          L !== void 0 && (arguments[0] = L);
          var Y = this.onsuccess, Z = this.onerror;
          this.onsuccess = null, this.onerror = null;
          var et = k.apply(this, arguments);
          return Y && (this.onsuccess = this.onsuccess ? Ut(Y, this.onsuccess) : Y), Z && (this.onerror = this.onerror ? Ut(Z, this.onerror) : Z), et !== void 0 ? et : L;
        };
      }
      function re(S, k) {
        return S === Ot ? k : function() {
          S.apply(this, arguments);
          var L = this.onsuccess, Y = this.onerror;
          this.onsuccess = this.onerror = null, k.apply(this, arguments), L && (this.onsuccess = this.onsuccess ? Ut(L, this.onsuccess) : L), Y && (this.onerror = this.onerror ? Ut(Y, this.onerror) : Y);
        };
      }
      function ue(S, k) {
        return S === Ot ? k : function(L) {
          var Y = S.apply(this, arguments);
          f(L, Y);
          var Z = this.onsuccess, et = this.onerror;
          return this.onsuccess = null, this.onerror = null, L = k.apply(this, arguments), Z && (this.onsuccess = this.onsuccess ? Ut(Z, this.onsuccess) : Z), et && (this.onerror = this.onerror ? Ut(et, this.onerror) : et), Y === void 0 ? L === void 0 ? void 0 : L : f(Y, L);
        };
      }
      function Ae(S, k) {
        return S === Ot ? k : function() {
          return k.apply(this, arguments) !== !1 && S.apply(this, arguments);
        };
      }
      function ve(S, k) {
        return S === Ot ? k : function() {
          var L = S.apply(this, arguments);
          if (L && typeof L.then == "function") {
            for (var Y = this, Z = arguments.length, et = new Array(Z); Z--; ) et[Z] = arguments[Z];
            return L.then(function() {
              return k.apply(Y, et);
            });
          }
          return k.apply(this, arguments);
        };
      }
      Bt.ModifyError = ht, Bt.DexieError = ct, Bt.BulkError = Et;
      var Re = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
      function oe(S) {
        Re = S;
      }
      var Le = {}, De = 100, te = typeof Promise > "u" ? [] : function() {
        var S = Promise.resolve();
        if (typeof crypto > "u" || !crypto.subtle) return [S, p(S), S];
        var k = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
        return [k, p(k), S];
      }(), Kt = te[0], hr = te[1], te = te[2], hr = hr && hr.then, It = Kt && Kt.constructor, Ht = !!te, Jt = function(S, k) {
        Ve.push([S, k]), ae && (queueMicrotask(Ke), ae = !1);
      }, Yt = !0, ae = !0, le = [], fe = [], Me = ie, Te = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: Ot, pgp: !1, env: {}, finalize: Ot }, ne = Te, Ve = [], fn = 0, _r = [];
      function Ce(S) {
        if (typeof this != "object") throw new TypeError("Promises must be constructed via new");
        this._listeners = [], this._lib = !1;
        var k = this._PSD = ne;
        if (typeof S != "function") {
          if (S !== Le) throw new TypeError("Not a function");
          return this._state = arguments[1], this._value = arguments[2], void (this._state === !1 && Ze(this, this._value));
        }
        this._state = null, this._value = null, ++k.ref, function L(Y, Z) {
          try {
            Z(function(et) {
              if (Y._state === null) {
                if (et === Y) throw new TypeError("A promise cannot be resolved with itself.");
                var ut = Y._lib && gi();
                et && typeof et.then == "function" ? L(Y, function(mt, bt) {
                  et instanceof Ce ? et._then(mt, bt) : et.then(mt, bt);
                }) : (Y._state = !0, Y._value = et, Vr(Y)), ut && va();
              }
            }, Ze.bind(null, Y));
          } catch (et) {
            Ze(Y, et);
          }
        }(this, S);
      }
      var Xi = { get: function() {
        var S = ne, k = zi;
        function L(Y, Z) {
          var et = this, ut = !S.global && (S !== ne || k !== zi), mt = ut && !ba(), bt = new Ce(function(St, At) {
            Wi(et, new Rn(ts(Y, S, ut, mt), ts(Z, S, ut, mt), St, At, S));
          });
          return this._consoleTask && (bt._consoleTask = this._consoleTask), bt;
        }
        return L.prototype = Le, L;
      }, set: function(S) {
        _(this, "then", S && S.prototype === Le ? Xi : { get: function() {
          return S;
        }, set: Xi.set });
      } };
      function Rn(S, k, L, Y, Z) {
        this.onFulfilled = typeof S == "function" ? S : null, this.onRejected = typeof k == "function" ? k : null, this.resolve = L, this.reject = Y, this.psd = Z;
      }
      function Ze(S, k) {
        var L, Y;
        fe.push(k), S._state === null && (L = S._lib && gi(), k = Me(k), S._state = !1, S._value = k, Y = S, le.some(function(Z) {
          return Z._value === Y._value;
        }) || le.push(Y), Vr(S), L && va());
      }
      function Vr(S) {
        var k = S._listeners;
        S._listeners = [];
        for (var L = 0, Y = k.length; L < Y; ++L) Wi(S, k[L]);
        var Z = S._PSD;
        --Z.ref || Z.finalize(), fn === 0 && (++fn, Jt(function() {
          --fn == 0 && to();
        }, []));
      }
      function Wi(S, k) {
        if (S._state !== null) {
          var L = S._state ? k.onFulfilled : k.onRejected;
          if (L === null) return (S._state ? k.resolve : k.reject)(S._value);
          ++k.psd.ref, ++fn, Jt(Sr, [L, S, k]);
        } else S._listeners.push(k);
      }
      function Sr(S, k, L) {
        try {
          var Y, Z = k._value;
          !k._state && fe.length && (fe = []), Y = Re && k._consoleTask ? k._consoleTask.run(function() {
            return S(Z);
          }) : S(Z), k._state || fe.indexOf(Z) !== -1 || function(et) {
            for (var ut = le.length; ut; ) if (le[--ut]._value === et._value) return le.splice(ut, 1);
          }(k), L.resolve(Y);
        } catch (et) {
          L.reject(et);
        } finally {
          --fn == 0 && to(), --L.psd.ref || L.psd.finalize();
        }
      }
      function Ke() {
        Ua(Te, function() {
          gi() && va();
        });
      }
      function gi() {
        var S = Yt;
        return ae = Yt = !1, S;
      }
      function va() {
        var S, k, L;
        do
          for (; 0 < Ve.length; ) for (S = Ve, Ve = [], L = S.length, k = 0; k < L; ++k) {
            var Y = S[k];
            Y[0].apply(null, Y[1]);
          }
        while (0 < Ve.length);
        ae = Yt = !0;
      }
      function to() {
        var S = le;
        le = [], S.forEach(function(Y) {
          Y._PSD.onunhandled.call(null, Y._value, Y);
        });
        for (var k = _r.slice(0), L = k.length; L; ) k[--L]();
      }
      function zc(S) {
        return new Ce(Le, !1, S);
      }
      function Fn(S, k) {
        var L = ne;
        return function() {
          var Y = gi(), Z = ne;
          try {
            return As(L, !0), S.apply(this, arguments);
          } catch (et) {
            k && k(et);
          } finally {
            As(Z, !1), Y && va();
          }
        };
      }
      x(Ce.prototype, { then: Xi, _then: function(S, k) {
        Wi(this, new Rn(null, null, S, k, ne));
      }, catch: function(S) {
        if (arguments.length === 1) return this.then(null, S);
        var k = S, L = arguments[1];
        return typeof k == "function" ? this.then(null, function(Y) {
          return (Y instanceof k ? L : zc)(Y);
        }) : this.then(null, function(Y) {
          return (Y && Y.name === k ? L : zc)(Y);
        });
      }, finally: function(S) {
        return this.then(function(k) {
          return Ce.resolve(S()).then(function() {
            return k;
          });
        }, function(k) {
          return Ce.resolve(S()).then(function() {
            return zc(k);
          });
        });
      }, timeout: function(S, k) {
        var L = this;
        return S < 1 / 0 ? new Ce(function(Y, Z) {
          var et = setTimeout(function() {
            return Z(new ft.Timeout(k));
          }, S);
          L.then(Y, Z).finally(clearTimeout.bind(null, et));
        }) : this;
      } }), typeof Symbol < "u" && Symbol.toStringTag && _(Ce.prototype, Symbol.toStringTag, "Dexie.Promise"), Te.env = eo(), x(Ce, { all: function() {
        var S = X.apply(null, arguments).map(Pc);
        return new Ce(function(k, L) {
          S.length === 0 && k([]);
          var Y = S.length;
          S.forEach(function(Z, et) {
            return Ce.resolve(Z).then(function(ut) {
              S[et] = ut, --Y || k(S);
            }, L);
          });
        });
      }, resolve: function(S) {
        return S instanceof Ce ? S : S && typeof S.then == "function" ? new Ce(function(k, L) {
          S.then(k, L);
        }) : new Ce(Le, !0, S);
      }, reject: zc, race: function() {
        var S = X.apply(null, arguments).map(Pc);
        return new Ce(function(k, L) {
          S.map(function(Y) {
            return Ce.resolve(Y).then(k, L);
          });
        });
      }, PSD: { get: function() {
        return ne;
      }, set: function(S) {
        return ne = S;
      } }, totalEchoes: { get: function() {
        return zi;
      } }, newPSD: rn, usePSD: Ua, scheduler: { get: function() {
        return Jt;
      }, set: function(S) {
        Jt = S;
      } }, rejectionMapper: { get: function() {
        return Me;
      }, set: function(S) {
        Me = S;
      } }, follow: function(S, k) {
        return new Ce(function(L, Y) {
          return rn(function(Z, et) {
            var ut = ne;
            ut.unhandleds = [], ut.onunhandled = et, ut.finalize = Ut(function() {
              var mt, bt = this;
              mt = function() {
                bt.unhandleds.length === 0 ? Z() : et(bt.unhandleds[0]);
              }, _r.push(function St() {
                mt(), _r.splice(_r.indexOf(St), 1);
              }), ++fn, Jt(function() {
                --fn == 0 && to();
              }, []);
            }, ut.finalize), S();
          }, k, L, Y);
        });
      } }), It && (It.allSettled && _(Ce, "allSettled", function() {
        var S = X.apply(null, arguments).map(Pc);
        return new Ce(function(k) {
          S.length === 0 && k([]);
          var L = S.length, Y = new Array(L);
          S.forEach(function(Z, et) {
            return Ce.resolve(Z).then(function(ut) {
              return Y[et] = { status: "fulfilled", value: ut };
            }, function(ut) {
              return Y[et] = { status: "rejected", reason: ut };
            }).then(function() {
              return --L || k(Y);
            });
          });
        });
      }), It.any && typeof AggregateError < "u" && _(Ce, "any", function() {
        var S = X.apply(null, arguments).map(Pc);
        return new Ce(function(k, L) {
          S.length === 0 && L(new AggregateError([]));
          var Y = S.length, Z = new Array(Y);
          S.forEach(function(et, ut) {
            return Ce.resolve(et).then(function(mt) {
              return k(mt);
            }, function(mt) {
              Z[ut] = mt, --Y || L(new AggregateError(Z));
            });
          });
        });
      }), It.withResolvers && (Ce.withResolvers = It.withResolvers));
      var Ci = { awaits: 0, echoes: 0, id: 0 }, Es = 0, wl = [], Pa = 0, zi = 0, Pi = 0;
      function rn(S, k, L, Y) {
        var Z = ne, et = Object.create(Z);
        return et.parent = Z, et.ref = 0, et.global = !1, et.id = ++Pi, Te.env, et.env = Ht ? { Promise: Ce, PromiseProp: { value: Ce, configurable: !0, writable: !0 }, all: Ce.all, race: Ce.race, allSettled: Ce.allSettled, any: Ce.any, resolve: Ce.resolve, reject: Ce.reject } : {}, k && f(et, k), ++Z.ref, et.finalize = function() {
          --this.parent.ref || this.parent.finalize();
        }, Y = Ua(et, S, L, Y), et.ref === 0 && et.finalize(), Y;
      }
      function ea() {
        return Ci.id || (Ci.id = ++Es), ++Ci.awaits, Ci.echoes += De, Ci.id;
      }
      function ba() {
        return !!Ci.awaits && (--Ci.awaits == 0 && (Ci.id = 0), Ci.echoes = Ci.awaits * De, !0);
      }
      function Pc(S) {
        return Ci.echoes && S && S.constructor === It ? (ea(), S.then(function(k) {
          return ba(), k;
        }, function(k) {
          return ba(), $e(k);
        })) : S;
      }
      function Gh() {
        var S = wl[wl.length - 1];
        wl.pop(), As(S, !1);
      }
      function As(S, k) {
        var L, Y = ne;
        (k ? !Ci.echoes || Pa++ && S === ne : !Pa || --Pa && S === ne) || queueMicrotask(k ? (function(Z) {
          ++zi, Ci.echoes && --Ci.echoes != 0 || (Ci.echoes = Ci.awaits = Ci.id = 0), wl.push(ne), As(Z, !0);
        }).bind(null, S) : Gh), S !== ne && (ne = S, Y === Te && (Te.env = eo()), Ht && (L = Te.env.Promise, k = S.env, (Y.global || S.global) && (Object.defineProperty(o, "Promise", k.PromiseProp), L.all = k.all, L.race = k.race, L.resolve = k.resolve, L.reject = k.reject, k.allSettled && (L.allSettled = k.allSettled), k.any && (L.any = k.any))));
      }
      function eo() {
        var S = o.Promise;
        return Ht ? { Promise: S, PromiseProp: Object.getOwnPropertyDescriptor(o, "Promise"), all: S.all, race: S.race, allSettled: S.allSettled, any: S.any, resolve: S.resolve, reject: S.reject } : {};
      }
      function Ua(S, k, L, Y, Z) {
        var et = ne;
        try {
          return As(S, !0), k(L, Y, Z);
        } finally {
          As(et, !1);
        }
      }
      function ts(S, k, L, Y) {
        return typeof S != "function" ? S : function() {
          var Z = ne;
          L && ea(), As(k, !0);
          try {
            return S.apply(this, arguments);
          } finally {
            As(Z, !1), Y && queueMicrotask(ba);
          }
        };
      }
      function wi(S) {
        Promise === It && Ci.echoes === 0 ? Pa === 0 ? S() : enqueueNativeMicroTask(S) : setTimeout(S, 0);
      }
      ("" + hr).indexOf("[native code]") === -1 && (ea = ba = Ot);
      var $e = Ce.reject, xr = "￿", Pn = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", Uc = "String expected.", kr = [], na = "__dbnames", es = "readonly", ia = "readwrite";
      function no(S, k) {
        return S ? k ? function() {
          return S.apply(this, arguments) && k.apply(this, arguments);
        } : S : k;
      }
      var Fu = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 };
      function El(S) {
        return typeof S != "string" || /\./.test(S) ? function(k) {
          return k;
        } : function(k) {
          return k[S] === void 0 && S in k && delete (k = P(k))[S], k;
        };
      }
      function Gd() {
        throw ft.Type();
      }
      function ln(S, k) {
        try {
          var L = Al(S), Y = Al(k);
          if (L !== Y) return L === "Array" ? 1 : Y === "Array" ? -1 : L === "binary" ? 1 : Y === "binary" ? -1 : L === "string" ? 1 : Y === "string" ? -1 : L === "Date" ? 1 : Y !== "Date" ? NaN : -1;
          switch (L) {
            case "number":
            case "Date":
            case "string":
              return k < S ? 1 : S < k ? -1 : 0;
            case "binary":
              return function(Z, et) {
                for (var ut = Z.length, mt = et.length, bt = ut < mt ? ut : mt, St = 0; St < bt; ++St) if (Z[St] !== et[St]) return Z[St] < et[St] ? -1 : 1;
                return ut === mt ? 0 : ut < mt ? -1 : 1;
              }(_a(S), _a(k));
            case "Array":
              return function(Z, et) {
                for (var ut = Z.length, mt = et.length, bt = ut < mt ? ut : mt, St = 0; St < bt; ++St) {
                  var At = ln(Z[St], et[St]);
                  if (At !== 0) return At;
                }
                return ut === mt ? 0 : ut < mt ? -1 : 1;
              }(S, k);
          }
        } catch {
        }
        return NaN;
      }
      function Al(S) {
        var k = typeof S;
        return k != "object" ? k : ArrayBuffer.isView(S) ? "binary" : (S = I(S), S === "ArrayBuffer" ? "binary" : S);
      }
      function _a(S) {
        return S instanceof Uint8Array ? S : ArrayBuffer.isView(S) ? new Uint8Array(S.buffer, S.byteOffset, S.byteLength) : new Uint8Array(S);
      }
      var Ir = (Yn.prototype._trans = function(S, k, L) {
        var Y = this._tx || ne.trans, Z = this.name, et = Re && typeof console < "u" && console.createTask && console.createTask("Dexie: ".concat(S === "readonly" ? "read" : "write", " ").concat(this.name));
        function ut(St, At, gt) {
          if (!gt.schema[Z]) throw new ft.NotFound("Table " + Z + " not part of transaction");
          return k(gt.idbtrans, gt);
        }
        var mt = gi();
        try {
          var bt = Y && Y.db._novip === this.db._novip ? Y === ne.trans ? Y._promise(S, ut, L) : rn(function() {
            return Y._promise(S, ut, L);
          }, { trans: Y, transless: ne.transless || ne }) : function St(At, gt, Rt, _t) {
            if (At.idbdb && (At._state.openComplete || ne.letThrough || At._vip)) {
              var wt = At._createTransaction(gt, Rt, At._dbSchema);
              try {
                wt.create(), At._state.PR1398_maxLoop = 3;
              } catch (Nt) {
                return Nt.name === ot.InvalidState && At.isOpen() && 0 < --At._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), At.close({ disableAutoOpen: !1 }), At.open().then(function() {
                  return St(At, gt, Rt, _t);
                })) : $e(Nt);
              }
              return wt._promise(gt, function(Nt, xt) {
                return rn(function() {
                  return ne.trans = wt, _t(Nt, xt, wt);
                });
              }).then(function(Nt) {
                if (gt === "readwrite") try {
                  wt.idbtrans.commit();
                } catch {
                }
                return gt === "readonly" ? Nt : wt._completion.then(function() {
                  return Nt;
                });
              });
            }
            if (At._state.openComplete) return $e(new ft.DatabaseClosed(At._state.dbOpenError));
            if (!At._state.isBeingOpened) {
              if (!At._state.autoOpen) return $e(new ft.DatabaseClosed());
              At.open().catch(Ot);
            }
            return At._state.dbReadyPromise.then(function() {
              return St(At, gt, Rt, _t);
            });
          }(this.db, S, [this.name], ut);
          return et && (bt._consoleTask = et, bt = bt.catch(function(St) {
            return console.trace(St), $e(St);
          })), bt;
        } finally {
          mt && va();
        }
      }, Yn.prototype.get = function(S, k) {
        var L = this;
        return S && S.constructor === Object ? this.where(S).first(k) : S == null ? $e(new ft.Type("Invalid argument to Table.get()")) : this._trans("readonly", function(Y) {
          return L.core.get({ trans: Y, key: S }).then(function(Z) {
            return L.hook.reading.fire(Z);
          });
        }).then(k);
      }, Yn.prototype.where = function(S) {
        if (typeof S == "string") return new this.db.WhereClause(this, S);
        if (h(S)) return new this.db.WhereClause(this, "[".concat(S.join("+"), "]"));
        var k = u(S);
        if (k.length === 1) return this.where(k[0]).equals(S[k[0]]);
        var L = this.schema.indexes.concat(this.schema.primKey).filter(function(mt) {
          if (mt.compound && k.every(function(St) {
            return 0 <= mt.keyPath.indexOf(St);
          })) {
            for (var bt = 0; bt < k.length; ++bt) if (k.indexOf(mt.keyPath[bt]) === -1) return !1;
            return !0;
          }
          return !1;
        }).sort(function(mt, bt) {
          return mt.keyPath.length - bt.keyPath.length;
        })[0];
        if (L && this.db._maxKey !== xr) {
          var et = L.keyPath.slice(0, k.length);
          return this.where(et).equals(et.map(function(bt) {
            return S[bt];
          }));
        }
        !L && Re && console.warn("The query ".concat(JSON.stringify(S), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(k.join("+"), "]"));
        var Y = this.schema.idxByName;
        function Z(mt, bt) {
          return ln(mt, bt) === 0;
        }
        var ut = k.reduce(function(gt, bt) {
          var St = gt[0], At = gt[1], gt = Y[bt], Rt = S[bt];
          return [St || gt, St || !gt ? no(At, gt && gt.multi ? function(_t) {
            return _t = U(_t, bt), h(_t) && _t.some(function(wt) {
              return Z(Rt, wt);
            });
          } : function(_t) {
            return Z(Rt, U(_t, bt));
          }) : At];
        }, [null, null]), et = ut[0], ut = ut[1];
        return et ? this.where(et.name).equals(S[et.keyPath]).filter(ut) : L ? this.filter(ut) : this.where(k).equals("");
      }, Yn.prototype.filter = function(S) {
        return this.toCollection().and(S);
      }, Yn.prototype.count = function(S) {
        return this.toCollection().count(S);
      }, Yn.prototype.offset = function(S) {
        return this.toCollection().offset(S);
      }, Yn.prototype.limit = function(S) {
        return this.toCollection().limit(S);
      }, Yn.prototype.each = function(S) {
        return this.toCollection().each(S);
      }, Yn.prototype.toArray = function(S) {
        return this.toCollection().toArray(S);
      }, Yn.prototype.toCollection = function() {
        return new this.db.Collection(new this.db.WhereClause(this));
      }, Yn.prototype.orderBy = function(S) {
        return new this.db.Collection(new this.db.WhereClause(this, h(S) ? "[".concat(S.join("+"), "]") : S));
      }, Yn.prototype.reverse = function() {
        return this.toCollection().reverse();
      }, Yn.prototype.mapToClass = function(S) {
        var k, L = this.db, Y = this.name;
        function Z() {
          return k !== null && k.apply(this, arguments) || this;
        }
        (this.schema.mappedClass = S).prototype instanceof Gd && (function(bt, St) {
          if (typeof St != "function" && St !== null) throw new TypeError("Class extends value " + String(St) + " is not a constructor or null");
          function At() {
            this.constructor = bt;
          }
          n(bt, St), bt.prototype = St === null ? Object.create(St) : (At.prototype = St.prototype, new At());
        }(Z, k = S), Object.defineProperty(Z.prototype, "db", { get: function() {
          return L;
        }, enumerable: !1, configurable: !0 }), Z.prototype.table = function() {
          return Y;
        }, S = Z);
        for (var et = /* @__PURE__ */ new Set(), ut = S.prototype; ut; ut = p(ut)) Object.getOwnPropertyNames(ut).forEach(function(bt) {
          return et.add(bt);
        });
        function mt(bt) {
          if (!bt) return bt;
          var St, At = Object.create(S.prototype);
          for (St in bt) if (!et.has(St)) try {
            At[St] = bt[St];
          } catch {
          }
          return At;
        }
        return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = mt, this.hook("reading", mt), S;
      }, Yn.prototype.defineClass = function() {
        return this.mapToClass(function(S) {
          f(this, S);
        });
      }, Yn.prototype.add = function(S, k) {
        var L = this, Y = this.schema.primKey, Z = Y.auto, et = Y.keyPath, ut = S;
        return et && Z && (ut = El(et)(S)), this._trans("readwrite", function(mt) {
          return L.core.mutate({ trans: mt, type: "add", keys: k != null ? [k] : null, values: [ut] });
        }).then(function(mt) {
          return mt.numFailures ? Ce.reject(mt.failures[0]) : mt.lastResult;
        }).then(function(mt) {
          if (et) try {
            q(S, et, mt);
          } catch {
          }
          return mt;
        });
      }, Yn.prototype.update = function(S, k) {
        return typeof S != "object" || h(S) ? this.where(":id").equals(S).modify(k) : (S = U(S, this.schema.primKey.keyPath), S === void 0 ? $e(new ft.InvalidArgument("Given object does not contain its primary key")) : this.where(":id").equals(S).modify(k));
      }, Yn.prototype.put = function(S, k) {
        var L = this, Y = this.schema.primKey, Z = Y.auto, et = Y.keyPath, ut = S;
        return et && Z && (ut = El(et)(S)), this._trans("readwrite", function(mt) {
          return L.core.mutate({ trans: mt, type: "put", values: [ut], keys: k != null ? [k] : null });
        }).then(function(mt) {
          return mt.numFailures ? Ce.reject(mt.failures[0]) : mt.lastResult;
        }).then(function(mt) {
          if (et) try {
            q(S, et, mt);
          } catch {
          }
          return mt;
        });
      }, Yn.prototype.delete = function(S) {
        var k = this;
        return this._trans("readwrite", function(L) {
          return k.core.mutate({ trans: L, type: "delete", keys: [S] });
        }).then(function(L) {
          return L.numFailures ? Ce.reject(L.failures[0]) : void 0;
        });
      }, Yn.prototype.clear = function() {
        var S = this;
        return this._trans("readwrite", function(k) {
          return S.core.mutate({ trans: k, type: "deleteRange", range: Fu });
        }).then(function(k) {
          return k.numFailures ? Ce.reject(k.failures[0]) : void 0;
        });
      }, Yn.prototype.bulkGet = function(S) {
        var k = this;
        return this._trans("readonly", function(L) {
          return k.core.getMany({ keys: S, trans: L }).then(function(Y) {
            return Y.map(function(Z) {
              return k.hook.reading.fire(Z);
            });
          });
        });
      }, Yn.prototype.bulkAdd = function(S, k, L) {
        var Y = this, Z = Array.isArray(k) ? k : void 0, et = (L = L || (Z ? void 0 : k)) ? L.allKeys : void 0;
        return this._trans("readwrite", function(ut) {
          var St = Y.schema.primKey, mt = St.auto, St = St.keyPath;
          if (St && Z) throw new ft.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
          if (Z && Z.length !== S.length) throw new ft.InvalidArgument("Arguments objects and keys must have the same length");
          var bt = S.length, St = St && mt ? S.map(El(St)) : S;
          return Y.core.mutate({ trans: ut, type: "add", keys: Z, values: St, wantResults: et }).then(function(wt) {
            var gt = wt.numFailures, Rt = wt.results, _t = wt.lastResult, wt = wt.failures;
            if (gt === 0) return et ? Rt : _t;
            throw new Et("".concat(Y.name, ".bulkAdd(): ").concat(gt, " of ").concat(bt, " operations failed"), wt);
          });
        });
      }, Yn.prototype.bulkPut = function(S, k, L) {
        var Y = this, Z = Array.isArray(k) ? k : void 0, et = (L = L || (Z ? void 0 : k)) ? L.allKeys : void 0;
        return this._trans("readwrite", function(ut) {
          var St = Y.schema.primKey, mt = St.auto, St = St.keyPath;
          if (St && Z) throw new ft.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
          if (Z && Z.length !== S.length) throw new ft.InvalidArgument("Arguments objects and keys must have the same length");
          var bt = S.length, St = St && mt ? S.map(El(St)) : S;
          return Y.core.mutate({ trans: ut, type: "put", keys: Z, values: St, wantResults: et }).then(function(wt) {
            var gt = wt.numFailures, Rt = wt.results, _t = wt.lastResult, wt = wt.failures;
            if (gt === 0) return et ? Rt : _t;
            throw new Et("".concat(Y.name, ".bulkPut(): ").concat(gt, " of ").concat(bt, " operations failed"), wt);
          });
        });
      }, Yn.prototype.bulkUpdate = function(S) {
        var k = this, L = this.core, Y = S.map(function(ut) {
          return ut.key;
        }), Z = S.map(function(ut) {
          return ut.changes;
        }), et = [];
        return this._trans("readwrite", function(ut) {
          return L.getMany({ trans: ut, keys: Y, cache: "clone" }).then(function(mt) {
            var bt = [], St = [];
            S.forEach(function(gt, Rt) {
              var _t = gt.key, wt = gt.changes, Nt = mt[Rt];
              if (Nt) {
                for (var xt = 0, Dt = Object.keys(wt); xt < Dt.length; xt++) {
                  var Ft = Dt[xt], Lt = wt[Ft];
                  if (Ft === k.schema.primKey.keyPath) {
                    if (ln(Lt, _t) !== 0) throw new ft.Constraint("Cannot update primary key in bulkUpdate()");
                  } else q(Nt, Ft, Lt);
                }
                et.push(Rt), bt.push(_t), St.push(Nt);
              }
            });
            var At = bt.length;
            return L.mutate({ trans: ut, type: "put", keys: bt, values: St, updates: { keys: Y, changeSpecs: Z } }).then(function(gt) {
              var Rt = gt.numFailures, _t = gt.failures;
              if (Rt === 0) return At;
              for (var wt = 0, Nt = Object.keys(_t); wt < Nt.length; wt++) {
                var xt, Dt = Nt[wt], Ft = et[Number(Dt)];
                Ft != null && (xt = _t[Dt], delete _t[Dt], _t[Ft] = xt);
              }
              throw new Et("".concat(k.name, ".bulkUpdate(): ").concat(Rt, " of ").concat(At, " operations failed"), _t);
            });
          });
        });
      }, Yn.prototype.bulkDelete = function(S) {
        var k = this, L = S.length;
        return this._trans("readwrite", function(Y) {
          return k.core.mutate({ trans: Y, type: "delete", keys: S });
        }).then(function(ut) {
          var Z = ut.numFailures, et = ut.lastResult, ut = ut.failures;
          if (Z === 0) return et;
          throw new Et("".concat(k.name, ".bulkDelete(): ").concat(Z, " of ").concat(L, " operations failed"), ut);
        });
      }, Yn);
      function Yn() {
      }
      function Ml(S) {
        function k(ut, mt) {
          if (mt) {
            for (var bt = arguments.length, St = new Array(bt - 1); --bt; ) St[bt - 1] = arguments[bt];
            return L[ut].subscribe.apply(null, St), S;
          }
          if (typeof ut == "string") return L[ut];
        }
        var L = {};
        k.addEventType = et;
        for (var Y = 1, Z = arguments.length; Y < Z; ++Y) et(arguments[Y]);
        return k;
        function et(ut, mt, bt) {
          if (typeof ut != "object") {
            var St;
            mt = mt || Ae;
            var At = { subscribers: [], fire: bt = bt || Ot, subscribe: function(gt) {
              At.subscribers.indexOf(gt) === -1 && (At.subscribers.push(gt), At.fire = mt(At.fire, gt));
            }, unsubscribe: function(gt) {
              At.subscribers = At.subscribers.filter(function(Rt) {
                return Rt !== gt;
              }), At.fire = At.subscribers.reduce(mt, bt);
            } };
            return L[ut] = k[ut] = At;
          }
          u(St = ut).forEach(function(gt) {
            var Rt = St[gt];
            if (h(Rt)) et(gt, St[gt][0], St[gt][1]);
            else {
              if (Rt !== "asap") throw new ft.InvalidArgument("Invalid event config");
              var _t = et(gt, ie, function() {
                for (var wt = arguments.length, Nt = new Array(wt); wt--; ) Nt[wt] = arguments[wt];
                _t.subscribers.forEach(function(xt) {
                  N(function() {
                    xt.apply(null, Nt);
                  });
                });
              });
            }
          });
        }
      }
      function Ms(S, k) {
        return T(k).from({ prototype: S }), k;
      }
      function io(S, k) {
        return !(S.filter || S.algorithm || S.or) && (k ? S.justLimit : !S.replayFilter);
      }
      function ro(S, k) {
        S.filter = no(S.filter, k);
      }
      function qu(S, k, L) {
        var Y = S.replayFilter;
        S.replayFilter = Y ? function() {
          return no(Y(), k());
        } : k, S.justLimit = L && !Y;
      }
      function Tr(S, k) {
        if (S.isPrimKey) return k.primaryKey;
        var L = k.getIndexByKeyPath(S.index);
        if (!L) throw new ft.Schema("KeyPath " + S.index + " on object store " + k.name + " is not indexed");
        return L;
      }
      function jc(S, k, L) {
        var Y = Tr(S, k.schema);
        return k.openCursor({ trans: L, values: !S.keysOnly, reverse: S.dir === "prev", unique: !!S.unique, query: { index: Y, range: S.range } });
      }
      function Rl(S, k, L, Y) {
        var Z = S.replayFilter ? no(S.filter, S.replayFilter()) : S.filter;
        if (S.or) {
          var et = {}, ut = function(mt, bt, St) {
            var At, gt;
            Z && !Z(bt, St, function(Rt) {
              return bt.stop(Rt);
            }, function(Rt) {
              return bt.fail(Rt);
            }) || ((gt = "" + (At = bt.primaryKey)) == "[object ArrayBuffer]" && (gt = "" + new Uint8Array(At)), v(et, gt) || (et[gt] = !0, k(mt, bt, St)));
          };
          return Promise.all([S.or._iterate(ut, L), Lc(jc(S, Y, L), S.algorithm, ut, !S.keysOnly && S.valueMapper)]);
        }
        return Lc(jc(S, Y, L), no(S.algorithm, Z), k, !S.keysOnly && S.valueMapper);
      }
      function Lc(S, k, L, Y) {
        var Z = Fn(Y ? function(et, ut, mt) {
          return L(Y(et), ut, mt);
        } : L);
        return S.then(function(et) {
          if (et) return et.start(function() {
            var ut = function() {
              return et.continue();
            };
            k && !k(et, function(mt) {
              return ut = mt;
            }, function(mt) {
              et.stop(mt), ut = Ot;
            }, function(mt) {
              et.fail(mt), ut = Ot;
            }) || Z(et.value, et, function(mt) {
              return ut = mt;
            }), ut();
          });
        });
      }
      var ns = (Gu.prototype.execute = function(S) {
        var k = this["@@propmod"];
        if (k.add !== void 0) {
          var L = k.add;
          if (h(L)) return s(s([], h(S) ? S : [], !0), L).sort();
          if (typeof L == "number") return (Number(S) || 0) + L;
          if (typeof L == "bigint") try {
            return BigInt(S) + L;
          } catch {
            return BigInt(0) + L;
          }
          throw new TypeError("Invalid term ".concat(L));
        }
        if (k.remove !== void 0) {
          var Y = k.remove;
          if (h(Y)) return h(S) ? S.filter(function(Z) {
            return !Y.includes(Z);
          }).sort() : [];
          if (typeof Y == "number") return Number(S) - Y;
          if (typeof Y == "bigint") try {
            return BigInt(S) - Y;
          } catch {
            return BigInt(0) - Y;
          }
          throw new TypeError("Invalid subtrahend ".concat(Y));
        }
        return L = (L = k.replacePrefix) === null || L === void 0 ? void 0 : L[0], L && typeof S == "string" && S.startsWith(L) ? k.replacePrefix[1] + S.substring(L.length) : S;
      }, Gu);
      function Gu(S) {
        this["@@propmod"] = S;
      }
      var Uo = (cn.prototype._read = function(S, k) {
        var L = this._ctx;
        return L.error ? L.table._trans(null, $e.bind(null, L.error)) : L.table._trans("readonly", S).then(k);
      }, cn.prototype._write = function(S) {
        var k = this._ctx;
        return k.error ? k.table._trans(null, $e.bind(null, k.error)) : k.table._trans("readwrite", S, "locked");
      }, cn.prototype._addAlgorithm = function(S) {
        var k = this._ctx;
        k.algorithm = no(k.algorithm, S);
      }, cn.prototype._iterate = function(S, k) {
        return Rl(this._ctx, S, k, this._ctx.table.core);
      }, cn.prototype.clone = function(S) {
        var k = Object.create(this.constructor.prototype), L = Object.create(this._ctx);
        return S && f(L, S), k._ctx = L, k;
      }, cn.prototype.raw = function() {
        return this._ctx.valueMapper = null, this;
      }, cn.prototype.each = function(S) {
        var k = this._ctx;
        return this._read(function(L) {
          return Rl(k, S, L, k.table.core);
        });
      }, cn.prototype.count = function(S) {
        var k = this;
        return this._read(function(L) {
          var Y = k._ctx, Z = Y.table.core;
          if (io(Y, !0)) return Z.count({ trans: L, query: { index: Tr(Y, Z.schema), range: Y.range } }).then(function(ut) {
            return Math.min(ut, Y.limit);
          });
          var et = 0;
          return Rl(Y, function() {
            return ++et, !1;
          }, L, Z).then(function() {
            return et;
          });
        }).then(S);
      }, cn.prototype.sortBy = function(S, k) {
        var L = S.split(".").reverse(), Y = L[0], Z = L.length - 1;
        function et(bt, St) {
          return St ? et(bt[L[St]], St - 1) : bt[Y];
        }
        var ut = this._ctx.dir === "next" ? 1 : -1;
        function mt(bt, St) {
          return ln(et(bt, Z), et(St, Z)) * ut;
        }
        return this.toArray(function(bt) {
          return bt.sort(mt);
        }).then(k);
      }, cn.prototype.toArray = function(S) {
        var k = this;
        return this._read(function(L) {
          var Y = k._ctx;
          if (Y.dir === "next" && io(Y, !0) && 0 < Y.limit) {
            var Z = Y.valueMapper, et = Tr(Y, Y.table.core.schema);
            return Y.table.core.query({ trans: L, limit: Y.limit, values: !0, query: { index: et, range: Y.range } }).then(function(mt) {
              return mt = mt.result, Z ? mt.map(Z) : mt;
            });
          }
          var ut = [];
          return Rl(Y, function(mt) {
            return ut.push(mt);
          }, L, Y.table.core).then(function() {
            return ut;
          });
        }, S);
      }, cn.prototype.offset = function(S) {
        var k = this._ctx;
        return S <= 0 || (k.offset += S, io(k) ? qu(k, function() {
          var L = S;
          return function(Y, Z) {
            return L === 0 || (L === 1 ? --L : Z(function() {
              Y.advance(L), L = 0;
            }), !1);
          };
        }) : qu(k, function() {
          var L = S;
          return function() {
            return --L < 0;
          };
        })), this;
      }, cn.prototype.limit = function(S) {
        return this._ctx.limit = Math.min(this._ctx.limit, S), qu(this._ctx, function() {
          var k = S;
          return function(L, Y, Z) {
            return --k <= 0 && Y(Z), 0 <= k;
          };
        }, !0), this;
      }, cn.prototype.until = function(S, k) {
        return ro(this._ctx, function(L, Y, Z) {
          return !S(L.value) || (Y(Z), k);
        }), this;
      }, cn.prototype.first = function(S) {
        return this.limit(1).toArray(function(k) {
          return k[0];
        }).then(S);
      }, cn.prototype.last = function(S) {
        return this.reverse().first(S);
      }, cn.prototype.filter = function(S) {
        var k;
        return ro(this._ctx, function(L) {
          return S(L.value);
        }), (k = this._ctx).isMatch = no(k.isMatch, S), this;
      }, cn.prototype.and = function(S) {
        return this.filter(S);
      }, cn.prototype.or = function(S) {
        return new this.db.WhereClause(this._ctx.table, S, this);
      }, cn.prototype.reverse = function() {
        return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
      }, cn.prototype.desc = function() {
        return this.reverse();
      }, cn.prototype.eachKey = function(S) {
        var k = this._ctx;
        return k.keysOnly = !k.isMatch, this.each(function(L, Y) {
          S(Y.key, Y);
        });
      }, cn.prototype.eachUniqueKey = function(S) {
        return this._ctx.unique = "unique", this.eachKey(S);
      }, cn.prototype.eachPrimaryKey = function(S) {
        var k = this._ctx;
        return k.keysOnly = !k.isMatch, this.each(function(L, Y) {
          S(Y.primaryKey, Y);
        });
      }, cn.prototype.keys = function(S) {
        var k = this._ctx;
        k.keysOnly = !k.isMatch;
        var L = [];
        return this.each(function(Y, Z) {
          L.push(Z.key);
        }).then(function() {
          return L;
        }).then(S);
      }, cn.prototype.primaryKeys = function(S) {
        var k = this._ctx;
        if (k.dir === "next" && io(k, !0) && 0 < k.limit) return this._read(function(Y) {
          var Z = Tr(k, k.table.core.schema);
          return k.table.core.query({ trans: Y, values: !1, limit: k.limit, query: { index: Z, range: k.range } });
        }).then(function(Y) {
          return Y.result;
        }).then(S);
        k.keysOnly = !k.isMatch;
        var L = [];
        return this.each(function(Y, Z) {
          L.push(Z.primaryKey);
        }).then(function() {
          return L;
        }).then(S);
      }, cn.prototype.uniqueKeys = function(S) {
        return this._ctx.unique = "unique", this.keys(S);
      }, cn.prototype.firstKey = function(S) {
        return this.limit(1).keys(function(k) {
          return k[0];
        }).then(S);
      }, cn.prototype.lastKey = function(S) {
        return this.reverse().firstKey(S);
      }, cn.prototype.distinct = function() {
        var S = this._ctx, S = S.index && S.table.schema.idxByName[S.index];
        if (!S || !S.multi) return this;
        var k = {};
        return ro(this._ctx, function(Z) {
          var Y = Z.primaryKey.toString(), Z = v(k, Y);
          return k[Y] = !0, !Z;
        }), this;
      }, cn.prototype.modify = function(S) {
        var k = this, L = this._ctx;
        return this._write(function(Y) {
          var Z, et, ut;
          ut = typeof S == "function" ? S : (Z = u(S), et = Z.length, function(xt) {
            for (var Dt = !1, Ft = 0; Ft < et; ++Ft) {
              var Lt = Z[Ft], Xt = S[Lt], de = U(xt, Lt);
              Xt instanceof ns ? (q(xt, Lt, Xt.execute(de)), Dt = !0) : de !== Xt && (q(xt, Lt, Xt), Dt = !0);
            }
            return Dt;
          });
          var mt = L.table.core, gt = mt.schema.primaryKey, bt = gt.outbound, St = gt.extractKey, At = 200, gt = k.db._options.modifyChunkSize;
          gt && (At = typeof gt == "object" ? gt[mt.name] || gt["*"] || 200 : gt);
          function Rt(xt, Lt) {
            var Ft = Lt.failures, Lt = Lt.numFailures;
            wt += xt - Lt;
            for (var Xt = 0, de = u(Ft); Xt < de.length; Xt++) {
              var Se = de[Xt];
              _t.push(Ft[Se]);
            }
          }
          var _t = [], wt = 0, Nt = [];
          return k.clone().primaryKeys().then(function(xt) {
            function Dt(Lt) {
              var Xt = Math.min(At, xt.length - Lt);
              return mt.getMany({ trans: Y, keys: xt.slice(Lt, Lt + Xt), cache: "immutable" }).then(function(de) {
                for (var Se = [], pe = [], _e = bt ? [] : null, we = [], be = 0; be < Xt; ++be) {
                  var Ee = de[be], Be = { value: P(Ee), primKey: xt[Lt + be] };
                  ut.call(Be, Be.value, Be) !== !1 && (Be.value == null ? we.push(xt[Lt + be]) : bt || ln(St(Ee), St(Be.value)) === 0 ? (pe.push(Be.value), bt && _e.push(xt[Lt + be])) : (we.push(xt[Lt + be]), Se.push(Be.value)));
                }
                return Promise.resolve(0 < Se.length && mt.mutate({ trans: Y, type: "add", values: Se }).then(function(qe) {
                  for (var Ye in qe.failures) we.splice(parseInt(Ye), 1);
                  Rt(Se.length, qe);
                })).then(function() {
                  return (0 < pe.length || Ft && typeof S == "object") && mt.mutate({ trans: Y, type: "put", keys: _e, values: pe, criteria: Ft, changeSpec: typeof S != "function" && S, isAdditionalChunk: 0 < Lt }).then(function(qe) {
                    return Rt(pe.length, qe);
                  });
                }).then(function() {
                  return (0 < we.length || Ft && S === Ol) && mt.mutate({ trans: Y, type: "delete", keys: we, criteria: Ft, isAdditionalChunk: 0 < Lt }).then(function(qe) {
                    return Rt(we.length, qe);
                  });
                }).then(function() {
                  return xt.length > Lt + Xt && Dt(Lt + At);
                });
              });
            }
            var Ft = io(L) && L.limit === 1 / 0 && (typeof S != "function" || S === Ol) && { index: L.index, range: L.range };
            return Dt(0).then(function() {
              if (0 < _t.length) throw new ht("Error modifying one or more objects", _t, wt, Nt);
              return xt.length;
            });
          });
        });
      }, cn.prototype.delete = function() {
        var S = this._ctx, k = S.range;
        return io(S) && (S.isPrimKey || k.type === 3) ? this._write(function(L) {
          var Y = S.table.core.schema.primaryKey, Z = k;
          return S.table.core.count({ trans: L, query: { index: Y, range: Z } }).then(function(et) {
            return S.table.core.mutate({ trans: L, type: "deleteRange", range: Z }).then(function(ut) {
              var mt = ut.failures;
              if (ut.lastResult, ut.results, ut = ut.numFailures, ut) throw new ht("Could not delete some values", Object.keys(mt).map(function(bt) {
                return mt[bt];
              }), et - ut);
              return et - ut;
            });
          });
        }) : this.modify(Ol);
      }, cn);
      function cn() {
      }
      var Ol = function(S, k) {
        return k.value = null;
      };
      function Vc(S, k) {
        return S < k ? -1 : S === k ? 0 : 1;
      }
      function Hd(S, k) {
        return k < S ? -1 : S === k ? 0 : 1;
      }
      function cr(S, k, L) {
        return S = S instanceof Nl ? new S.Collection(S) : S, S._ctx.error = new (L || TypeError)(k), S;
      }
      function jo(S) {
        return new S.Collection(S, function() {
          return Fc("");
        }).limit(0);
      }
      function Ic(S, k, L, Y) {
        var Z, et, ut, mt, bt, St, At, gt = L.length;
        if (!L.every(function(wt) {
          return typeof wt == "string";
        })) return cr(S, Uc);
        function Rt(wt) {
          Z = wt === "next" ? function(xt) {
            return xt.toUpperCase();
          } : function(xt) {
            return xt.toLowerCase();
          }, et = wt === "next" ? function(xt) {
            return xt.toLowerCase();
          } : function(xt) {
            return xt.toUpperCase();
          }, ut = wt === "next" ? Vc : Hd;
          var Nt = L.map(function(xt) {
            return { lower: et(xt), upper: Z(xt) };
          }).sort(function(xt, Dt) {
            return ut(xt.lower, Dt.lower);
          });
          mt = Nt.map(function(xt) {
            return xt.upper;
          }), bt = Nt.map(function(xt) {
            return xt.lower;
          }), At = (St = wt) === "next" ? "" : Y;
        }
        Rt("next"), S = new S.Collection(S, function() {
          return Sa(mt[0], bt[gt - 1] + Y);
        }), S._ondirectionchange = function(wt) {
          Rt(wt);
        };
        var _t = 0;
        return S._addAlgorithm(function(wt, Nt, xt) {
          var Dt = wt.key;
          if (typeof Dt != "string") return !1;
          var Ft = et(Dt);
          if (k(Ft, bt, _t)) return !0;
          for (var Lt = null, Xt = _t; Xt < gt; ++Xt) {
            var de = function(Se, pe, _e, we, be, Ee) {
              for (var Be = Math.min(Se.length, we.length), qe = -1, Ye = 0; Ye < Be; ++Ye) {
                var fr = pe[Ye];
                if (fr !== we[Ye]) return be(Se[Ye], _e[Ye]) < 0 ? Se.substr(0, Ye) + _e[Ye] + _e.substr(Ye + 1) : be(Se[Ye], we[Ye]) < 0 ? Se.substr(0, Ye) + we[Ye] + _e.substr(Ye + 1) : 0 <= qe ? Se.substr(0, qe) + pe[qe] + _e.substr(qe + 1) : null;
                be(Se[Ye], fr) < 0 && (qe = Ye);
              }
              return Be < we.length && Ee === "next" ? Se + _e.substr(Se.length) : Be < Se.length && Ee === "prev" ? Se.substr(0, _e.length) : qe < 0 ? null : Se.substr(0, qe) + we[qe] + _e.substr(qe + 1);
            }(Dt, Ft, mt[Xt], bt[Xt], ut, St);
            de === null && Lt === null ? _t = Xt + 1 : (Lt === null || 0 < ut(Lt, de)) && (Lt = de);
          }
          return Nt(Lt !== null ? function() {
            wt.continue(Lt + At);
          } : xt), !1;
        }), S;
      }
      function Sa(S, k, L, Y) {
        return { type: 2, lower: S, upper: k, lowerOpen: L, upperOpen: Y };
      }
      function Fc(S) {
        return { type: 1, lower: S, upper: S };
      }
      var Nl = (Object.defineProperty(ni.prototype, "Collection", { get: function() {
        return this._ctx.table.db.Collection;
      }, enumerable: !1, configurable: !0 }), ni.prototype.between = function(S, k, L, Y) {
        L = L !== !1, Y = Y === !0;
        try {
          return 0 < this._cmp(S, k) || this._cmp(S, k) === 0 && (L || Y) && (!L || !Y) ? jo(this) : new this.Collection(this, function() {
            return Sa(S, k, !L, !Y);
          });
        } catch {
          return cr(this, Pn);
        }
      }, ni.prototype.equals = function(S) {
        return S == null ? cr(this, Pn) : new this.Collection(this, function() {
          return Fc(S);
        });
      }, ni.prototype.above = function(S) {
        return S == null ? cr(this, Pn) : new this.Collection(this, function() {
          return Sa(S, void 0, !0);
        });
      }, ni.prototype.aboveOrEqual = function(S) {
        return S == null ? cr(this, Pn) : new this.Collection(this, function() {
          return Sa(S, void 0, !1);
        });
      }, ni.prototype.below = function(S) {
        return S == null ? cr(this, Pn) : new this.Collection(this, function() {
          return Sa(void 0, S, !1, !0);
        });
      }, ni.prototype.belowOrEqual = function(S) {
        return S == null ? cr(this, Pn) : new this.Collection(this, function() {
          return Sa(void 0, S);
        });
      }, ni.prototype.startsWith = function(S) {
        return typeof S != "string" ? cr(this, Uc) : this.between(S, S + xr, !0, !0);
      }, ni.prototype.startsWithIgnoreCase = function(S) {
        return S === "" ? this.startsWith(S) : Ic(this, function(k, L) {
          return k.indexOf(L[0]) === 0;
        }, [S], xr);
      }, ni.prototype.equalsIgnoreCase = function(S) {
        return Ic(this, function(k, L) {
          return k === L[0];
        }, [S], "");
      }, ni.prototype.anyOfIgnoreCase = function() {
        var S = X.apply(nt, arguments);
        return S.length === 0 ? jo(this) : Ic(this, function(k, L) {
          return L.indexOf(k) !== -1;
        }, S, "");
      }, ni.prototype.startsWithAnyOfIgnoreCase = function() {
        var S = X.apply(nt, arguments);
        return S.length === 0 ? jo(this) : Ic(this, function(k, L) {
          return L.some(function(Y) {
            return k.indexOf(Y) === 0;
          });
        }, S, xr);
      }, ni.prototype.anyOf = function() {
        var S = this, k = X.apply(nt, arguments), L = this._cmp;
        try {
          k.sort(L);
        } catch {
          return cr(this, Pn);
        }
        if (k.length === 0) return jo(this);
        var Y = new this.Collection(this, function() {
          return Sa(k[0], k[k.length - 1]);
        });
        Y._ondirectionchange = function(et) {
          L = et === "next" ? S._ascending : S._descending, k.sort(L);
        };
        var Z = 0;
        return Y._addAlgorithm(function(et, ut, mt) {
          for (var bt = et.key; 0 < L(bt, k[Z]); ) if (++Z === k.length) return ut(mt), !1;
          return L(bt, k[Z]) === 0 || (ut(function() {
            et.continue(k[Z]);
          }), !1);
        }), Y;
      }, ni.prototype.notEqual = function(S) {
        return this.inAnyRange([[-1 / 0, S], [S, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 });
      }, ni.prototype.noneOf = function() {
        var S = X.apply(nt, arguments);
        if (S.length === 0) return new this.Collection(this);
        try {
          S.sort(this._ascending);
        } catch {
          return cr(this, Pn);
        }
        var k = S.reduce(function(L, Y) {
          return L ? L.concat([[L[L.length - 1][1], Y]]) : [[-1 / 0, Y]];
        }, null);
        return k.push([S[S.length - 1], this.db._maxKey]), this.inAnyRange(k, { includeLowers: !1, includeUppers: !1 });
      }, ni.prototype.inAnyRange = function(Dt, k) {
        var L = this, Y = this._cmp, Z = this._ascending, et = this._descending, ut = this._min, mt = this._max;
        if (Dt.length === 0) return jo(this);
        if (!Dt.every(function(Ft) {
          return Ft[0] !== void 0 && Ft[1] !== void 0 && Z(Ft[0], Ft[1]) <= 0;
        })) return cr(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", ft.InvalidArgument);
        var bt = !k || k.includeLowers !== !1, St = k && k.includeUppers === !0, At, gt = Z;
        function Rt(Ft, Lt) {
          return gt(Ft[0], Lt[0]);
        }
        try {
          (At = Dt.reduce(function(Ft, Lt) {
            for (var Xt = 0, de = Ft.length; Xt < de; ++Xt) {
              var Se = Ft[Xt];
              if (Y(Lt[0], Se[1]) < 0 && 0 < Y(Lt[1], Se[0])) {
                Se[0] = ut(Se[0], Lt[0]), Se[1] = mt(Se[1], Lt[1]);
                break;
              }
            }
            return Xt === de && Ft.push(Lt), Ft;
          }, [])).sort(Rt);
        } catch {
          return cr(this, Pn);
        }
        var _t = 0, wt = St ? function(Ft) {
          return 0 < Z(Ft, At[_t][1]);
        } : function(Ft) {
          return 0 <= Z(Ft, At[_t][1]);
        }, Nt = bt ? function(Ft) {
          return 0 < et(Ft, At[_t][0]);
        } : function(Ft) {
          return 0 <= et(Ft, At[_t][0]);
        }, xt = wt, Dt = new this.Collection(this, function() {
          return Sa(At[0][0], At[At.length - 1][1], !bt, !St);
        });
        return Dt._ondirectionchange = function(Ft) {
          gt = Ft === "next" ? (xt = wt, Z) : (xt = Nt, et), At.sort(Rt);
        }, Dt._addAlgorithm(function(Ft, Lt, Xt) {
          for (var de, Se = Ft.key; xt(Se); ) if (++_t === At.length) return Lt(Xt), !1;
          return !wt(de = Se) && !Nt(de) || (L._cmp(Se, At[_t][1]) === 0 || L._cmp(Se, At[_t][0]) === 0 || Lt(function() {
            gt === Z ? Ft.continue(At[_t][0]) : Ft.continue(At[_t][1]);
          }), !1);
        }), Dt;
      }, ni.prototype.startsWithAnyOf = function() {
        var S = X.apply(nt, arguments);
        return S.every(function(k) {
          return typeof k == "string";
        }) ? S.length === 0 ? jo(this) : this.inAnyRange(S.map(function(k) {
          return [k, k + xr];
        })) : cr(this, "startsWithAnyOf() only works with strings");
      }, ni);
      function ni() {
      }
      function Cr(S) {
        return Fn(function(k) {
          return ao(k), S(k.target.error), !1;
        });
      }
      function ao(S) {
        S.stopPropagation && S.stopPropagation(), S.preventDefault && S.preventDefault();
      }
      var so = "storagemutated", qc = "x-storagemutated-1", ra = Ml(null, so), Gc = (Dr.prototype._lock = function() {
        return R(!ne.global), ++this._reculock, this._reculock !== 1 || ne.global || (ne.lockOwnerFor = this), this;
      }, Dr.prototype._unlock = function() {
        if (R(!ne.global), --this._reculock == 0) for (ne.global || (ne.lockOwnerFor = null); 0 < this._blockedFuncs.length && !this._locked(); ) {
          var S = this._blockedFuncs.shift();
          try {
            Ua(S[1], S[0]);
          } catch {
          }
        }
        return this;
      }, Dr.prototype._locked = function() {
        return this._reculock && ne.lockOwnerFor !== this;
      }, Dr.prototype.create = function(S) {
        var k = this;
        if (!this.mode) return this;
        var L = this.db.idbdb, Y = this.db._state.dbOpenError;
        if (R(!this.idbtrans), !S && !L) switch (Y && Y.name) {
          case "DatabaseClosedError":
            throw new ft.DatabaseClosed(Y);
          case "MissingAPIError":
            throw new ft.MissingAPI(Y.message, Y);
          default:
            throw new ft.OpenFailed(Y);
        }
        if (!this.active) throw new ft.TransactionInactive();
        return R(this._completion._state === null), (S = this.idbtrans = S || (this.db.core || L).transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })).onerror = Fn(function(Z) {
          ao(Z), k._reject(S.error);
        }), S.onabort = Fn(function(Z) {
          ao(Z), k.active && k._reject(new ft.Abort(S.error)), k.active = !1, k.on("abort").fire(Z);
        }), S.oncomplete = Fn(function() {
          k.active = !1, k._resolve(), "mutatedParts" in S && ra.storagemutated.fire(S.mutatedParts);
        }), this;
      }, Dr.prototype._promise = function(S, k, L) {
        var Y = this;
        if (S === "readwrite" && this.mode !== "readwrite") return $e(new ft.ReadOnly("Transaction is readonly"));
        if (!this.active) return $e(new ft.TransactionInactive());
        if (this._locked()) return new Ce(function(et, ut) {
          Y._blockedFuncs.push([function() {
            Y._promise(S, k, L).then(et, ut);
          }, ne]);
        });
        if (L) return rn(function() {
          var et = new Ce(function(ut, mt) {
            Y._lock();
            var bt = k(ut, mt, Y);
            bt && bt.then && bt.then(ut, mt);
          });
          return et.finally(function() {
            return Y._unlock();
          }), et._lib = !0, et;
        });
        var Z = new Ce(function(et, ut) {
          var mt = k(et, ut, Y);
          mt && mt.then && mt.then(et, ut);
        });
        return Z._lib = !0, Z;
      }, Dr.prototype._root = function() {
        return this.parent ? this.parent._root() : this;
      }, Dr.prototype.waitFor = function(S) {
        var k, L = this._root(), Y = Ce.resolve(S);
        L._waitingFor ? L._waitingFor = L._waitingFor.then(function() {
          return Y;
        }) : (L._waitingFor = Y, L._waitingQueue = [], k = L.idbtrans.objectStore(L.storeNames[0]), function et() {
          for (++L._spinCount; L._waitingQueue.length; ) L._waitingQueue.shift()();
          L._waitingFor && (k.get(-1 / 0).onsuccess = et);
        }());
        var Z = L._waitingFor;
        return new Ce(function(et, ut) {
          Y.then(function(mt) {
            return L._waitingQueue.push(Fn(et.bind(null, mt)));
          }, function(mt) {
            return L._waitingQueue.push(Fn(ut.bind(null, mt)));
          }).finally(function() {
            L._waitingFor === Z && (L._waitingFor = null);
          });
        });
      }, Dr.prototype.abort = function() {
        this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new ft.Abort()));
      }, Dr.prototype.table = function(S) {
        var k = this._memoizedTables || (this._memoizedTables = {});
        if (v(k, S)) return k[S];
        var L = this.schema[S];
        if (!L) throw new ft.NotFound("Table " + S + " not part of transaction");
        return L = new this.db.Table(S, L, this), L.core = this.db.core.table(S), k[S] = L;
      }, Dr);
      function Dr() {
      }
      function ja(S, k, L, Y, Z, et, ut) {
        return { name: S, keyPath: k, unique: L, multi: Y, auto: Z, compound: et, src: (L && !ut ? "&" : "") + (Y ? "*" : "") + (Z ? "++" : "") + Hu(k) };
      }
      function Hu(S) {
        return typeof S == "string" ? S : S ? "[" + [].join.call(S, "+") + "]" : "";
      }
      function kl(S, k, L) {
        return { name: S, primKey: k, indexes: L, mappedClass: null, idxByName: (Y = function(Z) {
          return [Z.name, Z];
        }, L.reduce(function(Z, et, ut) {
          return ut = Y(et, ut), ut && (Z[ut[0]] = ut[1]), Z;
        }, {})) };
        var Y;
      }
      var Lo = function(S) {
        try {
          return S.only([[]]), Lo = function() {
            return [[]];
          }, [[]];
        } catch {
          return Lo = function() {
            return xr;
          }, xr;
        }
      };
      function is(S) {
        return S == null ? function() {
        } : typeof S == "string" ? (k = S).split(".").length === 1 ? function(L) {
          return L[k];
        } : function(L) {
          return U(L, k);
        } : function(L) {
          return U(L, S);
        };
        var k;
      }
      function Vo(S) {
        return [].slice.call(S);
      }
      var Hc = 0;
      function Ui(S) {
        return S == null ? ":id" : typeof S == "string" ? S : "[".concat(S.join("+"), "]");
      }
      function oo(S, k, bt) {
        function Y(xt) {
          if (xt.type === 3) return null;
          if (xt.type === 4) throw new Error("Cannot convert never type to IDBKeyRange");
          var _t = xt.lower, wt = xt.upper, Nt = xt.lowerOpen, xt = xt.upperOpen;
          return _t === void 0 ? wt === void 0 ? null : k.upperBound(wt, !!xt) : wt === void 0 ? k.lowerBound(_t, !!Nt) : k.bound(_t, wt, !!Nt, !!xt);
        }
        function Z(Rt) {
          var _t, wt = Rt.name;
          return { name: wt, schema: Rt, mutate: function(Nt) {
            var xt = Nt.trans, Dt = Nt.type, Ft = Nt.keys, Lt = Nt.values, Xt = Nt.range;
            return new Promise(function(de, Se) {
              de = Fn(de);
              var pe = xt.objectStore(wt), _e = pe.keyPath == null, we = Dt === "put" || Dt === "add";
              if (!we && Dt !== "delete" && Dt !== "deleteRange") throw new Error("Invalid operation type: " + Dt);
              var be, Ee = (Ft || Lt || { length: 1 }).length;
              if (Ft && Lt && Ft.length !== Lt.length) throw new Error("Given keys array must have same length as given values array.");
              if (Ee === 0) return de({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
              function Be(ji) {
                ++fr, ao(ji);
              }
              var qe = [], Ye = [], fr = 0;
              if (Dt === "deleteRange") {
                if (Xt.type === 4) return de({ numFailures: fr, failures: Ye, results: [], lastResult: void 0 });
                Xt.type === 3 ? qe.push(be = pe.clear()) : qe.push(be = pe.delete(Y(Xt)));
              } else {
                var _e = we ? _e ? [Lt, Ft] : [Lt, null] : [Ft, null], Ge = _e[0], yi = _e[1];
                if (we) for (var ai = 0; ai < Ee; ++ai) qe.push(be = yi && yi[ai] !== void 0 ? pe[Dt](Ge[ai], yi[ai]) : pe[Dt](Ge[ai])), be.onerror = Be;
                else for (ai = 0; ai < Ee; ++ai) qe.push(be = pe[Dt](Ge[ai])), be.onerror = Be;
              }
              function uo(ji) {
                ji = ji.target.result, qe.forEach(function(Fr, Il) {
                  return Fr.error != null && (Ye[Il] = Fr.error);
                }), de({ numFailures: fr, failures: Ye, results: Dt === "delete" ? Ft : qe.map(function(Fr) {
                  return Fr.result;
                }), lastResult: ji });
              }
              be.onerror = function(ji) {
                Be(ji), uo(ji);
              }, be.onsuccess = uo;
            });
          }, getMany: function(Nt) {
            var xt = Nt.trans, Dt = Nt.keys;
            return new Promise(function(Ft, Lt) {
              Ft = Fn(Ft);
              for (var Xt, de = xt.objectStore(wt), Se = Dt.length, pe = new Array(Se), _e = 0, we = 0, be = function(qe) {
                qe = qe.target, pe[qe._pos] = qe.result, ++we === _e && Ft(pe);
              }, Ee = Cr(Lt), Be = 0; Be < Se; ++Be) Dt[Be] != null && ((Xt = de.get(Dt[Be]))._pos = Be, Xt.onsuccess = be, Xt.onerror = Ee, ++_e);
              _e === 0 && Ft(pe);
            });
          }, get: function(Nt) {
            var xt = Nt.trans, Dt = Nt.key;
            return new Promise(function(Ft, Lt) {
              Ft = Fn(Ft);
              var Xt = xt.objectStore(wt).get(Dt);
              Xt.onsuccess = function(de) {
                return Ft(de.target.result);
              }, Xt.onerror = Cr(Lt);
            });
          }, query: (_t = St, function(Nt) {
            return new Promise(function(xt, Dt) {
              xt = Fn(xt);
              var Ft, Lt, Xt, _e = Nt.trans, de = Nt.values, Se = Nt.limit, be = Nt.query, pe = Se === 1 / 0 ? void 0 : Se, we = be.index, be = be.range, _e = _e.objectStore(wt), we = we.isPrimaryKey ? _e : _e.index(we.name), be = Y(be);
              if (Se === 0) return xt({ result: [] });
              _t ? ((pe = de ? we.getAll(be, pe) : we.getAllKeys(be, pe)).onsuccess = function(Ee) {
                return xt({ result: Ee.target.result });
              }, pe.onerror = Cr(Dt)) : (Ft = 0, Lt = !de && "openKeyCursor" in we ? we.openKeyCursor(be) : we.openCursor(be), Xt = [], Lt.onsuccess = function(Ee) {
                var Be = Lt.result;
                return Be ? (Xt.push(de ? Be.value : Be.primaryKey), ++Ft === Se ? xt({ result: Xt }) : void Be.continue()) : xt({ result: Xt });
              }, Lt.onerror = Cr(Dt));
            });
          }), openCursor: function(Nt) {
            var xt = Nt.trans, Dt = Nt.values, Ft = Nt.query, Lt = Nt.reverse, Xt = Nt.unique;
            return new Promise(function(de, Se) {
              de = Fn(de);
              var we = Ft.index, pe = Ft.range, _e = xt.objectStore(wt), _e = we.isPrimaryKey ? _e : _e.index(we.name), we = Lt ? Xt ? "prevunique" : "prev" : Xt ? "nextunique" : "next", be = !Dt && "openKeyCursor" in _e ? _e.openKeyCursor(Y(pe), we) : _e.openCursor(Y(pe), we);
              be.onerror = Cr(Se), be.onsuccess = Fn(function(Ee) {
                var Be, qe, Ye, fr, Ge = be.result;
                Ge ? (Ge.___id = ++Hc, Ge.done = !1, Be = Ge.continue.bind(Ge), qe = (qe = Ge.continuePrimaryKey) && qe.bind(Ge), Ye = Ge.advance.bind(Ge), fr = function() {
                  throw new Error("Cursor not stopped");
                }, Ge.trans = xt, Ge.stop = Ge.continue = Ge.continuePrimaryKey = Ge.advance = function() {
                  throw new Error("Cursor not started");
                }, Ge.fail = Fn(Se), Ge.next = function() {
                  var yi = this, ai = 1;
                  return this.start(function() {
                    return ai-- ? yi.continue() : yi.stop();
                  }).then(function() {
                    return yi;
                  });
                }, Ge.start = function(yi) {
                  function ai() {
                    if (be.result) try {
                      yi();
                    } catch (ji) {
                      Ge.fail(ji);
                    }
                    else Ge.done = !0, Ge.start = function() {
                      throw new Error("Cursor behind last entry");
                    }, Ge.stop();
                  }
                  var uo = new Promise(function(ji, Fr) {
                    ji = Fn(ji), be.onerror = Cr(Fr), Ge.fail = Fr, Ge.stop = function(Il) {
                      Ge.stop = Ge.continue = Ge.continuePrimaryKey = Ge.advance = fr, ji(Il);
                    };
                  });
                  return be.onsuccess = Fn(function(ji) {
                    be.onsuccess = ai, ai();
                  }), Ge.continue = Be, Ge.continuePrimaryKey = qe, Ge.advance = Ye, ai(), uo;
                }, de(Ge)) : de(null);
              }, Se);
            });
          }, count: function(Nt) {
            var xt = Nt.query, Dt = Nt.trans, Ft = xt.index, Lt = xt.range;
            return new Promise(function(Xt, de) {
              var Se = Dt.objectStore(wt), pe = Ft.isPrimaryKey ? Se : Se.index(Ft.name), Se = Y(Lt), pe = Se ? pe.count(Se) : pe.count();
              pe.onsuccess = Fn(function(_e) {
                return Xt(_e.target.result);
              }), pe.onerror = Cr(de);
            });
          } };
        }
        var et, ut, mt, At = (ut = bt, mt = Vo((et = S).objectStoreNames), { schema: { name: et.name, tables: mt.map(function(Rt) {
          return ut.objectStore(Rt);
        }).map(function(Rt) {
          var _t = Rt.keyPath, xt = Rt.autoIncrement, wt = h(_t), Nt = {}, xt = { name: Rt.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: _t == null, compound: wt, keyPath: _t, autoIncrement: xt, unique: !0, extractKey: is(_t) }, indexes: Vo(Rt.indexNames).map(function(Dt) {
            return Rt.index(Dt);
          }).map(function(Xt) {
            var Ft = Xt.name, Lt = Xt.unique, de = Xt.multiEntry, Xt = Xt.keyPath, de = { name: Ft, compound: h(Xt), keyPath: Xt, unique: Lt, multiEntry: de, extractKey: is(Xt) };
            return Nt[Ui(Xt)] = de;
          }), getIndexByKeyPath: function(Dt) {
            return Nt[Ui(Dt)];
          } };
          return Nt[":id"] = xt.primaryKey, _t != null && (Nt[Ui(_t)] = xt.primaryKey), xt;
        }) }, hasGetAll: 0 < mt.length && "getAll" in ut.objectStore(mt[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) }), bt = At.schema, St = At.hasGetAll, At = bt.tables.map(Z), gt = {};
        return At.forEach(function(Rt) {
          return gt[Rt.name] = Rt;
        }), { stack: "dbcore", transaction: S.transaction.bind(S), table: function(Rt) {
          if (!gt[Rt]) throw new Error("Table '".concat(Rt, "' not found"));
          return gt[Rt];
        }, MIN_KEY: -1 / 0, MAX_KEY: Lo(k), schema: bt };
      }
      function Dl(S, k, L, Y) {
        var Z = L.IDBKeyRange;
        return L.indexedDB, { dbcore: (Y = oo(k, Z, Y), S.dbcore.reduce(function(et, ut) {
          return ut = ut.create, i(i({}, et), ut(et));
        }, Y)) };
      }
      function Rs(S, Y) {
        var L = Y.db, Y = Dl(S._middlewares, L, S._deps, Y);
        S.core = Y.dbcore, S.tables.forEach(function(Z) {
          var et = Z.name;
          S.core.schema.tables.some(function(ut) {
            return ut.name === et;
          }) && (Z.core = S.core.table(et), S[et] instanceof S.Table && (S[et].core = Z.core));
        });
      }
      function Kc(S, k, L, Y) {
        L.forEach(function(Z) {
          var et = Y[Z];
          k.forEach(function(ut) {
            var mt = function bt(St, At) {
              return A(St, At) || (St = p(St)) && bt(St, At);
            }(ut, Z);
            (!mt || "value" in mt && mt.value === void 0) && (ut === S.Transaction.prototype || ut instanceof S.Transaction ? _(ut, Z, { get: function() {
              return this.table(Z);
            }, set: function(bt) {
              b(this, Z, { value: bt, writable: !0, configurable: !0, enumerable: !0 });
            } }) : ut[Z] = new S.Table(Z, et));
          });
        });
      }
      function La(S, k) {
        k.forEach(function(L) {
          for (var Y in L) L[Y] instanceof S.Table && delete L[Y];
        });
      }
      function Bl(S, k) {
        return S._cfg.version - k._cfg.version;
      }
      function zl(S, k, L, Y) {
        var Z = S._dbSchema;
        L.objectStoreNames.contains("$meta") && !Z.$meta && (Z.$meta = kl("$meta", Kd("")[0], []), S._storeNames.push("$meta"));
        var et = S._createTransaction("readwrite", S._storeNames, Z);
        et.create(L), et._completion.catch(Y);
        var ut = et._reject.bind(et), mt = ne.transless || ne;
        rn(function() {
          return ne.trans = et, ne.transless = mt, k !== 0 ? (Rs(S, L), St = k, ((bt = et).storeNames.includes("$meta") ? bt.table("$meta").get("version").then(function(At) {
            return At ?? St;
          }) : Ce.resolve(St)).then(function(At) {
            return Rt = At, _t = et, wt = L, Nt = [], At = (gt = S)._versions, xt = gt._dbSchema = Io(0, gt.idbdb, wt), (At = At.filter(function(Dt) {
              return Dt._cfg.version >= Rt;
            })).length !== 0 ? (At.forEach(function(Dt) {
              Nt.push(function() {
                var Ft = xt, Lt = Dt._cfg.dbschema;
                Xc(gt, Ft, wt), Xc(gt, Lt, wt), xt = gt._dbSchema = Lt;
                var Xt = Yc(Ft, Lt);
                Xt.add.forEach(function(we) {
                  Ku(wt, we[0], we[1].primKey, we[1].indexes);
                }), Xt.change.forEach(function(we) {
                  if (we.recreate) throw new ft.Upgrade("Not yet support for changing primary key");
                  var be = wt.objectStore(we.name);
                  we.add.forEach(function(Ee) {
                    return Oi(be, Ee);
                  }), we.change.forEach(function(Ee) {
                    be.deleteIndex(Ee.name), Oi(be, Ee);
                  }), we.del.forEach(function(Ee) {
                    return be.deleteIndex(Ee);
                  });
                });
                var de = Dt._cfg.contentUpgrade;
                if (de && Dt._cfg.version > Rt) {
                  Rs(gt, wt), _t._memoizedTables = {};
                  var Se = j(Lt);
                  Xt.del.forEach(function(we) {
                    Se[we] = Ft[we];
                  }), La(gt, [gt.Transaction.prototype]), Kc(gt, [gt.Transaction.prototype], u(Se), Se), _t.schema = Se;
                  var pe, _e = rt(de);
                  return _e && ea(), Xt = Ce.follow(function() {
                    var we;
                    (pe = de(_t)) && _e && (we = ba.bind(null, null), pe.then(we, we));
                  }), pe && typeof pe.then == "function" ? Ce.resolve(pe) : Xt.then(function() {
                    return pe;
                  });
                }
              }), Nt.push(function(Ft) {
                var Lt, Xt, de = Dt._cfg.dbschema;
                Lt = de, Xt = Ft, [].slice.call(Xt.db.objectStoreNames).forEach(function(Se) {
                  return Lt[Se] == null && Xt.db.deleteObjectStore(Se);
                }), La(gt, [gt.Transaction.prototype]), Kc(gt, [gt.Transaction.prototype], gt._storeNames, gt._dbSchema), _t.schema = gt._dbSchema;
              }), Nt.push(function(Ft) {
                gt.idbdb.objectStoreNames.contains("$meta") && (Math.ceil(gt.idbdb.version / 10) === Dt._cfg.version ? (gt.idbdb.deleteObjectStore("$meta"), delete gt._dbSchema.$meta, gt._storeNames = gt._storeNames.filter(function(Lt) {
                  return Lt !== "$meta";
                })) : Ft.objectStore("$meta").put(Dt._cfg.version, "version"));
              });
            }), function Dt() {
              return Nt.length ? Ce.resolve(Nt.shift()(_t.idbtrans)).then(Dt) : Ce.resolve();
            }().then(function() {
              Hh(xt, wt);
            })) : Ce.resolve();
            var gt, Rt, _t, wt, Nt, xt;
          }).catch(ut)) : (u(Z).forEach(function(At) {
            Ku(L, At, Z[At].primKey, Z[At].indexes);
          }), Rs(S, L), void Ce.follow(function() {
            return S.on.populate.fire(et);
          }).catch(ut));
          var bt, St;
        });
      }
      function Pl(S, k) {
        Hh(S._dbSchema, k), k.db.version % 10 != 0 || k.objectStoreNames.contains("$meta") || k.db.createObjectStore("$meta").add(Math.ceil(k.db.version / 10 - 1), "version");
        var L = Io(0, S.idbdb, k);
        Xc(S, S._dbSchema, k);
        for (var Y = 0, Z = Yc(L, S._dbSchema).change; Y < Z.length; Y++) {
          var et = function(ut) {
            if (ut.change.length || ut.recreate) return console.warn("Unable to patch indexes of table ".concat(ut.name, " because it has changes on the type of index or primary key.")), { value: void 0 };
            var mt = k.objectStore(ut.name);
            ut.add.forEach(function(bt) {
              Re && console.debug("Dexie upgrade patch: Creating missing index ".concat(ut.name, ".").concat(bt.src)), Oi(mt, bt);
            });
          }(Z[Y]);
          if (typeof et == "object") return et.value;
        }
      }
      function Yc(S, k) {
        var L, Y = { del: [], add: [], change: [] };
        for (L in S) k[L] || Y.del.push(L);
        for (L in k) {
          var Z = S[L], et = k[L];
          if (Z) {
            var ut = { name: L, def: et, recreate: !1, del: [], add: [], change: [] };
            if ("" + (Z.primKey.keyPath || "") != "" + (et.primKey.keyPath || "") || Z.primKey.auto !== et.primKey.auto) ut.recreate = !0, Y.change.push(ut);
            else {
              var mt = Z.idxByName, bt = et.idxByName, St = void 0;
              for (St in mt) bt[St] || ut.del.push(St);
              for (St in bt) {
                var At = mt[St], gt = bt[St];
                At ? At.src !== gt.src && ut.change.push(gt) : ut.add.push(gt);
              }
              (0 < ut.del.length || 0 < ut.add.length || 0 < ut.change.length) && Y.change.push(ut);
            }
          } else Y.add.push([L, et]);
        }
        return Y;
      }
      function Ku(S, k, L, Y) {
        var Z = S.db.createObjectStore(k, L.keyPath ? { keyPath: L.keyPath, autoIncrement: L.auto } : { autoIncrement: L.auto });
        return Y.forEach(function(et) {
          return Oi(Z, et);
        }), Z;
      }
      function Hh(S, k) {
        u(S).forEach(function(L) {
          k.db.objectStoreNames.contains(L) || (Re && console.debug("Dexie: Creating missing table", L), Ku(k, L, S[L].primKey, S[L].indexes));
        });
      }
      function Oi(S, k) {
        S.createIndex(k.name, k.keyPath, { unique: k.unique, multiEntry: k.multi });
      }
      function Io(S, k, L) {
        var Y = {};
        return M(k.objectStoreNames, 0).forEach(function(Z) {
          for (var et = L.objectStore(Z), ut = ja(Hu(St = et.keyPath), St || "", !0, !1, !!et.autoIncrement, St && typeof St != "string", !0), mt = [], bt = 0; bt < et.indexNames.length; ++bt) {
            var At = et.index(et.indexNames[bt]), St = At.keyPath, At = ja(At.name, St, !!At.unique, !!At.multiEntry, !1, St && typeof St != "string", !1);
            mt.push(At);
          }
          Y[Z] = kl(Z, ut, mt);
        }), Y;
      }
      function Xc(S, k, L) {
        for (var Y = L.db.objectStoreNames, Z = 0; Z < Y.length; ++Z) {
          var et = Y[Z], ut = L.objectStore(et);
          S._hasGetAll = "getAll" in ut;
          for (var mt = 0; mt < ut.indexNames.length; ++mt) {
            var bt = ut.indexNames[mt], St = ut.index(bt).keyPath, At = typeof St == "string" ? St : "[" + M(St).join("+") + "]";
            !k[et] || (St = k[et].idxByName[At]) && (St.name = bt, delete k[et].idxByName[At], k[et].idxByName[bt] = St);
          }
        }
        typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && o.WorkerGlobalScope && o instanceof o.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (S._hasGetAll = !1);
      }
      function Kd(S) {
        return S.split(",").map(function(k, L) {
          var Y = (k = k.trim()).replace(/([&*]|\+\+)/g, ""), Z = /^\[/.test(Y) ? Y.match(/^\[(.*)\]$/)[1].split("+") : Y;
          return ja(Y, Z || null, /\&/.test(k), /\*/.test(k), /\+\+/.test(k), h(Z), L === 0);
        });
      }
      var Kh = (Wc.prototype._parseStoresSpec = function(S, k) {
        u(S).forEach(function(L) {
          if (S[L] !== null) {
            var Y = Kd(S[L]), Z = Y.shift();
            if (Z.unique = !0, Z.multi) throw new ft.Schema("Primary key cannot be multi-valued");
            Y.forEach(function(et) {
              if (et.auto) throw new ft.Schema("Only primary key can be marked as autoIncrement (++)");
              if (!et.keyPath) throw new ft.Schema("Index must have a name and cannot be an empty string");
            }), k[L] = kl(L, Z, Y);
          }
        });
      }, Wc.prototype.stores = function(L) {
        var k = this.db;
        this._cfg.storesSource = this._cfg.storesSource ? f(this._cfg.storesSource, L) : L;
        var L = k._versions, Y = {}, Z = {};
        return L.forEach(function(et) {
          f(Y, et._cfg.storesSource), Z = et._cfg.dbschema = {}, et._parseStoresSpec(Y, Z);
        }), k._dbSchema = Z, La(k, [k._allTables, k, k.Transaction.prototype]), Kc(k, [k._allTables, k, k.Transaction.prototype, this._cfg.tables], u(Z), Z), k._storeNames = u(Z), this;
      }, Wc.prototype.upgrade = function(S) {
        return this._cfg.contentUpgrade = ve(this._cfg.contentUpgrade || Ot, S), this;
      }, Wc);
      function Wc() {
      }
      function Fo(S, k) {
        var L = S._dbNamesDB;
        return L || (L = S._dbNamesDB = new xa(na, { addons: [], indexedDB: S, IDBKeyRange: k })).version(1).stores({ dbnames: "name" }), L.table("dbnames");
      }
      function Ul(S) {
        return S && typeof S.databases == "function";
      }
      function Yu(S) {
        return rn(function() {
          return ne.letThrough = !0, S();
        });
      }
      function Xu(S) {
        return !("from" in S);
      }
      var ur = function(S, k) {
        if (!this) {
          var L = new ur();
          return S && "d" in S && f(L, S), L;
        }
        f(this, arguments.length ? { d: 1, from: S, to: 1 < arguments.length ? k : S } : { d: 0 });
      };
      function qo(S, k, L) {
        var Y = ln(k, L);
        if (!isNaN(Y)) {
          if (0 < Y) throw RangeError();
          if (Xu(S)) return f(S, { from: k, to: L, d: 1 });
          var Z = S.l, Y = S.r;
          if (ln(L, S.from) < 0) return Z ? qo(Z, k, L) : S.l = { from: k, to: L, d: 1, l: null, r: null }, Wu(S);
          if (0 < ln(k, S.to)) return Y ? qo(Y, k, L) : S.r = { from: k, to: L, d: 1, l: null, r: null }, Wu(S);
          ln(k, S.from) < 0 && (S.from = k, S.l = null, S.d = Y ? Y.d + 1 : 1), 0 < ln(L, S.to) && (S.to = L, S.r = null, S.d = S.l ? S.l.d + 1 : 1), L = !S.r, Z && !S.l && Os(S, Z), Y && L && Os(S, Y);
        }
      }
      function Os(S, k) {
        Xu(k) || function L(Y, bt) {
          var et = bt.from, ut = bt.to, mt = bt.l, bt = bt.r;
          qo(Y, et, ut), mt && L(Y, mt), bt && L(Y, bt);
        }(S, k);
      }
      function Yd(S, k) {
        var L = jl(k), Y = L.next();
        if (Y.done) return !1;
        for (var Z = Y.value, et = jl(S), ut = et.next(Z.from), mt = ut.value; !Y.done && !ut.done; ) {
          if (ln(mt.from, Z.to) <= 0 && 0 <= ln(mt.to, Z.from)) return !0;
          ln(Z.from, mt.from) < 0 ? Z = (Y = L.next(mt.from)).value : mt = (ut = et.next(Z.from)).value;
        }
        return !1;
      }
      function jl(S) {
        var k = Xu(S) ? null : { s: 0, n: S };
        return { next: function(L) {
          for (var Y = 0 < arguments.length; k; ) switch (k.s) {
            case 0:
              if (k.s = 1, Y) for (; k.n.l && ln(L, k.n.from) < 0; ) k = { up: k, n: k.n.l, s: 1 };
              else for (; k.n.l; ) k = { up: k, n: k.n.l, s: 1 };
            case 1:
              if (k.s = 2, !Y || ln(L, k.n.to) <= 0) return { value: k.n, done: !1 };
            case 2:
              if (k.n.r) {
                k.s = 3, k = { up: k, n: k.n.r, s: 0 };
                continue;
              }
            case 3:
              k = k.up;
          }
          return { done: !0 };
        } };
      }
      function Wu(S) {
        var k, L, Y = (((k = S.r) === null || k === void 0 ? void 0 : k.d) || 0) - (((L = S.l) === null || L === void 0 ? void 0 : L.d) || 0), Z = 1 < Y ? "r" : Y < -1 ? "l" : "";
        Z && (k = Z == "r" ? "l" : "r", L = i({}, S), Y = S[Z], S.from = Y.from, S.to = Y.to, S[Z] = Y[Z], L[Z] = Y[k], (S[k] = L).d = $c(L)), S.d = $c(S);
      }
      function $c(L) {
        var k = L.r, L = L.l;
        return (k ? L ? Math.max(k.d, L.d) : k.d : L ? L.d : 0) + 1;
      }
      function Qc(S, k) {
        return u(k).forEach(function(L) {
          S[L] ? Os(S[L], k[L]) : S[L] = function Y(Z) {
            var et, ut, mt = {};
            for (et in Z) v(Z, et) && (ut = Z[et], mt[et] = !ut || typeof ut != "object" || G.has(ut.constructor) ? ut : Y(ut));
            return mt;
          }(k[L]);
        }), S;
      }
      function Zc(S, k) {
        return S.all || k.all || Object.keys(S).some(function(L) {
          return k[L] && Yd(k[L], S[L]);
        });
      }
      x(ur.prototype, ((hr = { add: function(S) {
        return Os(this, S), this;
      }, addKey: function(S) {
        return qo(this, S, S), this;
      }, addKeys: function(S) {
        var k = this;
        return S.forEach(function(L) {
          return qo(k, L, L);
        }), this;
      }, hasKey: function(S) {
        var k = jl(this).next(S).value;
        return k && ln(k.from, S) <= 0 && 0 <= ln(k.to, S);
      } })[K] = function() {
        return jl(this);
      }, hr));
      var lo = {}, Va = {}, Jc = !1;
      function $u(S) {
        Qc(Va, S), Jc || (Jc = !0, setTimeout(function() {
          Jc = !1, Qu(Va, !(Va = {}));
        }, 0));
      }
      function Qu(S, k) {
        k === void 0 && (k = !1);
        var L = /* @__PURE__ */ new Set();
        if (S.all) for (var Y = 0, Z = Object.values(lo); Y < Z.length; Y++) Ns(ut = Z[Y], S, L, k);
        else for (var et in S) {
          var ut, mt = /^idb\:\/\/(.*)\/(.*)\//.exec(et);
          mt && (et = mt[1], mt = mt[2], (ut = lo["idb://".concat(et, "/").concat(mt)]) && Ns(ut, S, L, k));
        }
        L.forEach(function(bt) {
          return bt();
        });
      }
      function Ns(S, k, L, Y) {
        for (var Z = [], et = 0, ut = Object.entries(S.queries.query); et < ut.length; et++) {
          for (var mt = ut[et], bt = mt[0], St = [], At = 0, gt = mt[1]; At < gt.length; At++) {
            var Rt = gt[At];
            Zc(k, Rt.obsSet) ? Rt.subscribers.forEach(function(xt) {
              return L.add(xt);
            }) : Y && St.push(Rt);
          }
          Y && Z.push([bt, St]);
        }
        if (Y) for (var _t = 0, wt = Z; _t < wt.length; _t++) {
          var Nt = wt[_t], bt = Nt[0], St = Nt[1];
          S.queries.query[bt] = St;
        }
      }
      function ks(S) {
        var k = S._state, L = S._deps.indexedDB;
        if (k.isBeingOpened || S.idbdb) return k.dbReadyPromise.then(function() {
          return k.dbOpenError ? $e(k.dbOpenError) : S;
        });
        k.isBeingOpened = !0, k.dbOpenError = null, k.openComplete = !1;
        var Y = k.openCanceller, Z = Math.round(10 * S.verno), et = !1;
        function ut() {
          if (k.openCanceller !== Y) throw new ft.DatabaseClosed("db.open() was cancelled");
        }
        function mt() {
          return new Ce(function(Rt, _t) {
            if (ut(), !L) throw new ft.MissingAPI();
            var wt = S.name, Nt = k.autoSchema || !Z ? L.open(wt) : L.open(wt, Z);
            if (!Nt) throw new ft.MissingAPI();
            Nt.onerror = Cr(_t), Nt.onblocked = Fn(S._fireOnBlocked), Nt.onupgradeneeded = Fn(function(xt) {
              var Dt;
              At = Nt.transaction, k.autoSchema && !S._options.allowEmptyDB ? (Nt.onerror = ao, At.abort(), Nt.result.close(), (Dt = L.deleteDatabase(wt)).onsuccess = Dt.onerror = Fn(function() {
                _t(new ft.NoSuchDatabase("Database ".concat(wt, " doesnt exist")));
              })) : (At.onerror = Cr(_t), xt = xt.oldVersion > Math.pow(2, 62) ? 0 : xt.oldVersion, gt = xt < 1, S.idbdb = Nt.result, et && Pl(S, At), zl(S, xt / 10, At, _t));
            }, _t), Nt.onsuccess = Fn(function() {
              At = null;
              var xt, Dt, Ft, Lt, Xt, de = S.idbdb = Nt.result, Se = M(de.objectStoreNames);
              if (0 < Se.length) try {
                var pe = de.transaction((Lt = Se).length === 1 ? Lt[0] : Lt, "readonly");
                if (k.autoSchema) Dt = de, Ft = pe, (xt = S).verno = Dt.version / 10, Ft = xt._dbSchema = Io(0, Dt, Ft), xt._storeNames = M(Dt.objectStoreNames, 0), Kc(xt, [xt._allTables], u(Ft), Ft);
                else if (Xc(S, S._dbSchema, pe), ((Xt = Yc(Io(0, (Xt = S).idbdb, pe), Xt._dbSchema)).add.length || Xt.change.some(function(_e) {
                  return _e.add.length || _e.change.length;
                })) && !et) return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."), de.close(), Z = de.version + 1, et = !0, Rt(mt());
                Rs(S, pe);
              } catch {
              }
              kr.push(S), de.onversionchange = Fn(function(_e) {
                k.vcFired = !0, S.on("versionchange").fire(_e);
              }), de.onclose = Fn(function(_e) {
                S.on("close").fire(_e);
              }), gt && (Xt = S._deps, pe = wt, de = Xt.indexedDB, Xt = Xt.IDBKeyRange, Ul(de) || pe === na || Fo(de, Xt).put({ name: pe }).catch(Ot)), Rt();
            }, _t);
          }).catch(function(Rt) {
            switch (Rt == null ? void 0 : Rt.name) {
              case "UnknownError":
                if (0 < k.PR1398_maxLoop) return k.PR1398_maxLoop--, console.warn("Dexie: Workaround for Chrome UnknownError on open()"), mt();
                break;
              case "VersionError":
                if (0 < Z) return Z = 0, mt();
            }
            return Ce.reject(Rt);
          });
        }
        var bt, St = k.dbReadyResolve, At = null, gt = !1;
        return Ce.race([Y, (typeof navigator > "u" ? Ce.resolve() : !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(Rt) {
          function _t() {
            return indexedDB.databases().finally(Rt);
          }
          bt = setInterval(_t, 100), _t();
        }).finally(function() {
          return clearInterval(bt);
        }) : Promise.resolve()).then(mt)]).then(function() {
          return ut(), k.onReadyBeingFired = [], Ce.resolve(Yu(function() {
            return S.on.ready.fire(S.vip);
          })).then(function Rt() {
            if (0 < k.onReadyBeingFired.length) {
              var _t = k.onReadyBeingFired.reduce(ve, Ot);
              return k.onReadyBeingFired = [], Ce.resolve(Yu(function() {
                return _t(S.vip);
              })).then(Rt);
            }
          });
        }).finally(function() {
          k.openCanceller === Y && (k.onReadyBeingFired = null, k.isBeingOpened = !1);
        }).catch(function(Rt) {
          k.dbOpenError = Rt;
          try {
            At && At.abort();
          } catch {
          }
          return Y === k.openCanceller && S._close(), $e(Rt);
        }).finally(function() {
          k.openComplete = !0, St();
        }).then(function() {
          var Rt;
          return gt && (Rt = {}, S.tables.forEach(function(_t) {
            _t.schema.indexes.forEach(function(wt) {
              wt.name && (Rt["idb://".concat(S.name, "/").concat(_t.name, "/").concat(wt.name)] = new ur(-1 / 0, [[[]]]));
            }), Rt["idb://".concat(S.name, "/").concat(_t.name, "/")] = Rt["idb://".concat(S.name, "/").concat(_t.name, "/:dels")] = new ur(-1 / 0, [[[]]]);
          }), ra(so).fire(Rt), Qu(Rt, !0)), S;
        });
      }
      function Go(S) {
        function k(et) {
          return S.next(et);
        }
        var L = Z(k), Y = Z(function(et) {
          return S.throw(et);
        });
        function Z(et) {
          return function(bt) {
            var mt = et(bt), bt = mt.value;
            return mt.done ? bt : bt && typeof bt.then == "function" ? bt.then(L, Y) : h(bt) ? Promise.all(bt).then(L, Y) : L(bt);
          };
        }
        return Z(k)();
      }
      function rs(S, k, L) {
        for (var Y = h(S) ? S.slice() : [S], Z = 0; Z < L; ++Z) Y.push(k);
        return Y;
      }
      var tu = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(S) {
        return i(i({}, S), { table: function(k) {
          var L = S.table(k), Y = L.schema, Z = {}, et = [];
          function ut(gt, Rt, _t) {
            var wt = Ui(gt), Nt = Z[wt] = Z[wt] || [], xt = gt == null ? 0 : typeof gt == "string" ? 1 : gt.length, Dt = 0 < Rt, Dt = i(i({}, _t), { name: Dt ? "".concat(wt, "(virtual-from:").concat(_t.name, ")") : _t.name, lowLevelIndex: _t, isVirtual: Dt, keyTail: Rt, keyLength: xt, extractKey: is(gt), unique: !Dt && _t.unique });
            return Nt.push(Dt), Dt.isPrimaryKey || et.push(Dt), 1 < xt && ut(xt === 2 ? gt[0] : gt.slice(0, xt - 1), Rt + 1, _t), Nt.sort(function(Ft, Lt) {
              return Ft.keyTail - Lt.keyTail;
            }), Dt;
          }
          k = ut(Y.primaryKey.keyPath, 0, Y.primaryKey), Z[":id"] = [k];
          for (var mt = 0, bt = Y.indexes; mt < bt.length; mt++) {
            var St = bt[mt];
            ut(St.keyPath, 0, St);
          }
          function At(gt) {
            var Rt, _t = gt.query.index;
            return _t.isVirtual ? i(i({}, gt), { query: { index: _t.lowLevelIndex, range: (Rt = gt.query.range, _t = _t.keyTail, { type: Rt.type === 1 ? 2 : Rt.type, lower: rs(Rt.lower, Rt.lowerOpen ? S.MAX_KEY : S.MIN_KEY, _t), lowerOpen: !0, upper: rs(Rt.upper, Rt.upperOpen ? S.MIN_KEY : S.MAX_KEY, _t), upperOpen: !0 }) } }) : gt;
          }
          return i(i({}, L), { schema: i(i({}, Y), { primaryKey: k, indexes: et, getIndexByKeyPath: function(gt) {
            return (gt = Z[Ui(gt)]) && gt[0];
          } }), count: function(gt) {
            return L.count(At(gt));
          }, query: function(gt) {
            return L.query(At(gt));
          }, openCursor: function(gt) {
            var Rt = gt.query.index, _t = Rt.keyTail, wt = Rt.isVirtual, Nt = Rt.keyLength;
            return wt ? L.openCursor(At(gt)).then(function(Dt) {
              return Dt && xt(Dt);
            }) : L.openCursor(gt);
            function xt(Dt) {
              return Object.create(Dt, { continue: { value: function(Ft) {
                Ft != null ? Dt.continue(rs(Ft, gt.reverse ? S.MAX_KEY : S.MIN_KEY, _t)) : gt.unique ? Dt.continue(Dt.key.slice(0, Nt).concat(gt.reverse ? S.MIN_KEY : S.MAX_KEY, _t)) : Dt.continue();
              } }, continuePrimaryKey: { value: function(Ft, Lt) {
                Dt.continuePrimaryKey(rs(Ft, S.MAX_KEY, _t), Lt);
              } }, primaryKey: { get: function() {
                return Dt.primaryKey;
              } }, key: { get: function() {
                var Ft = Dt.key;
                return Nt === 1 ? Ft[0] : Ft.slice(0, Nt);
              } }, value: { get: function() {
                return Dt.value;
              } } });
            }
          } });
        } });
      } };
      function Ho(S, k, L, Y) {
        return L = L || {}, Y = Y || "", u(S).forEach(function(Z) {
          var et, ut, mt;
          v(k, Z) ? (et = S[Z], ut = k[Z], typeof et == "object" && typeof ut == "object" && et && ut ? (mt = I(et)) !== I(ut) ? L[Y + Z] = k[Z] : mt === "Object" ? Ho(et, ut, L, Y + Z + ".") : et !== ut && (L[Y + Z] = k[Z]) : et !== ut && (L[Y + Z] = k[Z])) : L[Y + Z] = void 0;
        }), u(k).forEach(function(Z) {
          v(S, Z) || (L[Y + Z] = k[Z]);
        }), L;
      }
      function as(S, k) {
        return k.type === "delete" ? k.keys : k.keys || k.values.map(S.extractKey);
      }
      var dr = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function(S) {
        return i(i({}, S), { table: function(k) {
          var L = S.table(k), Y = L.schema.primaryKey;
          return i(i({}, L), { mutate: function(Z) {
            var et = ne.trans, ut = et.table(k).hook, mt = ut.deleting, bt = ut.creating, St = ut.updating;
            switch (Z.type) {
              case "add":
                if (bt.fire === Ot) break;
                return et._promise("readwrite", function() {
                  return At(Z);
                }, !0);
              case "put":
                if (bt.fire === Ot && St.fire === Ot) break;
                return et._promise("readwrite", function() {
                  return At(Z);
                }, !0);
              case "delete":
                if (mt.fire === Ot) break;
                return et._promise("readwrite", function() {
                  return At(Z);
                }, !0);
              case "deleteRange":
                if (mt.fire === Ot) break;
                return et._promise("readwrite", function() {
                  return function gt(Rt, _t, wt) {
                    return L.query({ trans: Rt, values: !1, query: { index: Y, range: _t }, limit: wt }).then(function(Nt) {
                      var xt = Nt.result;
                      return At({ type: "delete", keys: xt, trans: Rt }).then(function(Dt) {
                        return 0 < Dt.numFailures ? Promise.reject(Dt.failures[0]) : xt.length < wt ? { failures: [], numFailures: 0, lastResult: void 0 } : gt(Rt, i(i({}, _t), { lower: xt[xt.length - 1], lowerOpen: !0 }), wt);
                      });
                    });
                  }(Z.trans, Z.range, 1e4);
                }, !0);
            }
            return L.mutate(Z);
            function At(gt) {
              var Rt, _t, wt, Nt = ne.trans, xt = gt.keys || as(Y, gt);
              if (!xt) throw new Error("Keys missing");
              return (gt = gt.type === "add" || gt.type === "put" ? i(i({}, gt), { keys: xt }) : i({}, gt)).type !== "delete" && (gt.values = s([], gt.values)), gt.keys && (gt.keys = s([], gt.keys)), Rt = L, wt = xt, ((_t = gt).type === "add" ? Promise.resolve([]) : Rt.getMany({ trans: _t.trans, keys: wt, cache: "immutable" })).then(function(Dt) {
                var Ft = xt.map(function(Lt, Xt) {
                  var de, Se, pe, _e = Dt[Xt], we = { onerror: null, onsuccess: null };
                  return gt.type === "delete" ? mt.fire.call(we, Lt, _e, Nt) : gt.type === "add" || _e === void 0 ? (de = bt.fire.call(we, Lt, gt.values[Xt], Nt), Lt == null && de != null && (gt.keys[Xt] = Lt = de, Y.outbound || q(gt.values[Xt], Y.keyPath, Lt))) : (de = Ho(_e, gt.values[Xt]), (Se = St.fire.call(we, de, Lt, _e, Nt)) && (pe = gt.values[Xt], Object.keys(Se).forEach(function(be) {
                    v(pe, be) ? pe[be] = Se[be] : q(pe, be, Se[be]);
                  }))), we;
                });
                return L.mutate(gt).then(function(Lt) {
                  for (var Xt = Lt.failures, de = Lt.results, Se = Lt.numFailures, Lt = Lt.lastResult, pe = 0; pe < xt.length; ++pe) {
                    var _e = (de || xt)[pe], we = Ft[pe];
                    _e == null ? we.onerror && we.onerror(Xt[pe]) : we.onsuccess && we.onsuccess(gt.type === "put" && Dt[pe] ? gt.values[pe] : _e);
                  }
                  return { failures: Xt, results: de, numFailures: Se, lastResult: Lt };
                }).catch(function(Lt) {
                  return Ft.forEach(function(Xt) {
                    return Xt.onerror && Xt.onerror(Lt);
                  }), Promise.reject(Lt);
                });
              });
            }
          } });
        } });
      } };
      function Ll(S, k, L) {
        try {
          if (!k || k.keys.length < S.length) return null;
          for (var Y = [], Z = 0, et = 0; Z < k.keys.length && et < S.length; ++Z) ln(k.keys[Z], S[et]) === 0 && (Y.push(L ? P(k.values[Z]) : k.values[Z]), ++et);
          return Y.length === S.length ? Y : null;
        } catch {
          return null;
        }
      }
      var Xd = { stack: "dbcore", level: -1, create: function(S) {
        return { table: function(k) {
          var L = S.table(k);
          return i(i({}, L), { getMany: function(Y) {
            if (!Y.cache) return L.getMany(Y);
            var Z = Ll(Y.keys, Y.trans._cache, Y.cache === "clone");
            return Z ? Ce.resolve(Z) : L.getMany(Y).then(function(et) {
              return Y.trans._cache = { keys: Y.keys, values: Y.cache === "clone" ? P(et) : et }, et;
            });
          }, mutate: function(Y) {
            return Y.type !== "add" && (Y.trans._cache = null), L.mutate(Y);
          } });
        } };
      } };
      function Ds(S, k) {
        return S.trans.mode === "readonly" && !!S.subscr && !S.trans.explicit && S.trans.db._options.cache !== "disabled" && !k.schema.primaryKey.outbound;
      }
      function Vl(S, k) {
        switch (S) {
          case "query":
            return k.values && !k.unique;
          case "get":
          case "getMany":
          case "count":
          case "openCursor":
            return !1;
        }
      }
      var Wd = { stack: "dbcore", level: 0, name: "Observability", create: function(S) {
        var k = S.schema.name, L = new ur(S.MIN_KEY, S.MAX_KEY);
        return i(i({}, S), { transaction: function(Y, Z, et) {
          if (ne.subscr && Z !== "readonly") throw new ft.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(ne.querier));
          return S.transaction(Y, Z, et);
        }, table: function(Y) {
          var Z = S.table(Y), et = Z.schema, ut = et.primaryKey, gt = et.indexes, mt = ut.extractKey, bt = ut.outbound, St = ut.autoIncrement && gt.filter(function(_t) {
            return _t.compound && _t.keyPath.includes(ut.keyPath);
          }), At = i(i({}, Z), { mutate: function(_t) {
            function wt(be) {
              return be = "idb://".concat(k, "/").concat(Y, "/").concat(be), Lt[be] || (Lt[be] = new ur());
            }
            var Nt, xt, Dt, Ft = _t.trans, Lt = _t.mutatedParts || (_t.mutatedParts = {}), Xt = wt(""), de = wt(":dels"), Se = _t.type, we = _t.type === "deleteRange" ? [_t.range] : _t.type === "delete" ? [_t.keys] : _t.values.length < 50 ? [as(ut, _t).filter(function(be) {
              return be;
            }), _t.values] : [], pe = we[0], _e = we[1], we = _t.trans._cache;
            return h(pe) ? (Xt.addKeys(pe), (we = Se === "delete" || pe.length === _e.length ? Ll(pe, we) : null) || de.addKeys(pe), (we || _e) && (Nt = wt, xt = we, Dt = _e, et.indexes.forEach(function(be) {
              var Ee = Nt(be.name || "");
              function Be(Ye) {
                return Ye != null ? be.extractKey(Ye) : null;
              }
              function qe(Ye) {
                return be.multiEntry && h(Ye) ? Ye.forEach(function(fr) {
                  return Ee.addKey(fr);
                }) : Ee.addKey(Ye);
              }
              (xt || Dt).forEach(function(Ye, yi) {
                var Ge = xt && Be(xt[yi]), yi = Dt && Be(Dt[yi]);
                ln(Ge, yi) !== 0 && (Ge != null && qe(Ge), yi != null && qe(yi));
              });
            }))) : pe ? (_e = { from: (_e = pe.lower) !== null && _e !== void 0 ? _e : S.MIN_KEY, to: (_e = pe.upper) !== null && _e !== void 0 ? _e : S.MAX_KEY }, de.add(_e), Xt.add(_e)) : (Xt.add(L), de.add(L), et.indexes.forEach(function(be) {
              return wt(be.name).add(L);
            })), Z.mutate(_t).then(function(be) {
              return !pe || _t.type !== "add" && _t.type !== "put" || (Xt.addKeys(be.results), St && St.forEach(function(Ee) {
                for (var Be = _t.values.map(function(Ge) {
                  return Ee.extractKey(Ge);
                }), qe = Ee.keyPath.findIndex(function(Ge) {
                  return Ge === ut.keyPath;
                }), Ye = 0, fr = be.results.length; Ye < fr; ++Ye) Be[Ye][qe] = be.results[Ye];
                wt(Ee.name).addKeys(Be);
              })), Ft.mutatedParts = Qc(Ft.mutatedParts || {}, Lt), be;
            });
          } }), gt = function(wt) {
            var Nt = wt.query, wt = Nt.index, Nt = Nt.range;
            return [wt, new ur((wt = Nt.lower) !== null && wt !== void 0 ? wt : S.MIN_KEY, (Nt = Nt.upper) !== null && Nt !== void 0 ? Nt : S.MAX_KEY)];
          }, Rt = { get: function(_t) {
            return [ut, new ur(_t.key)];
          }, getMany: function(_t) {
            return [ut, new ur().addKeys(_t.keys)];
          }, count: gt, query: gt, openCursor: gt };
          return u(Rt).forEach(function(_t) {
            At[_t] = function(wt) {
              var Nt = ne.subscr, xt = !!Nt, Dt = Ds(ne, Z) && Vl(_t, wt) ? wt.obsSet = {} : Nt;
              if (xt) {
                var Ft = function(_e) {
                  return _e = "idb://".concat(k, "/").concat(Y, "/").concat(_e), Dt[_e] || (Dt[_e] = new ur());
                }, Lt = Ft(""), Xt = Ft(":dels"), Nt = Rt[_t](wt), xt = Nt[0], Nt = Nt[1];
                if ((_t === "query" && xt.isPrimaryKey && !wt.values ? Xt : Ft(xt.name || "")).add(Nt), !xt.isPrimaryKey) {
                  if (_t !== "count") {
                    var de = _t === "query" && bt && wt.values && Z.query(i(i({}, wt), { values: !1 }));
                    return Z[_t].apply(this, arguments).then(function(_e) {
                      if (_t === "query") {
                        if (bt && wt.values) return de.then(function(Be) {
                          return Be = Be.result, Lt.addKeys(Be), _e;
                        });
                        var we = wt.values ? _e.result.map(mt) : _e.result;
                        (wt.values ? Lt : Xt).addKeys(we);
                      } else if (_t === "openCursor") {
                        var be = _e, Ee = wt.values;
                        return be && Object.create(be, { key: { get: function() {
                          return Xt.addKey(be.primaryKey), be.key;
                        } }, primaryKey: { get: function() {
                          var Be = be.primaryKey;
                          return Xt.addKey(Be), Be;
                        } }, value: { get: function() {
                          return Ee && Lt.addKey(be.primaryKey), be.value;
                        } } });
                      }
                      return _e;
                    });
                  }
                  Xt.add(L);
                }
              }
              return Z[_t].apply(this, arguments);
            };
          }), At;
        } });
      } };
      function eu(S, k, L) {
        if (L.numFailures === 0) return k;
        if (k.type === "deleteRange") return null;
        var Y = k.keys ? k.keys.length : "values" in k && k.values ? k.values.length : 1;
        return L.numFailures === Y ? null : (k = i({}, k), h(k.keys) && (k.keys = k.keys.filter(function(Z, et) {
          return !(et in L.failures);
        })), "values" in k && h(k.values) && (k.values = k.values.filter(function(Z, et) {
          return !(et in L.failures);
        })), k);
      }
      function nu(S, k) {
        return L = S, ((Y = k).lower === void 0 || (Y.lowerOpen ? 0 < ln(L, Y.lower) : 0 <= ln(L, Y.lower))) && (S = S, (k = k).upper === void 0 || (k.upperOpen ? ln(S, k.upper) < 0 : ln(S, k.upper) <= 0));
        var L, Y;
      }
      function Br(S, k, Rt, Y, Z, et) {
        if (!Rt || Rt.length === 0) return S;
        var ut = k.query.index, mt = ut.multiEntry, bt = k.query.range, St = Y.schema.primaryKey.extractKey, At = ut.extractKey, gt = (ut.lowLevelIndex || ut).extractKey, Rt = Rt.reduce(function(_t, wt) {
          var Nt = _t, xt = [];
          if (wt.type === "add" || wt.type === "put") for (var Dt = new ur(), Ft = wt.values.length - 1; 0 <= Ft; --Ft) {
            var Lt, Xt = wt.values[Ft], de = St(Xt);
            Dt.hasKey(de) || (Lt = At(Xt), (mt && h(Lt) ? Lt.some(function(be) {
              return nu(be, bt);
            }) : nu(Lt, bt)) && (Dt.addKey(de), xt.push(Xt)));
          }
          switch (wt.type) {
            case "add":
              var Se = new ur().addKeys(k.values ? _t.map(function(Ee) {
                return St(Ee);
              }) : _t), Nt = _t.concat(k.values ? xt.filter(function(Ee) {
                return Ee = St(Ee), !Se.hasKey(Ee) && (Se.addKey(Ee), !0);
              }) : xt.map(function(Ee) {
                return St(Ee);
              }).filter(function(Ee) {
                return !Se.hasKey(Ee) && (Se.addKey(Ee), !0);
              }));
              break;
            case "put":
              var pe = new ur().addKeys(wt.values.map(function(Ee) {
                return St(Ee);
              }));
              Nt = _t.filter(function(Ee) {
                return !pe.hasKey(k.values ? St(Ee) : Ee);
              }).concat(k.values ? xt : xt.map(function(Ee) {
                return St(Ee);
              }));
              break;
            case "delete":
              var _e = new ur().addKeys(wt.keys);
              Nt = _t.filter(function(Ee) {
                return !_e.hasKey(k.values ? St(Ee) : Ee);
              });
              break;
            case "deleteRange":
              var we = wt.range;
              Nt = _t.filter(function(Ee) {
                return !nu(St(Ee), we);
              });
          }
          return Nt;
        }, S);
        return Rt === S ? S : (Rt.sort(function(_t, wt) {
          return ln(gt(_t), gt(wt)) || ln(St(_t), St(wt));
        }), k.limit && k.limit < 1 / 0 && (Rt.length > k.limit ? Rt.length = k.limit : S.length === k.limit && Rt.length < k.limit && (Z.dirty = !0)), et ? Object.freeze(Rt) : Rt);
      }
      function Ko(S, k) {
        return ln(S.lower, k.lower) === 0 && ln(S.upper, k.upper) === 0 && !!S.lowerOpen == !!k.lowerOpen && !!S.upperOpen == !!k.upperOpen;
      }
      function Yo(S, k) {
        return function(L, Y, Z, et) {
          if (L === void 0) return Y !== void 0 ? -1 : 0;
          if (Y === void 0) return 1;
          if ((Y = ln(L, Y)) === 0) {
            if (Z && et) return 0;
            if (Z) return 1;
            if (et) return -1;
          }
          return Y;
        }(S.lower, k.lower, S.lowerOpen, k.lowerOpen) <= 0 && 0 <= function(L, Y, Z, et) {
          if (L === void 0) return Y !== void 0 ? 1 : 0;
          if (Y === void 0) return -1;
          if ((Y = ln(L, Y)) === 0) {
            if (Z && et) return 0;
            if (Z) return -1;
            if (et) return 1;
          }
          return Y;
        }(S.upper, k.upper, S.upperOpen, k.upperOpen);
      }
      function Yh(S, k, L, Y) {
        S.subscribers.add(L), Y.addEventListener("abort", function() {
          var Z, et;
          S.subscribers.delete(L), S.subscribers.size === 0 && (Z = S, et = k, setTimeout(function() {
            Z.subscribers.size === 0 && it(et, Z);
          }, 3e3));
        });
      }
      var iu = { stack: "dbcore", level: 0, name: "Cache", create: function(S) {
        var k = S.schema.name;
        return i(i({}, S), { transaction: function(L, Y, Z) {
          var et, ut, mt = S.transaction(L, Y, Z);
          return Y === "readwrite" && (ut = (et = new AbortController()).signal, Z = function(bt) {
            return function() {
              if (et.abort(), Y === "readwrite") {
                for (var St = /* @__PURE__ */ new Set(), At = 0, gt = L; At < gt.length; At++) {
                  var Rt = gt[At], _t = lo["idb://".concat(k, "/").concat(Rt)];
                  if (_t) {
                    var wt = S.table(Rt), Nt = _t.optimisticOps.filter(function(Ee) {
                      return Ee.trans === mt;
                    });
                    if (mt._explicit && bt && mt.mutatedParts) for (var xt = 0, Dt = Object.values(_t.queries.query); xt < Dt.length; xt++) for (var Ft = 0, Lt = (Se = Dt[xt]).slice(); Ft < Lt.length; Ft++) Zc((pe = Lt[Ft]).obsSet, mt.mutatedParts) && (it(Se, pe), pe.subscribers.forEach(function(Ee) {
                      return St.add(Ee);
                    }));
                    else if (0 < Nt.length) {
                      _t.optimisticOps = _t.optimisticOps.filter(function(Ee) {
                        return Ee.trans !== mt;
                      });
                      for (var Xt = 0, de = Object.values(_t.queries.query); Xt < de.length; Xt++) for (var Se, pe, _e, we = 0, be = (Se = de[Xt]).slice(); we < be.length; we++) (pe = be[we]).res != null && mt.mutatedParts && (bt && !pe.dirty ? (_e = Object.isFrozen(pe.res), _e = Br(pe.res, pe.req, Nt, wt, pe, _e), pe.dirty ? (it(Se, pe), pe.subscribers.forEach(function(Ee) {
                        return St.add(Ee);
                      })) : _e !== pe.res && (pe.res = _e, pe.promise = Ce.resolve({ result: _e }))) : (pe.dirty && it(Se, pe), pe.subscribers.forEach(function(Ee) {
                        return St.add(Ee);
                      })));
                    }
                  }
                }
                St.forEach(function(Ee) {
                  return Ee();
                });
              }
            };
          }, mt.addEventListener("abort", Z(!1), { signal: ut }), mt.addEventListener("error", Z(!1), { signal: ut }), mt.addEventListener("complete", Z(!0), { signal: ut })), mt;
        }, table: function(L) {
          var Y = S.table(L), Z = Y.schema.primaryKey;
          return i(i({}, Y), { mutate: function(et) {
            var ut = ne.trans;
            if (Z.outbound || ut.db._options.cache === "disabled" || ut.explicit || ut.idbtrans.mode !== "readwrite") return Y.mutate(et);
            var mt = lo["idb://".concat(k, "/").concat(L)];
            return mt ? (ut = Y.mutate(et), et.type !== "add" && et.type !== "put" || !(50 <= et.values.length || as(Z, et).some(function(bt) {
              return bt == null;
            })) ? (mt.optimisticOps.push(et), et.mutatedParts && $u(et.mutatedParts), ut.then(function(bt) {
              0 < bt.numFailures && (it(mt.optimisticOps, et), (bt = eu(0, et, bt)) && mt.optimisticOps.push(bt), et.mutatedParts && $u(et.mutatedParts));
            }), ut.catch(function() {
              it(mt.optimisticOps, et), et.mutatedParts && $u(et.mutatedParts);
            })) : ut.then(function(bt) {
              var St = eu(0, i(i({}, et), { values: et.values.map(function(At, gt) {
                var Rt;
                return bt.failures[gt] ? At : (At = (Rt = Z.keyPath) !== null && Rt !== void 0 && Rt.includes(".") ? P(At) : i({}, At), q(At, Z.keyPath, bt.results[gt]), At);
              }) }), bt);
              mt.optimisticOps.push(St), queueMicrotask(function() {
                return et.mutatedParts && $u(et.mutatedParts);
              });
            }), ut) : Y.mutate(et);
          }, query: function(et) {
            if (!Ds(ne, Y) || !Vl("query", et)) return Y.query(et);
            var ut = ((St = ne.trans) === null || St === void 0 ? void 0 : St.db._options.cache) === "immutable", gt = ne, mt = gt.requery, bt = gt.signal, St = function(wt, Nt, xt, Dt) {
              var Ft = lo["idb://".concat(wt, "/").concat(Nt)];
              if (!Ft) return [];
              if (!(Nt = Ft.queries[xt])) return [null, !1, Ft, null];
              var Lt = Nt[(Dt.query ? Dt.query.index.name : null) || ""];
              if (!Lt) return [null, !1, Ft, null];
              switch (xt) {
                case "query":
                  var Xt = Lt.find(function(de) {
                    return de.req.limit === Dt.limit && de.req.values === Dt.values && Ko(de.req.query.range, Dt.query.range);
                  });
                  return Xt ? [Xt, !0, Ft, Lt] : [Lt.find(function(de) {
                    return ("limit" in de.req ? de.req.limit : 1 / 0) >= Dt.limit && (!Dt.values || de.req.values) && Yo(de.req.query.range, Dt.query.range);
                  }), !1, Ft, Lt];
                case "count":
                  return Xt = Lt.find(function(de) {
                    return Ko(de.req.query.range, Dt.query.range);
                  }), [Xt, !!Xt, Ft, Lt];
              }
            }(k, L, "query", et), At = St[0], gt = St[1], Rt = St[2], _t = St[3];
            return At && gt ? At.obsSet = et.obsSet : (gt = Y.query(et).then(function(wt) {
              var Nt = wt.result;
              if (At && (At.res = Nt), ut) {
                for (var xt = 0, Dt = Nt.length; xt < Dt; ++xt) Object.freeze(Nt[xt]);
                Object.freeze(Nt);
              } else wt.result = P(Nt);
              return wt;
            }).catch(function(wt) {
              return _t && At && it(_t, At), Promise.reject(wt);
            }), At = { obsSet: et.obsSet, promise: gt, subscribers: /* @__PURE__ */ new Set(), type: "query", req: et, dirty: !1 }, _t ? _t.push(At) : (_t = [At], (Rt = Rt || (lo["idb://".concat(k, "/").concat(L)] = { queries: { query: {}, count: {} }, objs: /* @__PURE__ */ new Map(), optimisticOps: [], unsignaledParts: {} })).queries.query[et.query.index.name || ""] = _t)), Yh(At, _t, mt, bt), At.promise.then(function(wt) {
              return { result: Br(wt.result, et, Rt == null ? void 0 : Rt.optimisticOps, Y, At, ut) };
            });
          } });
        } });
      } };
      function Xo(S, k) {
        return new Proxy(S, { get: function(L, Y, Z) {
          return Y === "db" ? k : Reflect.get(L, Y, Z);
        } });
      }
      var xa = (ii.prototype.version = function(S) {
        if (isNaN(S) || S < 0.1) throw new ft.Type("Given version is not a positive number");
        if (S = Math.round(10 * S) / 10, this.idbdb || this._state.isBeingOpened) throw new ft.Schema("Cannot add version when database is open");
        this.verno = Math.max(this.verno, S);
        var k = this._versions, L = k.filter(function(Y) {
          return Y._cfg.version === S;
        })[0];
        return L || (L = new this.Version(S), k.push(L), k.sort(Bl), L.stores({}), this._state.autoSchema = !1, L);
      }, ii.prototype._whenReady = function(S) {
        var k = this;
        return this.idbdb && (this._state.openComplete || ne.letThrough || this._vip) ? S() : new Ce(function(L, Y) {
          if (k._state.openComplete) return Y(new ft.DatabaseClosed(k._state.dbOpenError));
          if (!k._state.isBeingOpened) {
            if (!k._state.autoOpen) return void Y(new ft.DatabaseClosed());
            k.open().catch(Ot);
          }
          k._state.dbReadyPromise.then(L, Y);
        }).then(S);
      }, ii.prototype.use = function(S) {
        var k = S.stack, L = S.create, Y = S.level, Z = S.name;
        return Z && this.unuse({ stack: k, name: Z }), S = this._middlewares[k] || (this._middlewares[k] = []), S.push({ stack: k, create: L, level: Y ?? 10, name: Z }), S.sort(function(et, ut) {
          return et.level - ut.level;
        }), this;
      }, ii.prototype.unuse = function(S) {
        var k = S.stack, L = S.name, Y = S.create;
        return k && this._middlewares[k] && (this._middlewares[k] = this._middlewares[k].filter(function(Z) {
          return Y ? Z.create !== Y : !!L && Z.name !== L;
        })), this;
      }, ii.prototype.open = function() {
        var S = this;
        return Ua(Te, function() {
          return ks(S);
        });
      }, ii.prototype._close = function() {
        var S = this._state, k = kr.indexOf(this);
        if (0 <= k && kr.splice(k, 1), this.idbdb) {
          try {
            this.idbdb.close();
          } catch {
          }
          this.idbdb = null;
        }
        S.isBeingOpened || (S.dbReadyPromise = new Ce(function(L) {
          S.dbReadyResolve = L;
        }), S.openCanceller = new Ce(function(L, Y) {
          S.cancelOpen = Y;
        }));
      }, ii.prototype.close = function(L) {
        var k = (L === void 0 ? { disableAutoOpen: !0 } : L).disableAutoOpen, L = this._state;
        k ? (L.isBeingOpened && L.cancelOpen(new ft.DatabaseClosed()), this._close(), L.autoOpen = !1, L.dbOpenError = new ft.DatabaseClosed()) : (this._close(), L.autoOpen = this._options.autoOpen || L.isBeingOpened, L.openComplete = !1, L.dbOpenError = null);
      }, ii.prototype.delete = function(S) {
        var k = this;
        S === void 0 && (S = { disableAutoOpen: !0 });
        var L = 0 < arguments.length && typeof arguments[0] != "object", Y = this._state;
        return new Ce(function(Z, et) {
          function ut() {
            k.close(S);
            var mt = k._deps.indexedDB.deleteDatabase(k.name);
            mt.onsuccess = Fn(function() {
              var bt, St, At;
              bt = k._deps, St = k.name, At = bt.indexedDB, bt = bt.IDBKeyRange, Ul(At) || St === na || Fo(At, bt).delete(St).catch(Ot), Z();
            }), mt.onerror = Cr(et), mt.onblocked = k._fireOnBlocked;
          }
          if (L) throw new ft.InvalidArgument("Invalid closeOptions argument to db.delete()");
          Y.isBeingOpened ? Y.dbReadyPromise.then(ut) : ut();
        });
      }, ii.prototype.backendDB = function() {
        return this.idbdb;
      }, ii.prototype.isOpen = function() {
        return this.idbdb !== null;
      }, ii.prototype.hasBeenClosed = function() {
        var S = this._state.dbOpenError;
        return S && S.name === "DatabaseClosed";
      }, ii.prototype.hasFailed = function() {
        return this._state.dbOpenError !== null;
      }, ii.prototype.dynamicallyOpened = function() {
        return this._state.autoSchema;
      }, Object.defineProperty(ii.prototype, "tables", { get: function() {
        var S = this;
        return u(this._allTables).map(function(k) {
          return S._allTables[k];
        });
      }, enumerable: !1, configurable: !0 }), ii.prototype.transaction = function() {
        var S = (function(k, L, Y) {
          var Z = arguments.length;
          if (Z < 2) throw new ft.InvalidArgument("Too few arguments");
          for (var et = new Array(Z - 1); --Z; ) et[Z - 1] = arguments[Z];
          return Y = et.pop(), [k, D(et), Y];
        }).apply(this, arguments);
        return this._transaction.apply(this, S);
      }, ii.prototype._transaction = function(S, k, L) {
        var Y = this, Z = ne.trans;
        Z && Z.db === this && S.indexOf("!") === -1 || (Z = null);
        var et, ut, mt = S.indexOf("?") !== -1;
        S = S.replace("!", "").replace("?", "");
        try {
          if (ut = k.map(function(St) {
            if (St = St instanceof Y.Table ? St.name : St, typeof St != "string") throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
            return St;
          }), S == "r" || S === es) et = es;
          else {
            if (S != "rw" && S != ia) throw new ft.InvalidArgument("Invalid transaction mode: " + S);
            et = ia;
          }
          if (Z) {
            if (Z.mode === es && et === ia) {
              if (!mt) throw new ft.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
              Z = null;
            }
            Z && ut.forEach(function(St) {
              if (Z && Z.storeNames.indexOf(St) === -1) {
                if (!mt) throw new ft.SubTransaction("Table " + St + " not included in parent transaction.");
                Z = null;
              }
            }), mt && Z && !Z.active && (Z = null);
          }
        } catch (St) {
          return Z ? Z._promise(null, function(At, gt) {
            gt(St);
          }) : $e(St);
        }
        var bt = (function St(At, gt, Rt, _t, wt) {
          return Ce.resolve().then(function() {
            var Nt = ne.transless || ne, xt = At._createTransaction(gt, Rt, At._dbSchema, _t);
            if (xt.explicit = !0, Nt = { trans: xt, transless: Nt }, _t) xt.idbtrans = _t.idbtrans;
            else try {
              xt.create(), xt.idbtrans._explicit = !0, At._state.PR1398_maxLoop = 3;
            } catch (Lt) {
              return Lt.name === ot.InvalidState && At.isOpen() && 0 < --At._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), At.close({ disableAutoOpen: !1 }), At.open().then(function() {
                return St(At, gt, Rt, null, wt);
              })) : $e(Lt);
            }
            var Dt, Ft = rt(wt);
            return Ft && ea(), Nt = Ce.follow(function() {
              var Lt;
              (Dt = wt.call(xt, xt)) && (Ft ? (Lt = ba.bind(null, null), Dt.then(Lt, Lt)) : typeof Dt.next == "function" && typeof Dt.throw == "function" && (Dt = Go(Dt)));
            }, Nt), (Dt && typeof Dt.then == "function" ? Ce.resolve(Dt).then(function(Lt) {
              return xt.active ? Lt : $e(new ft.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
            }) : Nt.then(function() {
              return Dt;
            })).then(function(Lt) {
              return _t && xt._resolve(), xt._completion.then(function() {
                return Lt;
              });
            }).catch(function(Lt) {
              return xt._reject(Lt), $e(Lt);
            });
          });
        }).bind(null, this, et, ut, Z, L);
        return Z ? Z._promise(et, bt, "lock") : ne.trans ? Ua(ne.transless, function() {
          return Y._whenReady(bt);
        }) : this._whenReady(bt);
      }, ii.prototype.table = function(S) {
        if (!v(this._allTables, S)) throw new ft.InvalidTable("Table ".concat(S, " does not exist"));
        return this._allTables[S];
      }, ii);
      function ii(S, k) {
        var L = this;
        this._middlewares = {}, this.verno = 0;
        var Y = ii.dependencies;
        this._options = k = i({ addons: ii.addons, autoOpen: !0, indexedDB: Y.indexedDB, IDBKeyRange: Y.IDBKeyRange, cache: "cloned" }, k), this._deps = { indexedDB: k.indexedDB, IDBKeyRange: k.IDBKeyRange }, Y = k.addons, this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
        var Z, et, ut, mt, bt, St = { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: Ot, dbReadyPromise: null, cancelOpen: Ot, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3, autoOpen: k.autoOpen };
        St.dbReadyPromise = new Ce(function(gt) {
          St.dbReadyResolve = gt;
        }), St.openCanceller = new Ce(function(gt, Rt) {
          St.cancelOpen = Rt;
        }), this._state = St, this.name = S, this.on = Ml(this, "populate", "blocked", "versionchange", "close", { ready: [ve, Ot] }), this.on.ready.subscribe = E(this.on.ready.subscribe, function(gt) {
          return function(Rt, _t) {
            ii.vip(function() {
              var wt, Nt = L._state;
              Nt.openComplete ? (Nt.dbOpenError || Ce.resolve().then(Rt), _t && gt(Rt)) : Nt.onReadyBeingFired ? (Nt.onReadyBeingFired.push(Rt), _t && gt(Rt)) : (gt(Rt), wt = L, _t || gt(function xt() {
                wt.on.ready.unsubscribe(Rt), wt.on.ready.unsubscribe(xt);
              }));
            });
          };
        }), this.Collection = (Z = this, Ms(Uo.prototype, function(Dt, xt) {
          this.db = Z;
          var _t = Fu, wt = null;
          if (xt) try {
            _t = xt();
          } catch (Ft) {
            wt = Ft;
          }
          var Nt = Dt._ctx, xt = Nt.table, Dt = xt.hook.reading.fire;
          this._ctx = { table: xt, index: Nt.index, isPrimKey: !Nt.index || xt.schema.primKey.keyPath && Nt.index === xt.schema.primKey.name, range: _t, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: wt, or: Nt.or, valueMapper: Dt !== ie ? Dt : null };
        })), this.Table = (et = this, Ms(Ir.prototype, function(gt, Rt, _t) {
          this.db = et, this._tx = _t, this.name = gt, this.schema = Rt, this.hook = et._allTables[gt] ? et._allTables[gt].hook : Ml(null, { creating: [se, Ot], reading: [ce, ie], updating: [ue, Ot], deleting: [re, Ot] });
        })), this.Transaction = (ut = this, Ms(Gc.prototype, function(gt, Rt, _t, wt, Nt) {
          var xt = this;
          this.db = ut, this.mode = gt, this.storeNames = Rt, this.schema = _t, this.chromeTransactionDurability = wt, this.idbtrans = null, this.on = Ml(this, "complete", "error", "abort"), this.parent = Nt || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new Ce(function(Dt, Ft) {
            xt._resolve = Dt, xt._reject = Ft;
          }), this._completion.then(function() {
            xt.active = !1, xt.on.complete.fire();
          }, function(Dt) {
            var Ft = xt.active;
            return xt.active = !1, xt.on.error.fire(Dt), xt.parent ? xt.parent._reject(Dt) : Ft && xt.idbtrans && xt.idbtrans.abort(), $e(Dt);
          });
        })), this.Version = (mt = this, Ms(Kh.prototype, function(gt) {
          this.db = mt, this._cfg = { version: gt, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
        })), this.WhereClause = (bt = this, Ms(Nl.prototype, function(gt, Rt, _t) {
          if (this.db = bt, this._ctx = { table: gt, index: Rt === ":id" ? null : Rt, or: _t }, this._cmp = this._ascending = ln, this._descending = function(wt, Nt) {
            return ln(Nt, wt);
          }, this._max = function(wt, Nt) {
            return 0 < ln(wt, Nt) ? wt : Nt;
          }, this._min = function(wt, Nt) {
            return ln(wt, Nt) < 0 ? wt : Nt;
          }, this._IDBKeyRange = bt._deps.IDBKeyRange, !this._IDBKeyRange) throw new ft.MissingAPI();
        })), this.on("versionchange", function(gt) {
          0 < gt.newVersion ? console.warn("Another connection wants to upgrade database '".concat(L.name, "'. Closing db now to resume the upgrade.")) : console.warn("Another connection wants to delete database '".concat(L.name, "'. Closing db now to resume the delete request.")), L.close({ disableAutoOpen: !1 });
        }), this.on("blocked", function(gt) {
          !gt.newVersion || gt.newVersion < gt.oldVersion ? console.warn("Dexie.delete('".concat(L.name, "') was blocked")) : console.warn("Upgrade '".concat(L.name, "' blocked by other connection holding version ").concat(gt.oldVersion / 10));
        }), this._maxKey = Lo(k.IDBKeyRange), this._createTransaction = function(gt, Rt, _t, wt) {
          return new L.Transaction(gt, Rt, _t, L._options.chromeTransactionDurability, wt);
        }, this._fireOnBlocked = function(gt) {
          L.on("blocked").fire(gt), kr.filter(function(Rt) {
            return Rt.name === L.name && Rt !== L && !Rt._state.vcFired;
          }).map(function(Rt) {
            return Rt.on("versionchange").fire(gt);
          });
        }, this.use(Xd), this.use(iu), this.use(Wd), this.use(tu), this.use(dr);
        var At = new Proxy(this, { get: function(gt, Rt, _t) {
          if (Rt === "_vip") return !0;
          if (Rt === "table") return function(Nt) {
            return Xo(L.table(Nt), At);
          };
          var wt = Reflect.get(gt, Rt, _t);
          return wt instanceof Ir ? Xo(wt, At) : Rt === "tables" ? wt.map(function(Nt) {
            return Xo(Nt, At);
          }) : Rt === "_createTransaction" ? function() {
            return Xo(wt.apply(this, arguments), At);
          } : wt;
        } });
        this.vip = At, Y.forEach(function(gt) {
          return gt(L);
        });
      }
      var Bs, hr = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable", ri = (Zu.prototype.subscribe = function(S, k, L) {
        return this._subscribe(S && typeof S != "function" ? S : { next: S, error: k, complete: L });
      }, Zu.prototype[hr] = function() {
        return this;
      }, Zu);
      function Zu(S) {
        this._subscribe = S;
      }
      try {
        Bs = { indexedDB: o.indexedDB || o.mozIndexedDB || o.webkitIndexedDB || o.msIndexedDB, IDBKeyRange: o.IDBKeyRange || o.webkitIDBKeyRange };
      } catch {
        Bs = { indexedDB: null, IDBKeyRange: null };
      }
      function Xh(S) {
        var k, L = !1, Y = new ri(function(Z) {
          var et = rt(S), ut, mt = !1, bt = {}, St = {}, At = { get closed() {
            return mt;
          }, unsubscribe: function() {
            mt || (mt = !0, ut && ut.abort(), gt && ra.storagemutated.unsubscribe(_t));
          } };
          Z.start && Z.start(At);
          var gt = !1, Rt = function() {
            return wi(wt);
          }, _t = function(Nt) {
            Qc(bt, Nt), Zc(St, bt) && Rt();
          }, wt = function() {
            var Nt, xt, Dt;
            !mt && Bs.indexedDB && (bt = {}, Nt = {}, ut && ut.abort(), ut = new AbortController(), Dt = function(Ft) {
              var Lt = gi();
              try {
                et && ea();
                var Xt = rn(S, Ft);
                return Xt = et ? Xt.finally(ba) : Xt;
              } finally {
                Lt && va();
              }
            }(xt = { subscr: Nt, signal: ut.signal, requery: Rt, querier: S, trans: null }), Promise.resolve(Dt).then(function(Ft) {
              L = !0, k = Ft, mt || xt.signal.aborted || (bt = {}, function(Lt) {
                for (var Xt in Lt) if (v(Lt, Xt)) return;
                return 1;
              }(St = Nt) || gt || (ra(so, _t), gt = !0), wi(function() {
                return !mt && Z.next && Z.next(Ft);
              }));
            }, function(Ft) {
              L = !1, ["DatabaseClosedError", "AbortError"].includes(Ft == null ? void 0 : Ft.name) || mt || wi(function() {
                mt || Z.error && Z.error(Ft);
              });
            }));
          };
          return setTimeout(Rt, 0), At;
        });
        return Y.hasValue = function() {
          return L;
        }, Y.getValue = function() {
          return k;
        }, Y;
      }
      var co = xa;
      function Wo(S) {
        var k = zs;
        try {
          zs = !0, ra.storagemutated.fire(S), Qu(S, !0);
        } finally {
          zs = k;
        }
      }
      x(co, i(i({}, Bt), { delete: function(S) {
        return new co(S, { addons: [] }).delete();
      }, exists: function(S) {
        return new co(S, { addons: [] }).open().then(function(k) {
          return k.close(), !0;
        }).catch("NoSuchDatabaseError", function() {
          return !1;
        });
      }, getDatabaseNames: function(S) {
        try {
          return k = co.dependencies, L = k.indexedDB, k = k.IDBKeyRange, (Ul(L) ? Promise.resolve(L.databases()).then(function(Y) {
            return Y.map(function(Z) {
              return Z.name;
            }).filter(function(Z) {
              return Z !== na;
            });
          }) : Fo(L, k).toCollection().primaryKeys()).then(S);
        } catch {
          return $e(new ft.MissingAPI());
        }
        var k, L;
      }, defineClass: function() {
        return function(S) {
          f(this, S);
        };
      }, ignoreTransaction: function(S) {
        return ne.trans ? Ua(ne.transless, S) : S();
      }, vip: Yu, async: function(S) {
        return function() {
          try {
            var k = Go(S.apply(this, arguments));
            return k && typeof k.then == "function" ? k : Ce.resolve(k);
          } catch (L) {
            return $e(L);
          }
        };
      }, spawn: function(S, k, L) {
        try {
          var Y = Go(S.apply(L, k || []));
          return Y && typeof Y.then == "function" ? Y : Ce.resolve(Y);
        } catch (Z) {
          return $e(Z);
        }
      }, currentTransaction: { get: function() {
        return ne.trans || null;
      } }, waitFor: function(S, k) {
        return k = Ce.resolve(typeof S == "function" ? co.ignoreTransaction(S) : S).timeout(k || 6e4), ne.trans ? ne.trans.waitFor(k) : k;
      }, Promise: Ce, debug: { get: function() {
        return Re;
      }, set: function(S) {
        oe(S);
      } }, derive: T, extend: f, props: x, override: E, Events: Ml, on: ra, liveQuery: Xh, extendObservabilitySet: Qc, getByKeyPath: U, setByKeyPath: q, delByKeyPath: function(S, k) {
        typeof k == "string" ? q(S, k, void 0) : "length" in k && [].map.call(k, function(L) {
          q(S, L, void 0);
        });
      }, shallowClone: j, deepClone: P, getObjectDiff: Ho, cmp: ln, asap: N, minKey: -1 / 0, addons: [], connections: kr, errnames: ot, dependencies: Bs, cache: lo, semVer: "4.0.11", version: "4.0.11".split(".").map(function(S) {
        return parseInt(S);
      }).reduce(function(S, k, L) {
        return S + k / Math.pow(10, 2 * L);
      }) })), co.maxKey = Lo(co.dependencies.IDBKeyRange), typeof dispatchEvent < "u" && typeof addEventListener < "u" && (ra(so, function(S) {
        zs || (S = new CustomEvent(qc, { detail: S }), zs = !0, dispatchEvent(S), zs = !1);
      }), addEventListener(qc, function(S) {
        S = S.detail, zs || Wo(S);
      }));
      var aa, zs = !1, zr = function() {
      };
      return typeof BroadcastChannel < "u" && ((zr = function() {
        (aa = new BroadcastChannel(qc)).onmessage = function(S) {
          return S.data && Wo(S.data);
        };
      })(), typeof aa.unref == "function" && aa.unref(), ra(so, function(S) {
        zs || aa.postMessage(S);
      })), typeof addEventListener < "u" && (addEventListener("pagehide", function(S) {
        if (!xa.disableBfCache && S.persisted) {
          Re && console.debug("Dexie: handling persisted pagehide"), aa != null && aa.close();
          for (var k = 0, L = kr; k < L.length; k++) L[k].close({ disableAutoOpen: !1 });
        }
      }), addEventListener("pageshow", function(S) {
        !xa.disableBfCache && S.persisted && (Re && console.debug("Dexie: handling persisted pageshow"), zr(), Wo({ all: new ur(-1 / 0, [[]]) }));
      })), Ce.rejectionMapper = function(S, k) {
        return !S || S instanceof ct || S instanceof TypeError || S instanceof SyntaxError || !S.name || !Tt[S.name] ? S : (k = new Tt[S.name](k || S.message, S), "stack" in S && _(k, "stack", { get: function() {
          return this.inner.stack;
        } }), k);
      }, oe(Re), i(xa, Object.freeze({ __proto__: null, Dexie: xa, liveQuery: Xh, Entity: Gd, cmp: ln, PropModification: ns, replacePrefix: function(S, k) {
        return new ns({ replacePrefix: [S, k] });
      }, add: function(S) {
        return new ns({ add: S });
      }, remove: function(S) {
        return new ns({ remove: S });
      }, default: xa, RangeSet: ur, mergeRanges: Os, rangesOverlap: Yd }), { default: xa }), xa;
    });
  }(Yy)), Yy.exports;
}
var SU = _U();
const g2 = /* @__PURE__ */ lp(SU), Wx = Symbol.for("Dexie"), x1 = globalThis[Wx] || (globalThis[Wx] = g2);
if (g2.semVer !== x1.semVer)
  throw new Error(`Two different versions of Dexie loaded in the same app: ${g2.semVer} and ${x1.semVer}`);
const {
  liveQuery: jV,
  mergeRanges: LV,
  rangesOverlap: VV,
  RangeSet: IV,
  cmp: FV,
  Entity: qV,
  PropModification: GV,
  replacePrefix: HV,
  add: KV,
  remove: YV
} = x1;
class xU extends x1 {
  constructor() {
    super("BeatGenDB");
    Qe(this, "audioFiles");
    Qe(this, "midiFiles");
    Qe(this, "drumMachineFiles");
    this.version(1).stores({
      audioFiles: "++id, name, type, createdAt, updatedAt, *tags",
      midiFiles: "++id, name, type, trackId, createdAt, updatedAt, *tags",
      drumMachineFiles: "++id, name, trackId, createdAt, updatedAt, *tags"
    }), console.log("🗄️ Database initialized:", this.name);
  }
  logOperation(n, i) {
    const s = (/* @__PURE__ */ new Date()).toISOString();
    console.log(`🗄️ [${s}] ${n}:`, i);
  }
  async logDbState() {
    const n = await this.audioFiles.count(), i = await this.midiFiles.count();
    console.log("📊 Current DB State:", {
      audioFiles: n,
      midiFiles: i
    });
  }
  // Utility function to create file metadata
  createFileMetadata(n, i = {}) {
    const s = {
      name: n.name,
      type: n.type,
      size: n.size,
      data: n,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date(),
      ...i
    };
    return this.logOperation("Creating file metadata", {
      name: s.name,
      type: s.type,
      size: s.size,
      additionalData: i
    }), s;
  }
  // Audio File Operations
  async addAudioFile(n, i) {
    this.logOperation("Adding audio file", {
      name: n.name,
      type: n.type,
      size: n.size,
      duration: i
    });
    const s = this.createFileMetadata(n, { duration: i }), o = await this.audioFiles.add(s);
    return await this.logDbState(), o;
  }
  async getAudioFile(n) {
    this.logOperation("Getting audio file", { id: n });
    const i = await this.audioFiles.get(n);
    return this.logOperation("Retrieved audio file", {
      id: n,
      found: !!i,
      name: i == null ? void 0 : i.name
    }), i;
  }
  async getAllAudioFiles() {
    this.logOperation("Getting all audio files", {});
    const n = await this.audioFiles.toArray();
    return this.logOperation("Retrieved all audio files", {
      count: n.length,
      names: n.map((i) => i.name)
    }), n;
  }
  async updateAudioFile(n, i) {
    this.logOperation("Updating audio file", { id: n, updates: i }), i.updatedAt = /* @__PURE__ */ new Date();
    const s = await this.audioFiles.update(n, i);
    return this.logOperation("Updated audio file", { id: n, success: s > 0 }), await this.logDbState(), s;
  }
  async deleteAudioFile(n) {
    this.logOperation("Deleting audio file", { id: n }), await this.audioFiles.delete(n), await this.logDbState();
  }
  // MIDI File Operations
  async addMidiFile(n, i, s) {
    this.logOperation("Adding MIDI file", {
      name: n.name,
      type: n.type,
      size: n.size,
      tempo: i,
      timeSignature: s
    });
    const o = this.createFileMetadata(n, { tempo: i, timeSignature: s }), u = await this.midiFiles.add(o);
    return await this.logDbState(), u;
  }
  async getMidiFile(n) {
    this.logOperation("Getting MIDI file", { id: n });
    const i = await this.midiFiles.get(n);
    return this.logOperation("Retrieved MIDI file", {
      id: n,
      found: !!i,
      name: i == null ? void 0 : i.name
    }), i;
  }
  async getAllMidiFiles() {
    this.logOperation("Getting all MIDI files", {});
    const n = await this.midiFiles.toArray();
    return this.logOperation("Retrieved all MIDI files", {
      count: n.length,
      names: n.map((i) => i.name)
    }), n;
  }
  async updateMidiFile(n, i) {
    this.logOperation("Updating MIDI file", { id: n, updates: i }), i.updatedAt = /* @__PURE__ */ new Date();
    const s = await this.midiFiles.update(n, i);
    return this.logOperation("Updated MIDI file", { id: n, success: s > 0 }), await this.logDbState(), s;
  }
  async deleteMidiFile(n) {
    this.logOperation("Deleting MIDI file", { id: n }), await this.midiFiles.delete(n), await this.logDbState();
  }
  // Track-specific MIDI operations
  // Store a MIDI blob for a specific track
  async storeMidiTrackBlob(n, i, s, o, u, h) {
    this.logOperation("Storing MIDI track blob", {
      trackId: n,
      name: i,
      size: s.size,
      bpm: o,
      timeSignature: u
    });
    const f = await this.midiFiles.where("trackId").equals(n).first(), p = `${u[0]}/${u[1]}`;
    if (f)
      return await this.midiFiles.update(f.id, {
        data: s,
        type: "audio/midi",
        size: s.size,
        tempo: o,
        timeSignature: p,
        updatedAt: /* @__PURE__ */ new Date(),
        instrumentId: h
      }), this.logOperation("Updated existing MIDI track", {
        trackId: n,
        fileId: f.id
      }), await this.logDbState(), f.id;
    {
      const g = {
        name: i,
        trackId: n,
        data: s,
        type: "audio/midi",
        size: s.size,
        tempo: o,
        timeSignature: p,
        instrumentId: h,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }, v = await this.midiFiles.add(g);
      return this.logOperation("Created new MIDI track record", {
        trackId: n,
        fileId: v
      }), await this.logDbState(), v;
    }
  }
  // Get MIDI blob for a specific track
  async getMidiTrackBlob(n) {
    this.logOperation("Getting MIDI track blob", { trackId: n });
    const i = await this.midiFiles.where("trackId").equals(n).first();
    return i ? (this.logOperation("Found MIDI track blob", {
      trackId: n,
      fileId: i.id,
      size: i.size
    }), i.data) : (this.logOperation("MIDI track blob not found", { trackId: n }), null);
  }
  // Check if a track has a MIDI file
  async hasMidiTrack(n) {
    return await this.midiFiles.where("trackId").equals(n).count() > 0;
  }
  // Delete MIDI file for a specific track
  async deleteMidiTrack(n) {
    this.logOperation("Deleting MIDI track", { trackId: n }), await this.midiFiles.where("trackId").equals(n).delete(), this.logOperation("Deleted MIDI track", { trackId: n }), await this.logDbState();
  }
  // Search Operations
  async searchAudioFiles(n) {
    this.logOperation("Searching audio files", { query: n });
    const i = await this.audioFiles.where("name").startsWithIgnoreCase(n).or("tags").anyOfIgnoreCase(n).toArray();
    return this.logOperation("Search results for audio files", {
      query: n,
      count: i.length,
      names: i.map((s) => s.name)
    }), i;
  }
  async searchMidiFiles(n) {
    this.logOperation("Searching MIDI files", { query: n });
    const i = await this.midiFiles.where("name").startsWithIgnoreCase(n).or("tags").anyOfIgnoreCase(n).toArray();
    return this.logOperation("Search results for MIDI files", {
      query: n,
      count: i.length,
      names: i.map((s) => s.name)
    }), i;
  }
  // Utility function to get audio duration
  async getAudioDuration(n) {
    return this.logOperation("Getting audio duration", { name: n.name }), new Promise((i, s) => {
      const o = new Audio(), u = URL.createObjectURL(n);
      o.addEventListener("loadedmetadata", () => {
        URL.revokeObjectURL(u), this.logOperation("Got audio duration", {
          name: n.name,
          duration: o.duration
        }), i(o.duration);
      }), o.addEventListener("error", () => {
        URL.revokeObjectURL(u), this.logOperation("Error getting audio duration", {
          name: n.name,
          error: o.error
        }), s(new Error("Error loading audio file"));
      }), o.src = u;
    });
  }
  // Database cleanup
  async clearAllFiles() {
    this.logOperation("Clearing all files from database", {});
    try {
      await this.transaction("rw", this.audioFiles, this.midiFiles, async () => {
        await this.audioFiles.clear(), await this.midiFiles.clear();
      }), this.logOperation("Successfully cleared all files", {}), await this.logDbState();
    } catch (n) {
      throw this.logOperation("Failed to clear files", { error: n }), n;
    }
  }
  // Drum Machine Operations
  async addDrumMachineTrack(n, i = "Drum Machine") {
    this.logOperation("Adding drum machine track", {
      name: i,
      trackId: n
    });
    const s = {
      name: i,
      trackId: n,
      beatsPerMeasure: 4,
      // Default to 4/4 time
      stepsPerBeat: 4,
      // Default to 16th notes
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date()
    }, o = await this.drumMachineFiles.add(s);
    return await this.logDbState(), o;
  }
  async getDrumMachineTrack(n) {
    this.logOperation("Getting drum machine track", { id: n });
    const i = await this.drumMachineFiles.get(n);
    return this.logOperation("Retrieved drum machine track", {
      id: n,
      found: !!i,
      name: i == null ? void 0 : i.name
    }), i;
  }
  async getAllDrumMachineTracks() {
    this.logOperation("Getting all drum machine tracks", {});
    const n = await this.drumMachineFiles.toArray();
    return this.logOperation("Retrieved all drum machine tracks", {
      count: n.length,
      names: n.map((i) => i.name)
    }), n;
  }
  async updateDrumMachineTrack(n, i) {
    this.logOperation("Updating drum machine track", { id: n, updates: i }), i.updatedAt = /* @__PURE__ */ new Date();
    const s = await this.drumMachineFiles.update(n, i);
    return this.logOperation("Updated drum machine track", { id: n, success: s > 0 }), await this.logDbState(), s;
  }
  async deleteDrumMachineTrack(n) {
    this.logOperation("Deleting drum machine track", { id: n }), await this.drumMachineFiles.delete(n), await this.logDbState();
  }
}
const wm = new xU();
class TU {
  constructor() {
    Qe(this, "activePlayback", /* @__PURE__ */ new Map());
    Qe(this, "tracks", /* @__PURE__ */ new Map());
    Qe(this, "subscribers", /* @__PURE__ */ new Map());
    // Track metadata
    Qe(this, "currentBpm", 120);
    Qe(this, "currentTimeSignature", [4, 4]);
    // Debouncing for persistence operations
    Qe(this, "pendingUpdates", /* @__PURE__ */ new Map());
    Qe(this, "debounceTime", 500);
  }
  // 500ms debounce time
  async loadMidiFile(t) {
    var o, u, h;
    const n = await t.arrayBuffer(), i = new Yx.Midi(n);
    return {
      tracks: i.tracks.map((f) => ({
        id: Sb(),
        instrumentId: f.instrument.name || "default",
        notes: f.notes.map((p) => ({
          id: Date.now(),
          row: p.midi,
          // MIDI note number
          column: Math.floor(p.time * 4),
          // Convert time to grid columns (assuming quarter notes)
          length: Math.floor(p.duration * 4),
          // Convert duration to grid units
          velocity: p.velocity,
          duration: p.duration,
          time: p.time
        })),
        name: f.name
      })),
      bpm: ((o = i.header.tempos[0]) == null ? void 0 : o.bpm) || 120,
      timeSignature: [
        ((u = i.header.timeSignatures[0]) == null ? void 0 : u.timeSignature[0]) || 4,
        ((h = i.header.timeSignatures[0]) == null ? void 0 : h.timeSignature[1]) || 4
      ]
    };
  }
  createMidiFile(t) {
    const n = new Yx.Midi();
    return n.header.setTempo(t.bpm), n.header.timeSignatures.push({
      ticks: 0,
      timeSignature: t.timeSignature
    }), t.tracks.forEach((i) => {
      const s = n.addTrack();
      i.notes.forEach((o) => {
        s.addNote({
          midi: o.row,
          time: o.time,
          duration: o.duration,
          velocity: o.velocity
        });
      });
    }), new Blob([n.toArray()], { type: "audio/midi" });
  }
  midiToNotes(t) {
    return t.tracks.flatMap(
      (n) => n.notes.map((i) => ({
        id: i.id,
        row: i.row,
        column: i.column,
        length: i.length
      }))
    );
  }
  notesToMidi(t, n) {
    return {
      tracks: [{
        id: Sb(),
        instrumentId: "default",
        notes: t.map((s) => ({
          ...s,
          velocity: 0.8,
          // Default velocity
          duration: s.length / 4,
          // Convert grid units to seconds
          time: s.column / 4
          // Convert grid units to seconds
        }))
      }],
      bpm: n,
      timeSignature: this.currentTimeSignature
      // Use current time signature
    };
  }
  createTrack(t, n) {
    const i = Sb();
    return this.tracks.set(i, []), {
      id: i,
      instrumentId: t,
      notes: [],
      name: n
    };
  }
  // Subscribe to track updates
  subscribeToTrack(t, n) {
    this.subscribers.has(t) || this.subscribers.set(t, []);
    const i = this.subscribers.get(t) || [];
    return i.push(n), this.subscribers.set(t, i), () => {
      const s = this.subscribers.get(t) || [];
      this.subscribers.set(
        t,
        s.filter((o) => o !== n)
      );
    };
  }
  // Get notes for a track
  getNotesForTrack(t) {
    return this.tracks.get(t) || [];
  }
  schedulePlayback(t) {
    this.stopPlayback(t.id);
    const n = new _1((i, s) => {
      Lh.schedule(() => {
      }, i);
    }, t.notes.map((i) => [i.time, i]));
    n.start(0), this.activePlayback.set(t.id, n);
  }
  stopPlayback(t) {
    const n = this.activePlayback.get(t);
    n && (n.dispose(), this.activePlayback.delete(t));
  }
  // BPM and time signature methods
  /**
   * Set the current BPM
   */
  setBpm(t) {
    this.currentBpm = t;
  }
  /**
   * Set the current time signature
   */
  setTimeSignature(t) {
    this.currentTimeSignature = t;
  }
  /**
   * Get the current BPM
   */
  getBpm() {
    return this.currentBpm;
  }
  /**
   * Get the current time signature
   */
  getTimeSignature() {
    return this.currentTimeSignature;
  }
  // INTEGRATED PERSISTENCE METHODS
  /**
   * Create track with persistence
   */
  async createTrackWithPersistence(t, n = `Trackkeeee ${t}`) {
    const i = this.createTrack(t, n);
    try {
      await this.createMidiFileForTrack(
        i.id,
        n,
        t,
        this.currentBpm,
        this.currentTimeSignature
      ), console.log(`MidiManager: Created persisted track ${i.id}`);
    } catch (s) {
      console.error(`MidiManager: Error creating persisted track ${i.id}:`, s);
    }
    return i;
  }
  /**
   * Update track notes and persist to DB
   */
  updateTrack(t, n) {
    console.log(`MidiManager.updateTrack: Updating track ${t} with ${n.length} notes`), this.tracks.set(t, [...n]), this.notifyTrackSubscribers(t, n), this.debouncePersistence(t, n);
  }
  /**
   * Add a single note to a track
   */
  async addNoteToTrack(t, n) {
    console.log(`MidiManager.addNoteToTrack: Adding note to track ${t}`, n);
    const s = [...this.getNotesForTrack(t), n];
    this.updateTrack(t, s);
  }
  /**
   * Remove a single note from a track by its ID
   */
  async removeNoteFromTrack(t, n) {
    console.log(`MidiManager.removeNoteFromTrack: Removing note ${n} from track ${t}`);
    const s = this.getNotesForTrack(t).filter((o) => o.id !== n);
    this.updateTrack(t, s);
  }
  /**
   * Update a single note in a track
   */
  async updateNote(t, n) {
    console.log(`MidiManager.updateNote: Updating note ${n.id} in track ${t}`);
    const s = this.getNotesForTrack(t).map(
      (o) => o.id === n.id ? n : o
    );
    this.updateTrack(t, s);
  }
  /**
   * Notify all subscribers for a specific track
   * Extracted to follow DRY principles
   */
  notifyTrackSubscribers(t, n) {
    this.subscribers.has(t) && (this.subscribers.get(t) || []).forEach((s) => s(t, n));
  }
  /**
   * Debounce persistence operations to reduce DB load
   */
  debouncePersistence(t, n) {
    this.pendingUpdates.has(t) && clearTimeout(this.pendingUpdates.get(t));
    const i = this.tracks.get(t) ? `Tracko ${t}` : `Trackee ${t}`, s = setTimeout(async () => {
      try {
        await this.updateMidiFileForTrack(
          t,
          n,
          this.currentBpm,
          this.currentTimeSignature,
          i
        ), this.pendingUpdates.delete(t);
      } catch (o) {
        console.error(`MidiManager: Error persisting track ${t}:`, o), this.pendingUpdates.delete(t);
      }
    }, this.debounceTime);
    this.pendingUpdates.set(t, s);
  }
  /**
   * Load track data from DB
   */
  async loadTrackFromDB(t) {
    try {
      console.log(`MidiManager: Loading track ${t} from DB`);
      const n = await wm.getMidiTrackBlob(t);
      if (!n)
        return console.log(`MidiManager: No MIDI file found for track ${t}`), [];
      const i = new File([n], `track_${t}.mid`, { type: "audio/midi" }), s = await this.loadMidiFile(i), o = this.midiToNotes(s);
      return o && o.length > 0 && (this.tracks.set(t, o), console.log(`MidiManager: Loaded ${o.length} notes for track ${t} from DB`)), o;
    } catch (n) {
      return console.error(`MidiManager: Error loading track ${t} from DB:`, n), [];
    }
  }
  /**
   * Delete track with persistence cleanup
   */
  async deleteTrackWithPersistence(t) {
    this.tracks.delete(t), this.subscribers.delete(t), this.stopPlayback(t);
    try {
      this.pendingUpdates.has(t) && (clearTimeout(this.pendingUpdates.get(t)), this.pendingUpdates.delete(t)), await wm.deleteMidiTrack(t), console.log(`MidiManager: Deleted persisted track ${t}`);
    } catch (n) {
      console.error(`MidiManager: Error deleting persisted track ${t}:`, n);
    }
  }
  /**
   * Create initial MIDI file for a track
   */
  async createMidiFileForTrack(t, n, i, s, o) {
    try {
      console.log(`MidiManager: Creating MIDI file for track ${t}`);
      const u = this.notesToMidi([], s);
      u.timeSignature = o;
      const h = this.createMidiFile(u);
      await wm.storeMidiTrackBlob(t, n, h, s, o, i), console.log(`MidiManager: Created MIDI file for track ${t}`);
    } catch (u) {
      throw console.error(`MidiManager: Error creating MIDI file for track ${t}:`, u), u;
    }
  }
  /**
   * Update MIDI file for a track
   */
  async updateMidiFileForTrack(t, n, i, s, o = "Midi Track") {
    try {
      console.log(`MidiManager: Updating MIDI file for track ${t} with ${n.length} notes`);
      const u = this.notesToMidi(n, i);
      u.timeSignature = s;
      const h = this.createMidiFile(u);
      await wm.storeMidiTrackBlob(t, o, h, i, s), console.log(`MidiManager: Updated MIDI file for track ${t}`);
    } catch (u) {
      throw console.error(`MidiManager: Error updating MIDI file for track ${t}:`, u), u;
    }
  }
  /**
   * Export MIDI file from DB
   */
  async exportMidiFileFromDB(t) {
    try {
      console.log(`MidiManager: Exporting track ${t} from DB`);
      const n = await wm.getMidiTrackBlob(t);
      if (n)
        return n;
      const i = this.getNotesForTrack(t);
      if (i.length > 0) {
        console.log(`MidiManager: Creating MIDI export from ${i.length} in-memory notes`);
        const s = this.notesToMidi(i, this.currentBpm);
        return this.createMidiFile(s);
      }
      return console.warn(`MidiManager: No data found for track ${t} to export`), null;
    } catch (n) {
      return console.error(`MidiManager: Error exporting track ${t}:`, n), null;
    }
  }
}
class CU {
  constructor() {
    Qe(this, "instruments", /* @__PURE__ */ new Map());
  }
  async createInstrument(t) {
    let n;
    switch (t.type) {
      case "synth":
        n = new V_(sp, {
          ...t.settings
        }).toDestination();
        break;
      case "sampler":
        n = new a0({
          ...t.settings
        }).toDestination();
        break;
      case "custom":
        throw new Error("Custom instruments not implemented yet");
      default:
        throw new Error(`Unknown instrument type: ${t.type}`);
    }
    const i = {
      id: t.id,
      config: t,
      toneInstrument: n
    };
    return this.instruments.set(t.id, i), i;
  }
  deleteInstrument(t) {
    const n = this.instruments.get(t);
    n && (n.toneInstrument.dispose(), this.instruments.delete(t));
  }
  getInstrument(t) {
    return this.instruments.get(t);
  }
  playNote(t, n, i, s) {
    const o = this.instruments.get(t);
    if (!o) return;
    const u = Rx(n, "midi").toFrequency();
    i ? o.toneInstrument.triggerAttackRelease([u], i, s) : o.toneInstrument.triggerAttack([u], s);
  }
  stopNote(t, n, i) {
    const s = this.instruments.get(t);
    if (!s) return;
    const o = Rx(n, "midi").toFrequency();
    s.toneInstrument.triggerRelease([o], i);
  }
  updateInstrumentSettings(t, n) {
    const i = this.instruments.get(t);
    i && Object.entries(n).forEach(([s, o]) => {
      typeof i.toneInstrument.set == "function" && i.toneInstrument.set({ [s]: o });
    });
  }
  dispose() {
    this.instruments.forEach((t) => {
      t.toneInstrument.dispose();
    }), this.instruments.clear();
  }
}
class wU {
  // Track change listeners
  constructor() {
    Qe(this, "audioEngine");
    Qe(this, "projectManager");
    Qe(this, "transportController");
    Qe(this, "initialized", !1);
    Qe(this, "midiManager");
    Qe(this, "instrumentManager");
    Qe(this, "_tracks", []);
    // Array of tracks
    Qe(this, "_listeners", []);
    this.audioEngine = S1.getInstance(), this.projectManager = new eU(), this.transportController = new p2(), this.midiManager = new TU(), this.instrumentManager = new CU();
    const t = this.projectManager.getCurrentProject();
    t && (this.midiManager.setBpm(t.tempo), this.midiManager.setTimeSignature(t.timeSignature)), this.initialized = !0;
  }
  async initializeAudio() {
    if (!this.initialized)
      try {
        await this.audioEngine.initialize(), this.initialized = !0, this.syncTracksFromProjectManager();
      } catch (t) {
        throw console.error("Store: Audio initialization failed:", t), t;
      }
  }
  /**
   * Synchronize tracks from ProjectManager to our internal tracks array
   */
  syncTracksFromProjectManager() {
    const t = this.projectManager.getCurrentProject();
    t && (console.log("Synchronizing tracks from ProjectManager..."), t.tracks.forEach((n) => {
      this.addTrackToInternalState(n);
    }), console.log(`Total tracks after sync: ${this._tracks.length}`));
  }
  getTransport() {
    return this.transportController;
  }
  async createTrack(t, n, i) {
    if (!this.initialized)
      throw new Error("Store must be initialized before creating tracks");
    const s = i ? this.projectManager.addTrackWithProperties({
      id: i.id,
      name: t,
      type: n,
      volume: i.volume,
      pan: i.pan,
      muted: i.muted,
      soloed: i.soloed
    }) : this.projectManager.addTrack(t, n);
    if (n === "midi" || n === "drum")
      try {
        const o = this.projectManager.getCurrentProject();
        o && (this.midiManager.setBpm(o.tempo), await this.midiManager.createTrackWithPersistence(
          s.id,
          // Always use the track ID (whether new or existing)
          t
        ), console.log(i ? `Store: Using existing ${n} track ID: ${s.id} for persistence` : `Store: Created persisted ${n} track: ${s.id}`));
      } catch (o) {
        console.error(`Store: Error creating persisted ${n} track:`, o);
      }
    return this.addTrackToInternalState(s), s;
  }
  /**
   * Add a track to the internal _tracks array
   */
  addTrackToInternalState(t) {
    if (this._tracks.some((i) => i.id === t.id))
      return;
    const n = new Nu().toDestination();
    this._tracks.push({
      id: t.id,
      name: t.name,
      type: t.type,
      muted: t.muted,
      soloed: t.soloed,
      volume: t.volume,
      pan: t.pan,
      channel: n,
      position: { x: 0, y: this._tracks.length * 40 },
      // Default position
      drumPads: t.type === "drum" ? [] : void 0
    }), console.log(`Added track ${t.id} of type ${t.type} to internal state`), this._notifyListeners();
  }
  async loadAudioFile(t, n) {
    await this.transportController.loadAudioFile(t, n);
  }
  async removeTrack(t) {
    const n = this._tracks.find((i) => i.id === t);
    n && (n.type === "midi" || n.type === "drum") && await this.midiManager.deleteTrackWithPersistence(t), this.projectManager.removeTrack(t), this._tracks = this._tracks.filter((i) => i.id !== t), this.audioEngine.removeTrack(t), this._notifyListeners();
  }
  getAudioEngine() {
    return this.audioEngine;
  }
  getInstrumentManager() {
    return this.instrumentManager;
  }
  getMidiManager() {
    return this.midiManager;
  }
  /**
   * Add a listener for track changes
   */
  addListener(t) {
    this._listeners.push(t);
  }
  /**
   * Remove a listener
   */
  removeListener(t) {
    const n = this._listeners.indexOf(t);
    n !== -1 && this._listeners.splice(n, 1);
  }
  /**
   * Notify all listeners of changes
   */
  _notifyListeners() {
    this._listeners.forEach((t) => t());
  }
  /**
   * Gets the track with the specified ID
   */
  getTrackById(t) {
    return this._tracks.find((n) => n.id === t);
  }
  /**
   * Gets the drum pads for a track
   */
  getDrumPads(t) {
    const n = this._tracks.find((i) => i.id === t);
    return !n || n.type !== "drum" ? [] : (n.drumPads || (n.drumPads = []), n.drumPads);
  }
  /**
   * Toggles a drum pad on/off
   */
  toggleDrumPad(t, n, i) {
    console.log(`Store.toggleDrumPad called for track ${t}, column ${n}, row ${i}`);
    const s = this.getTrackById(t);
    if (!s || s.type !== "drum") {
      console.warn(`Cannot toggle drum pad: Track ${t} not found or not a drum track`);
      return;
    }
    s.drumPads || (s.drumPads = []);
    const o = s.drumPads.findIndex(
      (u) => u.column === n && u.row === i
    );
    o >= 0 ? (s.drumPads.splice(o, 1), console.log(`Removed drum pad at column ${n}, row ${i} for track ${t}`)) : (s.drumPads.push({
      row: i,
      column: n,
      velocity: 100
      // Default velocity
    }), console.log(`Added drum pad at column ${n}, row ${i} for track ${t}`)), console.log(`Drum pads for track ${t}: ${s.drumPads.length}`), this._notifyListeners();
  }
}
class EU {
  constructor(t, n, i, s, o) {
    Qe(this, "type", "TRACK_VOLUME_CHANGE");
    this.store = t, this.trackId = n, this.oldVolume = i, this.newVolume = s, this.updateTrackVolume = o;
  }
  async execute() {
    this.updateTrackVolume(this.trackId, this.newVolume), console.log("🔄 Execute TrackVolumeChangeAction:", {
      trackId: this.trackId,
      from: this.oldVolume,
      to: this.newVolume
    });
  }
  async undo() {
    this.updateTrackVolume(this.trackId, this.oldVolume), console.log("↩️ Undo TrackVolumeChangeAction:", {
      trackId: this.trackId,
      from: this.newVolume,
      to: this.oldVolume
    });
  }
}
class AU {
  constructor(t, n, i, s, o) {
    Qe(this, "type", "TRACK_PAN_CHANGE");
    this.store = t, this.trackId = n, this.oldPan = i, this.newPan = s, this.updateTrackPan = o;
  }
  async execute() {
    this.updateTrackPan(this.trackId, this.newPan), console.log("🔄 Execute TrackPanChangeAction:", {
      trackId: this.trackId,
      from: this.oldPan,
      to: this.newPan
    });
  }
  async undo() {
    this.updateTrackPan(this.trackId, this.oldPan), console.log("↩️ Undo TrackPanChangeAction:", {
      trackId: this.trackId,
      from: this.newPan,
      to: this.oldPan
    });
  }
}
class MU {
  constructor(t, n, i, s, o, u) {
    Qe(this, "type", "TRACK_POSITION_CHANGE");
    this.store = t, this.trackId = n, this.oldPosition = i, this.newPosition = s, this.updateTrackPosition = o, this.isPlaying = u;
  }
  async execute() {
    var n, i;
    this.updateTrackPosition(this.trackId, this.newPosition), this.store.getAudioEngine().setTrackPosition(
      this.trackId,
      this.newPosition.x,
      this.newPosition.y
    );
    const t = this.store.getTransport().isPlaying;
    t && (console.log("Playback active during execute - syncing track with transport"), (i = (n = this.store.getTransport()).handleTrackPositionChange) == null || i.call(n, this.trackId, this.newPosition.x)), console.log("🔄 Execute TrackPositionChangeAction:", {
      trackId: this.trackId,
      from: this.oldPosition,
      to: this.newPosition,
      isCurrentlyPlaying: t
    });
  }
  async undo() {
    var n, i;
    this.updateTrackPosition(this.trackId, this.oldPosition), this.store.getAudioEngine().setTrackPosition(
      this.trackId,
      this.oldPosition.x,
      this.oldPosition.y
    );
    const t = this.store.getTransport().isPlaying;
    t && (console.log("Playback active during undo - syncing track with transport"), (i = (n = this.store.getTransport()).handleTrackPositionChange) == null || i.call(n, this.trackId, this.oldPosition.x)), console.log("↩️ Undo TrackPositionChangeAction:", {
      trackId: this.trackId,
      from: this.newPosition,
      to: this.oldPosition,
      isCurrentlyPlaying: t
    });
  }
}
class RU {
  constructor(t, n, i, s, o, u) {
    Qe(this, "type", "BPM_CHANGE");
    this.store = t, this.oldBpm = n, this.newBpm = i, this.setBpm = s, this.setTracks = o, this.timeSignature = u;
  }
  updateBPM(t) {
    Lh.bpm.value = t, this.setBpm(t), this.setTracks(
      (n) => n.map((i) => i.duration ? {
        ...i,
        _calculatedWidth: o1(i.duration, t, this.timeSignature)
      } : i)
    );
  }
  async execute() {
    this.updateBPM(this.newBpm), console.log("🔄 Execute BPMChangeAction:", { from: this.oldBpm, to: this.newBpm });
  }
  async undo() {
    this.updateBPM(this.oldBpm), console.log("↩️ Undo BPMChangeAction:", { from: this.newBpm, to: this.oldBpm });
  }
}
class OU {
  constructor(t, n, i, s, o, u) {
    Qe(this, "type", "TIME_SIGNATURE_CHANGE");
    this.store = t, this.oldTimeSignature = n, this.newTimeSignature = i, this.setTimeSignature = s, this.setTracks = o, this.bpm = u;
  }
  updateTimeSignature(t) {
    const [n, i] = t;
    Lh.timeSignature = t, this.setTimeSignature(n, i), this.setTracks(
      (s) => s.map((o) => o.duration ? {
        ...o,
        _calculatedWidth: o1(o.duration, this.bpm, t)
      } : o)
    );
  }
  async execute() {
    this.updateTimeSignature(this.newTimeSignature), console.log("🔄 Execute TimeSignatureChangeAction:", {
      from: this.oldTimeSignature,
      to: this.newTimeSignature
    });
  }
  async undo() {
    this.updateTimeSignature(this.oldTimeSignature), console.log("↩️ Undo TimeSignatureChangeAction:", {
      from: this.newTimeSignature,
      to: this.oldTimeSignature
    });
  }
}
class NU {
  constructor(t, n, i, s) {
    Qe(this, "type", "KEY_SIGNATURE_CHANGE");
    this.store = t, this.oldKeySignature = n, this.newKeySignature = i, this.setKeySignature = s;
  }
  async execute() {
    this.setKeySignature(this.newKeySignature), this.store.projectManager && typeof this.store.projectManager.setKey == "function" && this.store.projectManager.setKey(this.newKeySignature), console.log("🔄 Execute KeySignatureChangeAction:", {
      from: this.oldKeySignature,
      to: this.newKeySignature
    });
  }
  async undo() {
    this.setKeySignature(this.oldKeySignature), this.store.projectManager && typeof this.store.projectManager.setKey == "function" && this.store.projectManager.setKey(this.oldKeySignature), console.log("↩️ Undo KeySignatureChangeAction:", {
      from: this.newKeySignature,
      to: this.oldKeySignature
    });
  }
}
class $x {
  constructor(t, n, i, s) {
    Qe(this, "type", "TRACK_ADD");
    this.store = t, this.trackData = n, this.addTrack = i, this.removeTrack = s;
  }
  async execute() {
    this.addTrack(this.trackData), this.trackData.type === "audio" && this.trackData.audioFile && (console.log("Reloading audio file for track during redo:", this.trackData.id), await this.store.loadAudioFile(this.trackData.id, this.trackData.audioFile)), this.store.getAudioEngine().setTrackVolume(this.trackData.id, this.trackData.volume), this.store.getAudioEngine().setTrackPan(this.trackData.id, this.trackData.pan), this.trackData.muted && this.store.getAudioEngine().setTrackMute(this.trackData.id, !0), this.store.getAudioEngine().setTrackPosition(
      this.trackData.id,
      this.trackData.position.x,
      this.trackData.position.y
    );
    const t = this.store.getTransport().isPlaying;
    t && (console.log("Playback is active - syncing newly added track with transport"), setTimeout(() => {
      this.store.getTransport().handleTrackPositionChange(
        this.trackData.id,
        this.trackData.position.x
      );
    }, 10)), console.log("🔄 Execute TrackAddAction:", {
      trackId: this.trackData.id,
      name: this.trackData.name,
      type: this.trackData.type,
      isPlaying: t
    });
  }
  async undo() {
    this.removeTrack(this.trackData.id), console.log("↩️ Undo TrackAddAction:", {
      trackId: this.trackData.id,
      name: this.trackData.name
    });
  }
}
class kU {
  constructor(t, n, i, s) {
    Qe(this, "type", "TRACK_DELETE");
    this.store = t, this.trackData = n, this.addTrack = i, this.removeTrack = s;
  }
  async execute() {
    this.removeTrack(this.trackData.id), console.log("🔄 Execute TrackDeleteAction:", {
      trackId: this.trackData.id,
      name: this.trackData.name
    });
  }
  async undo() {
    this.addTrack(this.trackData), this.trackData.type === "audio" && this.trackData.audioFile && await this.store.loadAudioFile(this.trackData.id, this.trackData.audioFile), this.store.getAudioEngine().setTrackPosition(
      this.trackData.id,
      this.trackData.position.x,
      this.trackData.position.y
    ), this.trackData.muted && this.store.getAudioEngine().setTrackMute(this.trackData.id, !0), this.trackData.soloed && this.store.getAudioEngine().setTrackSolo(this.trackData.id, !0), this.store.getAudioEngine().setTrackVolume(this.trackData.id, this.trackData.volume), this.store.getAudioEngine().setTrackPan(this.trackData.id, this.trackData.pan);
    const t = this.store.getTransport().isPlaying;
    t && (console.log("Playback active during undo of delete - syncing restored track with transport"), this.store.getTransport().handleTrackPositionChange(
      this.trackData.id,
      this.trackData.position.x
    )), console.log("↩️ Undo TrackDeleteAction:", {
      trackId: this.trackData.id,
      name: this.trackData.name,
      isPlaying: t
    });
  }
}
const op = uN((e, t) => ({
  // Default State
  store: new wU(),
  isInitialized: !1,
  isPlaying: !1,
  currentTime: 0,
  projectTitle: "Untitled Project",
  bpm: 120,
  timeSignature: [4, 4],
  keySignature: "C major",
  // Default key signature is C major
  tracks: [],
  zoomLevel: 1,
  measureCount: 40,
  // Initial number of measures
  canUndo: !1,
  canRedo: !1,
  addMenuAnchor: null,
  // Actions for state updates
  setStore: (n) => e({ store: n }),
  setIsInitialized: (n) => e({ isInitialized: n }),
  setIsPlaying: (n) => e({ isPlaying: n }),
  setCurrentTime: (n) => e({ currentTime: n }),
  setProjectTitle: (n) => {
    e({ projectTitle: n });
    const { store: i } = t();
    i && i.projectManager.getCurrentProject() && i.projectManager.setProjectName(n);
  },
  setBpm: (n) => {
    const i = t().bpm;
    if (i === n) return;
    e({ bpm: n });
    const { store: s, timeSignature: o } = t();
    if (s) {
      s.projectManager.setTempo(n), Lh.bpm.value = n;
      const u = new RU(
        s,
        i,
        n,
        (h) => e({ bpm: h }),
        (h) => e((f) => ({ tracks: h(f.tracks) })),
        o
      );
      Cn.executeAction(u).then(() => {
        e({
          canUndo: Cn.canUndo(),
          canRedo: Cn.canRedo()
        });
      });
    }
  },
  setTimeSignature: (n, i) => {
    const s = t().timeSignature, o = [n, i];
    if (s[0] === n && s[1] === i) return;
    e({ timeSignature: o });
    const { store: u, bpm: h } = t();
    if (u) {
      u.projectManager.setTimeSignature(n, i), Lh.timeSignature = o;
      const f = new OU(
        u,
        s,
        o,
        (p, g) => e({ timeSignature: [p, g] }),
        (p) => e((g) => ({ tracks: p(g.tracks) })),
        h
      );
      Cn.executeAction(f).then(() => {
        e({
          canUndo: Cn.canUndo(),
          canRedo: Cn.canRedo()
        });
      });
    }
  },
  setKeySignature: (n) => {
    const i = t().keySignature;
    if (i === n) return;
    e({ keySignature: n });
    const { store: s } = t();
    if (s) {
      const o = new NU(
        s,
        i,
        n,
        (u) => e({ keySignature: u })
      );
      Cn.executeAction(o).then(() => {
        e({
          canUndo: Cn.canUndo(),
          canRedo: Cn.canRedo()
        });
      });
    }
  },
  setTracks: (n) => e({ tracks: n }),
  setZoomLevel: (n) => e({ zoomLevel: n }),
  setMeasureCount: (n) => e({ measureCount: n }),
  setCanUndo: (n) => e({ canUndo: n }),
  setCanRedo: (n) => e({ canRedo: n }),
  setAddMenuAnchor: (n) => e({ addMenuAnchor: n }),
  // Core initialization
  initializeAudio: async () => {
    const { store: n, projectTitle: i } = t();
    if (n)
      try {
        if (!n.projectManager.getCurrentProject()) {
          console.log("Creating a new project");
          const s = n.projectManager.createProject(i);
          console.log("Project created:", s);
        }
        await n.initializeAudio(), e({ isInitialized: !0 }), window.storeInstance = n, console.log("Audio engine initialized");
      } catch (s) {
        console.error("Failed to initialize audio:", s), e({ isInitialized: !1 });
      }
  },
  // Track operations with history support
  handleTrackVolumeChange: (n, i) => {
    const { store: s, tracks: o } = t();
    if (!s) return;
    const u = o.find((p) => p.id === n);
    if (!u) {
      console.error(`Track with ID ${n} not found in handleTrackVolumeChange`);
      return;
    }
    const h = u.volume;
    if (h === i) return;
    const f = new EU(
      s,
      n,
      h,
      i,
      // Direct update function that bypasses history
      (p, g) => {
        const { tracks: v } = t();
        e({
          tracks: v.map((x) => x.id === p ? { ...x, volume: g } : x)
        }), s.getAudioEngine().setTrackVolume(p, g);
      }
    );
    Cn.executeAction(f).then(() => {
      e({
        canUndo: Cn.canUndo(),
        canRedo: Cn.canRedo()
      });
    });
  },
  handleTrackPanChange: (n, i) => {
    const { store: s, tracks: o } = t();
    if (!s) return;
    const u = o.find((p) => p.id === n);
    if (!u) {
      console.error(`Track with ID ${n} not found in handleTrackPanChange`);
      return;
    }
    const h = u.pan;
    if (h === i) return;
    const f = new AU(
      s,
      n,
      h,
      i,
      // Direct update function that bypasses history
      (p, g) => {
        const { tracks: v } = t();
        e({
          tracks: v.map((x) => x.id === p ? { ...x, pan: g } : x)
        }), s.getAudioEngine().setTrackPan(p, g), console.log(`History manager updated track ${p} pan to:`, g);
      }
    );
    Cn.executeAction(f).then(() => {
      e({
        canUndo: Cn.canUndo(),
        canRedo: Cn.canRedo()
      });
    });
  },
  handleTrackMuteToggle: (n, i) => {
    const { store: s, tracks: o } = t();
    if (!s) return;
    const u = o.map(
      (h) => h.id === n ? { ...h, muted: i } : h
    );
    e({ tracks: u }), s.getAudioEngine().setTrackMute(n, i);
  },
  handleTrackSoloToggle: (n, i) => {
    const { store: s, tracks: o } = t();
    if (!s) return;
    const u = o.map(
      (f) => f.id === n ? { ...f, soloed: i } : f
    );
    e({ tracks: u }), u.some((f) => f.soloed) ? u.forEach((f) => {
      const p = !f.soloed;
      f.muted !== p && s.getAudioEngine().setTrackMute(f.id, p);
    }) : u.forEach((f) => {
      s.getAudioEngine().setTrackMute(f.id, f.muted);
    });
  },
  handleTrackDelete: async (n) => {
    const { store: i, tracks: s } = t();
    if (i)
      try {
        const o = s.find((f) => f.id === n);
        if (!o) {
          console.error(`Track with ID ${n} not found for deletion`);
          return;
        }
        const u = { ...o }, h = new kU(
          i,
          u,
          // Add track callback
          (f) => {
            console.log("History: Re-adding deleted track:", f.id), e((p) => ({ tracks: [...p.tracks, f] }));
          },
          // Remove track callback
          (f) => {
            console.log("History: Removing track:", f), e((p) => ({ tracks: p.tracks.filter((g) => g.id !== f) })), i.getAudioEngine().removeTrack(f);
          }
        );
        await Cn.executeAction(h), e({
          canUndo: Cn.canUndo(),
          canRedo: Cn.canRedo()
        }), console.log(`Track ${n} deleted successfully (with history support)`);
      } catch (o) {
        console.error(`Failed to delete track ${n}:`, o);
      }
  },
  handleAddTrack: async (n) => {
    const { store: i, isInitialized: s, tracks: o, timeSignature: u, bpm: h } = t();
    if (!i || !s) {
      console.warn("Store not initialized");
      return;
    }
    try {
      let f;
      n === "midi" ? f = `MIDI Track ${o.length + 1}` : n === "drum" ? f = "Drum Machine" : f = `Audio Track ${o.length + 1}`;
      const p = await i.createTrack(f, n), g = await i.getAudioEngine().createTrack(p.id, p.name), _ = 4 * u[0] * 60 / h, T = {
        x: 0,
        y: o.length * bn.trackHeight
        // Use the proper track height from constants
      }, A = {
        ...p,
        ...g,
        position: T,
        duration: _,
        type: n,
        _calculatedWidth: o1(_, h, u)
      };
      i.getAudioEngine().setTrackPosition(
        A.id,
        T.x,
        T.y
      );
      const O = new $x(
        i,
        A,
        // Add track callback
        (M) => {
          console.log("History: Adding track:", M.id), e((E) => ({ tracks: [...E.tracks, M] }));
        },
        // Remove track callback
        (M) => {
          console.log("History: Removing track:", M), e((E) => ({ tracks: E.tracks.filter((R) => R.id !== M) })), i.getAudioEngine().removeTrack(M);
        }
      );
      await Cn.executeAction(O), e({
        canUndo: Cn.canUndo(),
        canRedo: Cn.canRedo()
      }), console.log(`Added new ${n} track (with history support):`, A);
    } catch (f) {
      console.error(`Failed to create ${n} track:`, f);
    }
  },
  handleTrackPositionChange: (n, i, s) => {
    var g, v;
    const { store: o, tracks: u, isPlaying: h } = t();
    if (!o) return;
    const f = u.find((x) => x.id === n);
    if (!f || s && f.position.x === i.x && f.position.y === i.y)
      return;
    const p = u.map(
      (x) => x.id === n ? { ...x, position: i } : x
    );
    if (e({ tracks: p }), o.getAudioEngine().setTrackPosition(
      n,
      i.x,
      i.y
    ), s) {
      const x = { ...f.position }, b = new MU(
        o,
        n,
        x,
        i,
        // Direct update function that bypasses history
        (_, T) => {
          var O, M;
          const { tracks: A } = t();
          e({
            tracks: A.map((E) => E.id === _ ? { ...E, position: T } : E)
          }), o.getAudioEngine().setTrackPosition(_, T.x, T.y), h && ((M = (O = o.getTransport()).handleTrackPositionChange) == null || M.call(O, _, T.x)), console.log(`History manager updated track ${_} position to:`, T);
        },
        h
      );
      Cn.executeAction(b).then(() => {
        e({
          canUndo: Cn.canUndo(),
          canRedo: Cn.canRedo()
        });
      }), h && ((v = (g = o.getTransport()).handleTrackPositionChange) == null || v.call(g, n, i.x)), console.log(`Track ${n} repositioned to:`, i);
    }
  },
  uploadAudioFile: async (n) => {
    var h, f;
    const { store: i, tracks: s, bpm: o, timeSignature: u } = t();
    if (!(!i || !t().isInitialized))
      try {
        const p = n.name.split(".")[0], g = await i.createTrack(p, "audio");
        await i.loadAudioFile(g.id, n);
        const v = i.getAudioEngine().getAllTracks().find((T) => T.id === g.id);
        if (!v) throw new Error("Failed to get created audio track");
        const x = ((f = (h = v.player) == null ? void 0 : h.buffer) == null ? void 0 : f.duration) || 0, b = {
          ...g,
          ...v,
          position: {
            x: 0,
            y: s.length * bn.trackHeight
            // Use the proper track height from constants
          },
          duration: x,
          audioFile: n,
          type: "audio",
          _calculatedWidth: o1(x, o, u)
        };
        i.getAudioEngine().setTrackPosition(
          b.id,
          b.position.x,
          b.position.y
        );
        const _ = new $x(
          i,
          b,
          // Add track callback
          (T) => {
            console.log("History: Adding audio file track:", T.id), e((A) => ({ tracks: [...A.tracks, T] })), T.audioFile && i.loadAudioFile(T.id, T.audioFile).catch((A) => {
              console.error("Failed to reload audio file during redo:", A);
            });
          },
          // Remove track callback
          (T) => {
            console.log("History: Removing audio file track:", T), e((A) => ({ tracks: A.tracks.filter((O) => O.id !== T) })), i.getAudioEngine().removeTrack(T);
          }
        );
        await Cn.executeAction(_), e({
          canUndo: Cn.canUndo(),
          canRedo: Cn.canRedo()
        }), console.log("Added audio track from file (with history support):", b);
      } catch (p) {
        console.error("Failed to upload audio file:", p);
      }
  },
  handleTrackNameChange: (n, i) => {
    const { store: s, tracks: o } = t();
    if (!s) return;
    const u = o.map(
      (h) => h.id === n ? { ...h, name: i } : h
    );
    e({ tracks: u }), s.getAudioEngine().setTrackName(n, i);
  },
  // Transport actions
  playPause: async () => {
    const { store: n, isPlaying: i } = t();
    if (n)
      try {
        i ? (console.log("🎮 UI: Triggering pause"), n.getTransport().pause(), e({ isPlaying: !1 })) : (console.log("🎮 UI: Triggering play"), await n.getTransport().play(), e({ isPlaying: !0 }));
      } catch (s) {
        console.error("Playback control failed:", s), e({ isPlaying: !1 });
      }
  },
  stop: () => {
    const { store: n } = t();
    n && (console.log("🎮 UI: Triggering stop"), n.getTransport().stop(), e({
      isPlaying: !1,
      currentTime: 0
    }));
  },
  seekToPosition: (n) => {
    const { store: i } = t();
    i && (i.getTransport().setPosition(n), e({ currentTime: n }));
  },
  // History actions for undo/redo
  undo: async () => {
    Cn.canUndo() ? (console.log("🔄 Performing undo operation"), await Cn.undo(), e({
      canUndo: Cn.canUndo(),
      canRedo: Cn.canRedo()
    })) : console.log("⚠️ No actions to undo");
  },
  redo: async () => {
    Cn.canRedo() ? (console.log("🔄 Performing redo operation"), await Cn.redo(), e({
      canUndo: Cn.canUndo(),
      canRedo: Cn.canRedo()
    })) : console.log("⚠️ No actions to redo");
  }
})), H6 = tt.createContext(null), DU = ({ children: e }) => {
  const [t, n] = tt.useState(null), [i, s] = tt.useState({}), [o, u] = tt.useState({}), { store: h } = op(), T = {
    activePianoRoll: t,
    openedPianoRolls: i,
    notesByTrack: o,
    openPianoRoll: (A) => {
      console.log("Opening piano roll for track:", A), n(A), s((O) => ({ ...O, [A]: !0 })), o[A] || (console.log("Initializing notes array for track:", A), u((O) => ({ ...O, [A]: [] }))), console.log("Piano roll state after opening:", {
        activePianoRoll: A,
        openedPianoRolls: { ...i, [A]: !0 },
        notesByTrack: o
      });
    },
    closePianoRoll: (A) => {
      s((O) => ({ ...O, [A]: !1 })), t === A && n(null);
    },
    createNote: async (A, O) => {
      if (!h) return;
      const M = o[A] || [], E = { ...O, trackId: A }, R = new rN(
        h,
        (N) => {
          u((U) => {
            const q = { ...U };
            return q[A] = N, q;
          });
        },
        E,
        M
      );
      await Cn.executeAction(R);
    },
    moveNote: async (A, O, M, E) => {
      if (!h) return;
      const R = o[A] || [], N = new aN(
        h,
        (U) => {
          u((q) => {
            const j = { ...q };
            return j[A] = U, j;
          });
        },
        O,
        M,
        E,
        R
      );
      await Cn.executeAction(N);
    },
    resizeNote: async (A, O, M, E, R, N) => {
      if (!h) return;
      const U = o[A] || [], q = new sN(
        h,
        (j) => {
          u((V) => {
            const D = { ...V };
            return D[A] = j, D;
          });
        },
        O,
        M,
        E,
        U,
        R,
        N
      );
      await Cn.executeAction(q);
    },
    playPreview: (A) => {
      var M, E;
      if (!h || !t) return;
      const O = (M = h.getTrackById) == null ? void 0 : M.call(h, t);
      O && ((E = h.getInstrumentManager()) == null || E.playNote(O.instrumentId || "default", A));
    },
    stopPreview: (A) => {
      var M, E;
      if (!h || !t) return;
      const O = (M = h.getTrackById) == null ? void 0 : M.call(h, t);
      O && ((E = h.getInstrumentManager()) == null || E.stopNote(O.instrumentId || "default", A));
    }
  };
  return /* @__PURE__ */ J.jsx(H6.Provider, { value: T, children: e });
}, qh = () => {
  const e = tt.useContext(H6);
  if (!e)
    throw new Error("usePianoRoll must be used within a PianoRollProvider");
  return e;
}, BU = ({
  children: e,
  title: t,
  isOpen: n,
  onClose: i,
  initialPosition: s = { x: 100, y: 100 },
  initialSize: o = { width: 800, height: 500 }
}) => {
  const [u, h] = tt.useState(s), [f, p] = tt.useState(o), [g, v] = tt.useState(!1), [x, b] = tt.useState(!1), [_, T] = tt.useState({ x: 0, y: 0 }), A = tt.useRef(null), O = tt.useRef(!1);
  tt.useEffect(() => {
    n && !O.current ? (h(s), p(o), O.current = !0) : n || (O.current = !1);
  }, [n, s, o]), tt.useEffect(() => {
    const R = (U) => {
      if (g) {
        const q = U.clientX - _.x, j = U.clientY - _.y;
        h({ x: q, y: j });
      } else if (x && A.current) {
        const q = A.current.getBoundingClientRect(), j = Math.max(400, U.clientX - q.left), V = Math.max(300, U.clientY - q.top);
        p({
          width: j,
          height: V
        });
      }
    }, N = () => {
      v(!1), b(!1);
    };
    return (g || x) && (document.addEventListener("mousemove", R), document.addEventListener("mouseup", N)), () => {
      document.removeEventListener("mousemove", R), document.removeEventListener("mouseup", N);
    };
  }, [g, x, _]);
  const M = (R) => {
    R.preventDefault(), !R.target.closest(".close-button") && (v(!0), T({
      x: R.clientX - u.x,
      y: R.clientY - u.y
    }));
  }, E = (R) => {
    R.preventDefault(), R.stopPropagation(), b(!0);
  };
  return n ? /* @__PURE__ */ J.jsx(
    bT,
    {
      open: !0,
      disableAutoFocus: !0,
      disableEscapeKeyDown: !0,
      onClose: i,
      sx: {
        pointerEvents: "none",
        // Make the modal container non-blocking
        "& .MuiBackdrop-root": {
          backgroundColor: "rgba(0, 0, 0, 0.2)",
          pointerEvents: "none"
          // Let clicks through the backdrop
        }
      },
      keepMounted: !0,
      children: /* @__PURE__ */ J.jsxs(
        xe,
        {
          ref: A,
          sx: {
            position: "absolute",
            left: `${u.x}px`,
            top: `${u.y}px`,
            width: `${f.width}px`,
            height: `${f.height}px`,
            bgcolor: "#222",
            boxShadow: 24,
            borderRadius: 1,
            display: "flex",
            flexDirection: "column",
            outline: "none",
            overflow: "hidden",
            pointerEvents: "auto",
            // Re-enable pointer events for the modal content
            color: "white"
          },
          children: [
            /* @__PURE__ */ J.jsx(
              xe,
              {
                sx: {
                  height: "32px",
                  bgcolor: "#333",
                  display: "flex",
                  alignItems: "center",
                  pl: 2,
                  pr: 4,
                  cursor: "move",
                  borderTopLeftRadius: "inherit",
                  borderTopRightRadius: "inherit",
                  userSelect: "none"
                },
                onMouseDown: M,
                children: /* @__PURE__ */ J.jsx(Wa, { variant: "subtitle2", sx: { fontWeight: "bold", flex: 1 }, children: t })
              }
            ),
            /* @__PURE__ */ J.jsx(
              Gf,
              {
                onClick: i,
                className: "close-button",
                sx: {
                  position: "absolute",
                  right: 8,
                  top: 4,
                  minWidth: "auto",
                  width: 24,
                  height: 24,
                  p: 0,
                  color: "#999",
                  zIndex: 10,
                  fontSize: "18px",
                  lineHeight: 1,
                  "&:hover": {
                    color: "#fff",
                    bgcolor: "rgba(255, 255, 255, 0.1)"
                  }
                },
                children: "×"
              }
            ),
            /* @__PURE__ */ J.jsx(xe, { sx: {
              flex: 1,
              overflow: "hidden",
              bgcolor: "#181818",
              borderBottomLeftRadius: "inherit",
              borderBottomRightRadius: "inherit"
            }, children: e }),
            /* @__PURE__ */ J.jsx(
              xe,
              {
                sx: {
                  position: "absolute",
                  bottom: 0,
                  right: 0,
                  width: 20,
                  height: 20,
                  cursor: "se-resize",
                  bgcolor: "transparent",
                  "&:hover": {
                    bgcolor: "rgba(255, 255, 255, 0.1)"
                  },
                  "&::after": {
                    content: '""',
                    position: "absolute",
                    bottom: 4,
                    right: 4,
                    width: 10,
                    height: 10,
                    borderRight: "2px solid #666",
                    borderBottom: "2px solid #666"
                  }
                },
                onMouseDown: E
              }
            )
          ]
        }
      )
    }
  ) : null;
};
var Xy = { exports: {} }, Em = {}, xb = {}, Tb = {}, Qx;
function Sn() {
  return Qx || (Qx = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e._registerNode = e.Konva = e.glob = void 0;
    const t = Math.PI / 180;
    function n() {
      return typeof window < "u" && ({}.toString.call(window) === "[object Window]" || {}.toString.call(window) === "[object global]");
    }
    e.glob = typeof Pb < "u" ? Pb : typeof window < "u" ? window : typeof WorkerGlobalScope < "u" ? self : {}, e.Konva = {
      _global: e.glob,
      version: "9.3.20",
      isBrowser: n(),
      isUnminified: /param/.test((function(s) {
      }).toString()),
      dblClickWindow: 400,
      getAngle(s) {
        return e.Konva.angleDeg ? s * t : s;
      },
      enableTrace: !1,
      pointerEventsEnabled: !0,
      autoDrawEnabled: !0,
      hitOnDragEnabled: !1,
      capturePointerEventsEnabled: !1,
      _mouseListenClick: !1,
      _touchListenClick: !1,
      _pointerListenClick: !1,
      _mouseInDblClickWindow: !1,
      _touchInDblClickWindow: !1,
      _pointerInDblClickWindow: !1,
      _mouseDblClickPointerId: null,
      _touchDblClickPointerId: null,
      _pointerDblClickPointerId: null,
      _fixTextRendering: !1,
      pixelRatio: typeof window < "u" && window.devicePixelRatio || 1,
      dragDistance: 3,
      angleDeg: !0,
      showWarnings: !0,
      dragButtons: [0, 1],
      isDragging() {
        return e.Konva.DD.isDragging;
      },
      isTransforming() {
        var s;
        return (s = e.Konva.Transformer) === null || s === void 0 ? void 0 : s.isTransforming();
      },
      isDragReady() {
        return !!e.Konva.DD.node;
      },
      releaseCanvasOnDestroy: !0,
      document: e.glob.document,
      _injectGlobal(s) {
        e.glob.Konva = s;
      }
    };
    const i = (s) => {
      e.Konva[s.prototype.getClassName()] = s;
    };
    e._registerNode = i, e.Konva._injectGlobal(e.Konva);
  }(Tb)), Tb;
}
var Cb = {}, Zx;
function lr() {
  return Zx || (Zx = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.Util = e.Transform = void 0;
    const t = Sn();
    class n {
      constructor(R = [1, 0, 0, 1, 0, 0]) {
        this.dirty = !1, this.m = R && R.slice() || [1, 0, 0, 1, 0, 0];
      }
      reset() {
        this.m[0] = 1, this.m[1] = 0, this.m[2] = 0, this.m[3] = 1, this.m[4] = 0, this.m[5] = 0;
      }
      copy() {
        return new n(this.m);
      }
      copyInto(R) {
        R.m[0] = this.m[0], R.m[1] = this.m[1], R.m[2] = this.m[2], R.m[3] = this.m[3], R.m[4] = this.m[4], R.m[5] = this.m[5];
      }
      point(R) {
        const N = this.m;
        return {
          x: N[0] * R.x + N[2] * R.y + N[4],
          y: N[1] * R.x + N[3] * R.y + N[5]
        };
      }
      translate(R, N) {
        return this.m[4] += this.m[0] * R + this.m[2] * N, this.m[5] += this.m[1] * R + this.m[3] * N, this;
      }
      scale(R, N) {
        return this.m[0] *= R, this.m[1] *= R, this.m[2] *= N, this.m[3] *= N, this;
      }
      rotate(R) {
        const N = Math.cos(R), U = Math.sin(R), q = this.m[0] * N + this.m[2] * U, j = this.m[1] * N + this.m[3] * U, V = this.m[0] * -U + this.m[2] * N, D = this.m[1] * -U + this.m[3] * N;
        return this.m[0] = q, this.m[1] = j, this.m[2] = V, this.m[3] = D, this;
      }
      getTranslation() {
        return {
          x: this.m[4],
          y: this.m[5]
        };
      }
      skew(R, N) {
        const U = this.m[0] + this.m[2] * N, q = this.m[1] + this.m[3] * N, j = this.m[2] + this.m[0] * R, V = this.m[3] + this.m[1] * R;
        return this.m[0] = U, this.m[1] = q, this.m[2] = j, this.m[3] = V, this;
      }
      multiply(R) {
        const N = this.m[0] * R.m[0] + this.m[2] * R.m[1], U = this.m[1] * R.m[0] + this.m[3] * R.m[1], q = this.m[0] * R.m[2] + this.m[2] * R.m[3], j = this.m[1] * R.m[2] + this.m[3] * R.m[3], V = this.m[0] * R.m[4] + this.m[2] * R.m[5] + this.m[4], D = this.m[1] * R.m[4] + this.m[3] * R.m[5] + this.m[5];
        return this.m[0] = N, this.m[1] = U, this.m[2] = q, this.m[3] = j, this.m[4] = V, this.m[5] = D, this;
      }
      invert() {
        const R = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]), N = this.m[3] * R, U = -this.m[1] * R, q = -this.m[2] * R, j = this.m[0] * R, V = R * (this.m[2] * this.m[5] - this.m[3] * this.m[4]), D = R * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
        return this.m[0] = N, this.m[1] = U, this.m[2] = q, this.m[3] = j, this.m[4] = V, this.m[5] = D, this;
      }
      getMatrix() {
        return this.m;
      }
      decompose() {
        const R = this.m[0], N = this.m[1], U = this.m[2], q = this.m[3], j = this.m[4], V = this.m[5], D = R * q - N * U, G = {
          x: j,
          y: V,
          rotation: 0,
          scaleX: 0,
          scaleY: 0,
          skewX: 0,
          skewY: 0
        };
        if (R != 0 || N != 0) {
          const W = Math.sqrt(R * R + N * N);
          G.rotation = N > 0 ? Math.acos(R / W) : -Math.acos(R / W), G.scaleX = W, G.scaleY = D / W, G.skewX = (R * U + N * q) / D, G.skewY = 0;
        } else if (U != 0 || q != 0) {
          const W = Math.sqrt(U * U + q * q);
          G.rotation = Math.PI / 2 - (q > 0 ? Math.acos(-U / W) : -Math.acos(U / W)), G.scaleX = D / W, G.scaleY = W, G.skewX = 0, G.skewY = (R * U + N * q) / D;
        }
        return G.rotation = e.Util._getRotation(G.rotation), G;
      }
    }
    e.Transform = n;
    const i = "[object Array]", s = "[object Number]", o = "[object String]", u = "[object Boolean]", h = Math.PI / 180, f = 180 / Math.PI, p = "#", g = "", v = "0", x = "Konva warning: ", b = "Konva error: ", _ = "rgb(", T = {
      aliceblue: [240, 248, 255],
      antiquewhite: [250, 235, 215],
      aqua: [0, 255, 255],
      aquamarine: [127, 255, 212],
      azure: [240, 255, 255],
      beige: [245, 245, 220],
      bisque: [255, 228, 196],
      black: [0, 0, 0],
      blanchedalmond: [255, 235, 205],
      blue: [0, 0, 255],
      blueviolet: [138, 43, 226],
      brown: [165, 42, 42],
      burlywood: [222, 184, 135],
      cadetblue: [95, 158, 160],
      chartreuse: [127, 255, 0],
      chocolate: [210, 105, 30],
      coral: [255, 127, 80],
      cornflowerblue: [100, 149, 237],
      cornsilk: [255, 248, 220],
      crimson: [220, 20, 60],
      cyan: [0, 255, 255],
      darkblue: [0, 0, 139],
      darkcyan: [0, 139, 139],
      darkgoldenrod: [184, 132, 11],
      darkgray: [169, 169, 169],
      darkgreen: [0, 100, 0],
      darkgrey: [169, 169, 169],
      darkkhaki: [189, 183, 107],
      darkmagenta: [139, 0, 139],
      darkolivegreen: [85, 107, 47],
      darkorange: [255, 140, 0],
      darkorchid: [153, 50, 204],
      darkred: [139, 0, 0],
      darksalmon: [233, 150, 122],
      darkseagreen: [143, 188, 143],
      darkslateblue: [72, 61, 139],
      darkslategray: [47, 79, 79],
      darkslategrey: [47, 79, 79],
      darkturquoise: [0, 206, 209],
      darkviolet: [148, 0, 211],
      deeppink: [255, 20, 147],
      deepskyblue: [0, 191, 255],
      dimgray: [105, 105, 105],
      dimgrey: [105, 105, 105],
      dodgerblue: [30, 144, 255],
      firebrick: [178, 34, 34],
      floralwhite: [255, 255, 240],
      forestgreen: [34, 139, 34],
      fuchsia: [255, 0, 255],
      gainsboro: [220, 220, 220],
      ghostwhite: [248, 248, 255],
      gold: [255, 215, 0],
      goldenrod: [218, 165, 32],
      gray: [128, 128, 128],
      green: [0, 128, 0],
      greenyellow: [173, 255, 47],
      grey: [128, 128, 128],
      honeydew: [240, 255, 240],
      hotpink: [255, 105, 180],
      indianred: [205, 92, 92],
      indigo: [75, 0, 130],
      ivory: [255, 255, 240],
      khaki: [240, 230, 140],
      lavender: [230, 230, 250],
      lavenderblush: [255, 240, 245],
      lawngreen: [124, 252, 0],
      lemonchiffon: [255, 250, 205],
      lightblue: [173, 216, 230],
      lightcoral: [240, 128, 128],
      lightcyan: [224, 255, 255],
      lightgoldenrodyellow: [250, 250, 210],
      lightgray: [211, 211, 211],
      lightgreen: [144, 238, 144],
      lightgrey: [211, 211, 211],
      lightpink: [255, 182, 193],
      lightsalmon: [255, 160, 122],
      lightseagreen: [32, 178, 170],
      lightskyblue: [135, 206, 250],
      lightslategray: [119, 136, 153],
      lightslategrey: [119, 136, 153],
      lightsteelblue: [176, 196, 222],
      lightyellow: [255, 255, 224],
      lime: [0, 255, 0],
      limegreen: [50, 205, 50],
      linen: [250, 240, 230],
      magenta: [255, 0, 255],
      maroon: [128, 0, 0],
      mediumaquamarine: [102, 205, 170],
      mediumblue: [0, 0, 205],
      mediumorchid: [186, 85, 211],
      mediumpurple: [147, 112, 219],
      mediumseagreen: [60, 179, 113],
      mediumslateblue: [123, 104, 238],
      mediumspringgreen: [0, 250, 154],
      mediumturquoise: [72, 209, 204],
      mediumvioletred: [199, 21, 133],
      midnightblue: [25, 25, 112],
      mintcream: [245, 255, 250],
      mistyrose: [255, 228, 225],
      moccasin: [255, 228, 181],
      navajowhite: [255, 222, 173],
      navy: [0, 0, 128],
      oldlace: [253, 245, 230],
      olive: [128, 128, 0],
      olivedrab: [107, 142, 35],
      orange: [255, 165, 0],
      orangered: [255, 69, 0],
      orchid: [218, 112, 214],
      palegoldenrod: [238, 232, 170],
      palegreen: [152, 251, 152],
      paleturquoise: [175, 238, 238],
      palevioletred: [219, 112, 147],
      papayawhip: [255, 239, 213],
      peachpuff: [255, 218, 185],
      peru: [205, 133, 63],
      pink: [255, 192, 203],
      plum: [221, 160, 203],
      powderblue: [176, 224, 230],
      purple: [128, 0, 128],
      rebeccapurple: [102, 51, 153],
      red: [255, 0, 0],
      rosybrown: [188, 143, 143],
      royalblue: [65, 105, 225],
      saddlebrown: [139, 69, 19],
      salmon: [250, 128, 114],
      sandybrown: [244, 164, 96],
      seagreen: [46, 139, 87],
      seashell: [255, 245, 238],
      sienna: [160, 82, 45],
      silver: [192, 192, 192],
      skyblue: [135, 206, 235],
      slateblue: [106, 90, 205],
      slategray: [119, 128, 144],
      slategrey: [119, 128, 144],
      snow: [255, 255, 250],
      springgreen: [0, 255, 127],
      steelblue: [70, 130, 180],
      tan: [210, 180, 140],
      teal: [0, 128, 128],
      thistle: [216, 191, 216],
      transparent: [255, 255, 255, 0],
      tomato: [255, 99, 71],
      turquoise: [64, 224, 208],
      violet: [238, 130, 238],
      wheat: [245, 222, 179],
      white: [255, 255, 255],
      whitesmoke: [245, 245, 245],
      yellow: [255, 255, 0],
      yellowgreen: [154, 205, 5]
    }, A = /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/;
    let O = [];
    const M = typeof requestAnimationFrame < "u" && requestAnimationFrame || function(E) {
      setTimeout(E, 60);
    };
    e.Util = {
      _isElement(E) {
        return !!(E && E.nodeType == 1);
      },
      _isFunction(E) {
        return !!(E && E.constructor && E.call && E.apply);
      },
      _isPlainObject(E) {
        return !!E && E.constructor === Object;
      },
      _isArray(E) {
        return Object.prototype.toString.call(E) === i;
      },
      _isNumber(E) {
        return Object.prototype.toString.call(E) === s && !isNaN(E) && isFinite(E);
      },
      _isString(E) {
        return Object.prototype.toString.call(E) === o;
      },
      _isBoolean(E) {
        return Object.prototype.toString.call(E) === u;
      },
      isObject(E) {
        return E instanceof Object;
      },
      isValidSelector(E) {
        if (typeof E != "string")
          return !1;
        const R = E[0];
        return R === "#" || R === "." || R === R.toUpperCase();
      },
      _sign(E) {
        return E === 0 || E > 0 ? 1 : -1;
      },
      requestAnimFrame(E) {
        O.push(E), O.length === 1 && M(function() {
          const R = O;
          O = [], R.forEach(function(N) {
            N();
          });
        });
      },
      createCanvasElement() {
        const E = document.createElement("canvas");
        try {
          E.style = E.style || {};
        } catch {
        }
        return E;
      },
      createImageElement() {
        return document.createElement("img");
      },
      _isInDocument(E) {
        for (; E = E.parentNode; )
          if (E == document)
            return !0;
        return !1;
      },
      _urlToImage(E, R) {
        const N = e.Util.createImageElement();
        N.onload = function() {
          R(N);
        }, N.src = E;
      },
      _rgbToHex(E, R, N) {
        return ((1 << 24) + (E << 16) + (R << 8) + N).toString(16).slice(1);
      },
      _hexToRgb(E) {
        E = E.replace(p, g);
        const R = parseInt(E, 16);
        return {
          r: R >> 16 & 255,
          g: R >> 8 & 255,
          b: R & 255
        };
      },
      getRandomColor() {
        let E = (Math.random() * 16777215 << 0).toString(16);
        for (; E.length < 6; )
          E = v + E;
        return p + E;
      },
      getRGB(E) {
        let R;
        return E in T ? (R = T[E], {
          r: R[0],
          g: R[1],
          b: R[2]
        }) : E[0] === p ? this._hexToRgb(E.substring(1)) : E.substr(0, 4) === _ ? (R = A.exec(E.replace(/ /g, "")), {
          r: parseInt(R[1], 10),
          g: parseInt(R[2], 10),
          b: parseInt(R[3], 10)
        }) : {
          r: 0,
          g: 0,
          b: 0
        };
      },
      colorToRGBA(E) {
        return E = E || "black", e.Util._namedColorToRBA(E) || e.Util._hex3ColorToRGBA(E) || e.Util._hex4ColorToRGBA(E) || e.Util._hex6ColorToRGBA(E) || e.Util._hex8ColorToRGBA(E) || e.Util._rgbColorToRGBA(E) || e.Util._rgbaColorToRGBA(E) || e.Util._hslColorToRGBA(E);
      },
      _namedColorToRBA(E) {
        const R = T[E.toLowerCase()];
        return R ? {
          r: R[0],
          g: R[1],
          b: R[2],
          a: 1
        } : null;
      },
      _rgbColorToRGBA(E) {
        if (E.indexOf("rgb(") === 0) {
          E = E.match(/rgb\(([^)]+)\)/)[1];
          const R = E.split(/ *, */).map(Number);
          return {
            r: R[0],
            g: R[1],
            b: R[2],
            a: 1
          };
        }
      },
      _rgbaColorToRGBA(E) {
        if (E.indexOf("rgba(") === 0) {
          E = E.match(/rgba\(([^)]+)\)/)[1];
          const R = E.split(/ *, */).map((N, U) => N.slice(-1) === "%" ? U === 3 ? parseInt(N) / 100 : parseInt(N) / 100 * 255 : Number(N));
          return {
            r: R[0],
            g: R[1],
            b: R[2],
            a: R[3]
          };
        }
      },
      _hex8ColorToRGBA(E) {
        if (E[0] === "#" && E.length === 9)
          return {
            r: parseInt(E.slice(1, 3), 16),
            g: parseInt(E.slice(3, 5), 16),
            b: parseInt(E.slice(5, 7), 16),
            a: parseInt(E.slice(7, 9), 16) / 255
          };
      },
      _hex6ColorToRGBA(E) {
        if (E[0] === "#" && E.length === 7)
          return {
            r: parseInt(E.slice(1, 3), 16),
            g: parseInt(E.slice(3, 5), 16),
            b: parseInt(E.slice(5, 7), 16),
            a: 1
          };
      },
      _hex4ColorToRGBA(E) {
        if (E[0] === "#" && E.length === 5)
          return {
            r: parseInt(E[1] + E[1], 16),
            g: parseInt(E[2] + E[2], 16),
            b: parseInt(E[3] + E[3], 16),
            a: parseInt(E[4] + E[4], 16) / 255
          };
      },
      _hex3ColorToRGBA(E) {
        if (E[0] === "#" && E.length === 4)
          return {
            r: parseInt(E[1] + E[1], 16),
            g: parseInt(E[2] + E[2], 16),
            b: parseInt(E[3] + E[3], 16),
            a: 1
          };
      },
      _hslColorToRGBA(E) {
        if (/hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.test(E)) {
          const [R, ...N] = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(E), U = Number(N[0]) / 360, q = Number(N[1]) / 100, j = Number(N[2]) / 100;
          let V, D, G;
          if (q === 0)
            return G = j * 255, {
              r: Math.round(G),
              g: Math.round(G),
              b: Math.round(G),
              a: 1
            };
          j < 0.5 ? V = j * (1 + q) : V = j + q - j * q;
          const W = 2 * j - V, P = [0, 0, 0];
          for (let H = 0; H < 3; H++)
            D = U + 1 / 3 * -(H - 1), D < 0 && D++, D > 1 && D--, 6 * D < 1 ? G = W + (V - W) * 6 * D : 2 * D < 1 ? G = V : 3 * D < 2 ? G = W + (V - W) * (2 / 3 - D) * 6 : G = W, P[H] = G * 255;
          return {
            r: Math.round(P[0]),
            g: Math.round(P[1]),
            b: Math.round(P[2]),
            a: 1
          };
        }
      },
      haveIntersection(E, R) {
        return !(R.x > E.x + E.width || R.x + R.width < E.x || R.y > E.y + E.height || R.y + R.height < E.y);
      },
      cloneObject(E) {
        const R = {};
        for (const N in E)
          this._isPlainObject(E[N]) ? R[N] = this.cloneObject(E[N]) : this._isArray(E[N]) ? R[N] = this.cloneArray(E[N]) : R[N] = E[N];
        return R;
      },
      cloneArray(E) {
        return E.slice(0);
      },
      degToRad(E) {
        return E * h;
      },
      radToDeg(E) {
        return E * f;
      },
      _degToRad(E) {
        return e.Util.warn("Util._degToRad is removed. Please use public Util.degToRad instead."), e.Util.degToRad(E);
      },
      _radToDeg(E) {
        return e.Util.warn("Util._radToDeg is removed. Please use public Util.radToDeg instead."), e.Util.radToDeg(E);
      },
      _getRotation(E) {
        return t.Konva.angleDeg ? e.Util.radToDeg(E) : E;
      },
      _capitalize(E) {
        return E.charAt(0).toUpperCase() + E.slice(1);
      },
      throw(E) {
        throw new Error(b + E);
      },
      error(E) {
        console.error(b + E);
      },
      warn(E) {
        t.Konva.showWarnings && console.warn(x + E);
      },
      each(E, R) {
        for (const N in E)
          R(N, E[N]);
      },
      _inRange(E, R, N) {
        return R <= E && E < N;
      },
      _getProjectionToSegment(E, R, N, U, q, j) {
        let V, D, G;
        const W = (E - N) * (E - N) + (R - U) * (R - U);
        if (W == 0)
          V = E, D = R, G = (q - N) * (q - N) + (j - U) * (j - U);
        else {
          const P = ((q - E) * (N - E) + (j - R) * (U - R)) / W;
          P < 0 ? (V = E, D = R, G = (E - q) * (E - q) + (R - j) * (R - j)) : P > 1 ? (V = N, D = U, G = (N - q) * (N - q) + (U - j) * (U - j)) : (V = E + P * (N - E), D = R + P * (U - R), G = (V - q) * (V - q) + (D - j) * (D - j));
        }
        return [V, D, G];
      },
      _getProjectionToLine(E, R, N) {
        const U = e.Util.cloneObject(E);
        let q = Number.MAX_VALUE;
        return R.forEach(function(j, V) {
          if (!N && V === R.length - 1)
            return;
          const D = R[(V + 1) % R.length], G = e.Util._getProjectionToSegment(j.x, j.y, D.x, D.y, E.x, E.y), W = G[0], P = G[1], H = G[2];
          H < q && (U.x = W, U.y = P, q = H);
        }), U;
      },
      _prepareArrayForTween(E, R, N) {
        const U = [], q = [];
        if (E.length > R.length) {
          const V = R;
          R = E, E = V;
        }
        for (let V = 0; V < E.length; V += 2)
          U.push({
            x: E[V],
            y: E[V + 1]
          });
        for (let V = 0; V < R.length; V += 2)
          q.push({
            x: R[V],
            y: R[V + 1]
          });
        const j = [];
        return q.forEach(function(V) {
          const D = e.Util._getProjectionToLine(V, U, N);
          j.push(D.x), j.push(D.y);
        }), j;
      },
      _prepareToStringify(E) {
        let R;
        E.visitedByCircularReferenceRemoval = !0;
        for (const N in E)
          if (E.hasOwnProperty(N) && E[N] && typeof E[N] == "object") {
            if (R = Object.getOwnPropertyDescriptor(E, N), E[N].visitedByCircularReferenceRemoval || e.Util._isElement(E[N]))
              if (R.configurable)
                delete E[N];
              else
                return null;
            else if (e.Util._prepareToStringify(E[N]) === null)
              if (R.configurable)
                delete E[N];
              else
                return null;
          }
        return delete E.visitedByCircularReferenceRemoval, E;
      },
      _assign(E, R) {
        for (const N in R)
          E[N] = R[N];
        return E;
      },
      _getFirstPointerId(E) {
        return E.touches ? E.changedTouches[0].identifier : E.pointerId || 999;
      },
      releaseCanvas(...E) {
        t.Konva.releaseCanvasOnDestroy && E.forEach((R) => {
          R.width = 0, R.height = 0;
        });
      },
      drawRoundedRectPath(E, R, N, U) {
        let q = 0, j = 0, V = 0, D = 0;
        typeof U == "number" ? q = j = V = D = Math.min(U, R / 2, N / 2) : (q = Math.min(U[0] || 0, R / 2, N / 2), j = Math.min(U[1] || 0, R / 2, N / 2), D = Math.min(U[2] || 0, R / 2, N / 2), V = Math.min(U[3] || 0, R / 2, N / 2)), E.moveTo(q, 0), E.lineTo(R - j, 0), E.arc(R - j, j, j, Math.PI * 3 / 2, 0, !1), E.lineTo(R, N - D), E.arc(R - D, N - D, D, 0, Math.PI / 2, !1), E.lineTo(V, N), E.arc(V, N - V, V, Math.PI / 2, Math.PI, !1), E.lineTo(0, q), E.arc(q, q, q, Math.PI, Math.PI * 3 / 2, !1);
      }
    };
  }(Cb)), Cb;
}
var Am = {}, wb = {}, vs = {}, Jx;
function Mn() {
  if (Jx) return vs;
  Jx = 1, Object.defineProperty(vs, "__esModule", { value: !0 }), vs.RGBComponent = i, vs.alphaComponent = s, vs.getNumberValidator = o, vs.getNumberOrArrayOfNumbersValidator = u, vs.getNumberOrAutoValidator = h, vs.getStringValidator = f, vs.getStringOrGradientValidator = p, vs.getFunctionValidator = g, vs.getNumberArrayValidator = v, vs.getBooleanValidator = x, vs.getComponentValidator = b;
  const e = Sn(), t = lr();
  function n(_) {
    return t.Util._isString(_) ? '"' + _ + '"' : Object.prototype.toString.call(_) === "[object Number]" || t.Util._isBoolean(_) ? _ : Object.prototype.toString.call(_);
  }
  function i(_) {
    return _ > 255 ? 255 : _ < 0 ? 0 : Math.round(_);
  }
  function s(_) {
    return _ > 1 ? 1 : _ < 1e-4 ? 1e-4 : _;
  }
  function o() {
    if (e.Konva.isUnminified)
      return function(_, T) {
        return t.Util._isNumber(_) || t.Util.warn(n(_) + ' is a not valid value for "' + T + '" attribute. The value should be a number.'), _;
      };
  }
  function u(_) {
    if (e.Konva.isUnminified)
      return function(T, A) {
        let O = t.Util._isNumber(T), M = t.Util._isArray(T) && T.length == _;
        return !O && !M && t.Util.warn(n(T) + ' is a not valid value for "' + A + '" attribute. The value should be a number or Array<number>(' + _ + ")"), T;
      };
  }
  function h() {
    if (e.Konva.isUnminified)
      return function(_, T) {
        var A = t.Util._isNumber(_), O = _ === "auto";
        return A || O || t.Util.warn(n(_) + ' is a not valid value for "' + T + '" attribute. The value should be a number or "auto".'), _;
      };
  }
  function f() {
    if (e.Konva.isUnminified)
      return function(_, T) {
        return t.Util._isString(_) || t.Util.warn(n(_) + ' is a not valid value for "' + T + '" attribute. The value should be a string.'), _;
      };
  }
  function p() {
    if (e.Konva.isUnminified)
      return function(_, T) {
        const A = t.Util._isString(_), O = Object.prototype.toString.call(_) === "[object CanvasGradient]" || _ && _.addColorStop;
        return A || O || t.Util.warn(n(_) + ' is a not valid value for "' + T + '" attribute. The value should be a string or a native gradient.'), _;
      };
  }
  function g() {
    if (e.Konva.isUnminified)
      return function(_, T) {
        return t.Util._isFunction(_) || t.Util.warn(n(_) + ' is a not valid value for "' + T + '" attribute. The value should be a function.'), _;
      };
  }
  function v() {
    if (e.Konva.isUnminified)
      return function(_, T) {
        const A = Int8Array ? Object.getPrototypeOf(Int8Array) : null;
        return A && _ instanceof A || (t.Util._isArray(_) ? _.forEach(function(O) {
          t.Util._isNumber(O) || t.Util.warn('"' + T + '" attribute has non numeric element ' + O + ". Make sure that all elements are numbers.");
        }) : t.Util.warn(n(_) + ' is a not valid value for "' + T + '" attribute. The value should be a array of numbers.')), _;
      };
  }
  function x() {
    if (e.Konva.isUnminified)
      return function(_, T) {
        var A = _ === !0 || _ === !1;
        return A || t.Util.warn(n(_) + ' is a not valid value for "' + T + '" attribute. The value should be a boolean.'), _;
      };
  }
  function b(_) {
    if (e.Konva.isUnminified)
      return function(T, A) {
        return T == null || t.Util.isObject(T) || t.Util.warn(n(T) + ' is a not valid value for "' + A + '" attribute. The value should be an object with properties ' + _), T;
      };
  }
  return vs;
}
var t4;
function An() {
  return t4 || (t4 = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.Factory = void 0;
    const t = lr(), n = Mn(), i = "get", s = "set";
    e.Factory = {
      addGetterSetter(o, u, h, f, p) {
        e.Factory.addGetter(o, u, h), e.Factory.addSetter(o, u, f, p), e.Factory.addOverloadedGetterSetter(o, u);
      },
      addGetter(o, u, h) {
        var f = i + t.Util._capitalize(u);
        o.prototype[f] = o.prototype[f] || function() {
          const p = this.attrs[u];
          return p === void 0 ? h : p;
        };
      },
      addSetter(o, u, h, f) {
        var p = s + t.Util._capitalize(u);
        o.prototype[p] || e.Factory.overWriteSetter(o, u, h, f);
      },
      overWriteSetter(o, u, h, f) {
        var p = s + t.Util._capitalize(u);
        o.prototype[p] = function(g) {
          return h && g !== void 0 && g !== null && (g = h.call(this, g, u)), this._setAttr(u, g), f && f.call(this), this;
        };
      },
      addComponentsGetterSetter(o, u, h, f, p) {
        const g = h.length, v = t.Util._capitalize, x = i + v(u), b = s + v(u);
        o.prototype[x] = function() {
          const T = {};
          for (let A = 0; A < g; A++) {
            const O = h[A];
            T[O] = this.getAttr(u + v(O));
          }
          return T;
        };
        const _ = (0, n.getComponentValidator)(h);
        o.prototype[b] = function(T) {
          const A = this.attrs[u];
          f && (T = f.call(this, T, u)), _ && _.call(this, T, u);
          for (const O in T)
            T.hasOwnProperty(O) && this._setAttr(u + v(O), T[O]);
          return T || h.forEach((O) => {
            this._setAttr(u + v(O), void 0);
          }), this._fireChangeEvent(u, A, T), p && p.call(this), this;
        }, e.Factory.addOverloadedGetterSetter(o, u);
      },
      addOverloadedGetterSetter(o, u) {
        var h = t.Util._capitalize(u), f = s + h, p = i + h;
        o.prototype[u] = function() {
          return arguments.length ? (this[f](arguments[0]), this) : this[p]();
        };
      },
      addDeprecatedGetterSetter(o, u, h, f) {
        t.Util.error("Adding deprecated " + u);
        const p = i + t.Util._capitalize(u), g = u + " property is deprecated and will be removed soon. Look at Konva change log for more information.";
        o.prototype[p] = function() {
          t.Util.error(g);
          const v = this.attrs[u];
          return v === void 0 ? h : v;
        }, e.Factory.addSetter(o, u, f, function() {
          t.Util.error(g);
        }), e.Factory.addOverloadedGetterSetter(o, u);
      },
      backCompat(o, u) {
        t.Util.each(u, function(h, f) {
          const p = o.prototype[f], g = i + t.Util._capitalize(h), v = s + t.Util._capitalize(h);
          function x() {
            p.apply(this, arguments), t.Util.error('"' + h + '" method is deprecated and will be removed soon. Use ""' + f + '" instead.');
          }
          o.prototype[h] = x, o.prototype[g] = x, o.prototype[v] = x;
        });
      },
      afterSetFilter() {
        this._filterUpToDate = !1;
      }
    };
  }(wb)), wb;
}
var Au = {}, Mu = {}, e4;
function K6() {
  if (e4) return Mu;
  e4 = 1, Object.defineProperty(Mu, "__esModule", { value: !0 }), Mu.HitContext = Mu.SceneContext = Mu.Context = void 0;
  const e = lr(), t = Sn();
  function n(O) {
    const M = [], E = O.length, R = e.Util;
    for (let N = 0; N < E; N++) {
      let U = O[N];
      R._isNumber(U) ? U = Math.round(U * 1e3) / 1e3 : R._isString(U) || (U = U + ""), M.push(U);
    }
    return M;
  }
  const i = ",", s = "(", o = ")", u = "([", h = "])", f = ";", p = "()", g = "=", v = [
    "arc",
    "arcTo",
    "beginPath",
    "bezierCurveTo",
    "clearRect",
    "clip",
    "closePath",
    "createLinearGradient",
    "createPattern",
    "createRadialGradient",
    "drawImage",
    "ellipse",
    "fill",
    "fillText",
    "getImageData",
    "createImageData",
    "lineTo",
    "moveTo",
    "putImageData",
    "quadraticCurveTo",
    "rect",
    "roundRect",
    "restore",
    "rotate",
    "save",
    "scale",
    "setLineDash",
    "setTransform",
    "stroke",
    "strokeText",
    "transform",
    "translate"
  ], x = [
    "fillStyle",
    "strokeStyle",
    "shadowColor",
    "shadowBlur",
    "shadowOffsetX",
    "shadowOffsetY",
    "letterSpacing",
    "lineCap",
    "lineDashOffset",
    "lineJoin",
    "lineWidth",
    "miterLimit",
    "direction",
    "font",
    "textAlign",
    "textBaseline",
    "globalAlpha",
    "globalCompositeOperation",
    "imageSmoothingEnabled"
  ], b = 100;
  let _ = class {
    constructor(M) {
      this.canvas = M, t.Konva.enableTrace && (this.traceArr = [], this._enableTrace());
    }
    fillShape(M) {
      M.fillEnabled() && this._fill(M);
    }
    _fill(M) {
    }
    strokeShape(M) {
      M.hasStroke() && this._stroke(M);
    }
    _stroke(M) {
    }
    fillStrokeShape(M) {
      M.attrs.fillAfterStrokeEnabled ? (this.strokeShape(M), this.fillShape(M)) : (this.fillShape(M), this.strokeShape(M));
    }
    getTrace(M, E) {
      let R = this.traceArr, N = R.length, U = "", q, j, V, D;
      for (q = 0; q < N; q++)
        j = R[q], V = j.method, V ? (D = j.args, U += V, M ? U += p : e.Util._isArray(D[0]) ? U += u + D.join(i) + h : (E && (D = D.map((G) => typeof G == "number" ? Math.floor(G) : G)), U += s + D.join(i) + o)) : (U += j.property, M || (U += g + j.val)), U += f;
      return U;
    }
    clearTrace() {
      this.traceArr = [];
    }
    _trace(M) {
      let E = this.traceArr, R;
      E.push(M), R = E.length, R >= b && E.shift();
    }
    reset() {
      const M = this.getCanvas().getPixelRatio();
      this.setTransform(1 * M, 0, 0, 1 * M, 0, 0);
    }
    getCanvas() {
      return this.canvas;
    }
    clear(M) {
      const E = this.getCanvas();
      M ? this.clearRect(M.x || 0, M.y || 0, M.width || 0, M.height || 0) : this.clearRect(0, 0, E.getWidth() / E.pixelRatio, E.getHeight() / E.pixelRatio);
    }
    _applyLineCap(M) {
      const E = M.attrs.lineCap;
      E && this.setAttr("lineCap", E);
    }
    _applyOpacity(M) {
      const E = M.getAbsoluteOpacity();
      E !== 1 && this.setAttr("globalAlpha", E);
    }
    _applyLineJoin(M) {
      const E = M.attrs.lineJoin;
      E && this.setAttr("lineJoin", E);
    }
    setAttr(M, E) {
      this._context[M] = E;
    }
    arc(M, E, R, N, U, q) {
      this._context.arc(M, E, R, N, U, q);
    }
    arcTo(M, E, R, N, U) {
      this._context.arcTo(M, E, R, N, U);
    }
    beginPath() {
      this._context.beginPath();
    }
    bezierCurveTo(M, E, R, N, U, q) {
      this._context.bezierCurveTo(M, E, R, N, U, q);
    }
    clearRect(M, E, R, N) {
      this._context.clearRect(M, E, R, N);
    }
    clip(...M) {
      this._context.clip.apply(this._context, M);
    }
    closePath() {
      this._context.closePath();
    }
    createImageData(M, E) {
      const R = arguments;
      if (R.length === 2)
        return this._context.createImageData(M, E);
      if (R.length === 1)
        return this._context.createImageData(M);
    }
    createLinearGradient(M, E, R, N) {
      return this._context.createLinearGradient(M, E, R, N);
    }
    createPattern(M, E) {
      return this._context.createPattern(M, E);
    }
    createRadialGradient(M, E, R, N, U, q) {
      return this._context.createRadialGradient(M, E, R, N, U, q);
    }
    drawImage(M, E, R, N, U, q, j, V, D) {
      const G = arguments, W = this._context;
      G.length === 3 ? W.drawImage(M, E, R) : G.length === 5 ? W.drawImage(M, E, R, N, U) : G.length === 9 && W.drawImage(M, E, R, N, U, q, j, V, D);
    }
    ellipse(M, E, R, N, U, q, j, V) {
      this._context.ellipse(M, E, R, N, U, q, j, V);
    }
    isPointInPath(M, E, R, N) {
      return R ? this._context.isPointInPath(R, M, E, N) : this._context.isPointInPath(M, E, N);
    }
    fill(...M) {
      this._context.fill.apply(this._context, M);
    }
    fillRect(M, E, R, N) {
      this._context.fillRect(M, E, R, N);
    }
    strokeRect(M, E, R, N) {
      this._context.strokeRect(M, E, R, N);
    }
    fillText(M, E, R, N) {
      N ? this._context.fillText(M, E, R, N) : this._context.fillText(M, E, R);
    }
    measureText(M) {
      return this._context.measureText(M);
    }
    getImageData(M, E, R, N) {
      return this._context.getImageData(M, E, R, N);
    }
    lineTo(M, E) {
      this._context.lineTo(M, E);
    }
    moveTo(M, E) {
      this._context.moveTo(M, E);
    }
    rect(M, E, R, N) {
      this._context.rect(M, E, R, N);
    }
    roundRect(M, E, R, N, U) {
      this._context.roundRect(M, E, R, N, U);
    }
    putImageData(M, E, R) {
      this._context.putImageData(M, E, R);
    }
    quadraticCurveTo(M, E, R, N) {
      this._context.quadraticCurveTo(M, E, R, N);
    }
    restore() {
      this._context.restore();
    }
    rotate(M) {
      this._context.rotate(M);
    }
    save() {
      this._context.save();
    }
    scale(M, E) {
      this._context.scale(M, E);
    }
    setLineDash(M) {
      this._context.setLineDash ? this._context.setLineDash(M) : "mozDash" in this._context ? this._context.mozDash = M : "webkitLineDash" in this._context && (this._context.webkitLineDash = M);
    }
    getLineDash() {
      return this._context.getLineDash();
    }
    setTransform(M, E, R, N, U, q) {
      this._context.setTransform(M, E, R, N, U, q);
    }
    stroke(M) {
      M ? this._context.stroke(M) : this._context.stroke();
    }
    strokeText(M, E, R, N) {
      this._context.strokeText(M, E, R, N);
    }
    transform(M, E, R, N, U, q) {
      this._context.transform(M, E, R, N, U, q);
    }
    translate(M, E) {
      this._context.translate(M, E);
    }
    _enableTrace() {
      let M = this, E = v.length, R = this.setAttr, N, U;
      const q = function(j) {
        let V = M[j], D;
        M[j] = function() {
          return U = n(Array.prototype.slice.call(arguments, 0)), D = V.apply(M, arguments), M._trace({
            method: j,
            args: U
          }), D;
        };
      };
      for (N = 0; N < E; N++)
        q(v[N]);
      M.setAttr = function() {
        R.apply(M, arguments);
        const j = arguments[0];
        let V = arguments[1];
        (j === "shadowOffsetX" || j === "shadowOffsetY" || j === "shadowBlur") && (V = V / this.canvas.getPixelRatio()), M._trace({
          property: j,
          val: V
        });
      };
    }
    _applyGlobalCompositeOperation(M) {
      const E = M.attrs.globalCompositeOperation;
      !E || E === "source-over" || this.setAttr("globalCompositeOperation", E);
    }
  };
  Mu.Context = _, x.forEach(function(O) {
    Object.defineProperty(_.prototype, O, {
      get() {
        return this._context[O];
      },
      set(M) {
        this._context[O] = M;
      }
    });
  });
  class T extends _ {
    constructor(M, { willReadFrequently: E = !1 } = {}) {
      super(M), this._context = M._canvas.getContext("2d", {
        willReadFrequently: E
      });
    }
    _fillColor(M) {
      const E = M.fill();
      this.setAttr("fillStyle", E), M._fillFunc(this);
    }
    _fillPattern(M) {
      this.setAttr("fillStyle", M._getFillPattern()), M._fillFunc(this);
    }
    _fillLinearGradient(M) {
      const E = M._getLinearGradient();
      E && (this.setAttr("fillStyle", E), M._fillFunc(this));
    }
    _fillRadialGradient(M) {
      const E = M._getRadialGradient();
      E && (this.setAttr("fillStyle", E), M._fillFunc(this));
    }
    _fill(M) {
      const E = M.fill(), R = M.getFillPriority();
      if (E && R === "color") {
        this._fillColor(M);
        return;
      }
      const N = M.getFillPatternImage();
      if (N && R === "pattern") {
        this._fillPattern(M);
        return;
      }
      const U = M.getFillLinearGradientColorStops();
      if (U && R === "linear-gradient") {
        this._fillLinearGradient(M);
        return;
      }
      const q = M.getFillRadialGradientColorStops();
      if (q && R === "radial-gradient") {
        this._fillRadialGradient(M);
        return;
      }
      E ? this._fillColor(M) : N ? this._fillPattern(M) : U ? this._fillLinearGradient(M) : q && this._fillRadialGradient(M);
    }
    _strokeLinearGradient(M) {
      const E = M.getStrokeLinearGradientStartPoint(), R = M.getStrokeLinearGradientEndPoint(), N = M.getStrokeLinearGradientColorStops(), U = this.createLinearGradient(E.x, E.y, R.x, R.y);
      if (N) {
        for (let q = 0; q < N.length; q += 2)
          U.addColorStop(N[q], N[q + 1]);
        this.setAttr("strokeStyle", U);
      }
    }
    _stroke(M) {
      const E = M.dash(), R = M.getStrokeScaleEnabled();
      if (M.hasStroke()) {
        if (!R) {
          this.save();
          const U = this.getCanvas().getPixelRatio();
          this.setTransform(U, 0, 0, U, 0, 0);
        }
        this._applyLineCap(M), E && M.dashEnabled() && (this.setLineDash(E), this.setAttr("lineDashOffset", M.dashOffset())), this.setAttr("lineWidth", M.strokeWidth()), M.getShadowForStrokeEnabled() || this.setAttr("shadowColor", "rgba(0,0,0,0)"), M.getStrokeLinearGradientColorStops() ? this._strokeLinearGradient(M) : this.setAttr("strokeStyle", M.stroke()), M._strokeFunc(this), R || this.restore();
      }
    }
    _applyShadow(M) {
      var E, R, N;
      const U = (E = M.getShadowRGBA()) !== null && E !== void 0 ? E : "black", q = (R = M.getShadowBlur()) !== null && R !== void 0 ? R : 5, j = (N = M.getShadowOffset()) !== null && N !== void 0 ? N : {
        x: 0,
        y: 0
      }, V = M.getAbsoluteScale(), D = this.canvas.getPixelRatio(), G = V.x * D, W = V.y * D;
      this.setAttr("shadowColor", U), this.setAttr("shadowBlur", q * Math.min(Math.abs(G), Math.abs(W))), this.setAttr("shadowOffsetX", j.x * G), this.setAttr("shadowOffsetY", j.y * W);
    }
  }
  Mu.SceneContext = T;
  class A extends _ {
    constructor(M) {
      super(M), this._context = M._canvas.getContext("2d", {
        willReadFrequently: !0
      });
    }
    _fill(M) {
      this.save(), this.setAttr("fillStyle", M.colorKey), M._fillFuncHit(this), this.restore();
    }
    strokeShape(M) {
      M.hasHitStroke() && this._stroke(M);
    }
    _stroke(M) {
      if (M.hasHitStroke()) {
        const E = M.getStrokeScaleEnabled();
        if (!E) {
          this.save();
          const U = this.getCanvas().getPixelRatio();
          this.setTransform(U, 0, 0, U, 0, 0);
        }
        this._applyLineCap(M);
        const R = M.hitStrokeWidth(), N = R === "auto" ? M.strokeWidth() : R;
        this.setAttr("lineWidth", N), this.setAttr("strokeStyle", M.colorKey), M._strokeFuncHit(this), E || this.restore();
      }
    }
  }
  return Mu.HitContext = A, Mu;
}
var n4;
function dv() {
  if (n4) return Au;
  n4 = 1, Object.defineProperty(Au, "__esModule", { value: !0 }), Au.HitCanvas = Au.SceneCanvas = Au.Canvas = void 0;
  const e = lr(), t = K6(), n = Sn();
  let i;
  function s() {
    if (i)
      return i;
    const f = e.Util.createCanvasElement(), p = f.getContext("2d");
    return i = function() {
      const g = n.Konva._global.devicePixelRatio || 1, v = p.webkitBackingStorePixelRatio || p.mozBackingStorePixelRatio || p.msBackingStorePixelRatio || p.oBackingStorePixelRatio || p.backingStorePixelRatio || 1;
      return g / v;
    }(), e.Util.releaseCanvas(f), i;
  }
  let o = class {
    constructor(p) {
      this.pixelRatio = 1, this.width = 0, this.height = 0, this.isCache = !1;
      const v = (p || {}).pixelRatio || n.Konva.pixelRatio || s();
      this.pixelRatio = v, this._canvas = e.Util.createCanvasElement(), this._canvas.style.padding = "0", this._canvas.style.margin = "0", this._canvas.style.border = "0", this._canvas.style.background = "transparent", this._canvas.style.position = "absolute", this._canvas.style.top = "0", this._canvas.style.left = "0";
    }
    getContext() {
      return this.context;
    }
    getPixelRatio() {
      return this.pixelRatio;
    }
    setPixelRatio(p) {
      const g = this.pixelRatio;
      this.pixelRatio = p, this.setSize(this.getWidth() / g, this.getHeight() / g);
    }
    setWidth(p) {
      this.width = this._canvas.width = p * this.pixelRatio, this._canvas.style.width = p + "px";
      const g = this.pixelRatio;
      this.getContext()._context.scale(g, g);
    }
    setHeight(p) {
      this.height = this._canvas.height = p * this.pixelRatio, this._canvas.style.height = p + "px";
      const g = this.pixelRatio;
      this.getContext()._context.scale(g, g);
    }
    getWidth() {
      return this.width;
    }
    getHeight() {
      return this.height;
    }
    setSize(p, g) {
      this.setWidth(p || 0), this.setHeight(g || 0);
    }
    toDataURL(p, g) {
      try {
        return this._canvas.toDataURL(p, g);
      } catch {
        try {
          return this._canvas.toDataURL();
        } catch (x) {
          return e.Util.error("Unable to get data URL. " + x.message + " For more info read https://konvajs.org/docs/posts/Tainted_Canvas.html."), "";
        }
      }
    }
  };
  Au.Canvas = o;
  class u extends o {
    constructor(p = { width: 0, height: 0, willReadFrequently: !1 }) {
      super(p), this.context = new t.SceneContext(this, {
        willReadFrequently: p.willReadFrequently
      }), this.setSize(p.width, p.height);
    }
  }
  Au.SceneCanvas = u;
  class h extends o {
    constructor(p = { width: 0, height: 0 }) {
      super(p), this.hitCanvas = !0, this.context = new t.HitContext(this), this.setSize(p.width, p.height);
    }
  }
  return Au.HitCanvas = h, Au;
}
var Eb = {}, i4;
function q_() {
  return i4 || (i4 = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.DD = void 0;
    const t = Sn(), n = lr();
    e.DD = {
      get isDragging() {
        let i = !1;
        return e.DD._dragElements.forEach((s) => {
          s.dragStatus === "dragging" && (i = !0);
        }), i;
      },
      justDragged: !1,
      get node() {
        let i;
        return e.DD._dragElements.forEach((s) => {
          i = s.node;
        }), i;
      },
      _dragElements: /* @__PURE__ */ new Map(),
      _drag(i) {
        const s = [];
        e.DD._dragElements.forEach((o, u) => {
          const { node: h } = o, f = h.getStage();
          f.setPointersPositions(i), o.pointerId === void 0 && (o.pointerId = n.Util._getFirstPointerId(i));
          const p = f._changedPointerPositions.find((g) => g.id === o.pointerId);
          if (p) {
            if (o.dragStatus !== "dragging") {
              const g = h.dragDistance();
              if (Math.max(Math.abs(p.x - o.startPointerPos.x), Math.abs(p.y - o.startPointerPos.y)) < g || (h.startDrag({ evt: i }), !h.isDragging()))
                return;
            }
            h._setDragPosition(i, o), s.push(h);
          }
        }), s.forEach((o) => {
          o.fire("dragmove", {
            type: "dragmove",
            target: o,
            evt: i
          }, !0);
        });
      },
      _endDragBefore(i) {
        const s = [];
        e.DD._dragElements.forEach((o) => {
          const { node: u } = o, h = u.getStage();
          if (i && h.setPointersPositions(i), !h._changedPointerPositions.find((g) => g.id === o.pointerId))
            return;
          (o.dragStatus === "dragging" || o.dragStatus === "stopped") && (e.DD.justDragged = !0, t.Konva._mouseListenClick = !1, t.Konva._touchListenClick = !1, t.Konva._pointerListenClick = !1, o.dragStatus = "stopped");
          const p = o.node.getLayer() || o.node instanceof t.Konva.Stage && o.node;
          p && s.indexOf(p) === -1 && s.push(p);
        }), s.forEach((o) => {
          o.draw();
        });
      },
      _endDragAfter(i) {
        e.DD._dragElements.forEach((s, o) => {
          s.dragStatus === "stopped" && s.node.fire("dragend", {
            type: "dragend",
            target: s.node,
            evt: i
          }, !0), s.dragStatus !== "dragging" && e.DD._dragElements.delete(o);
        });
      }
    }, t.Konva.isBrowser && (window.addEventListener("mouseup", e.DD._endDragBefore, !0), window.addEventListener("touchend", e.DD._endDragBefore, !0), window.addEventListener("touchcancel", e.DD._endDragBefore, !0), window.addEventListener("mousemove", e.DD._drag), window.addEventListener("touchmove", e.DD._drag), window.addEventListener("mouseup", e.DD._endDragAfter, !1), window.addEventListener("touchend", e.DD._endDragAfter, !1), window.addEventListener("touchcancel", e.DD._endDragAfter, !1));
  }(Eb)), Eb;
}
var r4;
function br() {
  if (r4) return Am;
  r4 = 1, Object.defineProperty(Am, "__esModule", { value: !0 }), Am.Node = void 0;
  const e = lr(), t = An(), n = dv(), i = Sn(), s = q_(), o = Mn(), u = "absoluteOpacity", h = "allEventListeners", f = "absoluteTransform", p = "absoluteScale", g = "canvas", v = "Change", x = "children", b = "konva", _ = "listening", T = "mouseenter", A = "mouseleave", O = "set", M = "Shape", E = " ", R = "stage", N = "transform", U = "Stage", q = "visible", j = [
    "xChange.konva",
    "yChange.konva",
    "scaleXChange.konva",
    "scaleYChange.konva",
    "skewXChange.konva",
    "skewYChange.konva",
    "rotationChange.konva",
    "offsetXChange.konva",
    "offsetYChange.konva",
    "transformsEnabledChange.konva"
  ].join(E);
  let V = 1, D = class y2 {
    constructor(P) {
      this._id = V++, this.eventListeners = {}, this.attrs = {}, this.index = 0, this._allEventListeners = null, this.parent = null, this._cache = /* @__PURE__ */ new Map(), this._attachedDepsListeners = /* @__PURE__ */ new Map(), this._lastPos = null, this._batchingTransformChange = !1, this._needClearTransformCache = !1, this._filterUpToDate = !1, this._isUnderCache = !1, this._dragEventId = null, this._shouldFireChangeEvents = !1, this.setAttrs(P), this._shouldFireChangeEvents = !0;
    }
    hasChildren() {
      return !1;
    }
    _clearCache(P) {
      (P === N || P === f) && this._cache.get(P) ? this._cache.get(P).dirty = !0 : P ? this._cache.delete(P) : this._cache.clear();
    }
    _getCache(P, H) {
      let I = this._cache.get(P);
      return (I === void 0 || (P === N || P === f) && I.dirty === !0) && (I = H.call(this), this._cache.set(P, I)), I;
    }
    _calculate(P, H, I) {
      if (!this._attachedDepsListeners.get(P)) {
        const K = H.map((Q) => Q + "Change.konva").join(E);
        this.on(K, () => {
          this._clearCache(P);
        }), this._attachedDepsListeners.set(P, !0);
      }
      return this._getCache(P, I);
    }
    _getCanvasCache() {
      return this._cache.get(g);
    }
    _clearSelfAndDescendantCache(P) {
      this._clearCache(P), P === f && this.fire("absoluteTransformChange");
    }
    clearCache() {
      if (this._cache.has(g)) {
        const { scene: P, filter: H, hit: I } = this._cache.get(g);
        e.Util.releaseCanvas(P, H, I), this._cache.delete(g);
      }
      return this._clearSelfAndDescendantCache(), this._requestDraw(), this;
    }
    cache(P) {
      const H = P || {};
      let I = {};
      (H.x === void 0 || H.y === void 0 || H.width === void 0 || H.height === void 0) && (I = this.getClientRect({
        skipTransform: !0,
        relativeTo: this.getParent() || void 0
      }));
      let K = Math.ceil(H.width || I.width), Q = Math.ceil(H.height || I.height), it = H.pixelRatio, nt = H.x === void 0 ? Math.floor(I.x) : H.x, X = H.y === void 0 ? Math.floor(I.y) : H.y, rt = H.offset || 0, vt = H.drawBorder || !1, ct = H.hitCanvasPixelRatio || 1;
      if (!K || !Q) {
        e.Util.error("Can not cache the node. Width or height of the node equals 0. Caching is skipped.");
        return;
      }
      const dt = Math.abs(Math.round(I.x) - nt) > 0.5 ? 1 : 0, ht = Math.abs(Math.round(I.y) - X) > 0.5 ? 1 : 0;
      K += rt * 2 + dt, Q += rt * 2 + ht, nt -= rt, X -= rt;
      const Et = new n.SceneCanvas({
        pixelRatio: it,
        width: K,
        height: Q
      }), ot = new n.SceneCanvas({
        pixelRatio: it,
        width: 0,
        height: 0,
        willReadFrequently: !0
      }), lt = new n.HitCanvas({
        pixelRatio: ct,
        width: K,
        height: Q
      }), ft = Et.getContext(), Tt = lt.getContext();
      return lt.isCache = !0, Et.isCache = !0, this._cache.delete(g), this._filterUpToDate = !1, H.imageSmoothingEnabled === !1 && (Et.getContext()._context.imageSmoothingEnabled = !1, ot.getContext()._context.imageSmoothingEnabled = !1), ft.save(), Tt.save(), ft.translate(-nt, -X), Tt.translate(-nt, -X), this._isUnderCache = !0, this._clearSelfAndDescendantCache(u), this._clearSelfAndDescendantCache(p), this.drawScene(Et, this), this.drawHit(lt, this), this._isUnderCache = !1, ft.restore(), Tt.restore(), vt && (ft.save(), ft.beginPath(), ft.rect(0, 0, K, Q), ft.closePath(), ft.setAttr("strokeStyle", "red"), ft.setAttr("lineWidth", 5), ft.stroke(), ft.restore()), this._cache.set(g, {
        scene: Et,
        filter: ot,
        hit: lt,
        x: nt,
        y: X
      }), this._requestDraw(), this;
    }
    isCached() {
      return this._cache.has(g);
    }
    getClientRect(P) {
      throw new Error('abstract "getClientRect" method call');
    }
    _transformedRect(P, H) {
      const I = [
        { x: P.x, y: P.y },
        { x: P.x + P.width, y: P.y },
        { x: P.x + P.width, y: P.y + P.height },
        { x: P.x, y: P.y + P.height }
      ];
      let K = 1 / 0, Q = 1 / 0, it = -1 / 0, nt = -1 / 0;
      const X = this.getAbsoluteTransform(H);
      return I.forEach(function(rt) {
        const vt = X.point(rt);
        K === void 0 && (K = it = vt.x, Q = nt = vt.y), K = Math.min(K, vt.x), Q = Math.min(Q, vt.y), it = Math.max(it, vt.x), nt = Math.max(nt, vt.y);
      }), {
        x: K,
        y: Q,
        width: it - K,
        height: nt - Q
      };
    }
    _drawCachedSceneCanvas(P) {
      P.save(), P._applyOpacity(this), P._applyGlobalCompositeOperation(this);
      const H = this._getCanvasCache();
      P.translate(H.x, H.y);
      const I = this._getCachedSceneCanvas(), K = I.pixelRatio;
      P.drawImage(I._canvas, 0, 0, I.width / K, I.height / K), P.restore();
    }
    _drawCachedHitCanvas(P) {
      const H = this._getCanvasCache(), I = H.hit;
      P.save(), P.translate(H.x, H.y), P.drawImage(I._canvas, 0, 0, I.width / I.pixelRatio, I.height / I.pixelRatio), P.restore();
    }
    _getCachedSceneCanvas() {
      let P = this.filters(), H = this._getCanvasCache(), I = H.scene, K = H.filter, Q = K.getContext(), it, nt, X, rt;
      if (P) {
        if (!this._filterUpToDate) {
          const vt = I.pixelRatio;
          K.setSize(I.width / I.pixelRatio, I.height / I.pixelRatio);
          try {
            for (it = P.length, Q.clear(), Q.drawImage(I._canvas, 0, 0, I.getWidth() / vt, I.getHeight() / vt), nt = Q.getImageData(0, 0, K.getWidth(), K.getHeight()), X = 0; X < it; X++) {
              if (rt = P[X], typeof rt != "function") {
                e.Util.error("Filter should be type of function, but got " + typeof rt + " instead. Please check correct filters");
                continue;
              }
              rt.call(this, nt), Q.putImageData(nt, 0, 0);
            }
          } catch (ct) {
            e.Util.error("Unable to apply filter. " + ct.message + " This post my help you https://konvajs.org/docs/posts/Tainted_Canvas.html.");
          }
          this._filterUpToDate = !0;
        }
        return K;
      }
      return I;
    }
    on(P, H) {
      if (this._cache && this._cache.delete(h), arguments.length === 3)
        return this._delegate.apply(this, arguments);
      let I = P.split(E), K = I.length, Q, it, nt, X, rt;
      for (Q = 0; Q < K; Q++)
        it = I[Q], nt = it.split("."), X = nt[0], rt = nt[1] || "", this.eventListeners[X] || (this.eventListeners[X] = []), this.eventListeners[X].push({
          name: rt,
          handler: H
        });
      return this;
    }
    off(P, H) {
      let I = (P || "").split(E), K = I.length, Q, it, nt, X, rt, vt;
      if (this._cache && this._cache.delete(h), !P)
        for (it in this.eventListeners)
          this._off(it);
      for (Q = 0; Q < K; Q++)
        if (nt = I[Q], X = nt.split("."), rt = X[0], vt = X[1], rt)
          this.eventListeners[rt] && this._off(rt, vt, H);
        else
          for (it in this.eventListeners)
            this._off(it, vt, H);
      return this;
    }
    dispatchEvent(P) {
      const H = {
        target: this,
        type: P.type,
        evt: P
      };
      return this.fire(P.type, H), this;
    }
    addEventListener(P, H) {
      return this.on(P, function(I) {
        H.call(this, I.evt);
      }), this;
    }
    removeEventListener(P) {
      return this.off(P), this;
    }
    _delegate(P, H, I) {
      const K = this;
      this.on(P, function(Q) {
        const it = Q.target.findAncestors(H, !0, K);
        for (let nt = 0; nt < it.length; nt++)
          Q = e.Util.cloneObject(Q), Q.currentTarget = it[nt], I.call(it[nt], Q);
      });
    }
    remove() {
      return this.isDragging() && this.stopDrag(), s.DD._dragElements.delete(this._id), this._remove(), this;
    }
    _clearCaches() {
      this._clearSelfAndDescendantCache(f), this._clearSelfAndDescendantCache(u), this._clearSelfAndDescendantCache(p), this._clearSelfAndDescendantCache(R), this._clearSelfAndDescendantCache(q), this._clearSelfAndDescendantCache(_);
    }
    _remove() {
      this._clearCaches();
      const P = this.getParent();
      P && P.children && (P.children.splice(this.index, 1), P._setChildrenIndices(), this.parent = null);
    }
    destroy() {
      return this.remove(), this.clearCache(), this;
    }
    getAttr(P) {
      const H = "get" + e.Util._capitalize(P);
      return e.Util._isFunction(this[H]) ? this[H]() : this.attrs[P];
    }
    getAncestors() {
      let P = this.getParent(), H = [];
      for (; P; )
        H.push(P), P = P.getParent();
      return H;
    }
    getAttrs() {
      return this.attrs || {};
    }
    setAttrs(P) {
      return this._batchTransformChanges(() => {
        let H, I;
        if (!P)
          return this;
        for (H in P)
          H !== x && (I = O + e.Util._capitalize(H), e.Util._isFunction(this[I]) ? this[I](P[H]) : this._setAttr(H, P[H]));
      }), this;
    }
    isListening() {
      return this._getCache(_, this._isListening);
    }
    _isListening(P) {
      if (!this.listening())
        return !1;
      const I = this.getParent();
      return I && I !== P && this !== P ? I._isListening(P) : !0;
    }
    isVisible() {
      return this._getCache(q, this._isVisible);
    }
    _isVisible(P) {
      if (!this.visible())
        return !1;
      const I = this.getParent();
      return I && I !== P && this !== P ? I._isVisible(P) : !0;
    }
    shouldDrawHit(P, H = !1) {
      if (P)
        return this._isVisible(P) && this._isListening(P);
      const I = this.getLayer();
      let K = !1;
      s.DD._dragElements.forEach((it) => {
        it.dragStatus === "dragging" && (it.node.nodeType === "Stage" || it.node.getLayer() === I) && (K = !0);
      });
      const Q = !H && !i.Konva.hitOnDragEnabled && (K || i.Konva.isTransforming());
      return this.isListening() && this.isVisible() && !Q;
    }
    show() {
      return this.visible(!0), this;
    }
    hide() {
      return this.visible(!1), this;
    }
    getZIndex() {
      return this.index || 0;
    }
    getAbsoluteZIndex() {
      let P = this.getDepth(), H = this, I = 0, K, Q, it, nt;
      function X(vt) {
        for (K = [], Q = vt.length, it = 0; it < Q; it++)
          nt = vt[it], I++, nt.nodeType !== M && (K = K.concat(nt.getChildren().slice())), nt._id === H._id && (it = Q);
        K.length > 0 && K[0].getDepth() <= P && X(K);
      }
      const rt = this.getStage();
      return H.nodeType !== U && rt && X(rt.getChildren()), I;
    }
    getDepth() {
      let P = 0, H = this.parent;
      for (; H; )
        P++, H = H.parent;
      return P;
    }
    _batchTransformChanges(P) {
      this._batchingTransformChange = !0, P(), this._batchingTransformChange = !1, this._needClearTransformCache && (this._clearCache(N), this._clearSelfAndDescendantCache(f)), this._needClearTransformCache = !1;
    }
    setPosition(P) {
      return this._batchTransformChanges(() => {
        this.x(P.x), this.y(P.y);
      }), this;
    }
    getPosition() {
      return {
        x: this.x(),
        y: this.y()
      };
    }
    getRelativePointerPosition() {
      const P = this.getStage();
      if (!P)
        return null;
      const H = P.getPointerPosition();
      if (!H)
        return null;
      const I = this.getAbsoluteTransform().copy();
      return I.invert(), I.point(H);
    }
    getAbsolutePosition(P) {
      let H = !1, I = this.parent;
      for (; I; ) {
        if (I.isCached()) {
          H = !0;
          break;
        }
        I = I.parent;
      }
      H && !P && (P = !0);
      const K = this.getAbsoluteTransform(P).getMatrix(), Q = new e.Transform(), it = this.offset();
      return Q.m = K.slice(), Q.translate(it.x, it.y), Q.getTranslation();
    }
    setAbsolutePosition(P) {
      const { x: H, y: I, ...K } = this._clearTransform();
      this.attrs.x = H, this.attrs.y = I, this._clearCache(N);
      const Q = this._getAbsoluteTransform().copy();
      return Q.invert(), Q.translate(P.x, P.y), P = {
        x: this.attrs.x + Q.getTranslation().x,
        y: this.attrs.y + Q.getTranslation().y
      }, this._setTransform(K), this.setPosition({ x: P.x, y: P.y }), this._clearCache(N), this._clearSelfAndDescendantCache(f), this;
    }
    _setTransform(P) {
      let H;
      for (H in P)
        this.attrs[H] = P[H];
    }
    _clearTransform() {
      const P = {
        x: this.x(),
        y: this.y(),
        rotation: this.rotation(),
        scaleX: this.scaleX(),
        scaleY: this.scaleY(),
        offsetX: this.offsetX(),
        offsetY: this.offsetY(),
        skewX: this.skewX(),
        skewY: this.skewY()
      };
      return this.attrs.x = 0, this.attrs.y = 0, this.attrs.rotation = 0, this.attrs.scaleX = 1, this.attrs.scaleY = 1, this.attrs.offsetX = 0, this.attrs.offsetY = 0, this.attrs.skewX = 0, this.attrs.skewY = 0, P;
    }
    move(P) {
      let H = P.x, I = P.y, K = this.x(), Q = this.y();
      return H !== void 0 && (K += H), I !== void 0 && (Q += I), this.setPosition({ x: K, y: Q }), this;
    }
    _eachAncestorReverse(P, H) {
      let I = [], K = this.getParent(), Q, it;
      if (!(H && H._id === this._id)) {
        for (I.unshift(this); K && (!H || K._id !== H._id); )
          I.unshift(K), K = K.parent;
        for (Q = I.length, it = 0; it < Q; it++)
          P(I[it]);
      }
    }
    rotate(P) {
      return this.rotation(this.rotation() + P), this;
    }
    moveToTop() {
      if (!this.parent)
        return e.Util.warn("Node has no parent. moveToTop function is ignored."), !1;
      const P = this.index, H = this.parent.getChildren().length;
      return P < H - 1 ? (this.parent.children.splice(P, 1), this.parent.children.push(this), this.parent._setChildrenIndices(), !0) : !1;
    }
    moveUp() {
      if (!this.parent)
        return e.Util.warn("Node has no parent. moveUp function is ignored."), !1;
      const P = this.index, H = this.parent.getChildren().length;
      return P < H - 1 ? (this.parent.children.splice(P, 1), this.parent.children.splice(P + 1, 0, this), this.parent._setChildrenIndices(), !0) : !1;
    }
    moveDown() {
      if (!this.parent)
        return e.Util.warn("Node has no parent. moveDown function is ignored."), !1;
      const P = this.index;
      return P > 0 ? (this.parent.children.splice(P, 1), this.parent.children.splice(P - 1, 0, this), this.parent._setChildrenIndices(), !0) : !1;
    }
    moveToBottom() {
      if (!this.parent)
        return e.Util.warn("Node has no parent. moveToBottom function is ignored."), !1;
      const P = this.index;
      return P > 0 ? (this.parent.children.splice(P, 1), this.parent.children.unshift(this), this.parent._setChildrenIndices(), !0) : !1;
    }
    setZIndex(P) {
      if (!this.parent)
        return e.Util.warn("Node has no parent. zIndex parameter is ignored."), this;
      (P < 0 || P >= this.parent.children.length) && e.Util.warn("Unexpected value " + P + " for zIndex property. zIndex is just index of a node in children of its parent. Expected value is from 0 to " + (this.parent.children.length - 1) + ".");
      const H = this.index;
      return this.parent.children.splice(H, 1), this.parent.children.splice(P, 0, this), this.parent._setChildrenIndices(), this;
    }
    getAbsoluteOpacity() {
      return this._getCache(u, this._getAbsoluteOpacity);
    }
    _getAbsoluteOpacity() {
      let P = this.opacity();
      const H = this.getParent();
      return H && !H._isUnderCache && (P *= H.getAbsoluteOpacity()), P;
    }
    moveTo(P) {
      return this.getParent() !== P && (this._remove(), P.add(this)), this;
    }
    toObject() {
      let P = this.getAttrs(), H, I, K, Q, it;
      const nt = {
        attrs: {},
        className: this.getClassName()
      };
      for (H in P)
        I = P[H], it = e.Util.isObject(I) && !e.Util._isPlainObject(I) && !e.Util._isArray(I), !it && (K = typeof this[H] == "function" && this[H], delete P[H], Q = K ? K.call(this) : null, P[H] = I, Q !== I && (nt.attrs[H] = I));
      return e.Util._prepareToStringify(nt);
    }
    toJSON() {
      return JSON.stringify(this.toObject());
    }
    getParent() {
      return this.parent;
    }
    findAncestors(P, H, I) {
      const K = [];
      H && this._isMatch(P) && K.push(this);
      let Q = this.parent;
      for (; Q; ) {
        if (Q === I)
          return K;
        Q._isMatch(P) && K.push(Q), Q = Q.parent;
      }
      return K;
    }
    isAncestorOf(P) {
      return !1;
    }
    findAncestor(P, H, I) {
      return this.findAncestors(P, H, I)[0];
    }
    _isMatch(P) {
      if (!P)
        return !1;
      if (typeof P == "function")
        return P(this);
      let H = P.replace(/ /g, "").split(","), I = H.length, K, Q;
      for (K = 0; K < I; K++)
        if (Q = H[K], e.Util.isValidSelector(Q) || (e.Util.warn('Selector "' + Q + '" is invalid. Allowed selectors examples are "#foo", ".bar" or "Group".'), e.Util.warn('If you have a custom shape with such className, please change it to start with upper letter like "Triangle".'), e.Util.warn("Konva is awesome, right?")), Q.charAt(0) === "#") {
          if (this.id() === Q.slice(1))
            return !0;
        } else if (Q.charAt(0) === ".") {
          if (this.hasName(Q.slice(1)))
            return !0;
        } else if (this.className === Q || this.nodeType === Q)
          return !0;
      return !1;
    }
    getLayer() {
      const P = this.getParent();
      return P ? P.getLayer() : null;
    }
    getStage() {
      return this._getCache(R, this._getStage);
    }
    _getStage() {
      const P = this.getParent();
      return P ? P.getStage() : null;
    }
    fire(P, H = {}, I) {
      return H.target = H.target || this, I ? this._fireAndBubble(P, H) : this._fire(P, H), this;
    }
    getAbsoluteTransform(P) {
      return P ? this._getAbsoluteTransform(P) : this._getCache(f, this._getAbsoluteTransform);
    }
    _getAbsoluteTransform(P) {
      let H;
      if (P)
        return H = new e.Transform(), this._eachAncestorReverse(function(I) {
          const K = I.transformsEnabled();
          K === "all" ? H.multiply(I.getTransform()) : K === "position" && H.translate(I.x() - I.offsetX(), I.y() - I.offsetY());
        }, P), H;
      {
        H = this._cache.get(f) || new e.Transform(), this.parent ? this.parent.getAbsoluteTransform().copyInto(H) : H.reset();
        const I = this.transformsEnabled();
        if (I === "all")
          H.multiply(this.getTransform());
        else if (I === "position") {
          const K = this.attrs.x || 0, Q = this.attrs.y || 0, it = this.attrs.offsetX || 0, nt = this.attrs.offsetY || 0;
          H.translate(K - it, Q - nt);
        }
        return H.dirty = !1, H;
      }
    }
    getAbsoluteScale(P) {
      let H = this;
      for (; H; )
        H._isUnderCache && (P = H), H = H.getParent();
      const K = this.getAbsoluteTransform(P).decompose();
      return {
        x: K.scaleX,
        y: K.scaleY
      };
    }
    getAbsoluteRotation() {
      return this.getAbsoluteTransform().decompose().rotation;
    }
    getTransform() {
      return this._getCache(N, this._getTransform);
    }
    _getTransform() {
      var P, H;
      const I = this._cache.get(N) || new e.Transform();
      I.reset();
      const K = this.x(), Q = this.y(), it = i.Konva.getAngle(this.rotation()), nt = (P = this.attrs.scaleX) !== null && P !== void 0 ? P : 1, X = (H = this.attrs.scaleY) !== null && H !== void 0 ? H : 1, rt = this.attrs.skewX || 0, vt = this.attrs.skewY || 0, ct = this.attrs.offsetX || 0, dt = this.attrs.offsetY || 0;
      return (K !== 0 || Q !== 0) && I.translate(K, Q), it !== 0 && I.rotate(it), (rt !== 0 || vt !== 0) && I.skew(rt, vt), (nt !== 1 || X !== 1) && I.scale(nt, X), (ct !== 0 || dt !== 0) && I.translate(-1 * ct, -1 * dt), I.dirty = !1, I;
    }
    clone(P) {
      let H = e.Util.cloneObject(this.attrs), I, K, Q, it, nt;
      for (I in P)
        H[I] = P[I];
      const X = new this.constructor(H);
      for (I in this.eventListeners)
        for (K = this.eventListeners[I], Q = K.length, it = 0; it < Q; it++)
          nt = K[it], nt.name.indexOf(b) < 0 && (X.eventListeners[I] || (X.eventListeners[I] = []), X.eventListeners[I].push(nt));
      return X;
    }
    _toKonvaCanvas(P) {
      P = P || {};
      const H = this.getClientRect(), I = this.getStage(), K = P.x !== void 0 ? P.x : Math.floor(H.x), Q = P.y !== void 0 ? P.y : Math.floor(H.y), it = P.pixelRatio || 1, nt = new n.SceneCanvas({
        width: P.width || Math.ceil(H.width) || (I ? I.width() : 0),
        height: P.height || Math.ceil(H.height) || (I ? I.height() : 0),
        pixelRatio: it
      }), X = nt.getContext(), rt = new n.SceneCanvas({
        width: nt.width / nt.pixelRatio + Math.abs(K),
        height: nt.height / nt.pixelRatio + Math.abs(Q),
        pixelRatio: nt.pixelRatio
      });
      return P.imageSmoothingEnabled === !1 && (X._context.imageSmoothingEnabled = !1), X.save(), (K || Q) && X.translate(-1 * K, -1 * Q), this.drawScene(nt, void 0, rt), X.restore(), nt;
    }
    toCanvas(P) {
      return this._toKonvaCanvas(P)._canvas;
    }
    toDataURL(P) {
      P = P || {};
      const H = P.mimeType || null, I = P.quality || null, K = this._toKonvaCanvas(P).toDataURL(H, I);
      return P.callback && P.callback(K), K;
    }
    toImage(P) {
      return new Promise((H, I) => {
        try {
          const K = P == null ? void 0 : P.callback;
          K && delete P.callback, e.Util._urlToImage(this.toDataURL(P), function(Q) {
            H(Q), K == null || K(Q);
          });
        } catch (K) {
          I(K);
        }
      });
    }
    toBlob(P) {
      return new Promise((H, I) => {
        try {
          const K = P == null ? void 0 : P.callback;
          K && delete P.callback, this.toCanvas(P).toBlob((Q) => {
            H(Q), K == null || K(Q);
          }, P == null ? void 0 : P.mimeType, P == null ? void 0 : P.quality);
        } catch (K) {
          I(K);
        }
      });
    }
    setSize(P) {
      return this.width(P.width), this.height(P.height), this;
    }
    getSize() {
      return {
        width: this.width(),
        height: this.height()
      };
    }
    getClassName() {
      return this.className || this.nodeType;
    }
    getType() {
      return this.nodeType;
    }
    getDragDistance() {
      return this.attrs.dragDistance !== void 0 ? this.attrs.dragDistance : this.parent ? this.parent.getDragDistance() : i.Konva.dragDistance;
    }
    _off(P, H, I) {
      let K = this.eventListeners[P], Q, it, nt;
      for (Q = 0; Q < K.length; Q++)
        if (it = K[Q].name, nt = K[Q].handler, (it !== "konva" || H === "konva") && (!H || it === H) && (!I || I === nt)) {
          if (K.splice(Q, 1), K.length === 0) {
            delete this.eventListeners[P];
            break;
          }
          Q--;
        }
    }
    _fireChangeEvent(P, H, I) {
      this._fire(P + v, {
        oldVal: H,
        newVal: I
      });
    }
    addName(P) {
      if (!this.hasName(P)) {
        const H = this.name(), I = H ? H + " " + P : P;
        this.name(I);
      }
      return this;
    }
    hasName(P) {
      if (!P)
        return !1;
      const H = this.name();
      return H ? (H || "").split(/\s/g).indexOf(P) !== -1 : !1;
    }
    removeName(P) {
      const H = (this.name() || "").split(/\s/g), I = H.indexOf(P);
      return I !== -1 && (H.splice(I, 1), this.name(H.join(" "))), this;
    }
    setAttr(P, H) {
      const I = this[O + e.Util._capitalize(P)];
      return e.Util._isFunction(I) ? I.call(this, H) : this._setAttr(P, H), this;
    }
    _requestDraw() {
      if (i.Konva.autoDrawEnabled) {
        const P = this.getLayer() || this.getStage();
        P == null || P.batchDraw();
      }
    }
    _setAttr(P, H) {
      const I = this.attrs[P];
      I === H && !e.Util.isObject(H) || (H == null ? delete this.attrs[P] : this.attrs[P] = H, this._shouldFireChangeEvents && this._fireChangeEvent(P, I, H), this._requestDraw());
    }
    _setComponentAttr(P, H, I) {
      let K;
      I !== void 0 && (K = this.attrs[P], K || (this.attrs[P] = this.getAttr(P)), this.attrs[P][H] = I, this._fireChangeEvent(P, K, I));
    }
    _fireAndBubble(P, H, I) {
      if (H && this.nodeType === M && (H.target = this), !((P === T || P === A) && (I && (this === I || this.isAncestorOf && this.isAncestorOf(I)) || this.nodeType === "Stage" && !I))) {
        this._fire(P, H);
        const Q = (P === T || P === A) && I && I.isAncestorOf && I.isAncestorOf(this) && !I.isAncestorOf(this.parent);
        (H && !H.cancelBubble || !H) && this.parent && this.parent.isListening() && !Q && (I && I.parent ? this._fireAndBubble.call(this.parent, P, H, I) : this._fireAndBubble.call(this.parent, P, H));
      }
    }
    _getProtoListeners(P) {
      var H, I, K;
      const Q = (H = this._cache.get(h)) !== null && H !== void 0 ? H : {};
      let it = Q == null ? void 0 : Q[P];
      if (it === void 0) {
        it = [];
        let nt = Object.getPrototypeOf(this);
        for (; nt; ) {
          const X = (K = (I = nt.eventListeners) === null || I === void 0 ? void 0 : I[P]) !== null && K !== void 0 ? K : [];
          it.push(...X), nt = Object.getPrototypeOf(nt);
        }
        Q[P] = it, this._cache.set(h, Q);
      }
      return it;
    }
    _fire(P, H) {
      H = H || {}, H.currentTarget = this, H.type = P;
      const I = this._getProtoListeners(P);
      if (I)
        for (var K = 0; K < I.length; K++)
          I[K].handler.call(this, H);
      const Q = this.eventListeners[P];
      if (Q)
        for (var K = 0; K < Q.length; K++)
          Q[K].handler.call(this, H);
    }
    draw() {
      return this.drawScene(), this.drawHit(), this;
    }
    _createDragElement(P) {
      const H = P ? P.pointerId : void 0, I = this.getStage(), K = this.getAbsolutePosition();
      if (!I)
        return;
      const Q = I._getPointerById(H) || I._changedPointerPositions[0] || K;
      s.DD._dragElements.set(this._id, {
        node: this,
        startPointerPos: Q,
        offset: {
          x: Q.x - K.x,
          y: Q.y - K.y
        },
        dragStatus: "ready",
        pointerId: H
      });
    }
    startDrag(P, H = !0) {
      s.DD._dragElements.has(this._id) || this._createDragElement(P);
      const I = s.DD._dragElements.get(this._id);
      I.dragStatus = "dragging", this.fire("dragstart", {
        type: "dragstart",
        target: this,
        evt: P && P.evt
      }, H);
    }
    _setDragPosition(P, H) {
      const I = this.getStage()._getPointerById(H.pointerId);
      if (!I)
        return;
      let K = {
        x: I.x - H.offset.x,
        y: I.y - H.offset.y
      };
      const Q = this.dragBoundFunc();
      if (Q !== void 0) {
        const it = Q.call(this, K, P);
        it ? K = it : e.Util.warn("dragBoundFunc did not return any value. That is unexpected behavior. You must return new absolute position from dragBoundFunc.");
      }
      (!this._lastPos || this._lastPos.x !== K.x || this._lastPos.y !== K.y) && (this.setAbsolutePosition(K), this._requestDraw()), this._lastPos = K;
    }
    stopDrag(P) {
      const H = s.DD._dragElements.get(this._id);
      H && (H.dragStatus = "stopped"), s.DD._endDragBefore(P), s.DD._endDragAfter(P);
    }
    setDraggable(P) {
      this._setAttr("draggable", P), this._dragChange();
    }
    isDragging() {
      const P = s.DD._dragElements.get(this._id);
      return P ? P.dragStatus === "dragging" : !1;
    }
    _listenDrag() {
      this._dragCleanup(), this.on("mousedown.konva touchstart.konva", function(P) {
        if (!(!(P.evt.button !== void 0) || i.Konva.dragButtons.indexOf(P.evt.button) >= 0) || this.isDragging())
          return;
        let K = !1;
        s.DD._dragElements.forEach((Q) => {
          this.isAncestorOf(Q.node) && (K = !0);
        }), K || this._createDragElement(P);
      });
    }
    _dragChange() {
      if (this.attrs.draggable)
        this._listenDrag();
      else {
        if (this._dragCleanup(), !this.getStage())
          return;
        const H = s.DD._dragElements.get(this._id), I = H && H.dragStatus === "dragging", K = H && H.dragStatus === "ready";
        I ? this.stopDrag() : K && s.DD._dragElements.delete(this._id);
      }
    }
    _dragCleanup() {
      this.off("mousedown.konva"), this.off("touchstart.konva");
    }
    isClientRectOnScreen(P = { x: 0, y: 0 }) {
      const H = this.getStage();
      if (!H)
        return !1;
      const I = {
        x: -P.x,
        y: -P.y,
        width: H.width() + 2 * P.x,
        height: H.height() + 2 * P.y
      };
      return e.Util.haveIntersection(I, this.getClientRect());
    }
    static create(P, H) {
      return e.Util._isString(P) && (P = JSON.parse(P)), this._createNode(P, H);
    }
    static _createNode(P, H) {
      let I = y2.prototype.getClassName.call(P), K = P.children, Q, it, nt;
      H && (P.attrs.container = H), i.Konva[I] || (e.Util.warn('Can not find a node with class name "' + I + '". Fallback to "Shape".'), I = "Shape");
      const X = i.Konva[I];
      if (Q = new X(P.attrs), K)
        for (it = K.length, nt = 0; nt < it; nt++)
          Q.add(y2._createNode(K[nt]));
      return Q;
    }
  };
  Am.Node = D, D.prototype.nodeType = "Node", D.prototype._attrsAffectingSize = [], D.prototype.eventListeners = {}, D.prototype.on.call(D.prototype, j, function() {
    if (this._batchingTransformChange) {
      this._needClearTransformCache = !0;
      return;
    }
    this._clearCache(N), this._clearSelfAndDescendantCache(f);
  }), D.prototype.on.call(D.prototype, "visibleChange.konva", function() {
    this._clearSelfAndDescendantCache(q);
  }), D.prototype.on.call(D.prototype, "listeningChange.konva", function() {
    this._clearSelfAndDescendantCache(_);
  }), D.prototype.on.call(D.prototype, "opacityChange.konva", function() {
    this._clearSelfAndDescendantCache(u);
  });
  const G = t.Factory.addGetterSetter;
  return G(D, "zIndex"), G(D, "absolutePosition"), G(D, "position"), G(D, "x", 0, (0, o.getNumberValidator)()), G(D, "y", 0, (0, o.getNumberValidator)()), G(D, "globalCompositeOperation", "source-over", (0, o.getStringValidator)()), G(D, "opacity", 1, (0, o.getNumberValidator)()), G(D, "name", "", (0, o.getStringValidator)()), G(D, "id", "", (0, o.getStringValidator)()), G(D, "rotation", 0, (0, o.getNumberValidator)()), t.Factory.addComponentsGetterSetter(D, "scale", ["x", "y"]), G(D, "scaleX", 1, (0, o.getNumberValidator)()), G(D, "scaleY", 1, (0, o.getNumberValidator)()), t.Factory.addComponentsGetterSetter(D, "skew", ["x", "y"]), G(D, "skewX", 0, (0, o.getNumberValidator)()), G(D, "skewY", 0, (0, o.getNumberValidator)()), t.Factory.addComponentsGetterSetter(D, "offset", ["x", "y"]), G(D, "offsetX", 0, (0, o.getNumberValidator)()), G(D, "offsetY", 0, (0, o.getNumberValidator)()), G(D, "dragDistance", void 0, (0, o.getNumberValidator)()), G(D, "width", 0, (0, o.getNumberValidator)()), G(D, "height", 0, (0, o.getNumberValidator)()), G(D, "listening", !0, (0, o.getBooleanValidator)()), G(D, "preventDefault", !0, (0, o.getBooleanValidator)()), G(D, "filters", void 0, function(W) {
    return this._filterUpToDate = !1, W;
  }), G(D, "visible", !0, (0, o.getBooleanValidator)()), G(D, "transformsEnabled", "all", (0, o.getStringValidator)()), G(D, "size"), G(D, "dragBoundFunc"), G(D, "draggable", !1, (0, o.getBooleanValidator)()), t.Factory.backCompat(D, {
    rotateDeg: "rotate",
    setRotationDeg: "setRotation",
    getRotationDeg: "getRotation"
  }), Am;
}
var Mm = {}, a4;
function hv() {
  if (a4) return Mm;
  a4 = 1, Object.defineProperty(Mm, "__esModule", { value: !0 }), Mm.Container = void 0;
  const e = An(), t = br(), n = Mn();
  let i = class extends t.Node {
    constructor() {
      super(...arguments), this.children = [];
    }
    getChildren(o) {
      if (!o)
        return this.children || [];
      const u = this.children || [], h = [];
      return u.forEach(function(f) {
        o(f) && h.push(f);
      }), h;
    }
    hasChildren() {
      return this.getChildren().length > 0;
    }
    removeChildren() {
      return this.getChildren().forEach((o) => {
        o.parent = null, o.index = 0, o.remove();
      }), this.children = [], this._requestDraw(), this;
    }
    destroyChildren() {
      return this.getChildren().forEach((o) => {
        o.parent = null, o.index = 0, o.destroy();
      }), this.children = [], this._requestDraw(), this;
    }
    add(...o) {
      if (o.length === 0)
        return this;
      if (o.length > 1) {
        for (let h = 0; h < o.length; h++)
          this.add(o[h]);
        return this;
      }
      const u = o[0];
      return u.getParent() ? (u.moveTo(this), this) : (this._validateAdd(u), u.index = this.getChildren().length, u.parent = this, u._clearCaches(), this.getChildren().push(u), this._fire("add", {
        child: u
      }), this._requestDraw(), this);
    }
    destroy() {
      return this.hasChildren() && this.destroyChildren(), super.destroy(), this;
    }
    find(o) {
      return this._generalFind(o, !1);
    }
    findOne(o) {
      const u = this._generalFind(o, !0);
      return u.length > 0 ? u[0] : void 0;
    }
    _generalFind(o, u) {
      const h = [];
      return this._descendants((f) => {
        const p = f._isMatch(o);
        return p && h.push(f), !!(p && u);
      }), h;
    }
    _descendants(o) {
      let u = !1;
      const h = this.getChildren();
      for (const f of h) {
        if (u = o(f), u)
          return !0;
        if (f.hasChildren() && (u = f._descendants(o), u))
          return !0;
      }
      return !1;
    }
    toObject() {
      const o = t.Node.prototype.toObject.call(this);
      return o.children = [], this.getChildren().forEach((u) => {
        o.children.push(u.toObject());
      }), o;
    }
    isAncestorOf(o) {
      let u = o.getParent();
      for (; u; ) {
        if (u._id === this._id)
          return !0;
        u = u.getParent();
      }
      return !1;
    }
    clone(o) {
      const u = t.Node.prototype.clone.call(this, o);
      return this.getChildren().forEach(function(h) {
        u.add(h.clone());
      }), u;
    }
    getAllIntersections(o) {
      const u = [];
      return this.find("Shape").forEach((h) => {
        h.isVisible() && h.intersects(o) && u.push(h);
      }), u;
    }
    _clearSelfAndDescendantCache(o) {
      var u;
      super._clearSelfAndDescendantCache(o), !this.isCached() && ((u = this.children) === null || u === void 0 || u.forEach(function(h) {
        h._clearSelfAndDescendantCache(o);
      }));
    }
    _setChildrenIndices() {
      var o;
      (o = this.children) === null || o === void 0 || o.forEach(function(u, h) {
        u.index = h;
      }), this._requestDraw();
    }
    drawScene(o, u, h) {
      const f = this.getLayer(), p = o || f && f.getCanvas(), g = p && p.getContext(), v = this._getCanvasCache(), x = v && v.scene, b = p && p.isCache;
      if (!this.isVisible() && !b)
        return this;
      if (x) {
        g.save();
        const _ = this.getAbsoluteTransform(u).getMatrix();
        g.transform(_[0], _[1], _[2], _[3], _[4], _[5]), this._drawCachedSceneCanvas(g), g.restore();
      } else
        this._drawChildren("drawScene", p, u, h);
      return this;
    }
    drawHit(o, u) {
      if (!this.shouldDrawHit(u))
        return this;
      const h = this.getLayer(), f = o || h && h.hitCanvas, p = f && f.getContext(), g = this._getCanvasCache();
      if (g && g.hit) {
        p.save();
        const x = this.getAbsoluteTransform(u).getMatrix();
        p.transform(x[0], x[1], x[2], x[3], x[4], x[5]), this._drawCachedHitCanvas(p), p.restore();
      } else
        this._drawChildren("drawHit", f, u);
      return this;
    }
    _drawChildren(o, u, h, f) {
      var p;
      const g = u && u.getContext(), v = this.clipWidth(), x = this.clipHeight(), b = this.clipFunc(), _ = typeof v == "number" && typeof x == "number" || b, T = h === this;
      if (_) {
        g.save();
        const O = this.getAbsoluteTransform(h);
        let M = O.getMatrix();
        g.transform(M[0], M[1], M[2], M[3], M[4], M[5]), g.beginPath();
        let E;
        if (b)
          E = b.call(this, g, this);
        else {
          const R = this.clipX(), N = this.clipY();
          g.rect(R || 0, N || 0, v, x);
        }
        g.clip.apply(g, E), M = O.copy().invert().getMatrix(), g.transform(M[0], M[1], M[2], M[3], M[4], M[5]);
      }
      const A = !T && this.globalCompositeOperation() !== "source-over" && o === "drawScene";
      A && (g.save(), g._applyGlobalCompositeOperation(this)), (p = this.children) === null || p === void 0 || p.forEach(function(O) {
        O[o](u, h, f);
      }), A && g.restore(), _ && g.restore();
    }
    getClientRect(o = {}) {
      var u;
      const h = o.skipTransform, f = o.relativeTo;
      let p, g, v, x, b = {
        x: 1 / 0,
        y: 1 / 0,
        width: 0,
        height: 0
      };
      const _ = this;
      (u = this.children) === null || u === void 0 || u.forEach(function(O) {
        if (!O.visible())
          return;
        const M = O.getClientRect({
          relativeTo: _,
          skipShadow: o.skipShadow,
          skipStroke: o.skipStroke
        });
        M.width === 0 && M.height === 0 || (p === void 0 ? (p = M.x, g = M.y, v = M.x + M.width, x = M.y + M.height) : (p = Math.min(p, M.x), g = Math.min(g, M.y), v = Math.max(v, M.x + M.width), x = Math.max(x, M.y + M.height)));
      });
      const T = this.find("Shape");
      let A = !1;
      for (let O = 0; O < T.length; O++)
        if (T[O]._isVisible(this)) {
          A = !0;
          break;
        }
      return A && p !== void 0 ? b = {
        x: p,
        y: g,
        width: v - p,
        height: x - g
      } : b = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      }, h ? b : this._transformedRect(b, f);
    }
  };
  return Mm.Container = i, e.Factory.addComponentsGetterSetter(i, "clip", [
    "x",
    "y",
    "width",
    "height"
  ]), e.Factory.addGetterSetter(i, "clipX", void 0, (0, n.getNumberValidator)()), e.Factory.addGetterSetter(i, "clipY", void 0, (0, n.getNumberValidator)()), e.Factory.addGetterSetter(i, "clipWidth", void 0, (0, n.getNumberValidator)()), e.Factory.addGetterSetter(i, "clipHeight", void 0, (0, n.getNumberValidator)()), e.Factory.addGetterSetter(i, "clipFunc"), Mm;
}
var Ab = {}, Md = {}, s4;
function Y6() {
  if (s4) return Md;
  s4 = 1, Object.defineProperty(Md, "__esModule", { value: !0 }), Md.getCapturedShape = i, Md.createEvent = s, Md.hasPointerCapture = o, Md.setPointerCapture = u, Md.releaseCapture = h;
  const e = Sn(), t = /* @__PURE__ */ new Map(), n = e.Konva._global.PointerEvent !== void 0;
  function i(f) {
    return t.get(f);
  }
  function s(f) {
    return {
      evt: f,
      pointerId: f.pointerId
    };
  }
  function o(f, p) {
    return t.get(f) === p;
  }
  function u(f, p) {
    h(f), p.getStage() && (t.set(f, p), n && p._fire("gotpointercapture", s(new PointerEvent("gotpointercapture"))));
  }
  function h(f, p) {
    const g = t.get(f);
    if (!g)
      return;
    const v = g.getStage();
    v && v.content, t.delete(f), n && g._fire("lostpointercapture", s(new PointerEvent("lostpointercapture")));
  }
  return Md;
}
var o4;
function zU() {
  return o4 || (o4 = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.Stage = e.stages = void 0;
    const t = lr(), n = An(), i = hv(), s = Sn(), o = dv(), u = q_(), h = Sn(), f = Y6(), p = "Stage", g = "string", v = "px", x = "mouseout", b = "mouseleave", _ = "mouseover", T = "mouseenter", A = "mousemove", O = "mousedown", M = "mouseup", E = "pointermove", R = "pointerdown", N = "pointerup", U = "pointercancel", q = "lostpointercapture", j = "pointerout", V = "pointerleave", D = "pointerover", G = "pointerenter", W = "contextmenu", P = "touchstart", H = "touchend", I = "touchmove", K = "touchcancel", Q = "wheel", it = 5, nt = [
      [T, "_pointerenter"],
      [O, "_pointerdown"],
      [A, "_pointermove"],
      [M, "_pointerup"],
      [b, "_pointerleave"],
      [P, "_pointerdown"],
      [I, "_pointermove"],
      [H, "_pointerup"],
      [K, "_pointercancel"],
      [_, "_pointerover"],
      [Q, "_wheel"],
      [W, "_contextmenu"],
      [R, "_pointerdown"],
      [E, "_pointermove"],
      [N, "_pointerup"],
      [U, "_pointercancel"],
      [q, "_lostpointercapture"]
    ], X = {
      mouse: {
        [j]: x,
        [V]: b,
        [D]: _,
        [G]: T,
        [E]: A,
        [R]: O,
        [N]: M,
        [U]: "mousecancel",
        pointerclick: "click",
        pointerdblclick: "dblclick"
      },
      touch: {
        [j]: "touchout",
        [V]: "touchleave",
        [D]: "touchover",
        [G]: "touchenter",
        [E]: I,
        [R]: P,
        [N]: H,
        [U]: K,
        pointerclick: "tap",
        pointerdblclick: "dbltap"
      },
      pointer: {
        [j]: j,
        [V]: V,
        [D]: D,
        [G]: G,
        [E]: E,
        [R]: R,
        [N]: N,
        [U]: U,
        pointerclick: "pointerclick",
        pointerdblclick: "pointerdblclick"
      }
    }, rt = (Et) => Et.indexOf("pointer") >= 0 ? "pointer" : Et.indexOf("touch") >= 0 ? "touch" : "mouse", vt = (Et) => {
      const ot = rt(Et);
      if (ot === "pointer")
        return s.Konva.pointerEventsEnabled && X.pointer;
      if (ot === "touch")
        return X.touch;
      if (ot === "mouse")
        return X.mouse;
    };
    function ct(Et = {}) {
      return (Et.clipFunc || Et.clipWidth || Et.clipHeight) && t.Util.warn("Stage does not support clipping. Please use clip for Layers or Groups."), Et;
    }
    const dt = "Pointer position is missing and not registered by the stage. Looks like it is outside of the stage container. You can set it manually from event: stage.setPointersPositions(event);";
    e.stages = [];
    class ht extends i.Container {
      constructor(ot) {
        super(ct(ot)), this._pointerPositions = [], this._changedPointerPositions = [], this._buildDOM(), this._bindContentEvents(), e.stages.push(this), this.on("widthChange.konva heightChange.konva", this._resizeDOM), this.on("visibleChange.konva", this._checkVisibility), this.on("clipWidthChange.konva clipHeightChange.konva clipFuncChange.konva", () => {
          ct(this.attrs);
        }), this._checkVisibility();
      }
      _validateAdd(ot) {
        const lt = ot.getType() === "Layer", ft = ot.getType() === "FastLayer";
        lt || ft || t.Util.throw("You may only add layers to the stage.");
      }
      _checkVisibility() {
        if (!this.content)
          return;
        const ot = this.visible() ? "" : "none";
        this.content.style.display = ot;
      }
      setContainer(ot) {
        if (typeof ot === g) {
          if (ot.charAt(0) === ".") {
            const ft = ot.slice(1);
            ot = document.getElementsByClassName(ft)[0];
          } else {
            var lt;
            ot.charAt(0) !== "#" ? lt = ot : lt = ot.slice(1), ot = document.getElementById(lt);
          }
          if (!ot)
            throw "Can not find container in document with id " + lt;
        }
        return this._setAttr("container", ot), this.content && (this.content.parentElement && this.content.parentElement.removeChild(this.content), ot.appendChild(this.content)), this;
      }
      shouldDrawHit() {
        return !0;
      }
      clear() {
        const ot = this.children, lt = ot.length;
        for (let ft = 0; ft < lt; ft++)
          ot[ft].clear();
        return this;
      }
      clone(ot) {
        return ot || (ot = {}), ot.container = typeof document < "u" && document.createElement("div"), i.Container.prototype.clone.call(this, ot);
      }
      destroy() {
        super.destroy();
        const ot = this.content;
        ot && t.Util._isInDocument(ot) && this.container().removeChild(ot);
        const lt = e.stages.indexOf(this);
        return lt > -1 && e.stages.splice(lt, 1), t.Util.releaseCanvas(this.bufferCanvas._canvas, this.bufferHitCanvas._canvas), this;
      }
      getPointerPosition() {
        const ot = this._pointerPositions[0] || this._changedPointerPositions[0];
        return ot ? {
          x: ot.x,
          y: ot.y
        } : (t.Util.warn(dt), null);
      }
      _getPointerById(ot) {
        return this._pointerPositions.find((lt) => lt.id === ot);
      }
      getPointersPositions() {
        return this._pointerPositions;
      }
      getStage() {
        return this;
      }
      getContent() {
        return this.content;
      }
      _toKonvaCanvas(ot) {
        ot = ot || {}, ot.x = ot.x || 0, ot.y = ot.y || 0, ot.width = ot.width || this.width(), ot.height = ot.height || this.height();
        const lt = new o.SceneCanvas({
          width: ot.width,
          height: ot.height,
          pixelRatio: ot.pixelRatio || 1
        }), ft = lt.getContext()._context, Tt = this.children;
        return (ot.x || ot.y) && ft.translate(-1 * ot.x, -1 * ot.y), Tt.forEach(function(Bt) {
          if (!Bt.isVisible())
            return;
          const Ot = Bt._toKonvaCanvas(ot);
          ft.drawImage(Ot._canvas, ot.x, ot.y, Ot.getWidth() / Ot.getPixelRatio(), Ot.getHeight() / Ot.getPixelRatio());
        }), lt;
      }
      getIntersection(ot) {
        if (!ot)
          return null;
        const lt = this.children, ft = lt.length, Tt = ft - 1;
        for (let Bt = Tt; Bt >= 0; Bt--) {
          const Ot = lt[Bt].getIntersection(ot);
          if (Ot)
            return Ot;
        }
        return null;
      }
      _resizeDOM() {
        const ot = this.width(), lt = this.height();
        this.content && (this.content.style.width = ot + v, this.content.style.height = lt + v), this.bufferCanvas.setSize(ot, lt), this.bufferHitCanvas.setSize(ot, lt), this.children.forEach((ft) => {
          ft.setSize({ width: ot, height: lt }), ft.draw();
        });
      }
      add(ot, ...lt) {
        if (arguments.length > 1) {
          for (let Tt = 0; Tt < arguments.length; Tt++)
            this.add(arguments[Tt]);
          return this;
        }
        super.add(ot);
        const ft = this.children.length;
        return ft > it && t.Util.warn("The stage has " + ft + " layers. Recommended maximum number of layers is 3-5. Adding more layers into the stage may drop the performance. Rethink your tree structure, you can use Konva.Group."), ot.setSize({ width: this.width(), height: this.height() }), ot.draw(), s.Konva.isBrowser && this.content.appendChild(ot.canvas._canvas), this;
      }
      getParent() {
        return null;
      }
      getLayer() {
        return null;
      }
      hasPointerCapture(ot) {
        return f.hasPointerCapture(ot, this);
      }
      setPointerCapture(ot) {
        f.setPointerCapture(ot, this);
      }
      releaseCapture(ot) {
        f.releaseCapture(ot, this);
      }
      getLayers() {
        return this.children;
      }
      _bindContentEvents() {
        s.Konva.isBrowser && nt.forEach(([ot, lt]) => {
          this.content.addEventListener(ot, (ft) => {
            this[lt](ft);
          }, { passive: !1 });
        });
      }
      _pointerenter(ot) {
        this.setPointersPositions(ot);
        const lt = vt(ot.type);
        lt && this._fire(lt.pointerenter, {
          evt: ot,
          target: this,
          currentTarget: this
        });
      }
      _pointerover(ot) {
        this.setPointersPositions(ot);
        const lt = vt(ot.type);
        lt && this._fire(lt.pointerover, {
          evt: ot,
          target: this,
          currentTarget: this
        });
      }
      _getTargetShape(ot) {
        let lt = this[ot + "targetShape"];
        return lt && !lt.getStage() && (lt = null), lt;
      }
      _pointerleave(ot) {
        const lt = vt(ot.type), ft = rt(ot.type);
        if (!lt)
          return;
        this.setPointersPositions(ot);
        const Tt = this._getTargetShape(ft), Bt = !(s.Konva.isDragging() || s.Konva.isTransforming()) || s.Konva.hitOnDragEnabled;
        Tt && Bt ? (Tt._fireAndBubble(lt.pointerout, { evt: ot }), Tt._fireAndBubble(lt.pointerleave, { evt: ot }), this._fire(lt.pointerleave, {
          evt: ot,
          target: this,
          currentTarget: this
        }), this[ft + "targetShape"] = null) : Bt && (this._fire(lt.pointerleave, {
          evt: ot,
          target: this,
          currentTarget: this
        }), this._fire(lt.pointerout, {
          evt: ot,
          target: this,
          currentTarget: this
        })), this.pointerPos = null, this._pointerPositions = [];
      }
      _pointerdown(ot) {
        const lt = vt(ot.type), ft = rt(ot.type);
        if (!lt)
          return;
        this.setPointersPositions(ot);
        let Tt = !1;
        this._changedPointerPositions.forEach((Bt) => {
          const Ot = this.getIntersection(Bt);
          if (u.DD.justDragged = !1, s.Konva["_" + ft + "ListenClick"] = !0, !Ot || !Ot.isListening()) {
            this[ft + "ClickStartShape"] = void 0;
            return;
          }
          s.Konva.capturePointerEventsEnabled && Ot.setPointerCapture(Bt.id), this[ft + "ClickStartShape"] = Ot, Ot._fireAndBubble(lt.pointerdown, {
            evt: ot,
            pointerId: Bt.id
          }), Tt = !0;
          const ie = ot.type.indexOf("touch") >= 0;
          Ot.preventDefault() && ot.cancelable && ie && ot.preventDefault();
        }), Tt || this._fire(lt.pointerdown, {
          evt: ot,
          target: this,
          currentTarget: this,
          pointerId: this._pointerPositions[0].id
        });
      }
      _pointermove(ot) {
        const lt = vt(ot.type), ft = rt(ot.type);
        if (!lt || (s.Konva.isDragging() && u.DD.node.preventDefault() && ot.cancelable && ot.preventDefault(), this.setPointersPositions(ot), !(!(s.Konva.isDragging() || s.Konva.isTransforming()) || s.Konva.hitOnDragEnabled)))
          return;
        const Bt = {};
        let Ot = !1;
        const ie = this._getTargetShape(ft);
        this._changedPointerPositions.forEach((ce) => {
          const Ut = f.getCapturedShape(ce.id) || this.getIntersection(ce), se = ce.id, re = { evt: ot, pointerId: se }, ue = ie !== Ut;
          if (ue && ie && (ie._fireAndBubble(lt.pointerout, { ...re }, Ut), ie._fireAndBubble(lt.pointerleave, { ...re }, Ut)), Ut) {
            if (Bt[Ut._id])
              return;
            Bt[Ut._id] = !0;
          }
          Ut && Ut.isListening() ? (Ot = !0, ue && (Ut._fireAndBubble(lt.pointerover, { ...re }, ie), Ut._fireAndBubble(lt.pointerenter, { ...re }, ie), this[ft + "targetShape"] = Ut), Ut._fireAndBubble(lt.pointermove, { ...re })) : ie && (this._fire(lt.pointerover, {
            evt: ot,
            target: this,
            currentTarget: this,
            pointerId: se
          }), this[ft + "targetShape"] = null);
        }), Ot || this._fire(lt.pointermove, {
          evt: ot,
          target: this,
          currentTarget: this,
          pointerId: this._changedPointerPositions[0].id
        });
      }
      _pointerup(ot) {
        const lt = vt(ot.type), ft = rt(ot.type);
        if (!lt)
          return;
        this.setPointersPositions(ot);
        const Tt = this[ft + "ClickStartShape"], Bt = this[ft + "ClickEndShape"], Ot = {};
        let ie = !1;
        this._changedPointerPositions.forEach((ce) => {
          const Ut = f.getCapturedShape(ce.id) || this.getIntersection(ce);
          if (Ut) {
            if (Ut.releaseCapture(ce.id), Ot[Ut._id])
              return;
            Ot[Ut._id] = !0;
          }
          const se = ce.id, re = { evt: ot, pointerId: se };
          let ue = !1;
          s.Konva["_" + ft + "InDblClickWindow"] ? (ue = !0, clearTimeout(this[ft + "DblTimeout"])) : u.DD.justDragged || (s.Konva["_" + ft + "InDblClickWindow"] = !0, clearTimeout(this[ft + "DblTimeout"])), this[ft + "DblTimeout"] = setTimeout(function() {
            s.Konva["_" + ft + "InDblClickWindow"] = !1;
          }, s.Konva.dblClickWindow), Ut && Ut.isListening() ? (ie = !0, this[ft + "ClickEndShape"] = Ut, Ut._fireAndBubble(lt.pointerup, { ...re }), s.Konva["_" + ft + "ListenClick"] && Tt && Tt === Ut && (Ut._fireAndBubble(lt.pointerclick, { ...re }), ue && Bt && Bt === Ut && Ut._fireAndBubble(lt.pointerdblclick, { ...re }))) : (this[ft + "ClickEndShape"] = null, s.Konva["_" + ft + "ListenClick"] && this._fire(lt.pointerclick, {
            evt: ot,
            target: this,
            currentTarget: this,
            pointerId: se
          }), ue && this._fire(lt.pointerdblclick, {
            evt: ot,
            target: this,
            currentTarget: this,
            pointerId: se
          }));
        }), ie || this._fire(lt.pointerup, {
          evt: ot,
          target: this,
          currentTarget: this,
          pointerId: this._changedPointerPositions[0].id
        }), s.Konva["_" + ft + "ListenClick"] = !1, ot.cancelable && ft !== "touch" && ft !== "pointer" && ot.preventDefault();
      }
      _contextmenu(ot) {
        this.setPointersPositions(ot);
        const lt = this.getIntersection(this.getPointerPosition());
        lt && lt.isListening() ? lt._fireAndBubble(W, { evt: ot }) : this._fire(W, {
          evt: ot,
          target: this,
          currentTarget: this
        });
      }
      _wheel(ot) {
        this.setPointersPositions(ot);
        const lt = this.getIntersection(this.getPointerPosition());
        lt && lt.isListening() ? lt._fireAndBubble(Q, { evt: ot }) : this._fire(Q, {
          evt: ot,
          target: this,
          currentTarget: this
        });
      }
      _pointercancel(ot) {
        this.setPointersPositions(ot);
        const lt = f.getCapturedShape(ot.pointerId) || this.getIntersection(this.getPointerPosition());
        lt && lt._fireAndBubble(N, f.createEvent(ot)), f.releaseCapture(ot.pointerId);
      }
      _lostpointercapture(ot) {
        f.releaseCapture(ot.pointerId);
      }
      setPointersPositions(ot) {
        const lt = this._getContentPosition();
        let ft = null, Tt = null;
        ot = ot || window.event, ot.touches !== void 0 ? (this._pointerPositions = [], this._changedPointerPositions = [], Array.prototype.forEach.call(ot.touches, (Bt) => {
          this._pointerPositions.push({
            id: Bt.identifier,
            x: (Bt.clientX - lt.left) / lt.scaleX,
            y: (Bt.clientY - lt.top) / lt.scaleY
          });
        }), Array.prototype.forEach.call(ot.changedTouches || ot.touches, (Bt) => {
          this._changedPointerPositions.push({
            id: Bt.identifier,
            x: (Bt.clientX - lt.left) / lt.scaleX,
            y: (Bt.clientY - lt.top) / lt.scaleY
          });
        })) : (ft = (ot.clientX - lt.left) / lt.scaleX, Tt = (ot.clientY - lt.top) / lt.scaleY, this.pointerPos = {
          x: ft,
          y: Tt
        }, this._pointerPositions = [{ x: ft, y: Tt, id: t.Util._getFirstPointerId(ot) }], this._changedPointerPositions = [
          { x: ft, y: Tt, id: t.Util._getFirstPointerId(ot) }
        ]);
      }
      _setPointerPosition(ot) {
        t.Util.warn('Method _setPointerPosition is deprecated. Use "stage.setPointersPositions(event)" instead.'), this.setPointersPositions(ot);
      }
      _getContentPosition() {
        if (!this.content || !this.content.getBoundingClientRect)
          return {
            top: 0,
            left: 0,
            scaleX: 1,
            scaleY: 1
          };
        const ot = this.content.getBoundingClientRect();
        return {
          top: ot.top,
          left: ot.left,
          scaleX: ot.width / this.content.clientWidth || 1,
          scaleY: ot.height / this.content.clientHeight || 1
        };
      }
      _buildDOM() {
        if (this.bufferCanvas = new o.SceneCanvas({
          width: this.width(),
          height: this.height()
        }), this.bufferHitCanvas = new o.HitCanvas({
          pixelRatio: 1,
          width: this.width(),
          height: this.height()
        }), !s.Konva.isBrowser)
          return;
        const ot = this.container();
        if (!ot)
          throw "Stage has no container. A container is required.";
        ot.innerHTML = "", this.content = document.createElement("div"), this.content.style.position = "relative", this.content.style.userSelect = "none", this.content.className = "konvajs-content", this.content.setAttribute("role", "presentation"), ot.appendChild(this.content), this._resizeDOM();
      }
      cache() {
        return t.Util.warn("Cache function is not allowed for stage. You may use cache only for layers, groups and shapes."), this;
      }
      clearCache() {
        return this;
      }
      batchDraw() {
        return this.getChildren().forEach(function(ot) {
          ot.batchDraw();
        }), this;
      }
    }
    e.Stage = ht, ht.prototype.nodeType = p, (0, h._registerNode)(ht), n.Factory.addGetterSetter(ht, "container"), s.Konva.isBrowser && document.addEventListener("visibilitychange", () => {
      e.stages.forEach((Et) => {
        Et.batchDraw();
      });
    });
  }(Ab)), Ab;
}
var Rm = {}, Mb = {}, l4;
function ta() {
  return l4 || (l4 = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.Shape = e.shapes = void 0;
    const t = Sn(), n = lr(), i = An(), s = br(), o = Mn(), u = Sn(), h = Y6(), f = "hasShadow", p = "shadowRGBA", g = "patternImage", v = "linearGradient", x = "radialGradient";
    let b;
    function _() {
      return b || (b = n.Util.createCanvasElement().getContext("2d"), b);
    }
    e.shapes = {};
    function T(V) {
      const D = this.attrs.fillRule;
      D ? V.fill(D) : V.fill();
    }
    function A(V) {
      V.stroke();
    }
    function O(V) {
      const D = this.attrs.fillRule;
      D ? V.fill(D) : V.fill();
    }
    function M(V) {
      V.stroke();
    }
    function E() {
      this._clearCache(f);
    }
    function R() {
      this._clearCache(p);
    }
    function N() {
      this._clearCache(g);
    }
    function U() {
      this._clearCache(v);
    }
    function q() {
      this._clearCache(x);
    }
    class j extends s.Node {
      constructor(D) {
        super(D);
        let G;
        for (; G = n.Util.getRandomColor(), !(G && !(G in e.shapes)); )
          ;
        this.colorKey = G, e.shapes[G] = this;
      }
      getContext() {
        return n.Util.warn("shape.getContext() method is deprecated. Please do not use it."), this.getLayer().getContext();
      }
      getCanvas() {
        return n.Util.warn("shape.getCanvas() method is deprecated. Please do not use it."), this.getLayer().getCanvas();
      }
      getSceneFunc() {
        return this.attrs.sceneFunc || this._sceneFunc;
      }
      getHitFunc() {
        return this.attrs.hitFunc || this._hitFunc;
      }
      hasShadow() {
        return this._getCache(f, this._hasShadow);
      }
      _hasShadow() {
        return this.shadowEnabled() && this.shadowOpacity() !== 0 && !!(this.shadowColor() || this.shadowBlur() || this.shadowOffsetX() || this.shadowOffsetY());
      }
      _getFillPattern() {
        return this._getCache(g, this.__getFillPattern);
      }
      __getFillPattern() {
        if (this.fillPatternImage()) {
          const G = _().createPattern(this.fillPatternImage(), this.fillPatternRepeat() || "repeat");
          if (G && G.setTransform) {
            const W = new n.Transform();
            W.translate(this.fillPatternX(), this.fillPatternY()), W.rotate(t.Konva.getAngle(this.fillPatternRotation())), W.scale(this.fillPatternScaleX(), this.fillPatternScaleY()), W.translate(-1 * this.fillPatternOffsetX(), -1 * this.fillPatternOffsetY());
            const P = W.getMatrix(), H = typeof DOMMatrix > "u" ? {
              a: P[0],
              b: P[1],
              c: P[2],
              d: P[3],
              e: P[4],
              f: P[5]
            } : new DOMMatrix(P);
            G.setTransform(H);
          }
          return G;
        }
      }
      _getLinearGradient() {
        return this._getCache(v, this.__getLinearGradient);
      }
      __getLinearGradient() {
        const D = this.fillLinearGradientColorStops();
        if (D) {
          const G = _(), W = this.fillLinearGradientStartPoint(), P = this.fillLinearGradientEndPoint(), H = G.createLinearGradient(W.x, W.y, P.x, P.y);
          for (let I = 0; I < D.length; I += 2)
            H.addColorStop(D[I], D[I + 1]);
          return H;
        }
      }
      _getRadialGradient() {
        return this._getCache(x, this.__getRadialGradient);
      }
      __getRadialGradient() {
        const D = this.fillRadialGradientColorStops();
        if (D) {
          const G = _(), W = this.fillRadialGradientStartPoint(), P = this.fillRadialGradientEndPoint(), H = G.createRadialGradient(W.x, W.y, this.fillRadialGradientStartRadius(), P.x, P.y, this.fillRadialGradientEndRadius());
          for (let I = 0; I < D.length; I += 2)
            H.addColorStop(D[I], D[I + 1]);
          return H;
        }
      }
      getShadowRGBA() {
        return this._getCache(p, this._getShadowRGBA);
      }
      _getShadowRGBA() {
        if (!this.hasShadow())
          return;
        const D = n.Util.colorToRGBA(this.shadowColor());
        if (D)
          return "rgba(" + D.r + "," + D.g + "," + D.b + "," + D.a * (this.shadowOpacity() || 1) + ")";
      }
      hasFill() {
        return this._calculate("hasFill", [
          "fillEnabled",
          "fill",
          "fillPatternImage",
          "fillLinearGradientColorStops",
          "fillRadialGradientColorStops"
        ], () => this.fillEnabled() && !!(this.fill() || this.fillPatternImage() || this.fillLinearGradientColorStops() || this.fillRadialGradientColorStops()));
      }
      hasStroke() {
        return this._calculate("hasStroke", [
          "strokeEnabled",
          "strokeWidth",
          "stroke",
          "strokeLinearGradientColorStops"
        ], () => this.strokeEnabled() && this.strokeWidth() && !!(this.stroke() || this.strokeLinearGradientColorStops()));
      }
      hasHitStroke() {
        const D = this.hitStrokeWidth();
        return D === "auto" ? this.hasStroke() : this.strokeEnabled() && !!D;
      }
      intersects(D) {
        const G = this.getStage();
        if (!G)
          return !1;
        const W = G.bufferHitCanvas;
        return W.getContext().clear(), this.drawHit(W, void 0, !0), W.context.getImageData(Math.round(D.x), Math.round(D.y), 1, 1).data[3] > 0;
      }
      destroy() {
        return s.Node.prototype.destroy.call(this), delete e.shapes[this.colorKey], delete this.colorKey, this;
      }
      _useBufferCanvas(D) {
        var G;
        if (!((G = this.attrs.perfectDrawEnabled) !== null && G !== void 0 ? G : !0))
          return !1;
        const P = D || this.hasFill(), H = this.hasStroke(), I = this.getAbsoluteOpacity() !== 1;
        if (P && H && I)
          return !0;
        const K = this.hasShadow(), Q = this.shadowForStrokeEnabled();
        return !!(P && H && K && Q);
      }
      setStrokeHitEnabled(D) {
        n.Util.warn("strokeHitEnabled property is deprecated. Please use hitStrokeWidth instead."), D ? this.hitStrokeWidth("auto") : this.hitStrokeWidth(0);
      }
      getStrokeHitEnabled() {
        return this.hitStrokeWidth() !== 0;
      }
      getSelfRect() {
        const D = this.size();
        return {
          x: this._centroid ? -D.width / 2 : 0,
          y: this._centroid ? -D.height / 2 : 0,
          width: D.width,
          height: D.height
        };
      }
      getClientRect(D = {}) {
        let G = !1, W = this.getParent();
        for (; W; ) {
          if (W.isCached()) {
            G = !0;
            break;
          }
          W = W.getParent();
        }
        const P = D.skipTransform, H = D.relativeTo || G && this.getStage() || void 0, I = this.getSelfRect(), Q = !D.skipStroke && this.hasStroke() && this.strokeWidth() || 0, it = I.width + Q, nt = I.height + Q, X = !D.skipShadow && this.hasShadow(), rt = X ? this.shadowOffsetX() : 0, vt = X ? this.shadowOffsetY() : 0, ct = it + Math.abs(rt), dt = nt + Math.abs(vt), ht = X && this.shadowBlur() || 0, Et = ct + ht * 2, ot = dt + ht * 2, lt = {
          width: Et,
          height: ot,
          x: -(Q / 2 + ht) + Math.min(rt, 0) + I.x,
          y: -(Q / 2 + ht) + Math.min(vt, 0) + I.y
        };
        return P ? lt : this._transformedRect(lt, H);
      }
      drawScene(D, G, W) {
        const P = this.getLayer();
        let H = D || P.getCanvas(), I = H.getContext(), K = this._getCanvasCache(), Q = this.getSceneFunc(), it = this.hasShadow(), nt, X;
        const rt = H.isCache, vt = G === this;
        if (!this.isVisible() && !vt)
          return this;
        if (K) {
          I.save();
          const dt = this.getAbsoluteTransform(G).getMatrix();
          return I.transform(dt[0], dt[1], dt[2], dt[3], dt[4], dt[5]), this._drawCachedSceneCanvas(I), I.restore(), this;
        }
        if (!Q)
          return this;
        if (I.save(), this._useBufferCanvas() && !rt) {
          nt = this.getStage();
          const dt = W || nt.bufferCanvas;
          X = dt.getContext(), X.clear(), X.save(), X._applyLineJoin(this);
          var ct = this.getAbsoluteTransform(G).getMatrix();
          X.transform(ct[0], ct[1], ct[2], ct[3], ct[4], ct[5]), Q.call(this, X, this), X.restore();
          const ht = dt.pixelRatio;
          it && I._applyShadow(this), I._applyOpacity(this), I._applyGlobalCompositeOperation(this), I.drawImage(dt._canvas, 0, 0, dt.width / ht, dt.height / ht);
        } else {
          if (I._applyLineJoin(this), !vt) {
            var ct = this.getAbsoluteTransform(G).getMatrix();
            I.transform(ct[0], ct[1], ct[2], ct[3], ct[4], ct[5]), I._applyOpacity(this), I._applyGlobalCompositeOperation(this);
          }
          it && I._applyShadow(this), Q.call(this, I, this);
        }
        return I.restore(), this;
      }
      drawHit(D, G, W = !1) {
        if (!this.shouldDrawHit(G, W))
          return this;
        const P = this.getLayer(), H = D || P.hitCanvas, I = H && H.getContext(), K = this.hitFunc() || this.sceneFunc(), Q = this._getCanvasCache(), it = Q && Q.hit;
        if (this.colorKey || n.Util.warn("Looks like your canvas has a destroyed shape in it. Do not reuse shape after you destroyed it. If you want to reuse shape you should call remove() instead of destroy()"), it) {
          I.save();
          const X = this.getAbsoluteTransform(G).getMatrix();
          return I.transform(X[0], X[1], X[2], X[3], X[4], X[5]), this._drawCachedHitCanvas(I), I.restore(), this;
        }
        if (!K)
          return this;
        if (I.save(), I._applyLineJoin(this), !(this === G)) {
          const X = this.getAbsoluteTransform(G).getMatrix();
          I.transform(X[0], X[1], X[2], X[3], X[4], X[5]);
        }
        return K.call(this, I, this), I.restore(), this;
      }
      drawHitFromCache(D = 0) {
        const G = this._getCanvasCache(), W = this._getCachedSceneCanvas(), P = G.hit, H = P.getContext(), I = P.getWidth(), K = P.getHeight();
        H.clear(), H.drawImage(W._canvas, 0, 0, I, K);
        try {
          const Q = H.getImageData(0, 0, I, K), it = Q.data, nt = it.length, X = n.Util._hexToRgb(this.colorKey);
          for (let rt = 0; rt < nt; rt += 4)
            it[rt + 3] > D ? (it[rt] = X.r, it[rt + 1] = X.g, it[rt + 2] = X.b, it[rt + 3] = 255) : it[rt + 3] = 0;
          H.putImageData(Q, 0, 0);
        } catch (Q) {
          n.Util.error("Unable to draw hit graph from cached scene canvas. " + Q.message);
        }
        return this;
      }
      hasPointerCapture(D) {
        return h.hasPointerCapture(D, this);
      }
      setPointerCapture(D) {
        h.setPointerCapture(D, this);
      }
      releaseCapture(D) {
        h.releaseCapture(D, this);
      }
    }
    e.Shape = j, j.prototype._fillFunc = T, j.prototype._strokeFunc = A, j.prototype._fillFuncHit = O, j.prototype._strokeFuncHit = M, j.prototype._centroid = !1, j.prototype.nodeType = "Shape", (0, u._registerNode)(j), j.prototype.eventListeners = {}, j.prototype.on.call(j.prototype, "shadowColorChange.konva shadowBlurChange.konva shadowOffsetChange.konva shadowOpacityChange.konva shadowEnabledChange.konva", E), j.prototype.on.call(j.prototype, "shadowColorChange.konva shadowOpacityChange.konva shadowEnabledChange.konva", R), j.prototype.on.call(j.prototype, "fillPriorityChange.konva fillPatternImageChange.konva fillPatternRepeatChange.konva fillPatternScaleXChange.konva fillPatternScaleYChange.konva fillPatternOffsetXChange.konva fillPatternOffsetYChange.konva fillPatternXChange.konva fillPatternYChange.konva fillPatternRotationChange.konva", N), j.prototype.on.call(j.prototype, "fillPriorityChange.konva fillLinearGradientColorStopsChange.konva fillLinearGradientStartPointXChange.konva fillLinearGradientStartPointYChange.konva fillLinearGradientEndPointXChange.konva fillLinearGradientEndPointYChange.konva", U), j.prototype.on.call(j.prototype, "fillPriorityChange.konva fillRadialGradientColorStopsChange.konva fillRadialGradientStartPointXChange.konva fillRadialGradientStartPointYChange.konva fillRadialGradientEndPointXChange.konva fillRadialGradientEndPointYChange.konva fillRadialGradientStartRadiusChange.konva fillRadialGradientEndRadiusChange.konva", q), i.Factory.addGetterSetter(j, "stroke", void 0, (0, o.getStringOrGradientValidator)()), i.Factory.addGetterSetter(j, "strokeWidth", 2, (0, o.getNumberValidator)()), i.Factory.addGetterSetter(j, "fillAfterStrokeEnabled", !1), i.Factory.addGetterSetter(j, "hitStrokeWidth", "auto", (0, o.getNumberOrAutoValidator)()), i.Factory.addGetterSetter(j, "strokeHitEnabled", !0, (0, o.getBooleanValidator)()), i.Factory.addGetterSetter(j, "perfectDrawEnabled", !0, (0, o.getBooleanValidator)()), i.Factory.addGetterSetter(j, "shadowForStrokeEnabled", !0, (0, o.getBooleanValidator)()), i.Factory.addGetterSetter(j, "lineJoin"), i.Factory.addGetterSetter(j, "lineCap"), i.Factory.addGetterSetter(j, "sceneFunc"), i.Factory.addGetterSetter(j, "hitFunc"), i.Factory.addGetterSetter(j, "dash"), i.Factory.addGetterSetter(j, "dashOffset", 0, (0, o.getNumberValidator)()), i.Factory.addGetterSetter(j, "shadowColor", void 0, (0, o.getStringValidator)()), i.Factory.addGetterSetter(j, "shadowBlur", 0, (0, o.getNumberValidator)()), i.Factory.addGetterSetter(j, "shadowOpacity", 1, (0, o.getNumberValidator)()), i.Factory.addComponentsGetterSetter(j, "shadowOffset", ["x", "y"]), i.Factory.addGetterSetter(j, "shadowOffsetX", 0, (0, o.getNumberValidator)()), i.Factory.addGetterSetter(j, "shadowOffsetY", 0, (0, o.getNumberValidator)()), i.Factory.addGetterSetter(j, "fillPatternImage"), i.Factory.addGetterSetter(j, "fill", void 0, (0, o.getStringOrGradientValidator)()), i.Factory.addGetterSetter(j, "fillPatternX", 0, (0, o.getNumberValidator)()), i.Factory.addGetterSetter(j, "fillPatternY", 0, (0, o.getNumberValidator)()), i.Factory.addGetterSetter(j, "fillLinearGradientColorStops"), i.Factory.addGetterSetter(j, "strokeLinearGradientColorStops"), i.Factory.addGetterSetter(j, "fillRadialGradientStartRadius", 0), i.Factory.addGetterSetter(j, "fillRadialGradientEndRadius", 0), i.Factory.addGetterSetter(j, "fillRadialGradientColorStops"), i.Factory.addGetterSetter(j, "fillPatternRepeat", "repeat"), i.Factory.addGetterSetter(j, "fillEnabled", !0), i.Factory.addGetterSetter(j, "strokeEnabled", !0), i.Factory.addGetterSetter(j, "shadowEnabled", !0), i.Factory.addGetterSetter(j, "dashEnabled", !0), i.Factory.addGetterSetter(j, "strokeScaleEnabled", !0), i.Factory.addGetterSetter(j, "fillPriority", "color"), i.Factory.addComponentsGetterSetter(j, "fillPatternOffset", ["x", "y"]), i.Factory.addGetterSetter(j, "fillPatternOffsetX", 0, (0, o.getNumberValidator)()), i.Factory.addGetterSetter(j, "fillPatternOffsetY", 0, (0, o.getNumberValidator)()), i.Factory.addComponentsGetterSetter(j, "fillPatternScale", ["x", "y"]), i.Factory.addGetterSetter(j, "fillPatternScaleX", 1, (0, o.getNumberValidator)()), i.Factory.addGetterSetter(j, "fillPatternScaleY", 1, (0, o.getNumberValidator)()), i.Factory.addComponentsGetterSetter(j, "fillLinearGradientStartPoint", [
      "x",
      "y"
    ]), i.Factory.addComponentsGetterSetter(j, "strokeLinearGradientStartPoint", [
      "x",
      "y"
    ]), i.Factory.addGetterSetter(j, "fillLinearGradientStartPointX", 0), i.Factory.addGetterSetter(j, "strokeLinearGradientStartPointX", 0), i.Factory.addGetterSetter(j, "fillLinearGradientStartPointY", 0), i.Factory.addGetterSetter(j, "strokeLinearGradientStartPointY", 0), i.Factory.addComponentsGetterSetter(j, "fillLinearGradientEndPoint", [
      "x",
      "y"
    ]), i.Factory.addComponentsGetterSetter(j, "strokeLinearGradientEndPoint", [
      "x",
      "y"
    ]), i.Factory.addGetterSetter(j, "fillLinearGradientEndPointX", 0), i.Factory.addGetterSetter(j, "strokeLinearGradientEndPointX", 0), i.Factory.addGetterSetter(j, "fillLinearGradientEndPointY", 0), i.Factory.addGetterSetter(j, "strokeLinearGradientEndPointY", 0), i.Factory.addComponentsGetterSetter(j, "fillRadialGradientStartPoint", [
      "x",
      "y"
    ]), i.Factory.addGetterSetter(j, "fillRadialGradientStartPointX", 0), i.Factory.addGetterSetter(j, "fillRadialGradientStartPointY", 0), i.Factory.addComponentsGetterSetter(j, "fillRadialGradientEndPoint", [
      "x",
      "y"
    ]), i.Factory.addGetterSetter(j, "fillRadialGradientEndPointX", 0), i.Factory.addGetterSetter(j, "fillRadialGradientEndPointY", 0), i.Factory.addGetterSetter(j, "fillPatternRotation", 0), i.Factory.addGetterSetter(j, "fillRule", void 0, (0, o.getStringValidator)()), i.Factory.backCompat(j, {
      dashArray: "dash",
      getDashArray: "getDash",
      setDashArray: "getDash",
      drawFunc: "sceneFunc",
      getDrawFunc: "getSceneFunc",
      setDrawFunc: "setSceneFunc",
      drawHitFunc: "hitFunc",
      getDrawHitFunc: "getHitFunc",
      setDrawHitFunc: "setHitFunc"
    });
  }(Mb)), Mb;
}
var c4;
function X6() {
  if (c4) return Rm;
  c4 = 1, Object.defineProperty(Rm, "__esModule", { value: !0 }), Rm.Layer = void 0;
  const e = lr(), t = hv(), n = br(), i = An(), s = dv(), o = Mn(), u = ta(), h = Sn(), f = "#", p = "beforeDraw", g = "draw", v = [
    { x: 0, y: 0 },
    { x: -1, y: -1 },
    { x: 1, y: -1 },
    { x: 1, y: 1 },
    { x: -1, y: 1 }
  ], x = v.length;
  class b extends t.Container {
    constructor(T) {
      super(T), this.canvas = new s.SceneCanvas(), this.hitCanvas = new s.HitCanvas({
        pixelRatio: 1
      }), this._waitingForDraw = !1, this.on("visibleChange.konva", this._checkVisibility), this._checkVisibility(), this.on("imageSmoothingEnabledChange.konva", this._setSmoothEnabled), this._setSmoothEnabled();
    }
    createPNGStream() {
      return this.canvas._canvas.createPNGStream();
    }
    getCanvas() {
      return this.canvas;
    }
    getNativeCanvasElement() {
      return this.canvas._canvas;
    }
    getHitCanvas() {
      return this.hitCanvas;
    }
    getContext() {
      return this.getCanvas().getContext();
    }
    clear(T) {
      return this.getContext().clear(T), this.getHitCanvas().getContext().clear(T), this;
    }
    setZIndex(T) {
      super.setZIndex(T);
      const A = this.getStage();
      return A && A.content && (A.content.removeChild(this.getNativeCanvasElement()), T < A.children.length - 1 ? A.content.insertBefore(this.getNativeCanvasElement(), A.children[T + 1].getCanvas()._canvas) : A.content.appendChild(this.getNativeCanvasElement())), this;
    }
    moveToTop() {
      n.Node.prototype.moveToTop.call(this);
      const T = this.getStage();
      return T && T.content && (T.content.removeChild(this.getNativeCanvasElement()), T.content.appendChild(this.getNativeCanvasElement())), !0;
    }
    moveUp() {
      if (!n.Node.prototype.moveUp.call(this))
        return !1;
      const A = this.getStage();
      return !A || !A.content ? !1 : (A.content.removeChild(this.getNativeCanvasElement()), this.index < A.children.length - 1 ? A.content.insertBefore(this.getNativeCanvasElement(), A.children[this.index + 1].getCanvas()._canvas) : A.content.appendChild(this.getNativeCanvasElement()), !0);
    }
    moveDown() {
      if (n.Node.prototype.moveDown.call(this)) {
        const T = this.getStage();
        if (T) {
          const A = T.children;
          T.content && (T.content.removeChild(this.getNativeCanvasElement()), T.content.insertBefore(this.getNativeCanvasElement(), A[this.index + 1].getCanvas()._canvas));
        }
        return !0;
      }
      return !1;
    }
    moveToBottom() {
      if (n.Node.prototype.moveToBottom.call(this)) {
        const T = this.getStage();
        if (T) {
          const A = T.children;
          T.content && (T.content.removeChild(this.getNativeCanvasElement()), T.content.insertBefore(this.getNativeCanvasElement(), A[1].getCanvas()._canvas));
        }
        return !0;
      }
      return !1;
    }
    getLayer() {
      return this;
    }
    remove() {
      const T = this.getNativeCanvasElement();
      return n.Node.prototype.remove.call(this), T && T.parentNode && e.Util._isInDocument(T) && T.parentNode.removeChild(T), this;
    }
    getStage() {
      return this.parent;
    }
    setSize({ width: T, height: A }) {
      return this.canvas.setSize(T, A), this.hitCanvas.setSize(T, A), this._setSmoothEnabled(), this;
    }
    _validateAdd(T) {
      const A = T.getType();
      A !== "Group" && A !== "Shape" && e.Util.throw("You may only add groups and shapes to a layer.");
    }
    _toKonvaCanvas(T) {
      return T = T || {}, T.width = T.width || this.getWidth(), T.height = T.height || this.getHeight(), T.x = T.x !== void 0 ? T.x : this.x(), T.y = T.y !== void 0 ? T.y : this.y(), n.Node.prototype._toKonvaCanvas.call(this, T);
    }
    _checkVisibility() {
      this.visible() ? this.canvas._canvas.style.display = "block" : this.canvas._canvas.style.display = "none";
    }
    _setSmoothEnabled() {
      this.getContext()._context.imageSmoothingEnabled = this.imageSmoothingEnabled();
    }
    getWidth() {
      if (this.parent)
        return this.parent.width();
    }
    setWidth() {
      e.Util.warn('Can not change width of layer. Use "stage.width(value)" function instead.');
    }
    getHeight() {
      if (this.parent)
        return this.parent.height();
    }
    setHeight() {
      e.Util.warn('Can not change height of layer. Use "stage.height(value)" function instead.');
    }
    batchDraw() {
      return this._waitingForDraw || (this._waitingForDraw = !0, e.Util.requestAnimFrame(() => {
        this.draw(), this._waitingForDraw = !1;
      })), this;
    }
    getIntersection(T) {
      if (!this.isListening() || !this.isVisible())
        return null;
      let A = 1, O = !1;
      for (; ; ) {
        for (let M = 0; M < x; M++) {
          const E = v[M], R = this._getIntersection({
            x: T.x + E.x * A,
            y: T.y + E.y * A
          }), N = R.shape;
          if (N)
            return N;
          if (O = !!R.antialiased, !R.antialiased)
            break;
        }
        if (O)
          A += 1;
        else
          return null;
      }
    }
    _getIntersection(T) {
      const A = this.hitCanvas.pixelRatio, O = this.hitCanvas.context.getImageData(Math.round(T.x * A), Math.round(T.y * A), 1, 1).data, M = O[3];
      if (M === 255) {
        const E = e.Util._rgbToHex(O[0], O[1], O[2]), R = u.shapes[f + E];
        return R ? {
          shape: R
        } : {
          antialiased: !0
        };
      } else if (M > 0)
        return {
          antialiased: !0
        };
      return {};
    }
    drawScene(T, A) {
      const O = this.getLayer(), M = T || O && O.getCanvas();
      return this._fire(p, {
        node: this
      }), this.clearBeforeDraw() && M.getContext().clear(), t.Container.prototype.drawScene.call(this, M, A), this._fire(g, {
        node: this
      }), this;
    }
    drawHit(T, A) {
      const O = this.getLayer(), M = T || O && O.hitCanvas;
      return O && O.clearBeforeDraw() && O.getHitCanvas().getContext().clear(), t.Container.prototype.drawHit.call(this, M, A), this;
    }
    enableHitGraph() {
      return this.hitGraphEnabled(!0), this;
    }
    disableHitGraph() {
      return this.hitGraphEnabled(!1), this;
    }
    setHitGraphEnabled(T) {
      e.Util.warn("hitGraphEnabled method is deprecated. Please use layer.listening() instead."), this.listening(T);
    }
    getHitGraphEnabled(T) {
      return e.Util.warn("hitGraphEnabled method is deprecated. Please use layer.listening() instead."), this.listening();
    }
    toggleHitCanvas() {
      if (!this.parent || !this.parent.content)
        return;
      const T = this.parent;
      !!this.hitCanvas._canvas.parentNode ? T.content.removeChild(this.hitCanvas._canvas) : T.content.appendChild(this.hitCanvas._canvas);
    }
    destroy() {
      return e.Util.releaseCanvas(this.getNativeCanvasElement(), this.getHitCanvas()._canvas), super.destroy();
    }
  }
  return Rm.Layer = b, b.prototype.nodeType = "Layer", (0, h._registerNode)(b), i.Factory.addGetterSetter(b, "imageSmoothingEnabled", !0), i.Factory.addGetterSetter(b, "clearBeforeDraw", !0), i.Factory.addGetterSetter(b, "hitGraphEnabled", !0, (0, o.getBooleanValidator)()), Rm;
}
var Om = {}, u4;
function PU() {
  if (u4) return Om;
  u4 = 1, Object.defineProperty(Om, "__esModule", { value: !0 }), Om.FastLayer = void 0;
  const e = lr(), t = X6(), n = Sn();
  let i = class extends t.Layer {
    constructor(o) {
      super(o), this.listening(!1), e.Util.warn('Konva.Fast layer is deprecated. Please use "new Konva.Layer({ listening: false })" instead.');
    }
  };
  return Om.FastLayer = i, i.prototype.nodeType = "FastLayer", (0, n._registerNode)(i), Om;
}
var Nm = {}, d4;
function G_() {
  if (d4) return Nm;
  d4 = 1, Object.defineProperty(Nm, "__esModule", { value: !0 }), Nm.Group = void 0;
  const e = lr(), t = hv(), n = Sn();
  class i extends t.Container {
    _validateAdd(o) {
      const u = o.getType();
      u !== "Group" && u !== "Shape" && e.Util.throw("You may only add groups and shapes to groups.");
    }
  }
  return Nm.Group = i, i.prototype.nodeType = "Group", (0, n._registerNode)(i), Nm;
}
var km = {}, h4;
function H_() {
  if (h4) return km;
  h4 = 1, Object.defineProperty(km, "__esModule", { value: !0 }), km.Animation = void 0;
  const e = Sn(), t = lr(), n = function() {
    return e.glob.performance && e.glob.performance.now ? function() {
      return e.glob.performance.now();
    } : function() {
      return (/* @__PURE__ */ new Date()).getTime();
    };
  }();
  let i = class Uf {
    constructor(o, u) {
      this.id = Uf.animIdCounter++, this.frame = {
        time: 0,
        timeDiff: 0,
        lastTime: n(),
        frameRate: 0
      }, this.func = o, this.setLayers(u);
    }
    setLayers(o) {
      let u = [];
      return o && (u = Array.isArray(o) ? o : [o]), this.layers = u, this;
    }
    getLayers() {
      return this.layers;
    }
    addLayer(o) {
      const u = this.layers, h = u.length;
      for (let f = 0; f < h; f++)
        if (u[f]._id === o._id)
          return !1;
      return this.layers.push(o), !0;
    }
    isRunning() {
      const u = Uf.animations, h = u.length;
      for (let f = 0; f < h; f++)
        if (u[f].id === this.id)
          return !0;
      return !1;
    }
    start() {
      return this.stop(), this.frame.timeDiff = 0, this.frame.lastTime = n(), Uf._addAnimation(this), this;
    }
    stop() {
      return Uf._removeAnimation(this), this;
    }
    _updateFrameObject(o) {
      this.frame.timeDiff = o - this.frame.lastTime, this.frame.lastTime = o, this.frame.time += this.frame.timeDiff, this.frame.frameRate = 1e3 / this.frame.timeDiff;
    }
    static _addAnimation(o) {
      this.animations.push(o), this._handleAnimation();
    }
    static _removeAnimation(o) {
      const u = o.id, h = this.animations, f = h.length;
      for (let p = 0; p < f; p++)
        if (h[p].id === u) {
          this.animations.splice(p, 1);
          break;
        }
    }
    static _runFrames() {
      const o = {}, u = this.animations;
      for (let h = 0; h < u.length; h++) {
        const f = u[h], p = f.layers, g = f.func;
        f._updateFrameObject(n());
        const v = p.length;
        let x;
        if (g ? x = g.call(f, f.frame) !== !1 : x = !0, !!x)
          for (let b = 0; b < v; b++) {
            const _ = p[b];
            _._id !== void 0 && (o[_._id] = _);
          }
      }
      for (const h in o)
        o.hasOwnProperty(h) && o[h].batchDraw();
    }
    static _animationLoop() {
      const o = Uf;
      o.animations.length ? (o._runFrames(), t.Util.requestAnimFrame(o._animationLoop)) : o.animRunning = !1;
    }
    static _handleAnimation() {
      this.animRunning || (this.animRunning = !0, t.Util.requestAnimFrame(this._animationLoop));
    }
  };
  return km.Animation = i, i.animations = [], i.animIdCounter = 0, i.animRunning = !1, km;
}
var Rb = {}, f4;
function UU() {
  return f4 || (f4 = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.Easings = e.Tween = void 0;
    const t = lr(), n = H_(), i = br(), s = Sn(), o = {
      node: 1,
      duration: 1,
      easing: 1,
      onFinish: 1,
      yoyo: 1
    }, u = 1, h = 2, f = 3, p = ["fill", "stroke", "shadowColor"];
    let g = 0;
    class v {
      constructor(_, T, A, O, M, E, R) {
        this.prop = _, this.propFunc = T, this.begin = O, this._pos = O, this.duration = E, this._change = 0, this.prevPos = 0, this.yoyo = R, this._time = 0, this._position = 0, this._startTime = 0, this._finish = 0, this.func = A, this._change = M - this.begin, this.pause();
      }
      fire(_) {
        const T = this[_];
        T && T();
      }
      setTime(_) {
        _ > this.duration ? this.yoyo ? (this._time = this.duration, this.reverse()) : this.finish() : _ < 0 ? this.yoyo ? (this._time = 0, this.play()) : this.reset() : (this._time = _, this.update());
      }
      getTime() {
        return this._time;
      }
      setPosition(_) {
        this.prevPos = this._pos, this.propFunc(_), this._pos = _;
      }
      getPosition(_) {
        return _ === void 0 && (_ = this._time), this.func(_, this.begin, this._change, this.duration);
      }
      play() {
        this.state = h, this._startTime = this.getTimer() - this._time, this.onEnterFrame(), this.fire("onPlay");
      }
      reverse() {
        this.state = f, this._time = this.duration - this._time, this._startTime = this.getTimer() - this._time, this.onEnterFrame(), this.fire("onReverse");
      }
      seek(_) {
        this.pause(), this._time = _, this.update(), this.fire("onSeek");
      }
      reset() {
        this.pause(), this._time = 0, this.update(), this.fire("onReset");
      }
      finish() {
        this.pause(), this._time = this.duration, this.update(), this.fire("onFinish");
      }
      update() {
        this.setPosition(this.getPosition(this._time)), this.fire("onUpdate");
      }
      onEnterFrame() {
        const _ = this.getTimer() - this._startTime;
        this.state === h ? this.setTime(_) : this.state === f && this.setTime(this.duration - _);
      }
      pause() {
        this.state = u, this.fire("onPause");
      }
      getTimer() {
        return (/* @__PURE__ */ new Date()).getTime();
      }
    }
    class x {
      constructor(_) {
        const T = this, A = _.node, O = A._id, M = _.easing || e.Easings.Linear, E = !!_.yoyo;
        let R, N;
        typeof _.duration > "u" ? R = 0.3 : _.duration === 0 ? R = 1e-3 : R = _.duration, this.node = A, this._id = g++;
        const U = A.getLayer() || (A instanceof s.Konva.Stage ? A.getLayers() : null);
        U || t.Util.error("Tween constructor have `node` that is not in a layer. Please add node into layer first."), this.anim = new n.Animation(function() {
          T.tween.onEnterFrame();
        }, U), this.tween = new v(N, function(q) {
          T._tweenFunc(q);
        }, M, 0, 1, R * 1e3, E), this._addListeners(), x.attrs[O] || (x.attrs[O] = {}), x.attrs[O][this._id] || (x.attrs[O][this._id] = {}), x.tweens[O] || (x.tweens[O] = {});
        for (N in _)
          o[N] === void 0 && this._addAttr(N, _[N]);
        this.reset(), this.onFinish = _.onFinish, this.onReset = _.onReset, this.onUpdate = _.onUpdate;
      }
      _addAttr(_, T) {
        const A = this.node, O = A._id;
        let M, E, R, N, U;
        const q = x.tweens[O][_];
        q && delete x.attrs[O][q][_];
        let j = A.getAttr(_);
        if (t.Util._isArray(T))
          if (M = [], E = Math.max(T.length, j.length), _ === "points" && T.length !== j.length && (T.length > j.length ? (N = j, j = t.Util._prepareArrayForTween(j, T, A.closed())) : (R = T, T = t.Util._prepareArrayForTween(T, j, A.closed()))), _.indexOf("fill") === 0)
            for (let V = 0; V < E; V++)
              if (V % 2 === 0)
                M.push(T[V] - j[V]);
              else {
                const D = t.Util.colorToRGBA(j[V]);
                U = t.Util.colorToRGBA(T[V]), j[V] = D, M.push({
                  r: U.r - D.r,
                  g: U.g - D.g,
                  b: U.b - D.b,
                  a: U.a - D.a
                });
              }
          else
            for (let V = 0; V < E; V++)
              M.push(T[V] - j[V]);
        else p.indexOf(_) !== -1 ? (j = t.Util.colorToRGBA(j), U = t.Util.colorToRGBA(T), M = {
          r: U.r - j.r,
          g: U.g - j.g,
          b: U.b - j.b,
          a: U.a - j.a
        }) : M = T - j;
        x.attrs[O][this._id][_] = {
          start: j,
          diff: M,
          end: T,
          trueEnd: R,
          trueStart: N
        }, x.tweens[O][_] = this._id;
      }
      _tweenFunc(_) {
        const T = this.node, A = x.attrs[T._id][this._id];
        let O, M, E, R, N, U, q, j;
        for (O in A) {
          if (M = A[O], E = M.start, R = M.diff, j = M.end, t.Util._isArray(E))
            if (N = [], q = Math.max(E.length, j.length), O.indexOf("fill") === 0)
              for (U = 0; U < q; U++)
                U % 2 === 0 ? N.push((E[U] || 0) + R[U] * _) : N.push("rgba(" + Math.round(E[U].r + R[U].r * _) + "," + Math.round(E[U].g + R[U].g * _) + "," + Math.round(E[U].b + R[U].b * _) + "," + (E[U].a + R[U].a * _) + ")");
            else
              for (U = 0; U < q; U++)
                N.push((E[U] || 0) + R[U] * _);
          else p.indexOf(O) !== -1 ? N = "rgba(" + Math.round(E.r + R.r * _) + "," + Math.round(E.g + R.g * _) + "," + Math.round(E.b + R.b * _) + "," + (E.a + R.a * _) + ")" : N = E + R * _;
          T.setAttr(O, N);
        }
      }
      _addListeners() {
        this.tween.onPlay = () => {
          this.anim.start();
        }, this.tween.onReverse = () => {
          this.anim.start();
        }, this.tween.onPause = () => {
          this.anim.stop();
        }, this.tween.onFinish = () => {
          const _ = this.node, T = x.attrs[_._id][this._id];
          T.points && T.points.trueEnd && _.setAttr("points", T.points.trueEnd), this.onFinish && this.onFinish.call(this);
        }, this.tween.onReset = () => {
          const _ = this.node, T = x.attrs[_._id][this._id];
          T.points && T.points.trueStart && _.points(T.points.trueStart), this.onReset && this.onReset();
        }, this.tween.onUpdate = () => {
          this.onUpdate && this.onUpdate.call(this);
        };
      }
      play() {
        return this.tween.play(), this;
      }
      reverse() {
        return this.tween.reverse(), this;
      }
      reset() {
        return this.tween.reset(), this;
      }
      seek(_) {
        return this.tween.seek(_ * 1e3), this;
      }
      pause() {
        return this.tween.pause(), this;
      }
      finish() {
        return this.tween.finish(), this;
      }
      destroy() {
        const _ = this.node._id, T = this._id, A = x.tweens[_];
        this.pause();
        for (const O in A)
          delete x.tweens[_][O];
        delete x.attrs[_][T];
      }
    }
    e.Tween = x, x.attrs = {}, x.tweens = {}, i.Node.prototype.to = function(b) {
      const _ = b.onFinish;
      b.node = this, b.onFinish = function() {
        this.destroy(), _ && _();
      }, new x(b).play();
    }, e.Easings = {
      BackEaseIn(b, _, T, A) {
        return T * (b /= A) * b * ((1.70158 + 1) * b - 1.70158) + _;
      },
      BackEaseOut(b, _, T, A) {
        return T * ((b = b / A - 1) * b * ((1.70158 + 1) * b + 1.70158) + 1) + _;
      },
      BackEaseInOut(b, _, T, A) {
        let O = 1.70158;
        return (b /= A / 2) < 1 ? T / 2 * (b * b * (((O *= 1.525) + 1) * b - O)) + _ : T / 2 * ((b -= 2) * b * (((O *= 1.525) + 1) * b + O) + 2) + _;
      },
      ElasticEaseIn(b, _, T, A, O, M) {
        let E = 0;
        return b === 0 ? _ : (b /= A) === 1 ? _ + T : (M || (M = A * 0.3), !O || O < Math.abs(T) ? (O = T, E = M / 4) : E = M / (2 * Math.PI) * Math.asin(T / O), -(O * Math.pow(2, 10 * (b -= 1)) * Math.sin((b * A - E) * (2 * Math.PI) / M)) + _);
      },
      ElasticEaseOut(b, _, T, A, O, M) {
        let E = 0;
        return b === 0 ? _ : (b /= A) === 1 ? _ + T : (M || (M = A * 0.3), !O || O < Math.abs(T) ? (O = T, E = M / 4) : E = M / (2 * Math.PI) * Math.asin(T / O), O * Math.pow(2, -10 * b) * Math.sin((b * A - E) * (2 * Math.PI) / M) + T + _);
      },
      ElasticEaseInOut(b, _, T, A, O, M) {
        let E = 0;
        return b === 0 ? _ : (b /= A / 2) === 2 ? _ + T : (M || (M = A * (0.3 * 1.5)), !O || O < Math.abs(T) ? (O = T, E = M / 4) : E = M / (2 * Math.PI) * Math.asin(T / O), b < 1 ? -0.5 * (O * Math.pow(2, 10 * (b -= 1)) * Math.sin((b * A - E) * (2 * Math.PI) / M)) + _ : O * Math.pow(2, -10 * (b -= 1)) * Math.sin((b * A - E) * (2 * Math.PI) / M) * 0.5 + T + _);
      },
      BounceEaseOut(b, _, T, A) {
        return (b /= A) < 1 / 2.75 ? T * (7.5625 * b * b) + _ : b < 2 / 2.75 ? T * (7.5625 * (b -= 1.5 / 2.75) * b + 0.75) + _ : b < 2.5 / 2.75 ? T * (7.5625 * (b -= 2.25 / 2.75) * b + 0.9375) + _ : T * (7.5625 * (b -= 2.625 / 2.75) * b + 0.984375) + _;
      },
      BounceEaseIn(b, _, T, A) {
        return T - e.Easings.BounceEaseOut(A - b, 0, T, A) + _;
      },
      BounceEaseInOut(b, _, T, A) {
        return b < A / 2 ? e.Easings.BounceEaseIn(b * 2, 0, T, A) * 0.5 + _ : e.Easings.BounceEaseOut(b * 2 - A, 0, T, A) * 0.5 + T * 0.5 + _;
      },
      EaseIn(b, _, T, A) {
        return T * (b /= A) * b + _;
      },
      EaseOut(b, _, T, A) {
        return -T * (b /= A) * (b - 2) + _;
      },
      EaseInOut(b, _, T, A) {
        return (b /= A / 2) < 1 ? T / 2 * b * b + _ : -T / 2 * (--b * (b - 2) - 1) + _;
      },
      StrongEaseIn(b, _, T, A) {
        return T * (b /= A) * b * b * b * b + _;
      },
      StrongEaseOut(b, _, T, A) {
        return T * ((b = b / A - 1) * b * b * b * b + 1) + _;
      },
      StrongEaseInOut(b, _, T, A) {
        return (b /= A / 2) < 1 ? T / 2 * b * b * b * b * b + _ : T / 2 * ((b -= 2) * b * b * b * b + 2) + _;
      },
      Linear(b, _, T, A) {
        return T * b / A + _;
      }
    };
  }(Rb)), Rb;
}
var p4;
function v2() {
  return p4 || (p4 = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.Konva = void 0;
    const t = Sn(), n = lr(), i = br(), s = hv(), o = zU(), u = X6(), h = PU(), f = G_(), p = q_(), g = ta(), v = H_(), x = UU(), b = K6(), _ = dv();
    e.Konva = n.Util._assign(t.Konva, {
      Util: n.Util,
      Transform: n.Transform,
      Node: i.Node,
      Container: s.Container,
      Stage: o.Stage,
      stages: o.stages,
      Layer: u.Layer,
      FastLayer: h.FastLayer,
      Group: f.Group,
      DD: p.DD,
      Shape: g.Shape,
      shapes: g.shapes,
      Animation: v.Animation,
      Tween: x.Tween,
      Easings: x.Easings,
      Context: b.Context,
      Canvas: _.Canvas
    }), e.default = e.Konva;
  }(xb)), xb;
}
var Dm = {}, m4;
function jU() {
  if (m4) return Dm;
  m4 = 1, Object.defineProperty(Dm, "__esModule", { value: !0 }), Dm.Arc = void 0;
  const e = An(), t = ta(), n = Sn(), i = Mn(), s = Sn();
  let o = class extends t.Shape {
    _sceneFunc(h) {
      const f = n.Konva.getAngle(this.angle()), p = this.clockwise();
      h.beginPath(), h.arc(0, 0, this.outerRadius(), 0, f, p), h.arc(0, 0, this.innerRadius(), f, 0, !p), h.closePath(), h.fillStrokeShape(this);
    }
    getWidth() {
      return this.outerRadius() * 2;
    }
    getHeight() {
      return this.outerRadius() * 2;
    }
    setWidth(h) {
      this.outerRadius(h / 2);
    }
    setHeight(h) {
      this.outerRadius(h / 2);
    }
    getSelfRect() {
      const h = this.innerRadius(), f = this.outerRadius(), p = this.clockwise(), g = n.Konva.getAngle(p ? 360 - this.angle() : this.angle()), v = Math.cos(Math.min(g, Math.PI)), x = 1, b = Math.sin(Math.min(Math.max(Math.PI, g), 3 * Math.PI / 2)), _ = Math.sin(Math.min(g, Math.PI / 2)), T = v * (v > 0 ? h : f), A = x * f, O = b * (b > 0 ? h : f), M = _ * (_ > 0 ? f : h);
      return {
        x: T,
        y: p ? -1 * M : O,
        width: A - T,
        height: M - O
      };
    }
  };
  return Dm.Arc = o, o.prototype._centroid = !0, o.prototype.className = "Arc", o.prototype._attrsAffectingSize = [
    "innerRadius",
    "outerRadius",
    "angle",
    "clockwise"
  ], (0, s._registerNode)(o), e.Factory.addGetterSetter(o, "innerRadius", 0, (0, i.getNumberValidator)()), e.Factory.addGetterSetter(o, "outerRadius", 0, (0, i.getNumberValidator)()), e.Factory.addGetterSetter(o, "angle", 0, (0, i.getNumberValidator)()), e.Factory.addGetterSetter(o, "clockwise", !1, (0, i.getBooleanValidator)()), Dm;
}
var Bm = {}, zm = {}, g4;
function W6() {
  if (g4) return zm;
  g4 = 1, Object.defineProperty(zm, "__esModule", { value: !0 }), zm.Line = void 0;
  const e = An(), t = Sn(), n = ta(), i = Mn();
  function s(h, f, p, g, v, x, b) {
    const _ = Math.sqrt(Math.pow(p - h, 2) + Math.pow(g - f, 2)), T = Math.sqrt(Math.pow(v - p, 2) + Math.pow(x - g, 2)), A = b * _ / (_ + T), O = b * T / (_ + T), M = p - A * (v - h), E = g - A * (x - f), R = p + O * (v - h), N = g + O * (x - f);
    return [M, E, R, N];
  }
  function o(h, f) {
    const p = h.length, g = [];
    for (let v = 2; v < p - 2; v += 2) {
      const x = s(h[v - 2], h[v - 1], h[v], h[v + 1], h[v + 2], h[v + 3], f);
      isNaN(x[0]) || (g.push(x[0]), g.push(x[1]), g.push(h[v]), g.push(h[v + 1]), g.push(x[2]), g.push(x[3]));
    }
    return g;
  }
  class u extends n.Shape {
    constructor(f) {
      super(f), this.on("pointsChange.konva tensionChange.konva closedChange.konva bezierChange.konva", function() {
        this._clearCache("tensionPoints");
      });
    }
    _sceneFunc(f) {
      let p = this.points(), g = p.length, v = this.tension(), x = this.closed(), b = this.bezier(), _, T, A;
      if (g) {
        if (f.beginPath(), f.moveTo(p[0], p[1]), v !== 0 && g > 4) {
          for (_ = this.getTensionPoints(), T = _.length, A = x ? 0 : 4, x || f.quadraticCurveTo(_[0], _[1], _[2], _[3]); A < T - 2; )
            f.bezierCurveTo(_[A++], _[A++], _[A++], _[A++], _[A++], _[A++]);
          x || f.quadraticCurveTo(_[T - 2], _[T - 1], p[g - 2], p[g - 1]);
        } else if (b)
          for (A = 2; A < g; )
            f.bezierCurveTo(p[A++], p[A++], p[A++], p[A++], p[A++], p[A++]);
        else
          for (A = 2; A < g; A += 2)
            f.lineTo(p[A], p[A + 1]);
        x ? (f.closePath(), f.fillStrokeShape(this)) : f.strokeShape(this);
      }
    }
    getTensionPoints() {
      return this._getCache("tensionPoints", this._getTensionPoints);
    }
    _getTensionPoints() {
      return this.closed() ? this._getTensionPointsClosed() : o(this.points(), this.tension());
    }
    _getTensionPointsClosed() {
      const f = this.points(), p = f.length, g = this.tension(), v = s(f[p - 2], f[p - 1], f[0], f[1], f[2], f[3], g), x = s(f[p - 4], f[p - 3], f[p - 2], f[p - 1], f[0], f[1], g), b = o(f, g);
      return [v[2], v[3]].concat(b).concat([
        x[0],
        x[1],
        f[p - 2],
        f[p - 1],
        x[2],
        x[3],
        v[0],
        v[1],
        f[0],
        f[1]
      ]);
    }
    getWidth() {
      return this.getSelfRect().width;
    }
    getHeight() {
      return this.getSelfRect().height;
    }
    getSelfRect() {
      let f = this.points();
      if (f.length < 4)
        return {
          x: f[0] || 0,
          y: f[1] || 0,
          width: 0,
          height: 0
        };
      this.tension() !== 0 ? f = [
        f[0],
        f[1],
        ...this._getTensionPoints(),
        f[f.length - 2],
        f[f.length - 1]
      ] : f = this.points();
      let p = f[0], g = f[0], v = f[1], x = f[1], b, _;
      for (let T = 0; T < f.length / 2; T++)
        b = f[T * 2], _ = f[T * 2 + 1], p = Math.min(p, b), g = Math.max(g, b), v = Math.min(v, _), x = Math.max(x, _);
      return {
        x: p,
        y: v,
        width: g - p,
        height: x - v
      };
    }
  }
  return zm.Line = u, u.prototype.className = "Line", u.prototype._attrsAffectingSize = ["points", "bezier", "tension"], (0, t._registerNode)(u), e.Factory.addGetterSetter(u, "closed", !1), e.Factory.addGetterSetter(u, "bezier", !1), e.Factory.addGetterSetter(u, "tension", 0, (0, i.getNumberValidator)()), e.Factory.addGetterSetter(u, "points", [], (0, i.getNumberArrayValidator)()), zm;
}
var Pm = {}, Ob = {}, y4;
function LU() {
  return y4 || (y4 = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.t2length = e.getQuadraticArcLength = e.getCubicArcLength = e.binomialCoefficients = e.cValues = e.tValues = void 0, e.tValues = [
      [],
      [],
      [
        -0.5773502691896257,
        0.5773502691896257
      ],
      [
        0,
        -0.7745966692414834,
        0.7745966692414834
      ],
      [
        -0.33998104358485626,
        0.33998104358485626,
        -0.8611363115940526,
        0.8611363115940526
      ],
      [
        0,
        -0.5384693101056831,
        0.5384693101056831,
        -0.906179845938664,
        0.906179845938664
      ],
      [
        0.6612093864662645,
        -0.6612093864662645,
        -0.2386191860831969,
        0.2386191860831969,
        -0.932469514203152,
        0.932469514203152
      ],
      [
        0,
        0.4058451513773972,
        -0.4058451513773972,
        -0.7415311855993945,
        0.7415311855993945,
        -0.9491079123427585,
        0.9491079123427585
      ],
      [
        -0.1834346424956498,
        0.1834346424956498,
        -0.525532409916329,
        0.525532409916329,
        -0.7966664774136267,
        0.7966664774136267,
        -0.9602898564975363,
        0.9602898564975363
      ],
      [
        0,
        -0.8360311073266358,
        0.8360311073266358,
        -0.9681602395076261,
        0.9681602395076261,
        -0.3242534234038089,
        0.3242534234038089,
        -0.6133714327005904,
        0.6133714327005904
      ],
      [
        -0.14887433898163122,
        0.14887433898163122,
        -0.4333953941292472,
        0.4333953941292472,
        -0.6794095682990244,
        0.6794095682990244,
        -0.8650633666889845,
        0.8650633666889845,
        -0.9739065285171717,
        0.9739065285171717
      ],
      [
        0,
        -0.26954315595234496,
        0.26954315595234496,
        -0.5190961292068118,
        0.5190961292068118,
        -0.7301520055740494,
        0.7301520055740494,
        -0.8870625997680953,
        0.8870625997680953,
        -0.978228658146057,
        0.978228658146057
      ],
      [
        -0.1252334085114689,
        0.1252334085114689,
        -0.3678314989981802,
        0.3678314989981802,
        -0.5873179542866175,
        0.5873179542866175,
        -0.7699026741943047,
        0.7699026741943047,
        -0.9041172563704749,
        0.9041172563704749,
        -0.9815606342467192,
        0.9815606342467192
      ],
      [
        0,
        -0.2304583159551348,
        0.2304583159551348,
        -0.44849275103644687,
        0.44849275103644687,
        -0.6423493394403402,
        0.6423493394403402,
        -0.8015780907333099,
        0.8015780907333099,
        -0.9175983992229779,
        0.9175983992229779,
        -0.9841830547185881,
        0.9841830547185881
      ],
      [
        -0.10805494870734367,
        0.10805494870734367,
        -0.31911236892788974,
        0.31911236892788974,
        -0.5152486363581541,
        0.5152486363581541,
        -0.6872929048116855,
        0.6872929048116855,
        -0.827201315069765,
        0.827201315069765,
        -0.9284348836635735,
        0.9284348836635735,
        -0.9862838086968123,
        0.9862838086968123
      ],
      [
        0,
        -0.20119409399743451,
        0.20119409399743451,
        -0.3941513470775634,
        0.3941513470775634,
        -0.5709721726085388,
        0.5709721726085388,
        -0.7244177313601701,
        0.7244177313601701,
        -0.8482065834104272,
        0.8482065834104272,
        -0.937273392400706,
        0.937273392400706,
        -0.9879925180204854,
        0.9879925180204854
      ],
      [
        -0.09501250983763744,
        0.09501250983763744,
        -0.2816035507792589,
        0.2816035507792589,
        -0.45801677765722737,
        0.45801677765722737,
        -0.6178762444026438,
        0.6178762444026438,
        -0.755404408355003,
        0.755404408355003,
        -0.8656312023878318,
        0.8656312023878318,
        -0.9445750230732326,
        0.9445750230732326,
        -0.9894009349916499,
        0.9894009349916499
      ],
      [
        0,
        -0.17848418149584785,
        0.17848418149584785,
        -0.3512317634538763,
        0.3512317634538763,
        -0.5126905370864769,
        0.5126905370864769,
        -0.6576711592166907,
        0.6576711592166907,
        -0.7815140038968014,
        0.7815140038968014,
        -0.8802391537269859,
        0.8802391537269859,
        -0.9506755217687678,
        0.9506755217687678,
        -0.9905754753144174,
        0.9905754753144174
      ],
      [
        -0.0847750130417353,
        0.0847750130417353,
        -0.2518862256915055,
        0.2518862256915055,
        -0.41175116146284263,
        0.41175116146284263,
        -0.5597708310739475,
        0.5597708310739475,
        -0.6916870430603532,
        0.6916870430603532,
        -0.8037049589725231,
        0.8037049589725231,
        -0.8926024664975557,
        0.8926024664975557,
        -0.9558239495713977,
        0.9558239495713977,
        -0.9915651684209309,
        0.9915651684209309
      ],
      [
        0,
        -0.16035864564022537,
        0.16035864564022537,
        -0.31656409996362983,
        0.31656409996362983,
        -0.46457074137596094,
        0.46457074137596094,
        -0.600545304661681,
        0.600545304661681,
        -0.7209661773352294,
        0.7209661773352294,
        -0.8227146565371428,
        0.8227146565371428,
        -0.9031559036148179,
        0.9031559036148179,
        -0.96020815213483,
        0.96020815213483,
        -0.9924068438435844,
        0.9924068438435844
      ],
      [
        -0.07652652113349734,
        0.07652652113349734,
        -0.22778585114164507,
        0.22778585114164507,
        -0.37370608871541955,
        0.37370608871541955,
        -0.5108670019508271,
        0.5108670019508271,
        -0.636053680726515,
        0.636053680726515,
        -0.7463319064601508,
        0.7463319064601508,
        -0.8391169718222188,
        0.8391169718222188,
        -0.912234428251326,
        0.912234428251326,
        -0.9639719272779138,
        0.9639719272779138,
        -0.9931285991850949,
        0.9931285991850949
      ],
      [
        0,
        -0.1455618541608951,
        0.1455618541608951,
        -0.2880213168024011,
        0.2880213168024011,
        -0.4243421202074388,
        0.4243421202074388,
        -0.5516188358872198,
        0.5516188358872198,
        -0.6671388041974123,
        0.6671388041974123,
        -0.7684399634756779,
        0.7684399634756779,
        -0.8533633645833173,
        0.8533633645833173,
        -0.9200993341504008,
        0.9200993341504008,
        -0.9672268385663063,
        0.9672268385663063,
        -0.9937521706203895,
        0.9937521706203895
      ],
      [
        -0.06973927331972223,
        0.06973927331972223,
        -0.20786042668822127,
        0.20786042668822127,
        -0.34193582089208424,
        0.34193582089208424,
        -0.469355837986757,
        0.469355837986757,
        -0.5876404035069116,
        0.5876404035069116,
        -0.6944872631866827,
        0.6944872631866827,
        -0.7878168059792081,
        0.7878168059792081,
        -0.8658125777203002,
        0.8658125777203002,
        -0.926956772187174,
        0.926956772187174,
        -0.9700604978354287,
        0.9700604978354287,
        -0.9942945854823992,
        0.9942945854823992
      ],
      [
        0,
        -0.1332568242984661,
        0.1332568242984661,
        -0.26413568097034495,
        0.26413568097034495,
        -0.3903010380302908,
        0.3903010380302908,
        -0.5095014778460075,
        0.5095014778460075,
        -0.6196098757636461,
        0.6196098757636461,
        -0.7186613631319502,
        0.7186613631319502,
        -0.8048884016188399,
        0.8048884016188399,
        -0.8767523582704416,
        0.8767523582704416,
        -0.9329710868260161,
        0.9329710868260161,
        -0.9725424712181152,
        0.9725424712181152,
        -0.9947693349975522,
        0.9947693349975522
      ],
      [
        -0.06405689286260563,
        0.06405689286260563,
        -0.1911188674736163,
        0.1911188674736163,
        -0.3150426796961634,
        0.3150426796961634,
        -0.4337935076260451,
        0.4337935076260451,
        -0.5454214713888396,
        0.5454214713888396,
        -0.6480936519369755,
        0.6480936519369755,
        -0.7401241915785544,
        0.7401241915785544,
        -0.820001985973903,
        0.820001985973903,
        -0.8864155270044011,
        0.8864155270044011,
        -0.9382745520027328,
        0.9382745520027328,
        -0.9747285559713095,
        0.9747285559713095,
        -0.9951872199970213,
        0.9951872199970213
      ]
    ], e.cValues = [
      [],
      [],
      [1, 1],
      [
        0.8888888888888888,
        0.5555555555555556,
        0.5555555555555556
      ],
      [
        0.6521451548625461,
        0.6521451548625461,
        0.34785484513745385,
        0.34785484513745385
      ],
      [
        0.5688888888888889,
        0.47862867049936647,
        0.47862867049936647,
        0.23692688505618908,
        0.23692688505618908
      ],
      [
        0.3607615730481386,
        0.3607615730481386,
        0.46791393457269104,
        0.46791393457269104,
        0.17132449237917036,
        0.17132449237917036
      ],
      [
        0.4179591836734694,
        0.3818300505051189,
        0.3818300505051189,
        0.27970539148927664,
        0.27970539148927664,
        0.1294849661688697,
        0.1294849661688697
      ],
      [
        0.362683783378362,
        0.362683783378362,
        0.31370664587788727,
        0.31370664587788727,
        0.22238103445337448,
        0.22238103445337448,
        0.10122853629037626,
        0.10122853629037626
      ],
      [
        0.3302393550012598,
        0.1806481606948574,
        0.1806481606948574,
        0.08127438836157441,
        0.08127438836157441,
        0.31234707704000286,
        0.31234707704000286,
        0.26061069640293544,
        0.26061069640293544
      ],
      [
        0.29552422471475287,
        0.29552422471475287,
        0.26926671930999635,
        0.26926671930999635,
        0.21908636251598204,
        0.21908636251598204,
        0.1494513491505806,
        0.1494513491505806,
        0.06667134430868814,
        0.06667134430868814
      ],
      [
        0.2729250867779006,
        0.26280454451024665,
        0.26280454451024665,
        0.23319376459199048,
        0.23319376459199048,
        0.18629021092773426,
        0.18629021092773426,
        0.1255803694649046,
        0.1255803694649046,
        0.05566856711617366,
        0.05566856711617366
      ],
      [
        0.24914704581340277,
        0.24914704581340277,
        0.2334925365383548,
        0.2334925365383548,
        0.20316742672306592,
        0.20316742672306592,
        0.16007832854334622,
        0.16007832854334622,
        0.10693932599531843,
        0.10693932599531843,
        0.04717533638651183,
        0.04717533638651183
      ],
      [
        0.2325515532308739,
        0.22628318026289723,
        0.22628318026289723,
        0.2078160475368885,
        0.2078160475368885,
        0.17814598076194574,
        0.17814598076194574,
        0.13887351021978725,
        0.13887351021978725,
        0.09212149983772845,
        0.09212149983772845,
        0.04048400476531588,
        0.04048400476531588
      ],
      [
        0.2152638534631578,
        0.2152638534631578,
        0.2051984637212956,
        0.2051984637212956,
        0.18553839747793782,
        0.18553839747793782,
        0.15720316715819355,
        0.15720316715819355,
        0.12151857068790319,
        0.12151857068790319,
        0.08015808715976021,
        0.08015808715976021,
        0.03511946033175186,
        0.03511946033175186
      ],
      [
        0.2025782419255613,
        0.19843148532711158,
        0.19843148532711158,
        0.1861610000155622,
        0.1861610000155622,
        0.16626920581699392,
        0.16626920581699392,
        0.13957067792615432,
        0.13957067792615432,
        0.10715922046717194,
        0.10715922046717194,
        0.07036604748810812,
        0.07036604748810812,
        0.03075324199611727,
        0.03075324199611727
      ],
      [
        0.1894506104550685,
        0.1894506104550685,
        0.18260341504492358,
        0.18260341504492358,
        0.16915651939500254,
        0.16915651939500254,
        0.14959598881657674,
        0.14959598881657674,
        0.12462897125553388,
        0.12462897125553388,
        0.09515851168249279,
        0.09515851168249279,
        0.062253523938647894,
        0.062253523938647894,
        0.027152459411754096,
        0.027152459411754096
      ],
      [
        0.17944647035620653,
        0.17656270536699264,
        0.17656270536699264,
        0.16800410215645004,
        0.16800410215645004,
        0.15404576107681028,
        0.15404576107681028,
        0.13513636846852548,
        0.13513636846852548,
        0.11188384719340397,
        0.11188384719340397,
        0.08503614831717918,
        0.08503614831717918,
        0.0554595293739872,
        0.0554595293739872,
        0.02414830286854793,
        0.02414830286854793
      ],
      [
        0.1691423829631436,
        0.1691423829631436,
        0.16427648374583273,
        0.16427648374583273,
        0.15468467512626524,
        0.15468467512626524,
        0.14064291467065065,
        0.14064291467065065,
        0.12255520671147846,
        0.12255520671147846,
        0.10094204410628717,
        0.10094204410628717,
        0.07642573025488905,
        0.07642573025488905,
        0.0497145488949698,
        0.0497145488949698,
        0.02161601352648331,
        0.02161601352648331
      ],
      [
        0.1610544498487837,
        0.15896884339395434,
        0.15896884339395434,
        0.15276604206585967,
        0.15276604206585967,
        0.1426067021736066,
        0.1426067021736066,
        0.12875396253933621,
        0.12875396253933621,
        0.11156664554733399,
        0.11156664554733399,
        0.09149002162245,
        0.09149002162245,
        0.06904454273764123,
        0.06904454273764123,
        0.0448142267656996,
        0.0448142267656996,
        0.019461788229726478,
        0.019461788229726478
      ],
      [
        0.15275338713072584,
        0.15275338713072584,
        0.14917298647260374,
        0.14917298647260374,
        0.14209610931838204,
        0.14209610931838204,
        0.13168863844917664,
        0.13168863844917664,
        0.11819453196151841,
        0.11819453196151841,
        0.10193011981724044,
        0.10193011981724044,
        0.08327674157670475,
        0.08327674157670475,
        0.06267204833410907,
        0.06267204833410907,
        0.04060142980038694,
        0.04060142980038694,
        0.017614007139152118,
        0.017614007139152118
      ],
      [
        0.14608113364969041,
        0.14452440398997005,
        0.14452440398997005,
        0.13988739479107315,
        0.13988739479107315,
        0.13226893863333747,
        0.13226893863333747,
        0.12183141605372853,
        0.12183141605372853,
        0.10879729916714838,
        0.10879729916714838,
        0.09344442345603386,
        0.09344442345603386,
        0.0761001136283793,
        0.0761001136283793,
        0.057134425426857205,
        0.057134425426857205,
        0.036953789770852494,
        0.036953789770852494,
        0.016017228257774335,
        0.016017228257774335
      ],
      [
        0.13925187285563198,
        0.13925187285563198,
        0.13654149834601517,
        0.13654149834601517,
        0.13117350478706238,
        0.13117350478706238,
        0.12325237681051242,
        0.12325237681051242,
        0.11293229608053922,
        0.11293229608053922,
        0.10041414444288096,
        0.10041414444288096,
        0.08594160621706773,
        0.08594160621706773,
        0.06979646842452049,
        0.06979646842452049,
        0.052293335152683286,
        0.052293335152683286,
        0.03377490158481415,
        0.03377490158481415,
        0.0146279952982722,
        0.0146279952982722
      ],
      [
        0.13365457218610619,
        0.1324620394046966,
        0.1324620394046966,
        0.12890572218808216,
        0.12890572218808216,
        0.12304908430672953,
        0.12304908430672953,
        0.11499664022241136,
        0.11499664022241136,
        0.10489209146454141,
        0.10489209146454141,
        0.09291576606003515,
        0.09291576606003515,
        0.07928141177671895,
        0.07928141177671895,
        0.06423242140852585,
        0.06423242140852585,
        0.04803767173108467,
        0.04803767173108467,
        0.030988005856979445,
        0.030988005856979445,
        0.013411859487141771,
        0.013411859487141771
      ],
      [
        0.12793819534675216,
        0.12793819534675216,
        0.1258374563468283,
        0.1258374563468283,
        0.12167047292780339,
        0.12167047292780339,
        0.1155056680537256,
        0.1155056680537256,
        0.10744427011596563,
        0.10744427011596563,
        0.09761865210411388,
        0.09761865210411388,
        0.08619016153195327,
        0.08619016153195327,
        0.0733464814110803,
        0.0733464814110803,
        0.05929858491543678,
        0.05929858491543678,
        0.04427743881741981,
        0.04427743881741981,
        0.028531388628933663,
        0.028531388628933663,
        0.0123412297999872,
        0.0123412297999872
      ]
    ], e.binomialCoefficients = [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1]];
    const t = (u, h, f) => {
      let p, g;
      const x = f / 2;
      p = 0;
      for (let b = 0; b < 20; b++)
        g = x * e.tValues[20][b] + x, p += e.cValues[20][b] * i(u, h, g);
      return x * p;
    };
    e.getCubicArcLength = t;
    const n = (u, h, f) => {
      f === void 0 && (f = 1);
      const p = u[0] - 2 * u[1] + u[2], g = h[0] - 2 * h[1] + h[2], v = 2 * u[1] - 2 * u[0], x = 2 * h[1] - 2 * h[0], b = 4 * (p * p + g * g), _ = 4 * (p * v + g * x), T = v * v + x * x;
      if (b === 0)
        return f * Math.sqrt(Math.pow(u[2] - u[0], 2) + Math.pow(h[2] - h[0], 2));
      const A = _ / (2 * b), O = T / b, M = f + A, E = O - A * A, R = M * M + E > 0 ? Math.sqrt(M * M + E) : 0, N = A * A + E > 0 ? Math.sqrt(A * A + E) : 0, U = A + Math.sqrt(A * A + E) !== 0 ? E * Math.log(Math.abs((M + R) / (A + N))) : 0;
      return Math.sqrt(b) / 2 * (M * R - A * N + U);
    };
    e.getQuadraticArcLength = n;
    function i(u, h, f) {
      const p = s(1, f, u), g = s(1, f, h), v = p * p + g * g;
      return Math.sqrt(v);
    }
    const s = (u, h, f) => {
      const p = f.length - 1;
      let g, v;
      if (p === 0)
        return 0;
      if (u === 0) {
        v = 0;
        for (let x = 0; x <= p; x++)
          v += e.binomialCoefficients[p][x] * Math.pow(1 - h, p - x) * Math.pow(h, x) * f[x];
        return v;
      } else {
        g = new Array(p);
        for (let x = 0; x < p; x++)
          g[x] = p * (f[x + 1] - f[x]);
        return s(u - 1, h, g);
      }
    }, o = (u, h, f) => {
      let p = 1, g = u / h, v = (u - f(g)) / h, x = 0;
      for (; p > 1e-3; ) {
        const b = f(g + v), _ = Math.abs(u - b) / h;
        if (_ < p)
          p = _, g += v;
        else {
          const T = f(g - v), A = Math.abs(u - T) / h;
          A < p ? (p = A, g -= v) : v /= 2;
        }
        if (x++, x > 500)
          break;
      }
      return g;
    };
    e.t2length = o;
  }(Ob)), Ob;
}
var v4;
function K_() {
  if (v4) return Pm;
  v4 = 1, Object.defineProperty(Pm, "__esModule", { value: !0 }), Pm.Path = void 0;
  const e = An(), t = ta(), n = Sn(), i = LU();
  let s = class bs extends t.Shape {
    constructor(u) {
      super(u), this.dataArray = [], this.pathLength = 0, this._readDataAttribute(), this.on("dataChange.konva", function() {
        this._readDataAttribute();
      });
    }
    _readDataAttribute() {
      this.dataArray = bs.parsePathData(this.data()), this.pathLength = bs.getPathLength(this.dataArray);
    }
    _sceneFunc(u) {
      const h = this.dataArray;
      u.beginPath();
      let f = !1;
      for (let R = 0; R < h.length; R++) {
        const N = h[R].command, U = h[R].points;
        switch (N) {
          case "L":
            u.lineTo(U[0], U[1]);
            break;
          case "M":
            u.moveTo(U[0], U[1]);
            break;
          case "C":
            u.bezierCurveTo(U[0], U[1], U[2], U[3], U[4], U[5]);
            break;
          case "Q":
            u.quadraticCurveTo(U[0], U[1], U[2], U[3]);
            break;
          case "A":
            var p = U[0], g = U[1], v = U[2], x = U[3], b = U[4], _ = U[5], T = U[6], A = U[7], O = v > x ? v : x, M = v > x ? 1 : v / x, E = v > x ? x / v : 1;
            u.translate(p, g), u.rotate(T), u.scale(M, E), u.arc(0, 0, O, b, b + _, 1 - A), u.scale(1 / M, 1 / E), u.rotate(-T), u.translate(-p, -g);
            break;
          case "z":
            f = !0, u.closePath();
            break;
        }
      }
      !f && !this.hasFill() ? u.strokeShape(this) : u.fillStrokeShape(this);
    }
    getSelfRect() {
      let u = [];
      this.dataArray.forEach(function(b) {
        if (b.command === "A") {
          const _ = b.points[4], T = b.points[5], A = b.points[4] + T;
          let O = Math.PI / 180;
          if (Math.abs(_ - A) < O && (O = Math.abs(_ - A)), T < 0)
            for (let M = _ - O; M > A; M -= O) {
              const E = bs.getPointOnEllipticalArc(b.points[0], b.points[1], b.points[2], b.points[3], M, 0);
              u.push(E.x, E.y);
            }
          else
            for (let M = _ + O; M < A; M += O) {
              const E = bs.getPointOnEllipticalArc(b.points[0], b.points[1], b.points[2], b.points[3], M, 0);
              u.push(E.x, E.y);
            }
        } else if (b.command === "C")
          for (let _ = 0; _ <= 1; _ += 0.01) {
            const T = bs.getPointOnCubicBezier(_, b.start.x, b.start.y, b.points[0], b.points[1], b.points[2], b.points[3], b.points[4], b.points[5]);
            u.push(T.x, T.y);
          }
        else
          u = u.concat(b.points);
      });
      let h = u[0], f = u[0], p = u[1], g = u[1], v, x;
      for (let b = 0; b < u.length / 2; b++)
        v = u[b * 2], x = u[b * 2 + 1], isNaN(v) || (h = Math.min(h, v), f = Math.max(f, v)), isNaN(x) || (p = Math.min(p, x), g = Math.max(g, x));
      return {
        x: h,
        y: p,
        width: f - h,
        height: g - p
      };
    }
    getLength() {
      return this.pathLength;
    }
    getPointAtLength(u) {
      return bs.getPointAtLengthOfDataArray(u, this.dataArray);
    }
    static getLineLength(u, h, f, p) {
      return Math.sqrt((f - u) * (f - u) + (p - h) * (p - h));
    }
    static getPathLength(u) {
      let h = 0;
      for (let f = 0; f < u.length; ++f)
        h += u[f].pathLength;
      return h;
    }
    static getPointAtLengthOfDataArray(u, h) {
      let f, p = 0, g = h.length;
      if (!g)
        return null;
      for (; p < g && u > h[p].pathLength; )
        u -= h[p].pathLength, ++p;
      if (p === g)
        return f = h[p - 1].points.slice(-2), {
          x: f[0],
          y: f[1]
        };
      if (u < 0.01)
        return f = h[p].points.slice(0, 2), {
          x: f[0],
          y: f[1]
        };
      const v = h[p], x = v.points;
      switch (v.command) {
        case "L":
          return bs.getPointOnLine(u, v.start.x, v.start.y, x[0], x[1]);
        case "C":
          return bs.getPointOnCubicBezier((0, i.t2length)(u, bs.getPathLength(h), (R) => (0, i.getCubicArcLength)([v.start.x, x[0], x[2], x[4]], [v.start.y, x[1], x[3], x[5]], R)), v.start.x, v.start.y, x[0], x[1], x[2], x[3], x[4], x[5]);
        case "Q":
          return bs.getPointOnQuadraticBezier((0, i.t2length)(u, bs.getPathLength(h), (R) => (0, i.getQuadraticArcLength)([v.start.x, x[0], x[2]], [v.start.y, x[1], x[3]], R)), v.start.x, v.start.y, x[0], x[1], x[2], x[3]);
        case "A":
          var b = x[0], _ = x[1], T = x[2], A = x[3], O = x[4], M = x[5], E = x[6];
          return O += M * u / v.pathLength, bs.getPointOnEllipticalArc(b, _, T, A, O, E);
      }
      return null;
    }
    static getPointOnLine(u, h, f, p, g, v, x) {
      v = v ?? h, x = x ?? f;
      const b = this.getLineLength(h, f, p, g);
      if (b < 1e-10)
        return { x: h, y: f };
      if (p === h)
        return { x: v, y: x + (g > f ? u : -u) };
      const _ = (g - f) / (p - h), T = Math.sqrt(u * u / (1 + _ * _)) * (p < h ? -1 : 1), A = _ * T;
      if (Math.abs(x - f - _ * (v - h)) < 1e-10)
        return { x: v + T, y: x + A };
      const O = ((v - h) * (p - h) + (x - f) * (g - f)) / (b * b), M = h + O * (p - h), E = f + O * (g - f), R = this.getLineLength(v, x, M, E), N = Math.sqrt(u * u - R * R), U = Math.sqrt(N * N / (1 + _ * _)) * (p < h ? -1 : 1), q = _ * U;
      return { x: M + U, y: E + q };
    }
    static getPointOnCubicBezier(u, h, f, p, g, v, x, b, _) {
      function T(N) {
        return N * N * N;
      }
      function A(N) {
        return 3 * N * N * (1 - N);
      }
      function O(N) {
        return 3 * N * (1 - N) * (1 - N);
      }
      function M(N) {
        return (1 - N) * (1 - N) * (1 - N);
      }
      const E = b * T(u) + v * A(u) + p * O(u) + h * M(u), R = _ * T(u) + x * A(u) + g * O(u) + f * M(u);
      return {
        x: E,
        y: R
      };
    }
    static getPointOnQuadraticBezier(u, h, f, p, g, v, x) {
      function b(M) {
        return M * M;
      }
      function _(M) {
        return 2 * M * (1 - M);
      }
      function T(M) {
        return (1 - M) * (1 - M);
      }
      const A = v * b(u) + p * _(u) + h * T(u), O = x * b(u) + g * _(u) + f * T(u);
      return {
        x: A,
        y: O
      };
    }
    static getPointOnEllipticalArc(u, h, f, p, g, v) {
      const x = Math.cos(v), b = Math.sin(v), _ = {
        x: f * Math.cos(g),
        y: p * Math.sin(g)
      };
      return {
        x: u + (_.x * x - _.y * b),
        y: h + (_.x * b + _.y * x)
      };
    }
    static parsePathData(u) {
      if (!u)
        return [];
      let h = u;
      const f = [
        "m",
        "M",
        "l",
        "L",
        "v",
        "V",
        "h",
        "H",
        "z",
        "Z",
        "c",
        "C",
        "q",
        "Q",
        "t",
        "T",
        "s",
        "S",
        "a",
        "A"
      ];
      h = h.replace(new RegExp(" ", "g"), ",");
      for (var p = 0; p < f.length; p++)
        h = h.replace(new RegExp(f[p], "g"), "|" + f[p]);
      const g = h.split("|"), v = [], x = [];
      let b = 0, _ = 0;
      const T = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:e[-+]?\d+)?)/gi;
      let A;
      for (p = 1; p < g.length; p++) {
        let P = g[p], H = P.charAt(0);
        for (P = P.slice(1), x.length = 0; A = T.exec(P); )
          x.push(A[0]);
        const I = [];
        for (let K = 0, Q = x.length; K < Q; K++) {
          if (x[K] === "00") {
            I.push(0, 0);
            continue;
          }
          const it = parseFloat(x[K]);
          isNaN(it) ? I.push(0) : I.push(it);
        }
        for (; I.length > 0 && !isNaN(I[0]); ) {
          let K = "", Q = [];
          const it = b, nt = _;
          var O, M, E, R, N, U, q, j, V, D;
          switch (H) {
            case "l":
              b += I.shift(), _ += I.shift(), K = "L", Q.push(b, _);
              break;
            case "L":
              b = I.shift(), _ = I.shift(), Q.push(b, _);
              break;
            case "m":
              var G = I.shift(), W = I.shift();
              if (b += G, _ += W, K = "M", v.length > 2 && v[v.length - 1].command === "z") {
                for (let X = v.length - 2; X >= 0; X--)
                  if (v[X].command === "M") {
                    b = v[X].points[0] + G, _ = v[X].points[1] + W;
                    break;
                  }
              }
              Q.push(b, _), H = "l";
              break;
            case "M":
              b = I.shift(), _ = I.shift(), K = "M", Q.push(b, _), H = "L";
              break;
            case "h":
              b += I.shift(), K = "L", Q.push(b, _);
              break;
            case "H":
              b = I.shift(), K = "L", Q.push(b, _);
              break;
            case "v":
              _ += I.shift(), K = "L", Q.push(b, _);
              break;
            case "V":
              _ = I.shift(), K = "L", Q.push(b, _);
              break;
            case "C":
              Q.push(I.shift(), I.shift(), I.shift(), I.shift()), b = I.shift(), _ = I.shift(), Q.push(b, _);
              break;
            case "c":
              Q.push(b + I.shift(), _ + I.shift(), b + I.shift(), _ + I.shift()), b += I.shift(), _ += I.shift(), K = "C", Q.push(b, _);
              break;
            case "S":
              M = b, E = _, O = v[v.length - 1], O.command === "C" && (M = b + (b - O.points[2]), E = _ + (_ - O.points[3])), Q.push(M, E, I.shift(), I.shift()), b = I.shift(), _ = I.shift(), K = "C", Q.push(b, _);
              break;
            case "s":
              M = b, E = _, O = v[v.length - 1], O.command === "C" && (M = b + (b - O.points[2]), E = _ + (_ - O.points[3])), Q.push(M, E, b + I.shift(), _ + I.shift()), b += I.shift(), _ += I.shift(), K = "C", Q.push(b, _);
              break;
            case "Q":
              Q.push(I.shift(), I.shift()), b = I.shift(), _ = I.shift(), Q.push(b, _);
              break;
            case "q":
              Q.push(b + I.shift(), _ + I.shift()), b += I.shift(), _ += I.shift(), K = "Q", Q.push(b, _);
              break;
            case "T":
              M = b, E = _, O = v[v.length - 1], O.command === "Q" && (M = b + (b - O.points[0]), E = _ + (_ - O.points[1])), b = I.shift(), _ = I.shift(), K = "Q", Q.push(M, E, b, _);
              break;
            case "t":
              M = b, E = _, O = v[v.length - 1], O.command === "Q" && (M = b + (b - O.points[0]), E = _ + (_ - O.points[1])), b += I.shift(), _ += I.shift(), K = "Q", Q.push(M, E, b, _);
              break;
            case "A":
              R = I.shift(), N = I.shift(), U = I.shift(), q = I.shift(), j = I.shift(), V = b, D = _, b = I.shift(), _ = I.shift(), K = "A", Q = this.convertEndpointToCenterParameterization(V, D, b, _, q, j, R, N, U);
              break;
            case "a":
              R = I.shift(), N = I.shift(), U = I.shift(), q = I.shift(), j = I.shift(), V = b, D = _, b += I.shift(), _ += I.shift(), K = "A", Q = this.convertEndpointToCenterParameterization(V, D, b, _, q, j, R, N, U);
              break;
          }
          v.push({
            command: K || H,
            points: Q,
            start: {
              x: it,
              y: nt
            },
            pathLength: this.calcLength(it, nt, K || H, Q)
          });
        }
        (H === "z" || H === "Z") && v.push({
          command: "z",
          points: [],
          start: void 0,
          pathLength: 0
        });
      }
      return v;
    }
    static calcLength(u, h, f, p) {
      let g, v, x, b;
      const _ = bs;
      switch (f) {
        case "L":
          return _.getLineLength(u, h, p[0], p[1]);
        case "C":
          return (0, i.getCubicArcLength)([u, p[0], p[2], p[4]], [h, p[1], p[3], p[5]], 1);
        case "Q":
          return (0, i.getQuadraticArcLength)([u, p[0], p[2]], [h, p[1], p[3]], 1);
        case "A":
          g = 0;
          var T = p[4], A = p[5], O = p[4] + A, M = Math.PI / 180;
          if (Math.abs(T - O) < M && (M = Math.abs(T - O)), v = _.getPointOnEllipticalArc(p[0], p[1], p[2], p[3], T, 0), A < 0)
            for (b = T - M; b > O; b -= M)
              x = _.getPointOnEllipticalArc(p[0], p[1], p[2], p[3], b, 0), g += _.getLineLength(v.x, v.y, x.x, x.y), v = x;
          else
            for (b = T + M; b < O; b += M)
              x = _.getPointOnEllipticalArc(p[0], p[1], p[2], p[3], b, 0), g += _.getLineLength(v.x, v.y, x.x, x.y), v = x;
          return x = _.getPointOnEllipticalArc(p[0], p[1], p[2], p[3], O, 0), g += _.getLineLength(v.x, v.y, x.x, x.y), g;
      }
      return 0;
    }
    static convertEndpointToCenterParameterization(u, h, f, p, g, v, x, b, _) {
      const T = _ * (Math.PI / 180), A = Math.cos(T) * (u - f) / 2 + Math.sin(T) * (h - p) / 2, O = -1 * Math.sin(T) * (u - f) / 2 + Math.cos(T) * (h - p) / 2, M = A * A / (x * x) + O * O / (b * b);
      M > 1 && (x *= Math.sqrt(M), b *= Math.sqrt(M));
      let E = Math.sqrt((x * x * (b * b) - x * x * (O * O) - b * b * (A * A)) / (x * x * (O * O) + b * b * (A * A)));
      g === v && (E *= -1), isNaN(E) && (E = 0);
      const R = E * x * O / b, N = E * -b * A / x, U = (u + f) / 2 + Math.cos(T) * R - Math.sin(T) * N, q = (h + p) / 2 + Math.sin(T) * R + Math.cos(T) * N, j = function(I) {
        return Math.sqrt(I[0] * I[0] + I[1] * I[1]);
      }, V = function(I, K) {
        return (I[0] * K[0] + I[1] * K[1]) / (j(I) * j(K));
      }, D = function(I, K) {
        return (I[0] * K[1] < I[1] * K[0] ? -1 : 1) * Math.acos(V(I, K));
      }, G = D([1, 0], [(A - R) / x, (O - N) / b]), W = [(A - R) / x, (O - N) / b], P = [(-1 * A - R) / x, (-1 * O - N) / b];
      let H = D(W, P);
      return V(W, P) <= -1 && (H = Math.PI), V(W, P) >= 1 && (H = 0), v === 0 && H > 0 && (H = H - 2 * Math.PI), v === 1 && H < 0 && (H = H + 2 * Math.PI), [U, q, x, b, G, H, T, v];
    }
  };
  return Pm.Path = s, s.prototype.className = "Path", s.prototype._attrsAffectingSize = ["data"], (0, n._registerNode)(s), e.Factory.addGetterSetter(s, "data"), Pm;
}
var b4;
function VU() {
  if (b4) return Bm;
  b4 = 1, Object.defineProperty(Bm, "__esModule", { value: !0 }), Bm.Arrow = void 0;
  const e = An(), t = W6(), n = Mn(), i = Sn(), s = K_();
  let o = class extends t.Line {
    _sceneFunc(h) {
      super._sceneFunc(h);
      const f = Math.PI * 2, p = this.points();
      let g = p;
      const v = this.tension() !== 0 && p.length > 4;
      v && (g = this.getTensionPoints());
      const x = this.pointerLength(), b = p.length;
      let _, T;
      if (v) {
        const M = [
          g[g.length - 4],
          g[g.length - 3],
          g[g.length - 2],
          g[g.length - 1],
          p[b - 2],
          p[b - 1]
        ], E = s.Path.calcLength(g[g.length - 4], g[g.length - 3], "C", M), R = s.Path.getPointOnQuadraticBezier(Math.min(1, 1 - x / E), M[0], M[1], M[2], M[3], M[4], M[5]);
        _ = p[b - 2] - R.x, T = p[b - 1] - R.y;
      } else
        _ = p[b - 2] - p[b - 4], T = p[b - 1] - p[b - 3];
      const A = (Math.atan2(T, _) + f) % f, O = this.pointerWidth();
      this.pointerAtEnding() && (h.save(), h.beginPath(), h.translate(p[b - 2], p[b - 1]), h.rotate(A), h.moveTo(0, 0), h.lineTo(-x, O / 2), h.lineTo(-x, -O / 2), h.closePath(), h.restore(), this.__fillStroke(h)), this.pointerAtBeginning() && (h.save(), h.beginPath(), h.translate(p[0], p[1]), v ? (_ = (g[0] + g[2]) / 2 - p[0], T = (g[1] + g[3]) / 2 - p[1]) : (_ = p[2] - p[0], T = p[3] - p[1]), h.rotate((Math.atan2(-T, -_) + f) % f), h.moveTo(0, 0), h.lineTo(-x, O / 2), h.lineTo(-x, -O / 2), h.closePath(), h.restore(), this.__fillStroke(h));
    }
    __fillStroke(h) {
      const f = this.dashEnabled();
      f && (this.attrs.dashEnabled = !1, h.setLineDash([])), h.fillStrokeShape(this), f && (this.attrs.dashEnabled = !0);
    }
    getSelfRect() {
      const h = super.getSelfRect(), f = this.pointerWidth() / 2;
      return {
        x: h.x,
        y: h.y - f,
        width: h.width,
        height: h.height + f * 2
      };
    }
  };
  return Bm.Arrow = o, o.prototype.className = "Arrow", (0, i._registerNode)(o), e.Factory.addGetterSetter(o, "pointerLength", 10, (0, n.getNumberValidator)()), e.Factory.addGetterSetter(o, "pointerWidth", 10, (0, n.getNumberValidator)()), e.Factory.addGetterSetter(o, "pointerAtBeginning", !1), e.Factory.addGetterSetter(o, "pointerAtEnding", !0), Bm;
}
var Um = {}, _4;
function IU() {
  if (_4) return Um;
  _4 = 1, Object.defineProperty(Um, "__esModule", { value: !0 }), Um.Circle = void 0;
  const e = An(), t = ta(), n = Mn(), i = Sn();
  let s = class extends t.Shape {
    _sceneFunc(u) {
      u.beginPath(), u.arc(0, 0, this.attrs.radius || 0, 0, Math.PI * 2, !1), u.closePath(), u.fillStrokeShape(this);
    }
    getWidth() {
      return this.radius() * 2;
    }
    getHeight() {
      return this.radius() * 2;
    }
    setWidth(u) {
      this.radius() !== u / 2 && this.radius(u / 2);
    }
    setHeight(u) {
      this.radius() !== u / 2 && this.radius(u / 2);
    }
  };
  return Um.Circle = s, s.prototype._centroid = !0, s.prototype.className = "Circle", s.prototype._attrsAffectingSize = ["radius"], (0, i._registerNode)(s), e.Factory.addGetterSetter(s, "radius", 0, (0, n.getNumberValidator)()), Um;
}
var jm = {}, S4;
function FU() {
  if (S4) return jm;
  S4 = 1, Object.defineProperty(jm, "__esModule", { value: !0 }), jm.Ellipse = void 0;
  const e = An(), t = ta(), n = Mn(), i = Sn();
  let s = class extends t.Shape {
    _sceneFunc(u) {
      const h = this.radiusX(), f = this.radiusY();
      u.beginPath(), u.save(), h !== f && u.scale(1, f / h), u.arc(0, 0, h, 0, Math.PI * 2, !1), u.restore(), u.closePath(), u.fillStrokeShape(this);
    }
    getWidth() {
      return this.radiusX() * 2;
    }
    getHeight() {
      return this.radiusY() * 2;
    }
    setWidth(u) {
      this.radiusX(u / 2);
    }
    setHeight(u) {
      this.radiusY(u / 2);
    }
  };
  return jm.Ellipse = s, s.prototype.className = "Ellipse", s.prototype._centroid = !0, s.prototype._attrsAffectingSize = ["radiusX", "radiusY"], (0, i._registerNode)(s), e.Factory.addComponentsGetterSetter(s, "radius", ["x", "y"]), e.Factory.addGetterSetter(s, "radiusX", 0, (0, n.getNumberValidator)()), e.Factory.addGetterSetter(s, "radiusY", 0, (0, n.getNumberValidator)()), jm;
}
var Lm = {}, x4;
function qU() {
  if (x4) return Lm;
  x4 = 1, Object.defineProperty(Lm, "__esModule", { value: !0 }), Lm.Image = void 0;
  const e = lr(), t = An(), n = ta(), i = Sn(), s = Mn();
  let o = class $6 extends n.Shape {
    constructor(h) {
      super(h), this._loadListener = () => {
        this._requestDraw();
      }, this.on("imageChange.konva", (f) => {
        this._removeImageLoad(f.oldVal), this._setImageLoad();
      }), this._setImageLoad();
    }
    _setImageLoad() {
      const h = this.image();
      h && h.complete || h && h.readyState === 4 || h && h.addEventListener && h.addEventListener("load", this._loadListener);
    }
    _removeImageLoad(h) {
      h && h.removeEventListener && h.removeEventListener("load", this._loadListener);
    }
    destroy() {
      return this._removeImageLoad(this.image()), super.destroy(), this;
    }
    _useBufferCanvas() {
      const h = !!this.cornerRadius(), f = this.hasShadow();
      return h && f ? !0 : super._useBufferCanvas(!0);
    }
    _sceneFunc(h) {
      const f = this.getWidth(), p = this.getHeight(), g = this.cornerRadius(), v = this.attrs.image;
      let x;
      if (v) {
        const b = this.attrs.cropWidth, _ = this.attrs.cropHeight;
        b && _ ? x = [
          v,
          this.cropX(),
          this.cropY(),
          b,
          _,
          0,
          0,
          f,
          p
        ] : x = [v, 0, 0, f, p];
      }
      (this.hasFill() || this.hasStroke() || g) && (h.beginPath(), g ? e.Util.drawRoundedRectPath(h, f, p, g) : h.rect(0, 0, f, p), h.closePath(), h.fillStrokeShape(this)), v && (g && h.clip(), h.drawImage.apply(h, x));
    }
    _hitFunc(h) {
      const f = this.width(), p = this.height(), g = this.cornerRadius();
      h.beginPath(), g ? e.Util.drawRoundedRectPath(h, f, p, g) : h.rect(0, 0, f, p), h.closePath(), h.fillStrokeShape(this);
    }
    getWidth() {
      var h, f;
      return (h = this.attrs.width) !== null && h !== void 0 ? h : (f = this.image()) === null || f === void 0 ? void 0 : f.width;
    }
    getHeight() {
      var h, f;
      return (h = this.attrs.height) !== null && h !== void 0 ? h : (f = this.image()) === null || f === void 0 ? void 0 : f.height;
    }
    static fromURL(h, f, p = null) {
      const g = e.Util.createImageElement();
      g.onload = function() {
        const v = new $6({
          image: g
        });
        f(v);
      }, g.onerror = p, g.crossOrigin = "Anonymous", g.src = h;
    }
  };
  return Lm.Image = o, o.prototype.className = "Image", (0, i._registerNode)(o), t.Factory.addGetterSetter(o, "cornerRadius", 0, (0, s.getNumberOrArrayOfNumbersValidator)(4)), t.Factory.addGetterSetter(o, "image"), t.Factory.addComponentsGetterSetter(o, "crop", ["x", "y", "width", "height"]), t.Factory.addGetterSetter(o, "cropX", 0, (0, s.getNumberValidator)()), t.Factory.addGetterSetter(o, "cropY", 0, (0, s.getNumberValidator)()), t.Factory.addGetterSetter(o, "cropWidth", 0, (0, s.getNumberValidator)()), t.Factory.addGetterSetter(o, "cropHeight", 0, (0, s.getNumberValidator)()), Lm;
}
var Th = {}, T4;
function GU() {
  if (T4) return Th;
  T4 = 1, Object.defineProperty(Th, "__esModule", { value: !0 }), Th.Tag = Th.Label = void 0;
  const e = An(), t = ta(), n = G_(), i = Mn(), s = Sn(), o = [
    "fontFamily",
    "fontSize",
    "fontStyle",
    "padding",
    "lineHeight",
    "text",
    "width",
    "height",
    "pointerDirection",
    "pointerWidth",
    "pointerHeight"
  ], u = "Change.konva", h = "none", f = "up", p = "right", g = "down", v = "left", x = o.length;
  let b = class extends n.Group {
    constructor(A) {
      super(A), this.on("add.konva", function(O) {
        this._addListeners(O.child), this._sync();
      });
    }
    getText() {
      return this.find("Text")[0];
    }
    getTag() {
      return this.find("Tag")[0];
    }
    _addListeners(A) {
      let O = this, M;
      const E = function() {
        O._sync();
      };
      for (M = 0; M < x; M++)
        A.on(o[M] + u, E);
    }
    getWidth() {
      return this.getText().width();
    }
    getHeight() {
      return this.getText().height();
    }
    _sync() {
      let A = this.getText(), O = this.getTag(), M, E, R, N, U, q, j;
      if (A && O) {
        switch (M = A.width(), E = A.height(), R = O.pointerDirection(), N = O.pointerWidth(), j = O.pointerHeight(), U = 0, q = 0, R) {
          case f:
            U = M / 2, q = -1 * j;
            break;
          case p:
            U = M + N, q = E / 2;
            break;
          case g:
            U = M / 2, q = E + j;
            break;
          case v:
            U = -1 * N, q = E / 2;
            break;
        }
        O.setAttrs({
          x: -1 * U,
          y: -1 * q,
          width: M,
          height: E
        }), A.setAttrs({
          x: -1 * U,
          y: -1 * q
        });
      }
    }
  };
  Th.Label = b, b.prototype.className = "Label", (0, s._registerNode)(b);
  class _ extends t.Shape {
    _sceneFunc(A) {
      const O = this.width(), M = this.height(), E = this.pointerDirection(), R = this.pointerWidth(), N = this.pointerHeight(), U = this.cornerRadius();
      let q = 0, j = 0, V = 0, D = 0;
      typeof U == "number" ? q = j = V = D = Math.min(U, O / 2, M / 2) : (q = Math.min(U[0] || 0, O / 2, M / 2), j = Math.min(U[1] || 0, O / 2, M / 2), D = Math.min(U[2] || 0, O / 2, M / 2), V = Math.min(U[3] || 0, O / 2, M / 2)), A.beginPath(), A.moveTo(q, 0), E === f && (A.lineTo((O - R) / 2, 0), A.lineTo(O / 2, -1 * N), A.lineTo((O + R) / 2, 0)), A.lineTo(O - j, 0), A.arc(O - j, j, j, Math.PI * 3 / 2, 0, !1), E === p && (A.lineTo(O, (M - N) / 2), A.lineTo(O + R, M / 2), A.lineTo(O, (M + N) / 2)), A.lineTo(O, M - D), A.arc(O - D, M - D, D, 0, Math.PI / 2, !1), E === g && (A.lineTo((O + R) / 2, M), A.lineTo(O / 2, M + N), A.lineTo((O - R) / 2, M)), A.lineTo(V, M), A.arc(V, M - V, V, Math.PI / 2, Math.PI, !1), E === v && (A.lineTo(0, (M + N) / 2), A.lineTo(-1 * R, M / 2), A.lineTo(0, (M - N) / 2)), A.lineTo(0, q), A.arc(q, q, q, Math.PI, Math.PI * 3 / 2, !1), A.closePath(), A.fillStrokeShape(this);
    }
    getSelfRect() {
      let A = 0, O = 0, M = this.pointerWidth(), E = this.pointerHeight(), R = this.pointerDirection(), N = this.width(), U = this.height();
      return R === f ? (O -= E, U += E) : R === g ? U += E : R === v ? (A -= M * 1.5, N += M) : R === p && (N += M * 1.5), {
        x: A,
        y: O,
        width: N,
        height: U
      };
    }
  }
  return Th.Tag = _, _.prototype.className = "Tag", (0, s._registerNode)(_), e.Factory.addGetterSetter(_, "pointerDirection", h), e.Factory.addGetterSetter(_, "pointerWidth", 0, (0, i.getNumberValidator)()), e.Factory.addGetterSetter(_, "pointerHeight", 0, (0, i.getNumberValidator)()), e.Factory.addGetterSetter(_, "cornerRadius", 0, (0, i.getNumberOrArrayOfNumbersValidator)(4)), Th;
}
var Vm = {}, C4;
function Q6() {
  if (C4) return Vm;
  C4 = 1, Object.defineProperty(Vm, "__esModule", { value: !0 }), Vm.Rect = void 0;
  const e = An(), t = ta(), n = Sn(), i = lr(), s = Mn();
  class o extends t.Shape {
    _sceneFunc(h) {
      const f = this.cornerRadius(), p = this.width(), g = this.height();
      h.beginPath(), f ? i.Util.drawRoundedRectPath(h, p, g, f) : h.rect(0, 0, p, g), h.closePath(), h.fillStrokeShape(this);
    }
  }
  return Vm.Rect = o, o.prototype.className = "Rect", (0, n._registerNode)(o), e.Factory.addGetterSetter(o, "cornerRadius", 0, (0, s.getNumberOrArrayOfNumbersValidator)(4)), Vm;
}
var Im = {}, w4;
function HU() {
  if (w4) return Im;
  w4 = 1, Object.defineProperty(Im, "__esModule", { value: !0 }), Im.RegularPolygon = void 0;
  const e = An(), t = ta(), n = Mn(), i = Sn();
  let s = class extends t.Shape {
    _sceneFunc(u) {
      const h = this._getPoints();
      u.beginPath(), u.moveTo(h[0].x, h[0].y);
      for (let f = 1; f < h.length; f++)
        u.lineTo(h[f].x, h[f].y);
      u.closePath(), u.fillStrokeShape(this);
    }
    _getPoints() {
      const u = this.attrs.sides, h = this.attrs.radius || 0, f = [];
      for (let p = 0; p < u; p++)
        f.push({
          x: h * Math.sin(p * 2 * Math.PI / u),
          y: -1 * h * Math.cos(p * 2 * Math.PI / u)
        });
      return f;
    }
    getSelfRect() {
      const u = this._getPoints();
      let h = u[0].x, f = u[0].y, p = u[0].x, g = u[0].y;
      return u.forEach((v) => {
        h = Math.min(h, v.x), f = Math.max(f, v.x), p = Math.min(p, v.y), g = Math.max(g, v.y);
      }), {
        x: h,
        y: p,
        width: f - h,
        height: g - p
      };
    }
    getWidth() {
      return this.radius() * 2;
    }
    getHeight() {
      return this.radius() * 2;
    }
    setWidth(u) {
      this.radius(u / 2);
    }
    setHeight(u) {
      this.radius(u / 2);
    }
  };
  return Im.RegularPolygon = s, s.prototype.className = "RegularPolygon", s.prototype._centroid = !0, s.prototype._attrsAffectingSize = ["radius"], (0, i._registerNode)(s), e.Factory.addGetterSetter(s, "radius", 0, (0, n.getNumberValidator)()), e.Factory.addGetterSetter(s, "sides", 0, (0, n.getNumberValidator)()), Im;
}
var Fm = {}, E4;
function KU() {
  if (E4) return Fm;
  E4 = 1, Object.defineProperty(Fm, "__esModule", { value: !0 }), Fm.Ring = void 0;
  const e = An(), t = ta(), n = Mn(), i = Sn(), s = Math.PI * 2;
  let o = class extends t.Shape {
    _sceneFunc(h) {
      h.beginPath(), h.arc(0, 0, this.innerRadius(), 0, s, !1), h.moveTo(this.outerRadius(), 0), h.arc(0, 0, this.outerRadius(), s, 0, !0), h.closePath(), h.fillStrokeShape(this);
    }
    getWidth() {
      return this.outerRadius() * 2;
    }
    getHeight() {
      return this.outerRadius() * 2;
    }
    setWidth(h) {
      this.outerRadius(h / 2);
    }
    setHeight(h) {
      this.outerRadius(h / 2);
    }
  };
  return Fm.Ring = o, o.prototype.className = "Ring", o.prototype._centroid = !0, o.prototype._attrsAffectingSize = ["innerRadius", "outerRadius"], (0, i._registerNode)(o), e.Factory.addGetterSetter(o, "innerRadius", 0, (0, n.getNumberValidator)()), e.Factory.addGetterSetter(o, "outerRadius", 0, (0, n.getNumberValidator)()), Fm;
}
var qm = {}, A4;
function YU() {
  if (A4) return qm;
  A4 = 1, Object.defineProperty(qm, "__esModule", { value: !0 }), qm.Sprite = void 0;
  const e = An(), t = ta(), n = H_(), i = Mn(), s = Sn();
  let o = class extends t.Shape {
    constructor(h) {
      super(h), this._updated = !0, this.anim = new n.Animation(() => {
        const f = this._updated;
        return this._updated = !1, f;
      }), this.on("animationChange.konva", function() {
        this.frameIndex(0);
      }), this.on("frameIndexChange.konva", function() {
        this._updated = !0;
      }), this.on("frameRateChange.konva", function() {
        this.anim.isRunning() && (clearInterval(this.interval), this._setInterval());
      });
    }
    _sceneFunc(h) {
      const f = this.animation(), p = this.frameIndex(), g = p * 4, v = this.animations()[f], x = this.frameOffsets(), b = v[g + 0], _ = v[g + 1], T = v[g + 2], A = v[g + 3], O = this.image();
      if ((this.hasFill() || this.hasStroke()) && (h.beginPath(), h.rect(0, 0, T, A), h.closePath(), h.fillStrokeShape(this)), O)
        if (x) {
          const M = x[f], E = p * 2;
          h.drawImage(O, b, _, T, A, M[E + 0], M[E + 1], T, A);
        } else
          h.drawImage(O, b, _, T, A, 0, 0, T, A);
    }
    _hitFunc(h) {
      const f = this.animation(), p = this.frameIndex(), g = p * 4, v = this.animations()[f], x = this.frameOffsets(), b = v[g + 2], _ = v[g + 3];
      if (h.beginPath(), x) {
        const T = x[f], A = p * 2;
        h.rect(T[A + 0], T[A + 1], b, _);
      } else
        h.rect(0, 0, b, _);
      h.closePath(), h.fillShape(this);
    }
    _useBufferCanvas() {
      return super._useBufferCanvas(!0);
    }
    _setInterval() {
      const h = this;
      this.interval = setInterval(function() {
        h._updateIndex();
      }, 1e3 / this.frameRate());
    }
    start() {
      if (this.isRunning())
        return;
      const h = this.getLayer();
      this.anim.setLayers(h), this._setInterval(), this.anim.start();
    }
    stop() {
      this.anim.stop(), clearInterval(this.interval);
    }
    isRunning() {
      return this.anim.isRunning();
    }
    _updateIndex() {
      const h = this.frameIndex(), f = this.animation(), p = this.animations(), g = p[f], v = g.length / 4;
      h < v - 1 ? this.frameIndex(h + 1) : this.frameIndex(0);
    }
  };
  return qm.Sprite = o, o.prototype.className = "Sprite", (0, s._registerNode)(o), e.Factory.addGetterSetter(o, "animation"), e.Factory.addGetterSetter(o, "animations"), e.Factory.addGetterSetter(o, "frameOffsets"), e.Factory.addGetterSetter(o, "image"), e.Factory.addGetterSetter(o, "frameIndex", 0, (0, i.getNumberValidator)()), e.Factory.addGetterSetter(o, "frameRate", 17, (0, i.getNumberValidator)()), e.Factory.backCompat(o, {
    index: "frameIndex",
    getIndex: "getFrameIndex",
    setIndex: "setFrameIndex"
  }), qm;
}
var Gm = {}, M4;
function XU() {
  if (M4) return Gm;
  M4 = 1, Object.defineProperty(Gm, "__esModule", { value: !0 }), Gm.Star = void 0;
  const e = An(), t = ta(), n = Mn(), i = Sn();
  let s = class extends t.Shape {
    _sceneFunc(u) {
      const h = this.innerRadius(), f = this.outerRadius(), p = this.numPoints();
      u.beginPath(), u.moveTo(0, 0 - f);
      for (let g = 1; g < p * 2; g++) {
        const v = g % 2 === 0 ? f : h, x = v * Math.sin(g * Math.PI / p), b = -1 * v * Math.cos(g * Math.PI / p);
        u.lineTo(x, b);
      }
      u.closePath(), u.fillStrokeShape(this);
    }
    getWidth() {
      return this.outerRadius() * 2;
    }
    getHeight() {
      return this.outerRadius() * 2;
    }
    setWidth(u) {
      this.outerRadius(u / 2);
    }
    setHeight(u) {
      this.outerRadius(u / 2);
    }
  };
  return Gm.Star = s, s.prototype.className = "Star", s.prototype._centroid = !0, s.prototype._attrsAffectingSize = ["innerRadius", "outerRadius"], (0, i._registerNode)(s), e.Factory.addGetterSetter(s, "numPoints", 5, (0, n.getNumberValidator)()), e.Factory.addGetterSetter(s, "innerRadius", 0, (0, n.getNumberValidator)()), e.Factory.addGetterSetter(s, "outerRadius", 0, (0, n.getNumberValidator)()), Gm;
}
var Df = {}, R4;
function Z6() {
  if (R4) return Df;
  R4 = 1, Object.defineProperty(Df, "__esModule", { value: !0 }), Df.Text = void 0, Df.stringToArray = u;
  const e = lr(), t = An(), n = ta(), i = Sn(), s = Mn(), o = Sn();
  function u(vt) {
    return [...vt].reduce((ct, dt, ht, Et) => {
      if (new RegExp("\\p{Emoji}", "u").test(dt)) {
        const ot = Et[ht + 1];
        ot && new RegExp("\\p{Emoji_Modifier}|\\u200D", "u").test(ot) ? (ct.push(dt + ot), Et[ht + 1] = "") : ct.push(dt);
      } else new RegExp("\\p{Regional_Indicator}{2}", "u").test(dt + (Et[ht + 1] || "")) ? ct.push(dt + Et[ht + 1]) : ht > 0 && new RegExp("\\p{Mn}|\\p{Me}|\\p{Mc}", "u").test(dt) ? ct[ct.length - 1] += dt : dt && ct.push(dt);
      return ct;
    }, []);
  }
  const h = "auto", f = "center", p = "inherit", g = "justify", v = "Change.konva", x = "2d", b = "-", _ = "left", T = "text", A = "Text", O = "top", M = "bottom", E = "middle", R = "normal", N = "px ", U = " ", q = "right", j = "rtl", V = "word", D = "char", G = "none", W = "…", P = [
    "direction",
    "fontFamily",
    "fontSize",
    "fontStyle",
    "fontVariant",
    "padding",
    "align",
    "verticalAlign",
    "lineHeight",
    "text",
    "width",
    "height",
    "wrap",
    "ellipsis",
    "letterSpacing"
  ], H = P.length;
  function I(vt) {
    return vt.split(",").map((ct) => {
      ct = ct.trim();
      const dt = ct.indexOf(" ") >= 0, ht = ct.indexOf('"') >= 0 || ct.indexOf("'") >= 0;
      return dt && !ht && (ct = `"${ct}"`), ct;
    }).join(", ");
  }
  let K;
  function Q() {
    return K || (K = e.Util.createCanvasElement().getContext(x), K);
  }
  function it(vt) {
    vt.fillText(this._partialText, this._partialTextX, this._partialTextY);
  }
  function nt(vt) {
    vt.setAttr("miterLimit", 2), vt.strokeText(this._partialText, this._partialTextX, this._partialTextY);
  }
  function X(vt) {
    return vt = vt || {}, !vt.fillLinearGradientColorStops && !vt.fillRadialGradientColorStops && !vt.fillPatternImage && (vt.fill = vt.fill || "black"), vt;
  }
  class rt extends n.Shape {
    constructor(ct) {
      super(X(ct)), this._partialTextX = 0, this._partialTextY = 0;
      for (let dt = 0; dt < H; dt++)
        this.on(P[dt] + v, this._setTextData);
      this._setTextData();
    }
    _sceneFunc(ct) {
      const dt = this.textArr, ht = dt.length;
      if (!this.text())
        return;
      let Et = this.padding(), ot = this.fontSize(), lt = this.lineHeight() * ot, ft = this.verticalAlign(), Tt = this.direction(), Bt = 0, Ot = this.align(), ie = this.getWidth(), ce = this.letterSpacing(), Ut = this.fill(), se = this.textDecoration(), re = se.indexOf("underline") !== -1, ue = se.indexOf("line-through") !== -1, Ae;
      Tt = Tt === p ? ct.direction : Tt;
      let ve = lt / 2, Re = E;
      if (i.Konva._fixTextRendering) {
        const Yt = this.measureSize("M");
        Re = "alphabetic", ve = (Yt.fontBoundingBoxAscent - Yt.fontBoundingBoxDescent) / 2 + lt / 2;
      }
      var oe = 0, Le = 0;
      for (Tt === j && ct.setAttr("direction", Tt), ct.setAttr("font", this._getContextFont()), ct.setAttr("textBaseline", Re), ct.setAttr("textAlign", _), ft === E ? Bt = (this.getHeight() - ht * lt - Et * 2) / 2 : ft === M && (Bt = this.getHeight() - ht * lt - Et * 2), ct.translate(Et, Bt + Et), Ae = 0; Ae < ht; Ae++) {
        var oe = 0, Le = 0, De = dt[Ae], Kt = De.text, te = De.width, It = De.lastInParagraph, Ht, Jt;
        if (ct.save(), Ot === q ? oe += ie - te - Et * 2 : Ot === f && (oe += (ie - te - Et * 2) / 2), re) {
          ct.save(), ct.beginPath();
          const le = i.Konva._fixTextRendering ? Math.round(ot / 4) : Math.round(ot / 2), fe = oe, Me = ve + Le + le;
          ct.moveTo(fe, Me), Ht = Kt.split(" ").length - 1, Jt = Ot === g && !It ? ie - Et * 2 : te, ct.lineTo(fe + Math.round(Jt), Me), ct.lineWidth = ot / 15;
          const Te = this._getLinearGradient();
          ct.strokeStyle = Te || Ut, ct.stroke(), ct.restore();
        }
        if (ue) {
          ct.save(), ct.beginPath();
          const le = i.Konva._fixTextRendering ? -Math.round(ot / 4) : 0;
          ct.moveTo(oe, ve + Le + le), Ht = Kt.split(" ").length - 1, Jt = Ot === g && !It ? ie - Et * 2 : te, ct.lineTo(oe + Math.round(Jt), ve + Le + le), ct.lineWidth = ot / 15;
          const fe = this._getLinearGradient();
          ct.strokeStyle = fe || Ut, ct.stroke(), ct.restore();
        }
        if (Tt !== j && (ce !== 0 || Ot === g)) {
          Ht = Kt.split(" ").length - 1;
          const le = u(Kt);
          for (let fe = 0; fe < le.length; fe++) {
            const Me = le[fe];
            Me === " " && !It && Ot === g && (oe += (ie - Et * 2 - te) / Ht), this._partialTextX = oe, this._partialTextY = ve + Le, this._partialText = Me, ct.fillStrokeShape(this), oe += this.measureSize(Me).width + ce;
          }
        } else
          ce !== 0 && ct.setAttr("letterSpacing", `${ce}px`), this._partialTextX = oe, this._partialTextY = ve + Le, this._partialText = Kt, ct.fillStrokeShape(this);
        ct.restore(), ht > 1 && (ve += lt);
      }
    }
    _hitFunc(ct) {
      const dt = this.getWidth(), ht = this.getHeight();
      ct.beginPath(), ct.rect(0, 0, dt, ht), ct.closePath(), ct.fillStrokeShape(this);
    }
    setText(ct) {
      const dt = e.Util._isString(ct) ? ct : ct == null ? "" : ct + "";
      return this._setAttr(T, dt), this;
    }
    getWidth() {
      return this.attrs.width === h || this.attrs.width === void 0 ? this.getTextWidth() + this.padding() * 2 : this.attrs.width;
    }
    getHeight() {
      return this.attrs.height === h || this.attrs.height === void 0 ? this.fontSize() * this.textArr.length * this.lineHeight() + this.padding() * 2 : this.attrs.height;
    }
    getTextWidth() {
      return this.textWidth;
    }
    getTextHeight() {
      return e.Util.warn("text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height."), this.textHeight;
    }
    measureSize(ct) {
      var dt, ht, Et, ot, lt, ft, Tt, Bt, Ot, ie, ce;
      let Ut = Q(), se = this.fontSize(), re;
      Ut.save(), Ut.font = this._getContextFont(), re = Ut.measureText(ct), Ut.restore();
      const ue = se / 100;
      return {
        actualBoundingBoxAscent: (dt = re.actualBoundingBoxAscent) !== null && dt !== void 0 ? dt : 71.58203125 * ue,
        actualBoundingBoxDescent: (ht = re.actualBoundingBoxDescent) !== null && ht !== void 0 ? ht : 0,
        actualBoundingBoxLeft: (Et = re.actualBoundingBoxLeft) !== null && Et !== void 0 ? Et : -7.421875 * ue,
        actualBoundingBoxRight: (ot = re.actualBoundingBoxRight) !== null && ot !== void 0 ? ot : 75.732421875 * ue,
        alphabeticBaseline: (lt = re.alphabeticBaseline) !== null && lt !== void 0 ? lt : 0,
        emHeightAscent: (ft = re.emHeightAscent) !== null && ft !== void 0 ? ft : 100 * ue,
        emHeightDescent: (Tt = re.emHeightDescent) !== null && Tt !== void 0 ? Tt : -20 * ue,
        fontBoundingBoxAscent: (Bt = re.fontBoundingBoxAscent) !== null && Bt !== void 0 ? Bt : 91 * ue,
        fontBoundingBoxDescent: (Ot = re.fontBoundingBoxDescent) !== null && Ot !== void 0 ? Ot : 21 * ue,
        hangingBaseline: (ie = re.hangingBaseline) !== null && ie !== void 0 ? ie : 72.80000305175781 * ue,
        ideographicBaseline: (ce = re.ideographicBaseline) !== null && ce !== void 0 ? ce : -21 * ue,
        width: re.width,
        height: se
      };
    }
    _getContextFont() {
      return this.fontStyle() + U + this.fontVariant() + U + (this.fontSize() + N) + I(this.fontFamily());
    }
    _addTextLine(ct) {
      this.align() === g && (ct = ct.trim());
      const ht = this._getTextWidth(ct);
      return this.textArr.push({
        text: ct,
        width: ht,
        lastInParagraph: !1
      });
    }
    _getTextWidth(ct) {
      const dt = this.letterSpacing(), ht = ct.length;
      return Q().measureText(ct).width + dt * ht;
    }
    _setTextData() {
      let ct = this.text().split(`
`), dt = +this.fontSize(), ht = 0, Et = this.lineHeight() * dt, ot = this.attrs.width, lt = this.attrs.height, ft = ot !== h && ot !== void 0, Tt = lt !== h && lt !== void 0, Bt = this.padding(), Ot = ot - Bt * 2, ie = lt - Bt * 2, ce = 0, Ut = this.wrap(), se = Ut !== G, re = Ut !== D && se, ue = this.ellipsis();
      this.textArr = [], Q().font = this._getContextFont();
      const Ae = ue ? this._getTextWidth(W) : 0;
      for (let ve = 0, Re = ct.length; ve < Re; ++ve) {
        let oe = ct[ve], Le = this._getTextWidth(oe);
        if (ft && Le > Ot)
          for (; oe.length > 0; ) {
            let De = 0, Kt = u(oe).length, te = "", It = 0;
            for (; De < Kt; ) {
              const Ht = De + Kt >>> 1, Jt = u(oe), Yt = Jt.slice(0, Ht + 1).join(""), ae = this._getTextWidth(Yt);
              (ue && Tt && ce + Et > ie ? ae + Ae : ae) <= Ot ? (De = Ht + 1, te = Yt, It = ae) : Kt = Ht;
            }
            if (te) {
              if (re) {
                const Yt = u(oe), ae = u(te), le = Yt[ae.length], fe = le === U || le === b;
                let Me;
                if (fe && It <= Ot)
                  Me = ae.length;
                else {
                  const Te = ae.lastIndexOf(U), ne = ae.lastIndexOf(b);
                  Me = Math.max(Te, ne) + 1;
                }
                Me > 0 && (De = Me, te = Yt.slice(0, De).join(""), It = this._getTextWidth(te));
              }
              if (te = te.trimRight(), this._addTextLine(te), ht = Math.max(ht, It), ce += Et, this._shouldHandleEllipsis(ce)) {
                this._tryToAddEllipsisToLastLine();
                break;
              }
              if (oe = u(oe).slice(De).join("").trimLeft(), oe.length > 0 && (Le = this._getTextWidth(oe), Le <= Ot)) {
                this._addTextLine(oe), ce += Et, ht = Math.max(ht, Le);
                break;
              }
            } else
              break;
          }
        else
          this._addTextLine(oe), ce += Et, ht = Math.max(ht, Le), this._shouldHandleEllipsis(ce) && ve < Re - 1 && this._tryToAddEllipsisToLastLine();
        if (this.textArr[this.textArr.length - 1] && (this.textArr[this.textArr.length - 1].lastInParagraph = !0), Tt && ce + Et > ie)
          break;
      }
      this.textHeight = dt, this.textWidth = ht;
    }
    _shouldHandleEllipsis(ct) {
      const dt = +this.fontSize(), ht = this.lineHeight() * dt, Et = this.attrs.height, ot = Et !== h && Et !== void 0, lt = this.padding(), ft = Et - lt * 2;
      return !(this.wrap() !== G) || ot && ct + ht > ft;
    }
    _tryToAddEllipsisToLastLine() {
      const ct = this.attrs.width, dt = ct !== h && ct !== void 0, ht = this.padding(), Et = ct - ht * 2, ot = this.ellipsis(), lt = this.textArr[this.textArr.length - 1];
      !lt || !ot || (dt && (this._getTextWidth(lt.text + W) < Et || (lt.text = lt.text.slice(0, lt.text.length - 3))), this.textArr.splice(this.textArr.length - 1, 1), this._addTextLine(lt.text + W));
    }
    getStrokeScaleEnabled() {
      return !0;
    }
    _useBufferCanvas() {
      const ct = this.textDecoration().indexOf("underline") !== -1 || this.textDecoration().indexOf("line-through") !== -1, dt = this.hasShadow();
      return ct && dt ? !0 : super._useBufferCanvas();
    }
  }
  return Df.Text = rt, rt.prototype._fillFunc = it, rt.prototype._strokeFunc = nt, rt.prototype.className = A, rt.prototype._attrsAffectingSize = [
    "text",
    "fontSize",
    "padding",
    "wrap",
    "lineHeight",
    "letterSpacing"
  ], (0, o._registerNode)(rt), t.Factory.overWriteSetter(rt, "width", (0, s.getNumberOrAutoValidator)()), t.Factory.overWriteSetter(rt, "height", (0, s.getNumberOrAutoValidator)()), t.Factory.addGetterSetter(rt, "direction", p), t.Factory.addGetterSetter(rt, "fontFamily", "Arial"), t.Factory.addGetterSetter(rt, "fontSize", 12, (0, s.getNumberValidator)()), t.Factory.addGetterSetter(rt, "fontStyle", R), t.Factory.addGetterSetter(rt, "fontVariant", R), t.Factory.addGetterSetter(rt, "padding", 0, (0, s.getNumberValidator)()), t.Factory.addGetterSetter(rt, "align", _), t.Factory.addGetterSetter(rt, "verticalAlign", O), t.Factory.addGetterSetter(rt, "lineHeight", 1, (0, s.getNumberValidator)()), t.Factory.addGetterSetter(rt, "wrap", V), t.Factory.addGetterSetter(rt, "ellipsis", !1, (0, s.getBooleanValidator)()), t.Factory.addGetterSetter(rt, "letterSpacing", 0, (0, s.getNumberValidator)()), t.Factory.addGetterSetter(rt, "text", "", (0, s.getStringValidator)()), t.Factory.addGetterSetter(rt, "textDecoration", ""), Df;
}
var Hm = {}, O4;
function WU() {
  if (O4) return Hm;
  O4 = 1, Object.defineProperty(Hm, "__esModule", { value: !0 }), Hm.TextPath = void 0;
  const e = lr(), t = An(), n = ta(), i = K_(), s = Z6(), o = Mn(), u = Sn(), h = "", f = "normal";
  function p(x) {
    x.fillText(this.partialText, 0, 0);
  }
  function g(x) {
    x.strokeText(this.partialText, 0, 0);
  }
  let v = class extends n.Shape {
    constructor(b) {
      super(b), this.dummyCanvas = e.Util.createCanvasElement(), this.dataArray = [], this._readDataAttribute(), this.on("dataChange.konva", function() {
        this._readDataAttribute(), this._setTextData();
      }), this.on("textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva fontSizeChange.konva fontFamilyChange.konva", this._setTextData), this._setTextData();
    }
    _getTextPathLength() {
      return i.Path.getPathLength(this.dataArray);
    }
    _getPointAtLength(b) {
      if (!this.attrs.data)
        return null;
      const _ = this.pathLength;
      return b - 1 > _ ? null : i.Path.getPointAtLengthOfDataArray(b, this.dataArray);
    }
    _readDataAttribute() {
      this.dataArray = i.Path.parsePathData(this.attrs.data), this.pathLength = this._getTextPathLength();
    }
    _sceneFunc(b) {
      b.setAttr("font", this._getContextFont()), b.setAttr("textBaseline", this.textBaseline()), b.setAttr("textAlign", "left"), b.save();
      const _ = this.textDecoration(), T = this.fill(), A = this.fontSize(), O = this.glyphInfo;
      _ === "underline" && b.beginPath();
      for (let M = 0; M < O.length; M++) {
        b.save();
        const E = O[M].p0;
        b.translate(E.x, E.y), b.rotate(O[M].rotation), this.partialText = O[M].text, b.fillStrokeShape(this), _ === "underline" && (M === 0 && b.moveTo(0, A / 2 + 1), b.lineTo(A, A / 2 + 1)), b.restore();
      }
      _ === "underline" && (b.strokeStyle = T, b.lineWidth = A / 20, b.stroke()), b.restore();
    }
    _hitFunc(b) {
      b.beginPath();
      const _ = this.glyphInfo;
      if (_.length >= 1) {
        const T = _[0].p0;
        b.moveTo(T.x, T.y);
      }
      for (let T = 0; T < _.length; T++) {
        const A = _[T].p1;
        b.lineTo(A.x, A.y);
      }
      b.setAttr("lineWidth", this.fontSize()), b.setAttr("strokeStyle", this.colorKey), b.stroke();
    }
    getTextWidth() {
      return this.textWidth;
    }
    getTextHeight() {
      return e.Util.warn("text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height."), this.textHeight;
    }
    setText(b) {
      return s.Text.prototype.setText.call(this, b);
    }
    _getContextFont() {
      return s.Text.prototype._getContextFont.call(this);
    }
    _getTextSize(b) {
      const T = this.dummyCanvas.getContext("2d");
      T.save(), T.font = this._getContextFont();
      const A = T.measureText(b);
      return T.restore(), {
        width: A.width,
        height: parseInt(`${this.fontSize()}`, 10)
      };
    }
    _setTextData() {
      const { width: b, height: _ } = this._getTextSize(this.attrs.text);
      if (this.textWidth = b, this.textHeight = _, this.glyphInfo = [], !this.attrs.data)
        return null;
      const T = this.letterSpacing(), A = this.align(), O = this.kerningFunc(), M = Math.max(this.textWidth + ((this.attrs.text || "").length - 1) * T, 0);
      let E = 0;
      A === "center" && (E = Math.max(0, this.pathLength / 2 - M / 2)), A === "right" && (E = Math.max(0, this.pathLength - M));
      const R = (0, s.stringToArray)(this.text());
      let N = E;
      for (let U = 0; U < R.length; U++) {
        const q = this._getPointAtLength(N);
        if (!q)
          return;
        let j = this._getTextSize(R[U]).width + T;
        if (R[U] === " " && A === "justify") {
          const H = this.text().split(" ").length - 1;
          j += (this.pathLength - M) / H;
        }
        const V = this._getPointAtLength(N + j);
        if (!V)
          return;
        const D = i.Path.getLineLength(q.x, q.y, V.x, V.y);
        let G = 0;
        if (O)
          try {
            G = O(R[U - 1], R[U]) * this.fontSize();
          } catch {
            G = 0;
          }
        q.x += G, V.x += G, this.textWidth += G;
        const W = i.Path.getPointOnLine(G + D / 2, q.x, q.y, V.x, V.y), P = Math.atan2(V.y - q.y, V.x - q.x);
        this.glyphInfo.push({
          transposeX: W.x,
          transposeY: W.y,
          text: R[U],
          rotation: P,
          p0: q,
          p1: V
        }), N += j;
      }
    }
    getSelfRect() {
      if (!this.glyphInfo.length)
        return {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        };
      const b = [];
      this.glyphInfo.forEach(function(N) {
        b.push(N.p0.x), b.push(N.p0.y), b.push(N.p1.x), b.push(N.p1.y);
      });
      let _ = b[0] || 0, T = b[0] || 0, A = b[1] || 0, O = b[1] || 0, M, E;
      for (let N = 0; N < b.length / 2; N++)
        M = b[N * 2], E = b[N * 2 + 1], _ = Math.min(_, M), T = Math.max(T, M), A = Math.min(A, E), O = Math.max(O, E);
      const R = this.fontSize();
      return {
        x: _ - R / 2,
        y: A - R / 2,
        width: T - _ + R,
        height: O - A + R
      };
    }
    destroy() {
      return e.Util.releaseCanvas(this.dummyCanvas), super.destroy();
    }
  };
  return Hm.TextPath = v, v.prototype._fillFunc = p, v.prototype._strokeFunc = g, v.prototype._fillFuncHit = p, v.prototype._strokeFuncHit = g, v.prototype.className = "TextPath", v.prototype._attrsAffectingSize = ["text", "fontSize", "data"], (0, u._registerNode)(v), t.Factory.addGetterSetter(v, "data"), t.Factory.addGetterSetter(v, "fontFamily", "Arial"), t.Factory.addGetterSetter(v, "fontSize", 12, (0, o.getNumberValidator)()), t.Factory.addGetterSetter(v, "fontStyle", f), t.Factory.addGetterSetter(v, "align", "left"), t.Factory.addGetterSetter(v, "letterSpacing", 0, (0, o.getNumberValidator)()), t.Factory.addGetterSetter(v, "textBaseline", "middle"), t.Factory.addGetterSetter(v, "fontVariant", f), t.Factory.addGetterSetter(v, "text", h), t.Factory.addGetterSetter(v, "textDecoration", ""), t.Factory.addGetterSetter(v, "kerningFunc", void 0), Hm;
}
var Km = {}, N4;
function $U() {
  if (N4) return Km;
  N4 = 1, Object.defineProperty(Km, "__esModule", { value: !0 }), Km.Transformer = void 0;
  const e = lr(), t = An(), n = br(), i = ta(), s = Q6(), o = G_(), u = Sn(), h = Mn(), f = Sn(), p = "tr-konva", g = [
    "resizeEnabledChange",
    "rotateAnchorOffsetChange",
    "rotateEnabledChange",
    "enabledAnchorsChange",
    "anchorSizeChange",
    "borderEnabledChange",
    "borderStrokeChange",
    "borderStrokeWidthChange",
    "borderDashChange",
    "anchorStrokeChange",
    "anchorStrokeWidthChange",
    "anchorFillChange",
    "anchorCornerRadiusChange",
    "ignoreStrokeChange",
    "anchorStyleFuncChange"
  ].map((j) => j + `.${p}`).join(" "), v = "nodesRect", x = [
    "widthChange",
    "heightChange",
    "scaleXChange",
    "scaleYChange",
    "skewXChange",
    "skewYChange",
    "rotationChange",
    "offsetXChange",
    "offsetYChange",
    "transformsEnabledChange",
    "strokeWidthChange"
  ], b = {
    "top-left": -45,
    "top-center": 0,
    "top-right": 45,
    "middle-right": -90,
    "middle-left": 90,
    "bottom-left": -135,
    "bottom-center": 180,
    "bottom-right": 135
  }, _ = "ontouchstart" in u.Konva._global;
  function T(j, V, D) {
    if (j === "rotater")
      return D;
    V += e.Util.degToRad(b[j] || 0);
    const G = (e.Util.radToDeg(V) % 360 + 360) % 360;
    return e.Util._inRange(G, 315 + 22.5, 360) || e.Util._inRange(G, 0, 22.5) ? "ns-resize" : e.Util._inRange(G, 45 - 22.5, 45 + 22.5) ? "nesw-resize" : e.Util._inRange(G, 90 - 22.5, 90 + 22.5) ? "ew-resize" : e.Util._inRange(G, 135 - 22.5, 135 + 22.5) ? "nwse-resize" : e.Util._inRange(G, 180 - 22.5, 180 + 22.5) ? "ns-resize" : e.Util._inRange(G, 225 - 22.5, 225 + 22.5) ? "nesw-resize" : e.Util._inRange(G, 270 - 22.5, 270 + 22.5) ? "ew-resize" : e.Util._inRange(G, 315 - 22.5, 315 + 22.5) ? "nwse-resize" : (e.Util.error("Transformer has unknown angle for cursor detection: " + G), "pointer");
  }
  const A = [
    "top-left",
    "top-center",
    "top-right",
    "middle-right",
    "middle-left",
    "bottom-left",
    "bottom-center",
    "bottom-right"
  ];
  function O(j) {
    return {
      x: j.x + j.width / 2 * Math.cos(j.rotation) + j.height / 2 * Math.sin(-j.rotation),
      y: j.y + j.height / 2 * Math.cos(j.rotation) + j.width / 2 * Math.sin(j.rotation)
    };
  }
  function M(j, V, D) {
    const G = D.x + (j.x - D.x) * Math.cos(V) - (j.y - D.y) * Math.sin(V), W = D.y + (j.x - D.x) * Math.sin(V) + (j.y - D.y) * Math.cos(V);
    return {
      ...j,
      rotation: j.rotation + V,
      x: G,
      y: W
    };
  }
  function E(j, V) {
    const D = O(j);
    return M(j, V, D);
  }
  function R(j, V, D) {
    let G = V;
    for (let W = 0; W < j.length; W++) {
      const P = u.Konva.getAngle(j[W]), H = Math.abs(P - V) % (Math.PI * 2);
      Math.min(H, Math.PI * 2 - H) < D && (G = P);
    }
    return G;
  }
  let N = 0, U = class extends o.Group {
    constructor(V) {
      super(V), this._movingAnchorName = null, this._transforming = !1, this._createElements(), this._handleMouseMove = this._handleMouseMove.bind(this), this._handleMouseUp = this._handleMouseUp.bind(this), this.update = this.update.bind(this), this.on(g, this.update), this.getNode() && this.update();
    }
    attachTo(V) {
      return this.setNode(V), this;
    }
    setNode(V) {
      return e.Util.warn("tr.setNode(shape), tr.node(shape) and tr.attachTo(shape) methods are deprecated. Please use tr.nodes(nodesArray) instead."), this.setNodes([V]);
    }
    getNode() {
      return this._nodes && this._nodes[0];
    }
    _getEventNamespace() {
      return p + this._id;
    }
    setNodes(V = []) {
      this._nodes && this._nodes.length && this.detach();
      const D = V.filter((W) => W.isAncestorOf(this) ? (e.Util.error("Konva.Transformer cannot be an a child of the node you are trying to attach"), !1) : !0);
      return this._nodes = V = D, V.length === 1 && this.useSingleNodeRotation() ? this.rotation(V[0].getAbsoluteRotation()) : this.rotation(0), this._nodes.forEach((W) => {
        const P = () => {
          this.nodes().length === 1 && this.useSingleNodeRotation() && this.rotation(this.nodes()[0].getAbsoluteRotation()), this._resetTransformCache(), !this._transforming && !this.isDragging() && this.update();
        };
        if (W._attrsAffectingSize.length) {
          const H = W._attrsAffectingSize.map((I) => I + "Change." + this._getEventNamespace()).join(" ");
          W.on(H, P);
        }
        W.on(x.map((H) => H + `.${this._getEventNamespace()}`).join(" "), P), W.on(`absoluteTransformChange.${this._getEventNamespace()}`, P), this._proxyDrag(W);
      }), this._resetTransformCache(), !!this.findOne(".top-left") && this.update(), this;
    }
    _proxyDrag(V) {
      let D;
      V.on(`dragstart.${this._getEventNamespace()}`, (G) => {
        D = V.getAbsolutePosition(), !this.isDragging() && V !== this.findOne(".back") && this.startDrag(G, !1);
      }), V.on(`dragmove.${this._getEventNamespace()}`, (G) => {
        if (!D)
          return;
        const W = V.getAbsolutePosition(), P = W.x - D.x, H = W.y - D.y;
        this.nodes().forEach((I) => {
          if (I === V || I.isDragging())
            return;
          const K = I.getAbsolutePosition();
          I.setAbsolutePosition({
            x: K.x + P,
            y: K.y + H
          }), I.startDrag(G);
        }), D = null;
      });
    }
    getNodes() {
      return this._nodes || [];
    }
    getActiveAnchor() {
      return this._movingAnchorName;
    }
    detach() {
      this._nodes && this._nodes.forEach((V) => {
        V.off("." + this._getEventNamespace());
      }), this._nodes = [], this._resetTransformCache();
    }
    _resetTransformCache() {
      this._clearCache(v), this._clearCache("transform"), this._clearSelfAndDescendantCache("absoluteTransform");
    }
    _getNodeRect() {
      return this._getCache(v, this.__getNodeRect);
    }
    __getNodeShape(V, D = this.rotation(), G) {
      const W = V.getClientRect({
        skipTransform: !0,
        skipShadow: !0,
        skipStroke: this.ignoreStroke()
      }), P = V.getAbsoluteScale(G), H = V.getAbsolutePosition(G), I = W.x * P.x - V.offsetX() * P.x, K = W.y * P.y - V.offsetY() * P.y, Q = (u.Konva.getAngle(V.getAbsoluteRotation()) + Math.PI * 2) % (Math.PI * 2), it = {
        x: H.x + I * Math.cos(Q) + K * Math.sin(-Q),
        y: H.y + K * Math.cos(Q) + I * Math.sin(Q),
        width: W.width * P.x,
        height: W.height * P.y,
        rotation: Q
      };
      return M(it, -u.Konva.getAngle(D), {
        x: 0,
        y: 0
      });
    }
    __getNodeRect() {
      if (!this.getNode())
        return {
          x: -1e8,
          y: -1e8,
          width: 0,
          height: 0,
          rotation: 0
        };
      const D = [];
      this.nodes().map((Q) => {
        const it = Q.getClientRect({
          skipTransform: !0,
          skipShadow: !0,
          skipStroke: this.ignoreStroke()
        }), nt = [
          { x: it.x, y: it.y },
          { x: it.x + it.width, y: it.y },
          { x: it.x + it.width, y: it.y + it.height },
          { x: it.x, y: it.y + it.height }
        ], X = Q.getAbsoluteTransform();
        nt.forEach(function(rt) {
          const vt = X.point(rt);
          D.push(vt);
        });
      });
      const G = new e.Transform();
      G.rotate(-u.Konva.getAngle(this.rotation()));
      let W = 1 / 0, P = 1 / 0, H = -1 / 0, I = -1 / 0;
      D.forEach(function(Q) {
        const it = G.point(Q);
        W === void 0 && (W = H = it.x, P = I = it.y), W = Math.min(W, it.x), P = Math.min(P, it.y), H = Math.max(H, it.x), I = Math.max(I, it.y);
      }), G.invert();
      const K = G.point({ x: W, y: P });
      return {
        x: K.x,
        y: K.y,
        width: H - W,
        height: I - P,
        rotation: u.Konva.getAngle(this.rotation())
      };
    }
    getX() {
      return this._getNodeRect().x;
    }
    getY() {
      return this._getNodeRect().y;
    }
    getWidth() {
      return this._getNodeRect().width;
    }
    getHeight() {
      return this._getNodeRect().height;
    }
    _createElements() {
      this._createBack(), A.forEach((V) => {
        this._createAnchor(V);
      }), this._createAnchor("rotater");
    }
    _createAnchor(V) {
      const D = new s.Rect({
        stroke: "rgb(0, 161, 255)",
        fill: "white",
        strokeWidth: 1,
        name: V + " _anchor",
        dragDistance: 0,
        draggable: !0,
        hitStrokeWidth: _ ? 10 : "auto"
      }), G = this;
      D.on("mousedown touchstart", function(W) {
        G._handleMouseDown(W);
      }), D.on("dragstart", (W) => {
        D.stopDrag(), W.cancelBubble = !0;
      }), D.on("dragend", (W) => {
        W.cancelBubble = !0;
      }), D.on("mouseenter", () => {
        const W = u.Konva.getAngle(this.rotation()), P = this.rotateAnchorCursor(), H = T(V, W, P);
        D.getStage().content && (D.getStage().content.style.cursor = H), this._cursorChange = !0;
      }), D.on("mouseout", () => {
        D.getStage().content && (D.getStage().content.style.cursor = ""), this._cursorChange = !1;
      }), this.add(D);
    }
    _createBack() {
      const V = new i.Shape({
        name: "back",
        width: 0,
        height: 0,
        draggable: !0,
        sceneFunc(D, G) {
          const W = G.getParent(), P = W.padding();
          D.beginPath(), D.rect(-P, -P, G.width() + P * 2, G.height() + P * 2), D.moveTo(G.width() / 2, -P), W.rotateEnabled() && W.rotateLineVisible() && D.lineTo(G.width() / 2, -W.rotateAnchorOffset() * e.Util._sign(G.height()) - P), D.fillStrokeShape(G);
        },
        hitFunc: (D, G) => {
          if (!this.shouldOverdrawWholeArea())
            return;
          const W = this.padding();
          D.beginPath(), D.rect(-W, -W, G.width() + W * 2, G.height() + W * 2), D.fillStrokeShape(G);
        }
      });
      this.add(V), this._proxyDrag(V), V.on("dragstart", (D) => {
        D.cancelBubble = !0;
      }), V.on("dragmove", (D) => {
        D.cancelBubble = !0;
      }), V.on("dragend", (D) => {
        D.cancelBubble = !0;
      }), this.on("dragmove", (D) => {
        this.update();
      });
    }
    _handleMouseDown(V) {
      if (this._transforming)
        return;
      this._movingAnchorName = V.target.name().split(" ")[0];
      const D = this._getNodeRect(), G = D.width, W = D.height, P = Math.sqrt(Math.pow(G, 2) + Math.pow(W, 2));
      this.sin = Math.abs(W / P), this.cos = Math.abs(G / P), typeof window < "u" && (window.addEventListener("mousemove", this._handleMouseMove), window.addEventListener("touchmove", this._handleMouseMove), window.addEventListener("mouseup", this._handleMouseUp, !0), window.addEventListener("touchend", this._handleMouseUp, !0)), this._transforming = !0;
      const H = V.target.getAbsolutePosition(), I = V.target.getStage().getPointerPosition();
      this._anchorDragOffset = {
        x: I.x - H.x,
        y: I.y - H.y
      }, N++, this._fire("transformstart", { evt: V.evt, target: this.getNode() }), this._nodes.forEach((K) => {
        K._fire("transformstart", { evt: V.evt, target: K });
      });
    }
    _handleMouseMove(V) {
      let D, G, W;
      const P = this.findOne("." + this._movingAnchorName), H = P.getStage();
      H.setPointersPositions(V);
      const I = H.getPointerPosition();
      let K = {
        x: I.x - this._anchorDragOffset.x,
        y: I.y - this._anchorDragOffset.y
      };
      const Q = P.getAbsolutePosition();
      this.anchorDragBoundFunc() && (K = this.anchorDragBoundFunc()(Q, K, V)), P.setAbsolutePosition(K);
      const it = P.getAbsolutePosition();
      if (Q.x === it.x && Q.y === it.y)
        return;
      if (this._movingAnchorName === "rotater") {
        const ft = this._getNodeRect();
        D = P.x() - ft.width / 2, G = -P.y() + ft.height / 2;
        let Tt = Math.atan2(-G, D) + Math.PI / 2;
        ft.height < 0 && (Tt -= Math.PI);
        const Ot = u.Konva.getAngle(this.rotation()) + Tt, ie = u.Konva.getAngle(this.rotationSnapTolerance()), Ut = R(this.rotationSnaps(), Ot, ie) - ft.rotation, se = E(ft, Ut);
        this._fitNodesInto(se, V);
        return;
      }
      const nt = this.shiftBehavior();
      let X;
      nt === "inverted" ? X = this.keepRatio() && !V.shiftKey : nt === "none" ? X = this.keepRatio() : X = this.keepRatio() || V.shiftKey;
      var ht = this.centeredScaling() || V.altKey;
      if (this._movingAnchorName === "top-left") {
        if (X) {
          var rt = ht ? {
            x: this.width() / 2,
            y: this.height() / 2
          } : {
            x: this.findOne(".bottom-right").x(),
            y: this.findOne(".bottom-right").y()
          };
          W = Math.sqrt(Math.pow(rt.x - P.x(), 2) + Math.pow(rt.y - P.y(), 2));
          var vt = this.findOne(".top-left").x() > rt.x ? -1 : 1, ct = this.findOne(".top-left").y() > rt.y ? -1 : 1;
          D = W * this.cos * vt, G = W * this.sin * ct, this.findOne(".top-left").x(rt.x - D), this.findOne(".top-left").y(rt.y - G);
        }
      } else if (this._movingAnchorName === "top-center")
        this.findOne(".top-left").y(P.y());
      else if (this._movingAnchorName === "top-right") {
        if (X) {
          var rt = ht ? {
            x: this.width() / 2,
            y: this.height() / 2
          } : {
            x: this.findOne(".bottom-left").x(),
            y: this.findOne(".bottom-left").y()
          };
          W = Math.sqrt(Math.pow(P.x() - rt.x, 2) + Math.pow(rt.y - P.y(), 2));
          var vt = this.findOne(".top-right").x() < rt.x ? -1 : 1, ct = this.findOne(".top-right").y() > rt.y ? -1 : 1;
          D = W * this.cos * vt, G = W * this.sin * ct, this.findOne(".top-right").x(rt.x + D), this.findOne(".top-right").y(rt.y - G);
        }
        var dt = P.position();
        this.findOne(".top-left").y(dt.y), this.findOne(".bottom-right").x(dt.x);
      } else if (this._movingAnchorName === "middle-left")
        this.findOne(".top-left").x(P.x());
      else if (this._movingAnchorName === "middle-right")
        this.findOne(".bottom-right").x(P.x());
      else if (this._movingAnchorName === "bottom-left") {
        if (X) {
          var rt = ht ? {
            x: this.width() / 2,
            y: this.height() / 2
          } : {
            x: this.findOne(".top-right").x(),
            y: this.findOne(".top-right").y()
          };
          W = Math.sqrt(Math.pow(rt.x - P.x(), 2) + Math.pow(P.y() - rt.y, 2));
          var vt = rt.x < P.x() ? -1 : 1, ct = P.y() < rt.y ? -1 : 1;
          D = W * this.cos * vt, G = W * this.sin * ct, P.x(rt.x - D), P.y(rt.y + G);
        }
        dt = P.position(), this.findOne(".top-left").x(dt.x), this.findOne(".bottom-right").y(dt.y);
      } else if (this._movingAnchorName === "bottom-center")
        this.findOne(".bottom-right").y(P.y());
      else if (this._movingAnchorName === "bottom-right") {
        if (X) {
          var rt = ht ? {
            x: this.width() / 2,
            y: this.height() / 2
          } : {
            x: this.findOne(".top-left").x(),
            y: this.findOne(".top-left").y()
          };
          W = Math.sqrt(Math.pow(P.x() - rt.x, 2) + Math.pow(P.y() - rt.y, 2));
          var vt = this.findOne(".bottom-right").x() < rt.x ? -1 : 1, ct = this.findOne(".bottom-right").y() < rt.y ? -1 : 1;
          D = W * this.cos * vt, G = W * this.sin * ct, this.findOne(".bottom-right").x(rt.x + D), this.findOne(".bottom-right").y(rt.y + G);
        }
      } else
        console.error(new Error("Wrong position argument of selection resizer: " + this._movingAnchorName));
      var ht = this.centeredScaling() || V.altKey;
      if (ht) {
        const ft = this.findOne(".top-left"), Tt = this.findOne(".bottom-right"), Bt = ft.x(), Ot = ft.y(), ie = this.getWidth() - Tt.x(), ce = this.getHeight() - Tt.y();
        Tt.move({
          x: -Bt,
          y: -Ot
        }), ft.move({
          x: ie,
          y: ce
        });
      }
      const Et = this.findOne(".top-left").getAbsolutePosition();
      D = Et.x, G = Et.y;
      const ot = this.findOne(".bottom-right").x() - this.findOne(".top-left").x(), lt = this.findOne(".bottom-right").y() - this.findOne(".top-left").y();
      this._fitNodesInto({
        x: D,
        y: G,
        width: ot,
        height: lt,
        rotation: u.Konva.getAngle(this.rotation())
      }, V);
    }
    _handleMouseUp(V) {
      this._removeEvents(V);
    }
    getAbsoluteTransform() {
      return this.getTransform();
    }
    _removeEvents(V) {
      var D;
      if (this._transforming) {
        this._transforming = !1, typeof window < "u" && (window.removeEventListener("mousemove", this._handleMouseMove), window.removeEventListener("touchmove", this._handleMouseMove), window.removeEventListener("mouseup", this._handleMouseUp, !0), window.removeEventListener("touchend", this._handleMouseUp, !0));
        const G = this.getNode();
        N--, this._fire("transformend", { evt: V, target: G }), (D = this.getLayer()) === null || D === void 0 || D.batchDraw(), G && this._nodes.forEach((W) => {
          var P;
          W._fire("transformend", { evt: V, target: W }), (P = W.getLayer()) === null || P === void 0 || P.batchDraw();
        }), this._movingAnchorName = null;
      }
    }
    _fitNodesInto(V, D) {
      const G = this._getNodeRect(), W = 1;
      if (e.Util._inRange(V.width, -this.padding() * 2 - W, W)) {
        this.update();
        return;
      }
      if (e.Util._inRange(V.height, -this.padding() * 2 - W, W)) {
        this.update();
        return;
      }
      const P = new e.Transform();
      if (P.rotate(u.Konva.getAngle(this.rotation())), this._movingAnchorName && V.width < 0 && this._movingAnchorName.indexOf("left") >= 0) {
        const X = P.point({
          x: -this.padding() * 2,
          y: 0
        });
        V.x += X.x, V.y += X.y, V.width += this.padding() * 2, this._movingAnchorName = this._movingAnchorName.replace("left", "right"), this._anchorDragOffset.x -= X.x, this._anchorDragOffset.y -= X.y;
      } else if (this._movingAnchorName && V.width < 0 && this._movingAnchorName.indexOf("right") >= 0) {
        const X = P.point({
          x: this.padding() * 2,
          y: 0
        });
        this._movingAnchorName = this._movingAnchorName.replace("right", "left"), this._anchorDragOffset.x -= X.x, this._anchorDragOffset.y -= X.y, V.width += this.padding() * 2;
      }
      if (this._movingAnchorName && V.height < 0 && this._movingAnchorName.indexOf("top") >= 0) {
        const X = P.point({
          x: 0,
          y: -this.padding() * 2
        });
        V.x += X.x, V.y += X.y, this._movingAnchorName = this._movingAnchorName.replace("top", "bottom"), this._anchorDragOffset.x -= X.x, this._anchorDragOffset.y -= X.y, V.height += this.padding() * 2;
      } else if (this._movingAnchorName && V.height < 0 && this._movingAnchorName.indexOf("bottom") >= 0) {
        const X = P.point({
          x: 0,
          y: this.padding() * 2
        });
        this._movingAnchorName = this._movingAnchorName.replace("bottom", "top"), this._anchorDragOffset.x -= X.x, this._anchorDragOffset.y -= X.y, V.height += this.padding() * 2;
      }
      if (this.boundBoxFunc()) {
        const X = this.boundBoxFunc()(G, V);
        X ? V = X : e.Util.warn("boundBoxFunc returned falsy. You should return new bound rect from it!");
      }
      const H = 1e7, I = new e.Transform();
      I.translate(G.x, G.y), I.rotate(G.rotation), I.scale(G.width / H, G.height / H);
      const K = new e.Transform(), Q = V.width / H, it = V.height / H;
      this.flipEnabled() === !1 ? (K.translate(V.x, V.y), K.rotate(V.rotation), K.translate(V.width < 0 ? V.width : 0, V.height < 0 ? V.height : 0), K.scale(Math.abs(Q), Math.abs(it))) : (K.translate(V.x, V.y), K.rotate(V.rotation), K.scale(Q, it));
      const nt = K.multiply(I.invert());
      this._nodes.forEach((X) => {
        var rt;
        const vt = X.getParent().getAbsoluteTransform(), ct = X.getTransform().copy();
        ct.translate(X.offsetX(), X.offsetY());
        const dt = new e.Transform();
        dt.multiply(vt.copy().invert()).multiply(nt).multiply(vt).multiply(ct);
        const ht = dt.decompose();
        X.setAttrs(ht), (rt = X.getLayer()) === null || rt === void 0 || rt.batchDraw();
      }), this.rotation(e.Util._getRotation(V.rotation)), this._nodes.forEach((X) => {
        this._fire("transform", { evt: D, target: X }), X._fire("transform", { evt: D, target: X });
      }), this._resetTransformCache(), this.update(), this.getLayer().batchDraw();
    }
    forceUpdate() {
      this._resetTransformCache(), this.update();
    }
    _batchChangeChild(V, D) {
      this.findOne(V).setAttrs(D);
    }
    update() {
      var V;
      const D = this._getNodeRect();
      this.rotation(e.Util._getRotation(D.rotation));
      const G = D.width, W = D.height, P = this.enabledAnchors(), H = this.resizeEnabled(), I = this.padding(), K = this.anchorSize(), Q = this.find("._anchor");
      Q.forEach((nt) => {
        nt.setAttrs({
          width: K,
          height: K,
          offsetX: K / 2,
          offsetY: K / 2,
          stroke: this.anchorStroke(),
          strokeWidth: this.anchorStrokeWidth(),
          fill: this.anchorFill(),
          cornerRadius: this.anchorCornerRadius()
        });
      }), this._batchChangeChild(".top-left", {
        x: 0,
        y: 0,
        offsetX: K / 2 + I,
        offsetY: K / 2 + I,
        visible: H && P.indexOf("top-left") >= 0
      }), this._batchChangeChild(".top-center", {
        x: G / 2,
        y: 0,
        offsetY: K / 2 + I,
        visible: H && P.indexOf("top-center") >= 0
      }), this._batchChangeChild(".top-right", {
        x: G,
        y: 0,
        offsetX: K / 2 - I,
        offsetY: K / 2 + I,
        visible: H && P.indexOf("top-right") >= 0
      }), this._batchChangeChild(".middle-left", {
        x: 0,
        y: W / 2,
        offsetX: K / 2 + I,
        visible: H && P.indexOf("middle-left") >= 0
      }), this._batchChangeChild(".middle-right", {
        x: G,
        y: W / 2,
        offsetX: K / 2 - I,
        visible: H && P.indexOf("middle-right") >= 0
      }), this._batchChangeChild(".bottom-left", {
        x: 0,
        y: W,
        offsetX: K / 2 + I,
        offsetY: K / 2 - I,
        visible: H && P.indexOf("bottom-left") >= 0
      }), this._batchChangeChild(".bottom-center", {
        x: G / 2,
        y: W,
        offsetY: K / 2 - I,
        visible: H && P.indexOf("bottom-center") >= 0
      }), this._batchChangeChild(".bottom-right", {
        x: G,
        y: W,
        offsetX: K / 2 - I,
        offsetY: K / 2 - I,
        visible: H && P.indexOf("bottom-right") >= 0
      }), this._batchChangeChild(".rotater", {
        x: G / 2,
        y: -this.rotateAnchorOffset() * e.Util._sign(W) - I,
        visible: this.rotateEnabled()
      }), this._batchChangeChild(".back", {
        width: G,
        height: W,
        visible: this.borderEnabled(),
        stroke: this.borderStroke(),
        strokeWidth: this.borderStrokeWidth(),
        dash: this.borderDash(),
        x: 0,
        y: 0
      });
      const it = this.anchorStyleFunc();
      it && Q.forEach((nt) => {
        it(nt);
      }), (V = this.getLayer()) === null || V === void 0 || V.batchDraw();
    }
    isTransforming() {
      return this._transforming;
    }
    stopTransform() {
      if (this._transforming) {
        this._removeEvents();
        const V = this.findOne("." + this._movingAnchorName);
        V && V.stopDrag();
      }
    }
    destroy() {
      return this.getStage() && this._cursorChange && this.getStage().content && (this.getStage().content.style.cursor = ""), o.Group.prototype.destroy.call(this), this.detach(), this._removeEvents(), this;
    }
    toObject() {
      return n.Node.prototype.toObject.call(this);
    }
    clone(V) {
      return n.Node.prototype.clone.call(this, V);
    }
    getClientRect() {
      return this.nodes().length > 0 ? super.getClientRect() : { x: 0, y: 0, width: 0, height: 0 };
    }
  };
  Km.Transformer = U, U.isTransforming = () => N > 0;
  function q(j) {
    return j instanceof Array || e.Util.warn("enabledAnchors value should be an array"), j instanceof Array && j.forEach(function(V) {
      A.indexOf(V) === -1 && e.Util.warn("Unknown anchor name: " + V + ". Available names are: " + A.join(", "));
    }), j || [];
  }
  return U.prototype.className = "Transformer", (0, f._registerNode)(U), t.Factory.addGetterSetter(U, "enabledAnchors", A, q), t.Factory.addGetterSetter(U, "flipEnabled", !0, (0, h.getBooleanValidator)()), t.Factory.addGetterSetter(U, "resizeEnabled", !0), t.Factory.addGetterSetter(U, "anchorSize", 10, (0, h.getNumberValidator)()), t.Factory.addGetterSetter(U, "rotateEnabled", !0), t.Factory.addGetterSetter(U, "rotateLineVisible", !0), t.Factory.addGetterSetter(U, "rotationSnaps", []), t.Factory.addGetterSetter(U, "rotateAnchorOffset", 50, (0, h.getNumberValidator)()), t.Factory.addGetterSetter(U, "rotateAnchorCursor", "crosshair"), t.Factory.addGetterSetter(U, "rotationSnapTolerance", 5, (0, h.getNumberValidator)()), t.Factory.addGetterSetter(U, "borderEnabled", !0), t.Factory.addGetterSetter(U, "anchorStroke", "rgb(0, 161, 255)"), t.Factory.addGetterSetter(U, "anchorStrokeWidth", 1, (0, h.getNumberValidator)()), t.Factory.addGetterSetter(U, "anchorFill", "white"), t.Factory.addGetterSetter(U, "anchorCornerRadius", 0, (0, h.getNumberValidator)()), t.Factory.addGetterSetter(U, "borderStroke", "rgb(0, 161, 255)"), t.Factory.addGetterSetter(U, "borderStrokeWidth", 1, (0, h.getNumberValidator)()), t.Factory.addGetterSetter(U, "borderDash"), t.Factory.addGetterSetter(U, "keepRatio", !0), t.Factory.addGetterSetter(U, "shiftBehavior", "default"), t.Factory.addGetterSetter(U, "centeredScaling", !1), t.Factory.addGetterSetter(U, "ignoreStroke", !1), t.Factory.addGetterSetter(U, "padding", 0, (0, h.getNumberValidator)()), t.Factory.addGetterSetter(U, "nodes"), t.Factory.addGetterSetter(U, "node"), t.Factory.addGetterSetter(U, "boundBoxFunc"), t.Factory.addGetterSetter(U, "anchorDragBoundFunc"), t.Factory.addGetterSetter(U, "anchorStyleFunc"), t.Factory.addGetterSetter(U, "shouldOverdrawWholeArea", !1), t.Factory.addGetterSetter(U, "useSingleNodeRotation", !0), t.Factory.backCompat(U, {
    lineEnabled: "borderEnabled",
    rotateHandlerOffset: "rotateAnchorOffset",
    enabledHandlers: "enabledAnchors"
  }), Km;
}
var Ym = {}, k4;
function QU() {
  if (k4) return Ym;
  k4 = 1, Object.defineProperty(Ym, "__esModule", { value: !0 }), Ym.Wedge = void 0;
  const e = An(), t = ta(), n = Sn(), i = Mn(), s = Sn();
  let o = class extends t.Shape {
    _sceneFunc(h) {
      h.beginPath(), h.arc(0, 0, this.radius(), 0, n.Konva.getAngle(this.angle()), this.clockwise()), h.lineTo(0, 0), h.closePath(), h.fillStrokeShape(this);
    }
    getWidth() {
      return this.radius() * 2;
    }
    getHeight() {
      return this.radius() * 2;
    }
    setWidth(h) {
      this.radius(h / 2);
    }
    setHeight(h) {
      this.radius(h / 2);
    }
  };
  return Ym.Wedge = o, o.prototype.className = "Wedge", o.prototype._centroid = !0, o.prototype._attrsAffectingSize = ["radius"], (0, s._registerNode)(o), e.Factory.addGetterSetter(o, "radius", 0, (0, i.getNumberValidator)()), e.Factory.addGetterSetter(o, "angle", 0, (0, i.getNumberValidator)()), e.Factory.addGetterSetter(o, "clockwise", !1), e.Factory.backCompat(o, {
    angleDeg: "angle",
    getAngleDeg: "getAngle",
    setAngleDeg: "setAngle"
  }), Ym;
}
var Xm = {}, D4;
function ZU() {
  if (D4) return Xm;
  D4 = 1, Object.defineProperty(Xm, "__esModule", { value: !0 }), Xm.Blur = void 0;
  const e = An(), t = br(), n = Mn();
  function i() {
    this.r = 0, this.g = 0, this.b = 0, this.a = 0, this.next = null;
  }
  const s = [
    512,
    512,
    456,
    512,
    328,
    456,
    335,
    512,
    405,
    328,
    271,
    456,
    388,
    335,
    292,
    512,
    454,
    405,
    364,
    328,
    298,
    271,
    496,
    456,
    420,
    388,
    360,
    335,
    312,
    292,
    273,
    512,
    482,
    454,
    428,
    405,
    383,
    364,
    345,
    328,
    312,
    298,
    284,
    271,
    259,
    496,
    475,
    456,
    437,
    420,
    404,
    388,
    374,
    360,
    347,
    335,
    323,
    312,
    302,
    292,
    282,
    273,
    265,
    512,
    497,
    482,
    468,
    454,
    441,
    428,
    417,
    405,
    394,
    383,
    373,
    364,
    354,
    345,
    337,
    328,
    320,
    312,
    305,
    298,
    291,
    284,
    278,
    271,
    265,
    259,
    507,
    496,
    485,
    475,
    465,
    456,
    446,
    437,
    428,
    420,
    412,
    404,
    396,
    388,
    381,
    374,
    367,
    360,
    354,
    347,
    341,
    335,
    329,
    323,
    318,
    312,
    307,
    302,
    297,
    292,
    287,
    282,
    278,
    273,
    269,
    265,
    261,
    512,
    505,
    497,
    489,
    482,
    475,
    468,
    461,
    454,
    447,
    441,
    435,
    428,
    422,
    417,
    411,
    405,
    399,
    394,
    389,
    383,
    378,
    373,
    368,
    364,
    359,
    354,
    350,
    345,
    341,
    337,
    332,
    328,
    324,
    320,
    316,
    312,
    309,
    305,
    301,
    298,
    294,
    291,
    287,
    284,
    281,
    278,
    274,
    271,
    268,
    265,
    262,
    259,
    257,
    507,
    501,
    496,
    491,
    485,
    480,
    475,
    470,
    465,
    460,
    456,
    451,
    446,
    442,
    437,
    433,
    428,
    424,
    420,
    416,
    412,
    408,
    404,
    400,
    396,
    392,
    388,
    385,
    381,
    377,
    374,
    370,
    367,
    363,
    360,
    357,
    354,
    350,
    347,
    344,
    341,
    338,
    335,
    332,
    329,
    326,
    323,
    320,
    318,
    315,
    312,
    310,
    307,
    304,
    302,
    299,
    297,
    294,
    292,
    289,
    287,
    285,
    282,
    280,
    278,
    275,
    273,
    271,
    269,
    267,
    265,
    263,
    261,
    259
  ], o = [
    9,
    11,
    12,
    13,
    13,
    14,
    14,
    15,
    15,
    15,
    15,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24
  ];
  function u(f, p) {
    const g = f.data, v = f.width, x = f.height;
    let b, _, T, A, O, M, E, R, N, U, q, j, V, D, G, W, P, H, I, K, Q, it, nt, X;
    const rt = p + p + 1, vt = v - 1, ct = x - 1, dt = p + 1, ht = dt * (dt + 1) / 2, Et = new i(), ot = s[p], lt = o[p];
    let ft = null, Tt = Et, Bt = null, Ot = null;
    for (T = 1; T < rt; T++)
      Tt = Tt.next = new i(), T === dt && (ft = Tt);
    for (Tt.next = Et, E = M = 0, _ = 0; _ < x; _++) {
      for (W = P = H = I = R = N = U = q = 0, j = dt * (K = g[M]), V = dt * (Q = g[M + 1]), D = dt * (it = g[M + 2]), G = dt * (nt = g[M + 3]), R += ht * K, N += ht * Q, U += ht * it, q += ht * nt, Tt = Et, T = 0; T < dt; T++)
        Tt.r = K, Tt.g = Q, Tt.b = it, Tt.a = nt, Tt = Tt.next;
      for (T = 1; T < dt; T++)
        A = M + ((vt < T ? vt : T) << 2), R += (Tt.r = K = g[A]) * (X = dt - T), N += (Tt.g = Q = g[A + 1]) * X, U += (Tt.b = it = g[A + 2]) * X, q += (Tt.a = nt = g[A + 3]) * X, W += K, P += Q, H += it, I += nt, Tt = Tt.next;
      for (Bt = Et, Ot = ft, b = 0; b < v; b++)
        g[M + 3] = nt = q * ot >> lt, nt !== 0 ? (nt = 255 / nt, g[M] = (R * ot >> lt) * nt, g[M + 1] = (N * ot >> lt) * nt, g[M + 2] = (U * ot >> lt) * nt) : g[M] = g[M + 1] = g[M + 2] = 0, R -= j, N -= V, U -= D, q -= G, j -= Bt.r, V -= Bt.g, D -= Bt.b, G -= Bt.a, A = E + ((A = b + p + 1) < vt ? A : vt) << 2, W += Bt.r = g[A], P += Bt.g = g[A + 1], H += Bt.b = g[A + 2], I += Bt.a = g[A + 3], R += W, N += P, U += H, q += I, Bt = Bt.next, j += K = Ot.r, V += Q = Ot.g, D += it = Ot.b, G += nt = Ot.a, W -= K, P -= Q, H -= it, I -= nt, Ot = Ot.next, M += 4;
      E += v;
    }
    for (b = 0; b < v; b++) {
      for (P = H = I = W = N = U = q = R = 0, M = b << 2, j = dt * (K = g[M]), V = dt * (Q = g[M + 1]), D = dt * (it = g[M + 2]), G = dt * (nt = g[M + 3]), R += ht * K, N += ht * Q, U += ht * it, q += ht * nt, Tt = Et, T = 0; T < dt; T++)
        Tt.r = K, Tt.g = Q, Tt.b = it, Tt.a = nt, Tt = Tt.next;
      for (O = v, T = 1; T <= p; T++)
        M = O + b << 2, R += (Tt.r = K = g[M]) * (X = dt - T), N += (Tt.g = Q = g[M + 1]) * X, U += (Tt.b = it = g[M + 2]) * X, q += (Tt.a = nt = g[M + 3]) * X, W += K, P += Q, H += it, I += nt, Tt = Tt.next, T < ct && (O += v);
      for (M = b, Bt = Et, Ot = ft, _ = 0; _ < x; _++)
        A = M << 2, g[A + 3] = nt = q * ot >> lt, nt > 0 ? (nt = 255 / nt, g[A] = (R * ot >> lt) * nt, g[A + 1] = (N * ot >> lt) * nt, g[A + 2] = (U * ot >> lt) * nt) : g[A] = g[A + 1] = g[A + 2] = 0, R -= j, N -= V, U -= D, q -= G, j -= Bt.r, V -= Bt.g, D -= Bt.b, G -= Bt.a, A = b + ((A = _ + dt) < ct ? A : ct) * v << 2, R += W += Bt.r = g[A], N += P += Bt.g = g[A + 1], U += H += Bt.b = g[A + 2], q += I += Bt.a = g[A + 3], Bt = Bt.next, j += K = Ot.r, V += Q = Ot.g, D += it = Ot.b, G += nt = Ot.a, W -= K, P -= Q, H -= it, I -= nt, Ot = Ot.next, M += v;
    }
  }
  const h = function(p) {
    const g = Math.round(this.blurRadius());
    g > 0 && u(p, g);
  };
  return Xm.Blur = h, e.Factory.addGetterSetter(t.Node, "blurRadius", 0, (0, n.getNumberValidator)(), e.Factory.afterSetFilter), Xm;
}
var Wm = {}, B4;
function JU() {
  if (B4) return Wm;
  B4 = 1, Object.defineProperty(Wm, "__esModule", { value: !0 }), Wm.Brighten = void 0;
  const e = An(), t = br(), n = Mn(), i = function(s) {
    const o = this.brightness() * 255, u = s.data, h = u.length;
    for (let f = 0; f < h; f += 4)
      u[f] += o, u[f + 1] += o, u[f + 2] += o;
  };
  return Wm.Brighten = i, e.Factory.addGetterSetter(t.Node, "brightness", 0, (0, n.getNumberValidator)(), e.Factory.afterSetFilter), Wm;
}
var $m = {}, z4;
function tj() {
  if (z4) return $m;
  z4 = 1, Object.defineProperty($m, "__esModule", { value: !0 }), $m.Contrast = void 0;
  const e = An(), t = br(), n = Mn(), i = function(s) {
    const o = Math.pow((this.contrast() + 100) / 100, 2), u = s.data, h = u.length;
    let f = 150, p = 150, g = 150;
    for (let v = 0; v < h; v += 4)
      f = u[v], p = u[v + 1], g = u[v + 2], f /= 255, f -= 0.5, f *= o, f += 0.5, f *= 255, p /= 255, p -= 0.5, p *= o, p += 0.5, p *= 255, g /= 255, g -= 0.5, g *= o, g += 0.5, g *= 255, f = f < 0 ? 0 : f > 255 ? 255 : f, p = p < 0 ? 0 : p > 255 ? 255 : p, g = g < 0 ? 0 : g > 255 ? 255 : g, u[v] = f, u[v + 1] = p, u[v + 2] = g;
  };
  return $m.Contrast = i, e.Factory.addGetterSetter(t.Node, "contrast", 0, (0, n.getNumberValidator)(), e.Factory.afterSetFilter), $m;
}
var Qm = {}, P4;
function ej() {
  if (P4) return Qm;
  P4 = 1, Object.defineProperty(Qm, "__esModule", { value: !0 }), Qm.Emboss = void 0;
  const e = An(), t = br(), n = lr(), i = Mn(), s = function(o) {
    const u = this.embossStrength() * 10, h = this.embossWhiteLevel() * 255, f = this.embossDirection(), p = this.embossBlend(), g = o.data, v = o.width, x = o.height, b = v * 4;
    let _ = 0, T = 0, A = x;
    switch (f) {
      case "top-left":
        _ = -1, T = -1;
        break;
      case "top":
        _ = -1, T = 0;
        break;
      case "top-right":
        _ = -1, T = 1;
        break;
      case "right":
        _ = 0, T = 1;
        break;
      case "bottom-right":
        _ = 1, T = 1;
        break;
      case "bottom":
        _ = 1, T = 0;
        break;
      case "bottom-left":
        _ = 1, T = -1;
        break;
      case "left":
        _ = 0, T = -1;
        break;
      default:
        n.Util.error("Unknown emboss direction: " + f);
    }
    do {
      const O = (A - 1) * b;
      let M = _;
      A + M < 1 && (M = 0), A + M > x && (M = 0);
      const E = (A - 1 + M) * v * 4;
      let R = v;
      do {
        const N = O + (R - 1) * 4;
        let U = T;
        R + U < 1 && (U = 0), R + U > v && (U = 0);
        const q = E + (R - 1 + U) * 4, j = g[N] - g[q], V = g[N + 1] - g[q + 1], D = g[N + 2] - g[q + 2];
        let G = j;
        const W = G > 0 ? G : -G, P = V > 0 ? V : -V, H = D > 0 ? D : -D;
        if (P > W && (G = V), H > W && (G = D), G *= u, p) {
          const I = g[N] + G, K = g[N + 1] + G, Q = g[N + 2] + G;
          g[N] = I > 255 ? 255 : I < 0 ? 0 : I, g[N + 1] = K > 255 ? 255 : K < 0 ? 0 : K, g[N + 2] = Q > 255 ? 255 : Q < 0 ? 0 : Q;
        } else {
          let I = h - G;
          I < 0 ? I = 0 : I > 255 && (I = 255), g[N] = g[N + 1] = g[N + 2] = I;
        }
      } while (--R);
    } while (--A);
  };
  return Qm.Emboss = s, e.Factory.addGetterSetter(t.Node, "embossStrength", 0.5, (0, i.getNumberValidator)(), e.Factory.afterSetFilter), e.Factory.addGetterSetter(t.Node, "embossWhiteLevel", 0.5, (0, i.getNumberValidator)(), e.Factory.afterSetFilter), e.Factory.addGetterSetter(t.Node, "embossDirection", "top-left", void 0, e.Factory.afterSetFilter), e.Factory.addGetterSetter(t.Node, "embossBlend", !1, void 0, e.Factory.afterSetFilter), Qm;
}
var Zm = {}, U4;
function nj() {
  if (U4) return Zm;
  U4 = 1, Object.defineProperty(Zm, "__esModule", { value: !0 }), Zm.Enhance = void 0;
  const e = An(), t = br(), n = Mn();
  function i(o, u, h, f, p) {
    const g = h - u, v = p - f;
    if (g === 0)
      return f + v / 2;
    if (v === 0)
      return f;
    let x = (o - u) / g;
    return x = v * x + f, x;
  }
  const s = function(o) {
    const u = o.data, h = u.length;
    let f = u[0], p = f, g, v = u[1], x = v, b, _ = u[2], T = _, A;
    const O = this.enhance();
    if (O === 0)
      return;
    for (let G = 0; G < h; G += 4)
      g = u[G + 0], g < f ? f = g : g > p && (p = g), b = u[G + 1], b < v ? v = b : b > x && (x = b), A = u[G + 2], A < _ ? _ = A : A > T && (T = A);
    p === f && (p = 255, f = 0), x === v && (x = 255, v = 0), T === _ && (T = 255, _ = 0);
    let M, E, R, N, U, q, j, V, D;
    O > 0 ? (E = p + O * (255 - p), R = f - O * (f - 0), U = x + O * (255 - x), q = v - O * (v - 0), V = T + O * (255 - T), D = _ - O * (_ - 0)) : (M = (p + f) * 0.5, E = p + O * (p - M), R = f + O * (f - M), N = (x + v) * 0.5, U = x + O * (x - N), q = v + O * (v - N), j = (T + _) * 0.5, V = T + O * (T - j), D = _ + O * (_ - j));
    for (let G = 0; G < h; G += 4)
      u[G + 0] = i(u[G + 0], f, p, R, E), u[G + 1] = i(u[G + 1], v, x, q, U), u[G + 2] = i(u[G + 2], _, T, D, V);
  };
  return Zm.Enhance = s, e.Factory.addGetterSetter(t.Node, "enhance", 0, (0, n.getNumberValidator)(), e.Factory.afterSetFilter), Zm;
}
var Jm = {}, j4;
function ij() {
  if (j4) return Jm;
  j4 = 1, Object.defineProperty(Jm, "__esModule", { value: !0 }), Jm.Grayscale = void 0;
  const e = function(t) {
    const n = t.data, i = n.length;
    for (let s = 0; s < i; s += 4) {
      const o = 0.34 * n[s] + 0.5 * n[s + 1] + 0.16 * n[s + 2];
      n[s] = o, n[s + 1] = o, n[s + 2] = o;
    }
  };
  return Jm.Grayscale = e, Jm;
}
var tg = {}, L4;
function rj() {
  if (L4) return tg;
  L4 = 1, Object.defineProperty(tg, "__esModule", { value: !0 }), tg.HSL = void 0;
  const e = An(), t = br(), n = Mn();
  e.Factory.addGetterSetter(t.Node, "hue", 0, (0, n.getNumberValidator)(), e.Factory.afterSetFilter), e.Factory.addGetterSetter(t.Node, "saturation", 0, (0, n.getNumberValidator)(), e.Factory.afterSetFilter), e.Factory.addGetterSetter(t.Node, "luminance", 0, (0, n.getNumberValidator)(), e.Factory.afterSetFilter);
  const i = function(s) {
    const o = s.data, u = o.length, h = 1, f = Math.pow(2, this.saturation()), p = Math.abs(this.hue() + 360) % 360, g = this.luminance() * 127, v = h * f * Math.cos(p * Math.PI / 180), x = h * f * Math.sin(p * Math.PI / 180), b = 0.299 * h + 0.701 * v + 0.167 * x, _ = 0.587 * h - 0.587 * v + 0.33 * x, T = 0.114 * h - 0.114 * v - 0.497 * x, A = 0.299 * h - 0.299 * v - 0.328 * x, O = 0.587 * h + 0.413 * v + 0.035 * x, M = 0.114 * h - 0.114 * v + 0.293 * x, E = 0.299 * h - 0.3 * v + 1.25 * x, R = 0.587 * h - 0.586 * v - 1.05 * x, N = 0.114 * h + 0.886 * v - 0.2 * x;
    let U, q, j, V;
    for (let D = 0; D < u; D += 4)
      U = o[D + 0], q = o[D + 1], j = o[D + 2], V = o[D + 3], o[D + 0] = b * U + _ * q + T * j + g, o[D + 1] = A * U + O * q + M * j + g, o[D + 2] = E * U + R * q + N * j + g, o[D + 3] = V;
  };
  return tg.HSL = i, tg;
}
var eg = {}, V4;
function aj() {
  if (V4) return eg;
  V4 = 1, Object.defineProperty(eg, "__esModule", { value: !0 }), eg.HSV = void 0;
  const e = An(), t = br(), n = Mn(), i = function(s) {
    const o = s.data, u = o.length, h = Math.pow(2, this.value()), f = Math.pow(2, this.saturation()), p = Math.abs(this.hue() + 360) % 360, g = h * f * Math.cos(p * Math.PI / 180), v = h * f * Math.sin(p * Math.PI / 180), x = 0.299 * h + 0.701 * g + 0.167 * v, b = 0.587 * h - 0.587 * g + 0.33 * v, _ = 0.114 * h - 0.114 * g - 0.497 * v, T = 0.299 * h - 0.299 * g - 0.328 * v, A = 0.587 * h + 0.413 * g + 0.035 * v, O = 0.114 * h - 0.114 * g + 0.293 * v, M = 0.299 * h - 0.3 * g + 1.25 * v, E = 0.587 * h - 0.586 * g - 1.05 * v, R = 0.114 * h + 0.886 * g - 0.2 * v;
    let N, U, q, j;
    for (let V = 0; V < u; V += 4)
      N = o[V + 0], U = o[V + 1], q = o[V + 2], j = o[V + 3], o[V + 0] = x * N + b * U + _ * q, o[V + 1] = T * N + A * U + O * q, o[V + 2] = M * N + E * U + R * q, o[V + 3] = j;
  };
  return eg.HSV = i, e.Factory.addGetterSetter(t.Node, "hue", 0, (0, n.getNumberValidator)(), e.Factory.afterSetFilter), e.Factory.addGetterSetter(t.Node, "saturation", 0, (0, n.getNumberValidator)(), e.Factory.afterSetFilter), e.Factory.addGetterSetter(t.Node, "value", 0, (0, n.getNumberValidator)(), e.Factory.afterSetFilter), eg;
}
var ng = {}, I4;
function sj() {
  if (I4) return ng;
  I4 = 1, Object.defineProperty(ng, "__esModule", { value: !0 }), ng.Invert = void 0;
  const e = function(t) {
    const n = t.data, i = n.length;
    for (let s = 0; s < i; s += 4)
      n[s] = 255 - n[s], n[s + 1] = 255 - n[s + 1], n[s + 2] = 255 - n[s + 2];
  };
  return ng.Invert = e, ng;
}
var ig = {}, F4;
function oj() {
  if (F4) return ig;
  F4 = 1, Object.defineProperty(ig, "__esModule", { value: !0 }), ig.Kaleidoscope = void 0;
  const e = An(), t = br(), n = lr(), i = Mn(), s = function(h, f, p) {
    const g = h.data, v = f.data, x = h.width, b = h.height, _ = p.polarCenterX || x / 2, T = p.polarCenterY || b / 2;
    let A = Math.sqrt(_ * _ + T * T), O = x - _, M = b - T;
    const E = Math.sqrt(O * O + M * M);
    A = E > A ? E : A;
    const R = b, N = x, U = 360 / N * Math.PI / 180;
    for (let q = 0; q < N; q += 1) {
      const j = Math.sin(q * U), V = Math.cos(q * U);
      for (let D = 0; D < R; D += 1) {
        O = Math.floor(_ + A * D / R * V), M = Math.floor(T + A * D / R * j);
        let G = (M * x + O) * 4;
        const W = g[G + 0], P = g[G + 1], H = g[G + 2], I = g[G + 3];
        G = (q + D * x) * 4, v[G + 0] = W, v[G + 1] = P, v[G + 2] = H, v[G + 3] = I;
      }
    }
  }, o = function(h, f, p) {
    const g = h.data, v = f.data, x = h.width, b = h.height, _ = p.polarCenterX || x / 2, T = p.polarCenterY || b / 2;
    let A = Math.sqrt(_ * _ + T * T), O = x - _, M = b - T;
    const E = Math.sqrt(O * O + M * M);
    A = E > A ? E : A;
    const R = b, N = x, U = 0;
    let q, j;
    for (O = 0; O < x; O += 1)
      for (M = 0; M < b; M += 1) {
        const V = O - _, D = M - T, G = Math.sqrt(V * V + D * D) * R / A;
        let W = (Math.atan2(D, V) * 180 / Math.PI + 360 + U) % 360;
        W = W * N / 360, q = Math.floor(W), j = Math.floor(G);
        let P = (j * x + q) * 4;
        const H = g[P + 0], I = g[P + 1], K = g[P + 2], Q = g[P + 3];
        P = (M * x + O) * 4, v[P + 0] = H, v[P + 1] = I, v[P + 2] = K, v[P + 3] = Q;
      }
  }, u = function(h) {
    const f = h.width, p = h.height;
    let g, v, x, b, _, T, A, O, M, E, R = Math.round(this.kaleidoscopePower());
    const N = Math.round(this.kaleidoscopeAngle()), U = Math.floor(f * (N % 360) / 360);
    if (R < 1)
      return;
    const q = n.Util.createCanvasElement();
    q.width = f, q.height = p;
    const j = q.getContext("2d").getImageData(0, 0, f, p);
    n.Util.releaseCanvas(q), s(h, j, {
      polarCenterX: f / 2,
      polarCenterY: p / 2
    });
    let V = f / Math.pow(2, R);
    for (; V <= 8; )
      V = V * 2, R -= 1;
    V = Math.ceil(V);
    let D = V, G = 0, W = D, P = 1;
    for (U + V > f && (G = D, W = 0, P = -1), v = 0; v < p; v += 1)
      for (g = G; g !== W; g += P)
        x = Math.round(g + U) % f, M = (f * v + x) * 4, _ = j.data[M + 0], T = j.data[M + 1], A = j.data[M + 2], O = j.data[M + 3], E = (f * v + g) * 4, j.data[E + 0] = _, j.data[E + 1] = T, j.data[E + 2] = A, j.data[E + 3] = O;
    for (v = 0; v < p; v += 1)
      for (D = Math.floor(V), b = 0; b < R; b += 1) {
        for (g = 0; g < D + 1; g += 1)
          M = (f * v + g) * 4, _ = j.data[M + 0], T = j.data[M + 1], A = j.data[M + 2], O = j.data[M + 3], E = (f * v + D * 2 - g - 1) * 4, j.data[E + 0] = _, j.data[E + 1] = T, j.data[E + 2] = A, j.data[E + 3] = O;
        D *= 2;
      }
    o(j, h, {});
  };
  return ig.Kaleidoscope = u, e.Factory.addGetterSetter(t.Node, "kaleidoscopePower", 2, (0, i.getNumberValidator)(), e.Factory.afterSetFilter), e.Factory.addGetterSetter(t.Node, "kaleidoscopeAngle", 0, (0, i.getNumberValidator)(), e.Factory.afterSetFilter), ig;
}
var rg = {}, q4;
function lj() {
  if (q4) return rg;
  q4 = 1, Object.defineProperty(rg, "__esModule", { value: !0 }), rg.Mask = void 0;
  const e = An(), t = br(), n = Mn();
  function i(x, b, _) {
    let T = (_ * x.width + b) * 4;
    const A = [];
    return A.push(x.data[T++], x.data[T++], x.data[T++], x.data[T++]), A;
  }
  function s(x, b) {
    return Math.sqrt(Math.pow(x[0] - b[0], 2) + Math.pow(x[1] - b[1], 2) + Math.pow(x[2] - b[2], 2));
  }
  function o(x) {
    const b = [0, 0, 0];
    for (let _ = 0; _ < x.length; _++)
      b[0] += x[_][0], b[1] += x[_][1], b[2] += x[_][2];
    return b[0] /= x.length, b[1] /= x.length, b[2] /= x.length, b;
  }
  function u(x, b) {
    const _ = i(x, 0, 0), T = i(x, x.width - 1, 0), A = i(x, 0, x.height - 1), O = i(x, x.width - 1, x.height - 1), M = b || 10;
    if (s(_, T) < M && s(T, O) < M && s(O, A) < M && s(A, _) < M) {
      const E = o([T, _, O, A]), R = [];
      for (let N = 0; N < x.width * x.height; N++) {
        const U = s(E, [
          x.data[N * 4],
          x.data[N * 4 + 1],
          x.data[N * 4 + 2]
        ]);
        R[N] = U < M ? 0 : 255;
      }
      return R;
    }
  }
  function h(x, b) {
    for (let _ = 0; _ < x.width * x.height; _++)
      x.data[4 * _ + 3] = b[_];
  }
  function f(x, b, _) {
    const T = [1, 1, 1, 1, 0, 1, 1, 1, 1], A = Math.round(Math.sqrt(T.length)), O = Math.floor(A / 2), M = [];
    for (let E = 0; E < _; E++)
      for (let R = 0; R < b; R++) {
        const N = E * b + R;
        let U = 0;
        for (let q = 0; q < A; q++)
          for (let j = 0; j < A; j++) {
            const V = E + q - O, D = R + j - O;
            if (V >= 0 && V < _ && D >= 0 && D < b) {
              const G = V * b + D, W = T[q * A + j];
              U += x[G] * W;
            }
          }
        M[N] = U === 255 * 8 ? 255 : 0;
      }
    return M;
  }
  function p(x, b, _) {
    const T = [1, 1, 1, 1, 1, 1, 1, 1, 1], A = Math.round(Math.sqrt(T.length)), O = Math.floor(A / 2), M = [];
    for (let E = 0; E < _; E++)
      for (let R = 0; R < b; R++) {
        const N = E * b + R;
        let U = 0;
        for (let q = 0; q < A; q++)
          for (let j = 0; j < A; j++) {
            const V = E + q - O, D = R + j - O;
            if (V >= 0 && V < _ && D >= 0 && D < b) {
              const G = V * b + D, W = T[q * A + j];
              U += x[G] * W;
            }
          }
        M[N] = U >= 255 * 4 ? 255 : 0;
      }
    return M;
  }
  function g(x, b, _) {
    const T = [0.1111111111111111, 0.1111111111111111, 0.1111111111111111, 0.1111111111111111, 0.1111111111111111, 0.1111111111111111, 0.1111111111111111, 0.1111111111111111, 0.1111111111111111], A = Math.round(Math.sqrt(T.length)), O = Math.floor(A / 2), M = [];
    for (let E = 0; E < _; E++)
      for (let R = 0; R < b; R++) {
        const N = E * b + R;
        let U = 0;
        for (let q = 0; q < A; q++)
          for (let j = 0; j < A; j++) {
            const V = E + q - O, D = R + j - O;
            if (V >= 0 && V < _ && D >= 0 && D < b) {
              const G = V * b + D, W = T[q * A + j];
              U += x[G] * W;
            }
          }
        M[N] = U;
      }
    return M;
  }
  const v = function(x) {
    const b = this.threshold();
    let _ = u(x, b);
    return _ && (_ = f(_, x.width, x.height), _ = p(_, x.width, x.height), _ = g(_, x.width, x.height), h(x, _)), x;
  };
  return rg.Mask = v, e.Factory.addGetterSetter(t.Node, "threshold", 0, (0, n.getNumberValidator)(), e.Factory.afterSetFilter), rg;
}
var ag = {}, G4;
function cj() {
  if (G4) return ag;
  G4 = 1, Object.defineProperty(ag, "__esModule", { value: !0 }), ag.Noise = void 0;
  const e = An(), t = br(), n = Mn(), i = function(s) {
    const o = this.noise() * 255, u = s.data, h = u.length, f = o / 2;
    for (let p = 0; p < h; p += 4)
      u[p + 0] += f - 2 * f * Math.random(), u[p + 1] += f - 2 * f * Math.random(), u[p + 2] += f - 2 * f * Math.random();
  };
  return ag.Noise = i, e.Factory.addGetterSetter(t.Node, "noise", 0.2, (0, n.getNumberValidator)(), e.Factory.afterSetFilter), ag;
}
var sg = {}, H4;
function uj() {
  if (H4) return sg;
  H4 = 1, Object.defineProperty(sg, "__esModule", { value: !0 }), sg.Pixelate = void 0;
  const e = An(), t = lr(), n = br(), i = Mn(), s = function(o) {
    let u = Math.ceil(this.pixelSize()), h = o.width, f = o.height, p, g, v, x, b, _, T, A = Math.ceil(h / u), O = Math.ceil(f / u), M, E, R, N, U, q, j, V = o.data;
    if (u <= 0) {
      t.Util.error("pixelSize value can not be <= 0");
      return;
    }
    for (U = 0; U < A; U += 1)
      for (q = 0; q < O; q += 1) {
        for (x = 0, b = 0, _ = 0, T = 0, M = U * u, E = M + u, R = q * u, N = R + u, j = 0, p = M; p < E; p += 1)
          if (!(p >= h))
            for (g = R; g < N; g += 1)
              g >= f || (v = (h * g + p) * 4, x += V[v + 0], b += V[v + 1], _ += V[v + 2], T += V[v + 3], j += 1);
        for (x = x / j, b = b / j, _ = _ / j, T = T / j, p = M; p < E; p += 1)
          if (!(p >= h))
            for (g = R; g < N; g += 1)
              g >= f || (v = (h * g + p) * 4, V[v + 0] = x, V[v + 1] = b, V[v + 2] = _, V[v + 3] = T);
      }
  };
  return sg.Pixelate = s, e.Factory.addGetterSetter(n.Node, "pixelSize", 8, (0, i.getNumberValidator)(), e.Factory.afterSetFilter), sg;
}
var og = {}, K4;
function dj() {
  if (K4) return og;
  K4 = 1, Object.defineProperty(og, "__esModule", { value: !0 }), og.Posterize = void 0;
  const e = An(), t = br(), n = Mn(), i = function(s) {
    const o = Math.round(this.levels() * 254) + 1, u = s.data, h = u.length, f = 255 / o;
    for (let p = 0; p < h; p += 1)
      u[p] = Math.floor(u[p] / f) * f;
  };
  return og.Posterize = i, e.Factory.addGetterSetter(t.Node, "levels", 0.5, (0, n.getNumberValidator)(), e.Factory.afterSetFilter), og;
}
var lg = {}, Y4;
function hj() {
  if (Y4) return lg;
  Y4 = 1, Object.defineProperty(lg, "__esModule", { value: !0 }), lg.RGB = void 0;
  const e = An(), t = br(), n = Mn(), i = function(s) {
    const o = s.data, u = o.length, h = this.red(), f = this.green(), p = this.blue();
    for (let g = 0; g < u; g += 4) {
      const v = (0.34 * o[g] + 0.5 * o[g + 1] + 0.16 * o[g + 2]) / 255;
      o[g] = v * h, o[g + 1] = v * f, o[g + 2] = v * p, o[g + 3] = o[g + 3];
    }
  };
  return lg.RGB = i, e.Factory.addGetterSetter(t.Node, "red", 0, function(s) {
    return this._filterUpToDate = !1, s > 255 ? 255 : s < 0 ? 0 : Math.round(s);
  }), e.Factory.addGetterSetter(t.Node, "green", 0, function(s) {
    return this._filterUpToDate = !1, s > 255 ? 255 : s < 0 ? 0 : Math.round(s);
  }), e.Factory.addGetterSetter(t.Node, "blue", 0, n.RGBComponent, e.Factory.afterSetFilter), lg;
}
var cg = {}, X4;
function fj() {
  if (X4) return cg;
  X4 = 1, Object.defineProperty(cg, "__esModule", { value: !0 }), cg.RGBA = void 0;
  const e = An(), t = br(), n = Mn(), i = function(s) {
    const o = s.data, u = o.length, h = this.red(), f = this.green(), p = this.blue(), g = this.alpha();
    for (let v = 0; v < u; v += 4) {
      const x = 1 - g;
      o[v] = h * g + o[v] * x, o[v + 1] = f * g + o[v + 1] * x, o[v + 2] = p * g + o[v + 2] * x;
    }
  };
  return cg.RGBA = i, e.Factory.addGetterSetter(t.Node, "red", 0, function(s) {
    return this._filterUpToDate = !1, s > 255 ? 255 : s < 0 ? 0 : Math.round(s);
  }), e.Factory.addGetterSetter(t.Node, "green", 0, function(s) {
    return this._filterUpToDate = !1, s > 255 ? 255 : s < 0 ? 0 : Math.round(s);
  }), e.Factory.addGetterSetter(t.Node, "blue", 0, n.RGBComponent, e.Factory.afterSetFilter), e.Factory.addGetterSetter(t.Node, "alpha", 1, function(s) {
    return this._filterUpToDate = !1, s > 1 ? 1 : s < 0 ? 0 : s;
  }), cg;
}
var ug = {}, W4;
function pj() {
  if (W4) return ug;
  W4 = 1, Object.defineProperty(ug, "__esModule", { value: !0 }), ug.Sepia = void 0;
  const e = function(t) {
    const n = t.data, i = n.length;
    for (let s = 0; s < i; s += 4) {
      const o = n[s + 0], u = n[s + 1], h = n[s + 2];
      n[s + 0] = Math.min(255, o * 0.393 + u * 0.769 + h * 0.189), n[s + 1] = Math.min(255, o * 0.349 + u * 0.686 + h * 0.168), n[s + 2] = Math.min(255, o * 0.272 + u * 0.534 + h * 0.131);
    }
  };
  return ug.Sepia = e, ug;
}
var dg = {}, $4;
function mj() {
  if ($4) return dg;
  $4 = 1, Object.defineProperty(dg, "__esModule", { value: !0 }), dg.Solarize = void 0;
  const e = function(t) {
    const n = t.data, i = t.width, s = t.height, o = i * 4;
    let u = s;
    do {
      const h = (u - 1) * o;
      let f = i;
      do {
        const p = h + (f - 1) * 4;
        let g = n[p], v = n[p + 1], x = n[p + 2];
        g > 127 && (g = 255 - g), v > 127 && (v = 255 - v), x > 127 && (x = 255 - x), n[p] = g, n[p + 1] = v, n[p + 2] = x;
      } while (--f);
    } while (--u);
  };
  return dg.Solarize = e, dg;
}
var hg = {}, Q4;
function gj() {
  if (Q4) return hg;
  Q4 = 1, Object.defineProperty(hg, "__esModule", { value: !0 }), hg.Threshold = void 0;
  const e = An(), t = br(), n = Mn(), i = function(s) {
    const o = this.threshold() * 255, u = s.data, h = u.length;
    for (let f = 0; f < h; f += 1)
      u[f] = u[f] < o ? 0 : 255;
  };
  return hg.Threshold = i, e.Factory.addGetterSetter(t.Node, "threshold", 0.5, (0, n.getNumberValidator)(), e.Factory.afterSetFilter), hg;
}
var Z4;
function yj() {
  if (Z4) return Em;
  Z4 = 1, Object.defineProperty(Em, "__esModule", { value: !0 }), Em.Konva = void 0;
  const e = v2(), t = jU(), n = VU(), i = IU(), s = FU(), o = qU(), u = GU(), h = W6(), f = K_(), p = Q6(), g = HU(), v = KU(), x = YU(), b = XU(), _ = Z6(), T = WU(), A = $U(), O = QU(), M = ZU(), E = JU(), R = tj(), N = ej(), U = nj(), q = ij(), j = rj(), V = aj(), D = sj(), G = oj(), W = lj(), P = cj(), H = uj(), I = dj(), K = hj(), Q = fj(), it = pj(), nt = mj(), X = gj();
  return Em.Konva = e.Konva.Util._assign(e.Konva, {
    Arc: t.Arc,
    Arrow: n.Arrow,
    Circle: i.Circle,
    Ellipse: s.Ellipse,
    Image: o.Image,
    Label: u.Label,
    Tag: u.Tag,
    Line: h.Line,
    Path: f.Path,
    Rect: p.Rect,
    RegularPolygon: g.RegularPolygon,
    Ring: v.Ring,
    Sprite: x.Sprite,
    Star: b.Star,
    Text: _.Text,
    TextPath: T.TextPath,
    Transformer: A.Transformer,
    Wedge: O.Wedge,
    Filters: {
      Blur: M.Blur,
      Brighten: E.Brighten,
      Contrast: R.Contrast,
      Emboss: N.Emboss,
      Enhance: U.Enhance,
      Grayscale: q.Grayscale,
      HSL: j.HSL,
      HSV: V.HSV,
      Invert: D.Invert,
      Kaleidoscope: G.Kaleidoscope,
      Mask: W.Mask,
      Noise: P.Noise,
      Pixelate: H.Pixelate,
      Posterize: I.Posterize,
      RGB: K.RGB,
      RGBA: Q.RGBA,
      Sepia: it.Sepia,
      Solarize: nt.Solarize,
      Threshold: X.Threshold
    }
  }), Em;
}
var vj = Xy.exports, J4;
function bj() {
  if (J4) return Xy.exports;
  J4 = 1, Object.defineProperty(vj, "__esModule", { value: !0 });
  const e = yj();
  return Xy.exports = e.Konva, Xy.exports;
}
bj();
var Uy = { exports: {} }, t3;
function _j() {
  return t3 || (t3 = 1, function(e, t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.Konva = void 0;
    var n = v2();
    Object.defineProperty(t, "Konva", { enumerable: !0, get: function() {
      return n.Konva;
    } });
    const i = v2();
    e.exports = i.Konva;
  }(Uy, Uy.exports)), Uy.exports;
}
var Sj = _j();
const T1 = /* @__PURE__ */ lp(Sj);
var Nb = { exports: {} }, kb = { exports: {} };
/**
 * @license React
 * react-reconciler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var e3;
function xj() {
  return e3 || (e3 = 1, function(e) {
    e.exports = function(t) {
      function n(l, c, y, w) {
        return new u0(l, c, y, w);
      }
      function i() {
      }
      function s(l) {
        var c = "https://react.dev/errors/" + l;
        if (1 < arguments.length) {
          c += "?args[]=" + encodeURIComponent(arguments[1]);
          for (var y = 2; y < arguments.length; y++)
            c += "&args[]=" + encodeURIComponent(arguments[y]);
        }
        return "Minified React error #" + l + "; visit " + c + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      function o(l) {
        return l === null || typeof l != "object" ? null : (l = qn && l[qn] || l["@@iterator"], typeof l == "function" ? l : null);
      }
      function u(l) {
        if (l == null) return null;
        if (typeof l == "function")
          return l.$$typeof === Qi ? null : l.displayName || l.name || null;
        if (typeof l == "string") return l;
        switch (l) {
          case Wl:
            return "Fragment";
          case go:
            return "Portal";
          case $l:
            return "Profiler";
          case lu:
            return "StrictMode";
          case nl:
            return "Suspense";
          case rh:
            return "SuspenseList";
        }
        if (typeof l == "object")
          switch (l.$$typeof) {
            case Ql:
              return (l.displayName || "Context") + ".Provider";
            case Cp:
              return (l._context.displayName || "Context") + ".Consumer";
            case Zh:
              var c = l.render;
              return l = l.displayName, l || (l = c.displayName || c.name || "", l = l !== "" ? "ForwardRef(" + l + ")" : "ForwardRef"), l;
            case id:
              return c = l.displayName || null, c !== null ? c : u(l.type) || "Memo";
            case il:
              c = l._payload, l = l._init;
              try {
                return u(l(c));
              } catch {
              }
          }
        return null;
      }
      function h(l) {
        if (Zl === void 0)
          try {
            throw Error();
          } catch (y) {
            var c = y.stack.trim().match(/\n( *(at )?)/);
            Zl = c && c[1] || "", Jl = -1 < y.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < y.stack.indexOf("@") ? "@unknown:0:0" : "";
          }
        return `
` + Zl + l + Jl;
      }
      function f(l, c) {
        if (!l || rd) return "";
        rd = !0;
        var y = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
          var w = {
            DetermineComponentFrameRoot: function() {
              try {
                if (c) {
                  var Oe = function() {
                    throw Error();
                  };
                  if (Object.defineProperty(Oe.prototype, "props", {
                    set: function() {
                      throw Error();
                    }
                  }), typeof Reflect == "object" && Reflect.construct) {
                    try {
                      Reflect.construct(Oe, []);
                    } catch (en) {
                      var ge = en;
                    }
                    Reflect.construct(l, [], Oe);
                  } else {
                    try {
                      Oe.call();
                    } catch (en) {
                      ge = en;
                    }
                    l.call(Oe.prototype);
                  }
                } else {
                  try {
                    throw Error();
                  } catch (en) {
                    ge = en;
                  }
                  (Oe = l()) && typeof Oe.catch == "function" && Oe.catch(function() {
                  });
                }
              } catch (en) {
                if (en && ge && typeof en.stack == "string")
                  return [en.stack, ge.stack];
              }
              return [null, null];
            }
          };
          w.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
          var z = Object.getOwnPropertyDescriptor(
            w.DetermineComponentFrameRoot,
            "name"
          );
          z && z.configurable && Object.defineProperty(
            w.DetermineComponentFrameRoot,
            "name",
            { value: "DetermineComponentFrameRoot" }
          );
          var F = w.DetermineComponentFrameRoot(), st = F[0], yt = F[1];
          if (st && yt) {
            var Pt = st.split(`
`), Qt = yt.split(`
`);
            for (z = w = 0; w < Pt.length && !Pt[w].includes("DetermineComponentFrameRoot"); )
              w++;
            for (; z < Qt.length && !Qt[z].includes(
              "DetermineComponentFrameRoot"
            ); )
              z++;
            if (w === Pt.length || z === Qt.length)
              for (w = Pt.length - 1, z = Qt.length - 1; 1 <= w && 0 <= z && Pt[w] !== Qt[z]; )
                z--;
            for (; 1 <= w && 0 <= z; w--, z--)
              if (Pt[w] !== Qt[z]) {
                if (w !== 1 || z !== 1)
                  do
                    if (w--, z--, 0 > z || Pt[w] !== Qt[z]) {
                      var ye = `
` + Pt[w].replace(" at new ", " at ");
                      return l.displayName && ye.includes("<anonymous>") && (ye = ye.replace("<anonymous>", l.displayName)), ye;
                    }
                  while (1 <= w && 0 <= z);
                break;
              }
          }
        } finally {
          rd = !1, Error.prepareStackTrace = y;
        }
        return (y = l ? l.displayName || l.name : "") ? h(y) : "";
      }
      function p(l) {
        switch (l.tag) {
          case 26:
          case 27:
          case 5:
            return h(l.type);
          case 16:
            return h("Lazy");
          case 13:
            return h("Suspense");
          case 19:
            return h("SuspenseList");
          case 0:
          case 15:
            return l = f(l.type, !1), l;
          case 11:
            return l = f(l.type.render, !1), l;
          case 1:
            return l = f(l.type, !0), l;
          default:
            return "";
        }
      }
      function g(l) {
        try {
          var c = "";
          do
            c += p(l), l = l.return;
          while (l);
          return c;
        } catch (y) {
          return `
Error generating stack: ` + y.message + `
` + y.stack;
        }
      }
      function v(l) {
        var c = l, y = l;
        if (l.alternate) for (; c.return; ) c = c.return;
        else {
          l = c;
          do
            c = l, (c.flags & 4098) !== 0 && (y = c.return), l = c.return;
          while (l);
        }
        return c.tag === 3 ? y : null;
      }
      function x(l) {
        if (v(l) !== l)
          throw Error(s(188));
      }
      function b(l) {
        var c = l.alternate;
        if (!c) {
          if (c = v(l), c === null) throw Error(s(188));
          return c !== l ? null : l;
        }
        for (var y = l, w = c; ; ) {
          var z = y.return;
          if (z === null) break;
          var F = z.alternate;
          if (F === null) {
            if (w = z.return, w !== null) {
              y = w;
              continue;
            }
            break;
          }
          if (z.child === F.child) {
            for (F = z.child; F; ) {
              if (F === y) return x(z), l;
              if (F === w) return x(z), c;
              F = F.sibling;
            }
            throw Error(s(188));
          }
          if (y.return !== w.return) y = z, w = F;
          else {
            for (var st = !1, yt = z.child; yt; ) {
              if (yt === y) {
                st = !0, y = z, w = F;
                break;
              }
              if (yt === w) {
                st = !0, w = z, y = F;
                break;
              }
              yt = yt.sibling;
            }
            if (!st) {
              for (yt = F.child; yt; ) {
                if (yt === y) {
                  st = !0, y = F, w = z;
                  break;
                }
                if (yt === w) {
                  st = !0, w = F, y = z;
                  break;
                }
                yt = yt.sibling;
              }
              if (!st) throw Error(s(189));
            }
          }
          if (y.alternate !== w) throw Error(s(190));
        }
        if (y.tag !== 3) throw Error(s(188));
        return y.stateNode.current === y ? l : c;
      }
      function _(l) {
        var c = l.tag;
        if (c === 5 || c === 26 || c === 27 || c === 6) return l;
        for (l = l.child; l !== null; ) {
          if (c = _(l), c !== null) return c;
          l = l.sibling;
        }
        return null;
      }
      function T(l) {
        var c = l.tag;
        if (c === 5 || c === 26 || c === 27 || c === 6) return l;
        for (l = l.child; l !== null; ) {
          if (l.tag !== 4 && (c = T(l), c !== null))
            return c;
          l = l.sibling;
        }
        return null;
      }
      function A(l) {
        return { current: l };
      }
      function O(l) {
        0 > ic || (l.current = hf[ic], hf[ic] = null, ic--);
      }
      function M(l, c) {
        ic++, hf[ic] = l.current, l.current = c;
      }
      function E(l) {
        return l >>>= 0, l === 0 ? 32 : 31 - (Xp(l) / Tv | 0) | 0;
      }
      function R(l) {
        var c = l & 42;
        if (c !== 0) return c;
        switch (l & -l) {
          case 1:
            return 1;
          case 2:
            return 2;
          case 4:
            return 4;
          case 8:
            return 8;
          case 16:
            return 16;
          case 32:
            return 32;
          case 64:
            return 64;
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return l & 4194176;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            return l & 62914560;
          case 67108864:
            return 67108864;
          case 134217728:
            return 134217728;
          case 268435456:
            return 268435456;
          case 536870912:
            return 536870912;
          case 1073741824:
            return 0;
          default:
            return l;
        }
      }
      function N(l, c) {
        var y = l.pendingLanes;
        if (y === 0) return 0;
        var w = 0, z = l.suspendedLanes, F = l.pingedLanes, st = l.warmLanes;
        l = l.finishedLanes !== 0;
        var yt = y & 134217727;
        return yt !== 0 ? (y = yt & ~z, y !== 0 ? w = R(y) : (F &= yt, F !== 0 ? w = R(F) : l || (st = yt & ~st, st !== 0 && (w = R(st))))) : (yt = y & ~z, yt !== 0 ? w = R(yt) : F !== 0 ? w = R(F) : l || (st = y & ~st, st !== 0 && (w = R(st)))), w === 0 ? 0 : c !== 0 && c !== w && (c & z) === 0 && (z = w & -w, st = c & -c, z >= st || z === 32 && (st & 4194176) !== 0) ? c : w;
      }
      function U(l, c) {
        return (l.pendingLanes & ~(l.suspendedLanes & ~l.pingedLanes) & c) === 0;
      }
      function q(l, c) {
        switch (l) {
          case 1:
          case 2:
          case 4:
          case 8:
            return c + 250;
          case 16:
          case 32:
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return c + 5e3;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            return -1;
          case 67108864:
          case 134217728:
          case 268435456:
          case 536870912:
          case 1073741824:
            return -1;
          default:
            return -1;
        }
      }
      function j() {
        var l = lh;
        return lh <<= 1, (lh & 4194176) === 0 && (lh = 128), l;
      }
      function V() {
        var l = cd;
        return cd <<= 1, (cd & 62914560) === 0 && (cd = 4194304), l;
      }
      function D(l) {
        for (var c = [], y = 0; 31 > y; y++) c.push(l);
        return c;
      }
      function G(l, c) {
        l.pendingLanes |= c, c !== 268435456 && (l.suspendedLanes = 0, l.pingedLanes = 0, l.warmLanes = 0);
      }
      function W(l, c, y, w, z, F) {
        var st = l.pendingLanes;
        l.pendingLanes = y, l.suspendedLanes = 0, l.pingedLanes = 0, l.warmLanes = 0, l.expiredLanes &= y, l.entangledLanes &= y, l.errorRecoveryDisabledLanes &= y, l.shellSuspendCounter = 0;
        var yt = l.entanglements, Pt = l.expirationTimes, Qt = l.hiddenUpdates;
        for (y = st & ~y; 0 < y; ) {
          var ye = 31 - Ii(y), Oe = 1 << ye;
          yt[ye] = 0, Pt[ye] = -1;
          var ge = Qt[ye];
          if (ge !== null)
            for (Qt[ye] = null, ye = 0; ye < ge.length; ye++) {
              var en = ge[ye];
              en !== null && (en.lane &= -536870913);
            }
          y &= ~Oe;
        }
        w !== 0 && P(l, w, 0), F !== 0 && z === 0 && l.tag !== 0 && (l.suspendedLanes |= F & ~(st & ~c));
      }
      function P(l, c, y) {
        l.pendingLanes |= c, l.suspendedLanes &= ~c;
        var w = 31 - Ii(c);
        l.entangledLanes |= c, l.entanglements[w] = l.entanglements[w] | 1073741824 | y & 4194218;
      }
      function H(l, c) {
        var y = l.entangledLanes |= c;
        for (l = l.entanglements; y; ) {
          var w = 31 - Ii(y), z = 1 << w;
          z & c | l[w] & c && (l[w] |= c), y &= ~z;
        }
      }
      function I(l) {
        return l &= -l, 2 < l ? 8 < l ? (l & 134217727) !== 0 ? 32 : 268435456 : 8 : 2;
      }
      function K(l) {
        if (Zi && typeof Zi.onCommitFiberRoot == "function")
          try {
            Zi.onCommitFiberRoot(
              dd,
              l,
              void 0,
              (l.current.flags & 128) === 128
            );
          } catch {
          }
      }
      function Q(l) {
        if (typeof Hr == "function" && pf(l), Zi && typeof Zi.setStrictMode == "function")
          try {
            Zi.setStrictMode(dd, l);
          } catch {
          }
      }
      function it(l, c) {
        return l === c && (l !== 0 || 1 / l === 1 / c) || l !== l && c !== c;
      }
      function nt(l, c) {
        if (typeof l == "object" && l !== null) {
          var y = mf.get(l);
          return y !== void 0 ? y : (c = {
            value: l,
            source: c,
            stack: g(c)
          }, mf.set(l, c), c);
        }
        return {
          value: l,
          source: c,
          stack: g(c)
        };
      }
      function X(l, c) {
        Ha[Ka++] = hd, Ha[Ka++] = ac, ac = l, hd = c;
      }
      function rt(l, c, y) {
        Ea[Kr++] = _o, Ea[Kr++] = So, Ea[Kr++] = Ls, Ls = l;
        var w = _o;
        l = So;
        var z = 32 - Ii(w) - 1;
        w &= ~(1 << z), y += 1;
        var F = 32 - Ii(c) + z;
        if (30 < F) {
          var st = z - z % 5;
          F = (w & (1 << st) - 1).toString(32), w >>= st, z -= st, _o = 1 << 32 - Ii(c) + z | y << z | w, So = F + l;
        } else
          _o = 1 << F | y << z | w, So = l;
      }
      function vt(l) {
        l.return !== null && (X(l, 1), rt(l, 1, 0));
      }
      function ct(l) {
        for (; l === ac; )
          ac = Ha[--Ka], Ha[Ka] = null, hd = Ha[--Ka], Ha[Ka] = null;
        for (; l === Ls; )
          Ls = Ea[--Kr], Ea[Kr] = null, So = Ea[--Kr], Ea[Kr] = null, _o = Ea[--Kr], Ea[Kr] = null;
      }
      function dt(l, c) {
        M(ll, c), M(ls, l), M(Fi, null), l = wp(c), O(Fi), M(Fi, l);
      }
      function ht() {
        O(Fi), O(ls), O(ll);
      }
      function Et(l) {
        l.memoizedState !== null && M(uh, l);
        var c = Fi.current, y = d0(c, l.type);
        c !== y && (M(ls, l), M(Fi, y));
      }
      function ot(l) {
        ls.current === l && (O(Fi), O(ls)), uh.current === l && (O(uh), Ps ? al._currentValue = uu : al._currentValue2 = uu);
      }
      function lt(l) {
        var c = Error(s(418, ""));
        throw ie(nt(c, l)), dh;
      }
      function ft(l, c) {
        if (!wa) throw Error(s(175));
        fu(
          l.stateNode,
          l.type,
          l.memoizedProps,
          c,
          l
        ) || lt(l);
      }
      function Tt(l) {
        for (qi = l.return; qi; )
          switch (qi.tag) {
            case 3:
            case 27:
              Vs = !0;
              return;
            case 5:
            case 13:
              Vs = !1;
              return;
            default:
              qi = qi.return;
          }
      }
      function Bt(l) {
        if (!wa || l !== qi) return !1;
        if (!Nn) return Tt(l), Nn = !0, !1;
        var c = !1;
        if (Er ? l.tag !== 3 && l.tag !== 27 && (l.tag !== 5 || jp(l.type) && !Pr(l.type, l.memoizedProps)) && (c = !0) : l.tag !== 3 && (l.tag !== 5 || jp(l.type) && !Pr(l.type, l.memoizedProps)) && (c = !0), c && Xn && lt(l), Tt(l), l.tag === 13) {
          if (!wa) throw Error(s(316));
          if (l = l.memoizedState, l = l !== null ? l.dehydrated : null, !l) throw Error(s(317));
          Xn = q0(l);
        } else
          Xn = qi ? nc(l.stateNode) : null;
        return !0;
      }
      function Ot() {
        wa && (Xn = qi = null, Nn = !1);
      }
      function ie(l) {
        cs === null ? cs = [l] : cs.push(l);
      }
      function ce() {
        for (var l = cl, c = Is = cl = 0; c < l; ) {
          var y = Aa[c];
          Aa[c++] = null;
          var w = Aa[c];
          Aa[c++] = null;
          var z = Aa[c];
          Aa[c++] = null;
          var F = Aa[c];
          if (Aa[c++] = null, w !== null && z !== null) {
            var st = w.pending;
            st === null ? z.next = z : (z.next = st.next, st.next = z), w.pending = z;
          }
          F !== 0 && ue(y, z, F);
        }
      }
      function Ut(l, c, y, w) {
        Aa[cl++] = l, Aa[cl++] = c, Aa[cl++] = y, Aa[cl++] = w, Is |= w, l.lanes |= w, l = l.alternate, l !== null && (l.lanes |= w);
      }
      function se(l, c, y, w) {
        return Ut(l, c, y, w), Ae(l);
      }
      function re(l, c) {
        return Ut(l, null, null, c), Ae(l);
      }
      function ue(l, c, y) {
        l.lanes |= y;
        var w = l.alternate;
        w !== null && (w.lanes |= y);
        for (var z = !1, F = l.return; F !== null; )
          F.childLanes |= y, w = F.alternate, w !== null && (w.childLanes |= y), F.tag === 22 && (l = F.stateNode, l === null || l._visibility & 1 || (z = !0)), l = F, F = F.return;
        z && c !== null && l.tag === 3 && (F = l.stateNode, z = 31 - Ii(y), F = F.hiddenUpdates, l = F[z], l === null ? F[z] = [c] : l.push(c), c.lane = y | 536870912);
      }
      function Ae(l) {
        if (50 < Su)
          throw Su = 0, Jp = null, Error(s(185));
        for (var c = l.return; c !== null; )
          l = c, c = l.return;
        return l.tag === 3 ? l.stateNode : null;
      }
      function ve(l) {
        l !== sc && l.next === null && (sc === null ? di = sc = l : sc = sc.next = l), Gi = !0, gf || (gf = !0, te(oe));
      }
      function Re(l, c) {
        if (!yf && Gi) {
          yf = !0;
          do
            for (var y = !1, w = di; w !== null; ) {
              if (l !== 0) {
                var z = w.pendingLanes;
                if (z === 0) var F = 0;
                else {
                  var st = w.suspendedLanes, yt = w.pingedLanes;
                  F = (1 << 31 - Ii(42 | l) + 1) - 1, F &= z & ~(st & ~yt), F = F & 201326677 ? F & 201326677 | 1 : F ? F | 2 : 0;
                }
                F !== 0 && (y = !0, Kt(w, F));
              } else
                F = vn, F = N(
                  w,
                  w === $n ? F : 0
                ), (F & 3) === 0 || U(w, F) || (y = !0, Kt(w, F));
              w = w.next;
            }
          while (y);
          yf = !1;
        }
      }
      function oe() {
        Gi = gf = !1;
        var l = 0;
        fd !== 0 && (m0() && (l = fd), fd = 0);
        for (var c = Ga(), y = null, w = di; w !== null; ) {
          var z = w.next, F = Le(w, c);
          F === 0 ? (w.next = null, y === null ? di = z : y.next = z, z === null && (sc = y)) : (y = w, (l !== 0 || (F & 3) !== 0) && (Gi = !0)), w = z;
        }
        Re(l);
      }
      function Le(l, c) {
        for (var y = l.suspendedLanes, w = l.pingedLanes, z = l.expirationTimes, F = l.pendingLanes & -62914561; 0 < F; ) {
          var st = 31 - Ii(F), yt = 1 << st, Pt = z[st];
          Pt === -1 ? ((yt & y) === 0 || (yt & w) !== 0) && (z[st] = q(yt, c)) : Pt <= c && (l.expiredLanes |= yt), F &= ~yt;
        }
        if (c = $n, y = vn, y = N(
          l,
          l === c ? y : 0
        ), w = l.callbackNode, y === 0 || l === c && Gn === 2 || l.cancelPendingCommit !== null)
          return w !== null && w !== null && js(w), l.callbackNode = null, l.callbackPriority = 0;
        if ((y & 3) === 0 || U(l, y)) {
          if (c = y & -y, c === l.callbackPriority) return c;
          switch (w !== null && js(w), I(y)) {
            case 2:
            case 8:
              y = ch;
              break;
            case 32:
              y = ud;
              break;
            case 268435456:
              y = mu;
              break;
            default:
              y = ud;
          }
          return w = De.bind(null, l), y = bo(y, w), l.callbackPriority = c, l.callbackNode = y, c;
        }
        return w !== null && w !== null && js(w), l.callbackPriority = 2, l.callbackNode = null, 2;
      }
      function De(l, c) {
        var y = l.callbackNode;
        if (Hl() && l.callbackNode !== y)
          return null;
        var w = vn;
        return w = N(
          l,
          l === $n ? w : 0
        ), w === 0 ? null : (Ia(l, w, c), Le(l, Ga()), l.callbackNode != null && l.callbackNode === y ? De.bind(null, l) : null);
      }
      function Kt(l, c) {
        if (Hl()) return null;
        Ia(l, c, !0);
      }
      function te(l) {
        b0 ? _0(function() {
          (yn & 6) !== 0 ? bo(ff, l) : l();
        }) : bo(ff, l);
      }
      function It() {
        return fd === 0 && (fd = j()), fd;
      }
      function Ht(l, c) {
        if (pd === null) {
          var y = pd = [];
          vf = 0, hi = It(), Ar = {
            status: "pending",
            value: void 0,
            then: function(w) {
              y.push(w);
            }
          };
        }
        return vf++, c.then(Jt, Jt), c;
      }
      function Jt() {
        if (--vf === 0 && pd !== null) {
          Ar !== null && (Ar.status = "fulfilled");
          var l = pd;
          pd = null, hi = 0, Ar = null;
          for (var c = 0; c < l.length; c++) (0, l[c])();
        }
      }
      function Yt(l, c) {
        var y = [], w = {
          status: "pending",
          value: null,
          reason: null,
          then: function(z) {
            y.push(z);
          }
        };
        return l.then(
          function() {
            w.status = "fulfilled", w.value = c;
            for (var z = 0; z < y.length; z++) (0, y[z])(c);
          },
          function(z) {
            for (w.status = "rejected", w.reason = z, z = 0; z < y.length; z++)
              (0, y[z])(void 0);
          }
        ), w;
      }
      function ae(l) {
        l.updateQueue = {
          baseState: l.memoizedState,
          firstBaseUpdate: null,
          lastBaseUpdate: null,
          shared: { pending: null, lanes: 0, hiddenCallbacks: null },
          callbacks: null
        };
      }
      function le(l, c) {
        l = l.updateQueue, c.updateQueue === l && (c.updateQueue = {
          baseState: l.baseState,
          firstBaseUpdate: l.firstBaseUpdate,
          lastBaseUpdate: l.lastBaseUpdate,
          shared: l.shared,
          callbacks: null
        });
      }
      function fe(l) {
        return { lane: l, tag: 0, payload: null, callback: null, next: null };
      }
      function Me(l, c, y) {
        var w = l.updateQueue;
        if (w === null) return null;
        if (w = w.shared, (yn & 2) !== 0) {
          var z = w.pending;
          return z === null ? c.next = c : (c.next = z.next, z.next = c), w.pending = c, c = Ae(l), ue(l, null, y), c;
        }
        return Ut(l, w, c, y), Ae(l);
      }
      function Te(l, c, y) {
        if (c = c.updateQueue, c !== null && (c = c.shared, (y & 4194176) !== 0)) {
          var w = c.lanes;
          w &= l.pendingLanes, y |= w, c.lanes = y, H(l, y);
        }
      }
      function ne(l, c) {
        var y = l.updateQueue, w = l.alternate;
        if (w !== null && (w = w.updateQueue, y === w)) {
          var z = null, F = null;
          if (y = y.firstBaseUpdate, y !== null) {
            do {
              var st = {
                lane: y.lane,
                tag: y.tag,
                payload: y.payload,
                callback: null,
                next: null
              };
              F === null ? z = F = st : F = F.next = st, y = y.next;
            } while (y !== null);
            F === null ? z = F = c : F = F.next = c;
          } else z = F = c;
          y = {
            baseState: w.baseState,
            firstBaseUpdate: z,
            lastBaseUpdate: F,
            shared: w.shared,
            callbacks: w.callbacks
          }, l.updateQueue = y;
          return;
        }
        l = y.lastBaseUpdate, l === null ? y.firstBaseUpdate = c : l.next = c, y.lastBaseUpdate = c;
      }
      function Ve() {
        if (bf) {
          var l = Ar;
          if (l !== null) throw l;
        }
      }
      function fn(l, c, y, w) {
        bf = !1;
        var z = l.updateQueue;
        Yr = !1;
        var F = z.firstBaseUpdate, st = z.lastBaseUpdate, yt = z.shared.pending;
        if (yt !== null) {
          z.shared.pending = null;
          var Pt = yt, Qt = Pt.next;
          Pt.next = null, st === null ? F = Qt : st.next = Qt, st = Pt;
          var ye = l.alternate;
          ye !== null && (ye = ye.updateQueue, yt = ye.lastBaseUpdate, yt !== st && (yt === null ? ye.firstBaseUpdate = Qt : yt.next = Qt, ye.lastBaseUpdate = Pt));
        }
        if (F !== null) {
          var Oe = z.baseState;
          st = 0, ye = Qt = Pt = null, yt = F;
          do {
            var ge = yt.lane & -536870913, en = ge !== yt.lane;
            if (en ? (vn & ge) === ge : (w & ge) === ge) {
              ge !== 0 && ge === hi && (bf = !0), ye !== null && (ye = ye.next = {
                lane: 0,
                tag: yt.tag,
                payload: yt.payload,
                callback: null,
                next: null
              });
              t: {
                var ys = l, _d = yt;
                ge = c;
                var xu = y;
                switch (_d.tag) {
                  case 1:
                    if (ys = _d.payload, typeof ys == "function") {
                      Oe = ys.call(
                        xu,
                        Oe,
                        ge
                      );
                      break t;
                    }
                    Oe = ys;
                    break t;
                  case 3:
                    ys.flags = ys.flags & -65537 | 128;
                  case 0:
                    if (ys = _d.payload, ge = typeof ys == "function" ? ys.call(xu, Oe, ge) : ys, ge == null) break t;
                    Oe = Li({}, Oe, ge);
                    break t;
                  case 2:
                    Yr = !0;
                }
              }
              ge = yt.callback, ge !== null && (l.flags |= 64, en && (l.flags |= 8192), en = z.callbacks, en === null ? z.callbacks = [ge] : en.push(ge));
            } else
              en = {
                lane: ge,
                tag: yt.tag,
                payload: yt.payload,
                callback: yt.callback,
                next: null
              }, ye === null ? (Qt = ye = en, Pt = Oe) : ye = ye.next = en, st |= ge;
            if (yt = yt.next, yt === null) {
              if (yt = z.shared.pending, yt === null)
                break;
              en = yt, yt = en.next, en.next = null, z.lastBaseUpdate = en, z.shared.pending = null;
            }
          } while (!0);
          ye === null && (Pt = Oe), z.baseState = Pt, z.firstBaseUpdate = Qt, z.lastBaseUpdate = ye, F === null && (z.shared.lanes = 0), ms |= st, l.lanes = st, l.memoizedState = Oe;
        }
      }
      function _r(l, c) {
        if (typeof l != "function")
          throw Error(s(191, l));
        l.call(c);
      }
      function Ce(l, c) {
        var y = l.callbacks;
        if (y !== null)
          for (l.callbacks = null, l = 0; l < y.length; l++)
            _r(y[l], c);
      }
      function Xi(l, c) {
        if (la(l, c)) return !0;
        if (typeof l != "object" || l === null || typeof c != "object" || c === null)
          return !1;
        var y = Object.keys(l), w = Object.keys(c);
        if (y.length !== w.length) return !1;
        for (w = 0; w < y.length; w++) {
          var z = y[w];
          if (!Q0.call(c, z) || !la(l[z], c[z]))
            return !1;
        }
        return !0;
      }
      function Rn(l) {
        return l = l.status, l === "fulfilled" || l === "rejected";
      }
      function Ze() {
      }
      function Vr(l, c, y) {
        switch (y = l[y], y === void 0 ? l.push(c) : y !== c && (c.then(Ze, Ze), c = y), c.status) {
          case "fulfilled":
            return c.value;
          case "rejected":
            throw l = c.reason, l === hh ? Error(s(483)) : l;
          default:
            if (typeof c.status == "string") c.then(Ze, Ze);
            else {
              if (l = $n, l !== null && 100 < l.shellSuspendCounter)
                throw Error(s(482));
              l = c, l.status = "pending", l.then(
                function(w) {
                  if (c.status === "pending") {
                    var z = c;
                    z.status = "fulfilled", z.value = w;
                  }
                },
                function(w) {
                  if (c.status === "pending") {
                    var z = c;
                    z.status = "rejected", z.reason = w;
                  }
                }
              );
            }
            switch (c.status) {
              case "fulfilled":
                return c.value;
              case "rejected":
                throw l = c.reason, l === hh ? Error(s(483)) : l;
            }
            throw Xr = c, hh;
        }
      }
      function Wi() {
        if (Xr === null) throw Error(s(459));
        var l = Xr;
        return Xr = null, l;
      }
      function Sr(l) {
        var c = Wr;
        return Wr += 1, gu === null && (gu = []), Vr(gu, l, c);
      }
      function Ke(l, c) {
        c = c.props.ref, l.ref = c !== void 0 ? c : null;
      }
      function gi(l, c) {
        throw c.$$typeof === Tp ? Error(s(525)) : (l = Object.prototype.toString.call(c), Error(
          s(
            31,
            l === "[object Object]" ? "object with keys {" + Object.keys(c).join(", ") + "}" : l
          )
        ));
      }
      function va(l) {
        var c = l._init;
        return c(l._payload);
      }
      function to(l) {
        function c(Vt, kt) {
          if (l) {
            var Gt = Vt.deletions;
            Gt === null ? (Vt.deletions = [kt], Vt.flags |= 16) : Gt.push(kt);
          }
        }
        function y(Vt, kt) {
          if (!l) return null;
          for (; kt !== null; )
            c(Vt, kt), kt = kt.sibling;
          return null;
        }
        function w(Vt) {
          for (var kt = /* @__PURE__ */ new Map(); Vt !== null; )
            Vt.key !== null ? kt.set(Vt.key, Vt) : kt.set(Vt.index, Vt), Vt = Vt.sibling;
          return kt;
        }
        function z(Vt, kt) {
          return Vt = Jo(Vt, kt), Vt.index = 0, Vt.sibling = null, Vt;
        }
        function F(Vt, kt, Gt) {
          return Vt.index = Gt, l ? (Gt = Vt.alternate, Gt !== null ? (Gt = Gt.index, Gt < kt ? (Vt.flags |= 33554434, kt) : Gt) : (Vt.flags |= 33554434, kt)) : (Vt.flags |= 1048576, kt);
        }
        function st(Vt) {
          return l && Vt.alternate === null && (Vt.flags |= 33554434), Vt;
        }
        function yt(Vt, kt, Gt, me) {
          return kt === null || kt.tag !== 6 ? (kt = ih(Gt, Vt.mode, me), kt.return = Vt, kt) : (kt = z(kt, Gt), kt.return = Vt, kt);
        }
        function Pt(Vt, kt, Gt, me) {
          var ze = Gt.type;
          return ze === Wl ? ye(
            Vt,
            kt,
            Gt.props.children,
            me,
            Gt.key
          ) : kt !== null && (kt.elementType === ze || typeof ze == "object" && ze !== null && ze.$$typeof === il && va(ze) === kt.type) ? (kt = z(kt, Gt.props), Ke(kt, Gt), kt.return = Vt, kt) : (kt = ou(
            Gt.type,
            Gt.key,
            Gt.props,
            null,
            Vt.mode,
            me
          ), Ke(kt, Gt), kt.return = Vt, kt);
        }
        function Qt(Vt, kt, Gt, me) {
          return kt === null || kt.tag !== 4 || kt.stateNode.containerInfo !== Gt.containerInfo || kt.stateNode.implementation !== Gt.implementation ? (kt = Ca(Gt, Vt.mode, me), kt.return = Vt, kt) : (kt = z(kt, Gt.children || []), kt.return = Vt, kt);
        }
        function ye(Vt, kt, Gt, me, ze) {
          return kt === null || kt.tag !== 7 ? (kt = Yl(
            Gt,
            Vt.mode,
            me,
            ze
          ), kt.return = Vt, kt) : (kt = z(kt, Gt), kt.return = Vt, kt);
        }
        function Oe(Vt, kt, Gt) {
          if (typeof kt == "string" && kt !== "" || typeof kt == "number" || typeof kt == "bigint")
            return kt = ih(
              "" + kt,
              Vt.mode,
              Gt
            ), kt.return = Vt, kt;
          if (typeof kt == "object" && kt !== null) {
            switch (kt.$$typeof) {
              case Xl:
                return Gt = ou(
                  kt.type,
                  kt.key,
                  kt.props,
                  null,
                  Vt.mode,
                  Gt
                ), Ke(Gt, kt), Gt.return = Vt, Gt;
              case go:
                return kt = Ca(
                  kt,
                  Vt.mode,
                  Gt
                ), kt.return = Vt, kt;
              case il:
                var me = kt._init;
                return kt = me(kt._payload), Oe(Vt, kt, Gt);
            }
            if (tc(kt) || o(kt))
              return kt = Yl(
                kt,
                Vt.mode,
                Gt,
                null
              ), kt.return = Vt, kt;
            if (typeof kt.then == "function")
              return Oe(Vt, Sr(kt), Gt);
            if (kt.$$typeof === Ql)
              return Oe(
                Vt,
                Ll(Vt, kt),
                Gt
              );
            gi(Vt, kt);
          }
          return null;
        }
        function ge(Vt, kt, Gt, me) {
          var ze = kt !== null ? kt.key : null;
          if (typeof Gt == "string" && Gt !== "" || typeof Gt == "number" || typeof Gt == "bigint")
            return ze !== null ? null : yt(Vt, kt, "" + Gt, me);
          if (typeof Gt == "object" && Gt !== null) {
            switch (Gt.$$typeof) {
              case Xl:
                return Gt.key === ze ? Pt(Vt, kt, Gt, me) : null;
              case go:
                return Gt.key === ze ? Qt(Vt, kt, Gt, me) : null;
              case il:
                return ze = Gt._init, Gt = ze(Gt._payload), ge(Vt, kt, Gt, me);
            }
            if (tc(Gt) || o(Gt))
              return ze !== null ? null : ye(Vt, kt, Gt, me, null);
            if (typeof Gt.then == "function")
              return ge(
                Vt,
                kt,
                Sr(Gt),
                me
              );
            if (Gt.$$typeof === Ql)
              return ge(
                Vt,
                kt,
                Ll(Vt, Gt),
                me
              );
            gi(Vt, Gt);
          }
          return null;
        }
        function en(Vt, kt, Gt, me, ze) {
          if (typeof me == "string" && me !== "" || typeof me == "number" || typeof me == "bigint")
            return Vt = Vt.get(Gt) || null, yt(kt, Vt, "" + me, ze);
          if (typeof me == "object" && me !== null) {
            switch (me.$$typeof) {
              case Xl:
                return Vt = Vt.get(
                  me.key === null ? Gt : me.key
                ) || null, Pt(kt, Vt, me, ze);
              case go:
                return Vt = Vt.get(
                  me.key === null ? Gt : me.key
                ) || null, Qt(kt, Vt, me, ze);
              case il:
                var Qn = me._init;
                return me = Qn(me._payload), en(
                  Vt,
                  kt,
                  Gt,
                  me,
                  ze
                );
            }
            if (tc(me) || o(me))
              return Vt = Vt.get(Gt) || null, ye(kt, Vt, me, ze, null);
            if (typeof me.then == "function")
              return en(
                Vt,
                kt,
                Gt,
                Sr(me),
                ze
              );
            if (me.$$typeof === Ql)
              return en(
                Vt,
                kt,
                Gt,
                Ll(kt, me),
                ze
              );
            gi(kt, me);
          }
          return null;
        }
        function ys(Vt, kt, Gt, me) {
          for (var ze = null, Qn = null, He = kt, mn = kt = 0, ti = null; He !== null && mn < Gt.length; mn++) {
            He.index > mn ? (ti = He, He = null) : ti = He.sibling;
            var xn = ge(
              Vt,
              He,
              Gt[mn],
              me
            );
            if (xn === null) {
              He === null && (He = ti);
              break;
            }
            l && He && xn.alternate === null && c(Vt, He), kt = F(xn, kt, mn), Qn === null ? ze = xn : Qn.sibling = xn, Qn = xn, He = ti;
          }
          if (mn === Gt.length)
            return y(Vt, He), Nn && X(Vt, mn), ze;
          if (He === null) {
            for (; mn < Gt.length; mn++)
              He = Oe(Vt, Gt[mn], me), He !== null && (kt = F(
                He,
                kt,
                mn
              ), Qn === null ? ze = He : Qn.sibling = He, Qn = He);
            return Nn && X(Vt, mn), ze;
          }
          for (He = w(He); mn < Gt.length; mn++)
            ti = en(
              He,
              Vt,
              mn,
              Gt[mn],
              me
            ), ti !== null && (l && ti.alternate !== null && He.delete(
              ti.key === null ? mn : ti.key
            ), kt = F(
              ti,
              kt,
              mn
            ), Qn === null ? ze = ti : Qn.sibling = ti, Qn = ti);
          return l && He.forEach(function(mc) {
            return c(Vt, mc);
          }), Nn && X(Vt, mn), ze;
        }
        function _d(Vt, kt, Gt, me) {
          if (Gt == null) throw Error(s(151));
          for (var ze = null, Qn = null, He = kt, mn = kt = 0, ti = null, xn = Gt.next(); He !== null && !xn.done; mn++, xn = Gt.next()) {
            He.index > mn ? (ti = He, He = null) : ti = He.sibling;
            var mc = ge(Vt, He, xn.value, me);
            if (mc === null) {
              He === null && (He = ti);
              break;
            }
            l && He && mc.alternate === null && c(Vt, He), kt = F(mc, kt, mn), Qn === null ? ze = mc : Qn.sibling = mc, Qn = mc, He = ti;
          }
          if (xn.done)
            return y(Vt, He), Nn && X(Vt, mn), ze;
          if (He === null) {
            for (; !xn.done; mn++, xn = Gt.next())
              xn = Oe(Vt, xn.value, me), xn !== null && (kt = F(
                xn,
                kt,
                mn
              ), Qn === null ? ze = xn : Qn.sibling = xn, Qn = xn);
            return Nn && X(Vt, mn), ze;
          }
          for (He = w(He); !xn.done; mn++, xn = Gt.next())
            xn = en(
              He,
              Vt,
              mn,
              xn.value,
              me
            ), xn !== null && (l && xn.alternate !== null && He.delete(xn.key === null ? mn : xn.key), kt = F(xn, kt, mn), Qn === null ? ze = xn : Qn.sibling = xn, Qn = xn);
          return l && He.forEach(function(J0) {
            return c(Vt, J0);
          }), Nn && X(Vt, mn), ze;
        }
        function xu(Vt, kt, Gt, me) {
          if (typeof Gt == "object" && Gt !== null && Gt.type === Wl && Gt.key === null && (Gt = Gt.props.children), typeof Gt == "object" && Gt !== null) {
            switch (Gt.$$typeof) {
              case Xl:
                t: {
                  for (var ze = Gt.key; kt !== null; ) {
                    if (kt.key === ze) {
                      if (ze = Gt.type, ze === Wl) {
                        if (kt.tag === 7) {
                          y(
                            Vt,
                            kt.sibling
                          ), me = z(
                            kt,
                            Gt.props.children
                          ), me.return = Vt, Vt = me;
                          break t;
                        }
                      } else if (kt.elementType === ze || typeof ze == "object" && ze !== null && ze.$$typeof === il && va(ze) === kt.type) {
                        y(
                          Vt,
                          kt.sibling
                        ), me = z(kt, Gt.props), Ke(me, Gt), me.return = Vt, Vt = me;
                        break t;
                      }
                      y(Vt, kt);
                      break;
                    } else c(Vt, kt);
                    kt = kt.sibling;
                  }
                  Gt.type === Wl ? (me = Yl(
                    Gt.props.children,
                    Vt.mode,
                    me,
                    Gt.key
                  ), me.return = Vt, Vt = me) : (me = ou(
                    Gt.type,
                    Gt.key,
                    Gt.props,
                    null,
                    Vt.mode,
                    me
                  ), Ke(me, Gt), me.return = Vt, Vt = me);
                }
                return st(Vt);
              case go:
                t: {
                  for (ze = Gt.key; kt !== null; ) {
                    if (kt.key === ze)
                      if (kt.tag === 4 && kt.stateNode.containerInfo === Gt.containerInfo && kt.stateNode.implementation === Gt.implementation) {
                        y(
                          Vt,
                          kt.sibling
                        ), me = z(
                          kt,
                          Gt.children || []
                        ), me.return = Vt, Vt = me;
                        break t;
                      } else {
                        y(Vt, kt);
                        break;
                      }
                    else c(Vt, kt);
                    kt = kt.sibling;
                  }
                  me = Ca(Gt, Vt.mode, me), me.return = Vt, Vt = me;
                }
                return st(Vt);
              case il:
                return ze = Gt._init, Gt = ze(Gt._payload), xu(
                  Vt,
                  kt,
                  Gt,
                  me
                );
            }
            if (tc(Gt))
              return ys(
                Vt,
                kt,
                Gt,
                me
              );
            if (o(Gt)) {
              if (ze = o(Gt), typeof ze != "function")
                throw Error(s(150));
              return Gt = ze.call(Gt), _d(
                Vt,
                kt,
                Gt,
                me
              );
            }
            if (typeof Gt.then == "function")
              return xu(
                Vt,
                kt,
                Sr(Gt),
                me
              );
            if (Gt.$$typeof === Ql)
              return xu(
                Vt,
                kt,
                Ll(Vt, Gt),
                me
              );
            gi(Vt, Gt);
          }
          return typeof Gt == "string" && Gt !== "" || typeof Gt == "number" || typeof Gt == "bigint" ? (Gt = "" + Gt, kt !== null && kt.tag === 6 ? (y(Vt, kt.sibling), me = z(kt, Gt), me.return = Vt, Vt = me) : (y(Vt, kt), me = ih(Gt, Vt.mode, me), me.return = Vt, Vt = me), st(Vt)) : y(Vt, kt);
        }
        return function(Vt, kt, Gt, me) {
          try {
            Wr = 0;
            var ze = xu(
              Vt,
              kt,
              Gt,
              me
            );
            return gu = null, ze;
          } catch (He) {
            if (He === hh) throw He;
            var Qn = n(29, He, null, Vt.mode);
            return Qn.lanes = me, Qn.return = Vt, Qn;
          } finally {
          }
        };
      }
      function zc(l, c) {
        l = Hs, M(qs, l), M(Fs, c), Hs = l | c.baseLanes;
      }
      function Fn() {
        M(qs, Hs), M(Fs, Fs.current);
      }
      function Ci() {
        Hs = qs.current, O(Fs), O(qs);
      }
      function Es(l) {
        var c = l.alternate;
        M(oi, oi.current & 1), M(Ma, l), us === null && (c === null || Fs.current !== null || c.memoizedState !== null) && (us = l);
      }
      function wl(l) {
        if (l.tag === 22) {
          if (M(oi, oi.current), M(Ma, l), us === null) {
            var c = l.alternate;
            c !== null && c.memoizedState !== null && (us = l);
          }
        } else Pa();
      }
      function Pa() {
        M(oi, oi.current), M(Ma, Ma.current);
      }
      function zi(l) {
        O(Ma), us === l && (us = null), O(oi);
      }
      function Pi(l) {
        for (var c = l; c !== null; ) {
          if (c.tag === 13) {
            var y = c.memoizedState;
            if (y !== null && (y = y.dehydrated, y === null || du(y) || oh(y)))
              return c;
          } else if (c.tag === 19 && c.memoizedProps.revealOrder !== void 0) {
            if ((c.flags & 128) !== 0) return c;
          } else if (c.child !== null) {
            c.child.return = c, c = c.child;
            continue;
          }
          if (c === l) break;
          for (; c.sibling === null; ) {
            if (c.return === null || c.return === l) return null;
            c = c.return;
          }
          c.sibling.return = c.return, c = c.sibling;
        }
        return null;
      }
      function rn() {
        throw Error(s(321));
      }
      function ea(l, c) {
        if (c === null) return !1;
        for (var y = 0; y < c.length && y < l.length; y++)
          if (!la(l[y], c[y])) return !1;
        return !0;
      }
      function ba(l, c, y, w, z, F) {
        return ul = F, Je = c, c.memoizedState = null, c.updateQueue = null, c.lanes = 0, Xe.H = l === null || l.memoizedState === null ? fl : ua, lc = !1, F = y(w, z), lc = !1, yu && (F = Gh(
          c,
          y,
          w,
          z
        )), Pc(l), F;
      }
      function Pc(l) {
        Xe.H = Hi;
        var c = Dn !== null && Dn.next !== null;
        if (ul = 0, bi = Dn = Je = null, dl = !1, md = 0, hl = null, c) throw Error(s(300));
        l === null || Ji || (l = l.dependencies, l !== null && Ho(l) && (Ji = !0));
      }
      function Gh(l, c, y, w) {
        Je = l;
        var z = 0;
        do {
          if (yu && (hl = null), md = 0, yu = !1, 25 <= z) throw Error(s(301));
          if (z += 1, bi = Dn = null, l.updateQueue != null) {
            var F = l.updateQueue;
            F.lastEffect = null, F.events = null, F.stores = null, F.memoCache != null && (F.memoCache.index = 0);
          }
          Xe.H = uc, F = c(y, w);
        } while (yu);
        return F;
      }
      function As() {
        var l = Xe.H, c = l.useState()[0];
        return c = typeof c.then == "function" ? xr(c) : c, l = l.useState()[0], (Dn !== null ? Dn.memoizedState : null) !== l && (Je.flags |= 1024), c;
      }
      function eo() {
        var l = cc !== 0;
        return cc = 0, l;
      }
      function Ua(l, c, y) {
        c.updateQueue = l.updateQueue, c.flags &= -2053, l.lanes &= ~y;
      }
      function ts(l) {
        if (dl) {
          for (l = l.memoizedState; l !== null; ) {
            var c = l.queue;
            c !== null && (c.pending = null), l = l.next;
          }
          dl = !1;
        }
        ul = 0, bi = Dn = Je = null, yu = !1, md = cc = 0, hl = null;
      }
      function wi() {
        var l = {
          memoizedState: null,
          baseState: null,
          baseQueue: null,
          queue: null,
          next: null
        };
        return bi === null ? Je.memoizedState = bi = l : bi = bi.next = l, bi;
      }
      function $e() {
        if (Dn === null) {
          var l = Je.alternate;
          l = l !== null ? l.memoizedState : null;
        } else l = Dn.next;
        var c = bi === null ? Je.memoizedState : bi.next;
        if (c !== null)
          bi = c, Dn = l;
        else {
          if (l === null)
            throw Je.alternate === null ? Error(s(467)) : Error(s(310));
          Dn = l, l = {
            memoizedState: Dn.memoizedState,
            baseState: Dn.baseState,
            baseQueue: Dn.baseQueue,
            queue: Dn.queue,
            next: null
          }, bi === null ? Je.memoizedState = bi = l : bi = bi.next = l;
        }
        return bi;
      }
      function xr(l) {
        var c = md;
        return md += 1, hl === null && (hl = []), l = Vr(hl, l, c), c = Je, (bi === null ? c.memoizedState : bi.next) === null && (c = c.alternate, Xe.H = c === null || c.memoizedState === null ? fl : ua), l;
      }
      function Pn(l) {
        if (l !== null && typeof l == "object") {
          if (typeof l.then == "function") return xr(l);
          if (l.$$typeof === Ql) return dr(l);
        }
        throw Error(s(438, String(l)));
      }
      function Uc(l) {
        var c = null, y = Je.updateQueue;
        if (y !== null && (c = y.memoCache), c == null) {
          var w = Je.alternate;
          w !== null && (w = w.updateQueue, w !== null && (w = w.memoCache, w != null && (c = {
            data: w.data.map(function(z) {
              return z.slice();
            }),
            index: 0
          })));
        }
        if (c == null && (c = { data: [], index: 0 }), y === null && (y = Wp(), Je.updateQueue = y), y.memoCache = c, y = c.data[c.index], y === void 0)
          for (y = c.data[c.index] = Array(l), w = 0; w < l; w++)
            y[w] = un;
        return c.index++, y;
      }
      function kr(l, c) {
        return typeof c == "function" ? c(l) : c;
      }
      function na(l) {
        var c = $e();
        return es(c, Dn, l);
      }
      function es(l, c, y) {
        var w = l.queue;
        if (w === null) throw Error(s(311));
        w.lastRenderedReducer = y;
        var z = l.baseQueue, F = w.pending;
        if (F !== null) {
          if (z !== null) {
            var st = z.next;
            z.next = F.next, F.next = st;
          }
          c.baseQueue = z = F, w.pending = null;
        }
        if (F = l.baseState, z === null) l.memoizedState = F;
        else {
          c = z.next;
          var yt = st = null, Pt = null, Qt = c, ye = !1;
          do {
            var Oe = Qt.lane & -536870913;
            if (Oe !== Qt.lane ? (vn & Oe) === Oe : (ul & Oe) === Oe) {
              var ge = Qt.revertLane;
              if (ge === 0)
                Pt !== null && (Pt = Pt.next = {
                  lane: 0,
                  revertLane: 0,
                  action: Qt.action,
                  hasEagerState: Qt.hasEagerState,
                  eagerState: Qt.eagerState,
                  next: null
                }), Oe === hi && (ye = !0);
              else if ((ul & ge) === ge) {
                Qt = Qt.next, ge === hi && (ye = !0);
                continue;
              } else
                Oe = {
                  lane: 0,
                  revertLane: Qt.revertLane,
                  action: Qt.action,
                  hasEagerState: Qt.hasEagerState,
                  eagerState: Qt.eagerState,
                  next: null
                }, Pt === null ? (yt = Pt = Oe, st = F) : Pt = Pt.next = Oe, Je.lanes |= ge, ms |= ge;
              Oe = Qt.action, lc && y(F, Oe), F = Qt.hasEagerState ? Qt.eagerState : y(F, Oe);
            } else
              ge = {
                lane: Oe,
                revertLane: Qt.revertLane,
                action: Qt.action,
                hasEagerState: Qt.hasEagerState,
                eagerState: Qt.eagerState,
                next: null
              }, Pt === null ? (yt = Pt = ge, st = F) : Pt = Pt.next = ge, Je.lanes |= Oe, ms |= Oe;
            Qt = Qt.next;
          } while (Qt !== null && Qt !== c);
          if (Pt === null ? st = F : Pt.next = yt, !la(F, l.memoizedState) && (Ji = !0, ye && (y = Ar, y !== null)))
            throw y;
          l.memoizedState = F, l.baseState = st, l.baseQueue = Pt, w.lastRenderedState = F;
        }
        return z === null && (w.lanes = 0), [l.memoizedState, w.dispatch];
      }
      function ia(l) {
        var c = $e(), y = c.queue;
        if (y === null) throw Error(s(311));
        y.lastRenderedReducer = l;
        var w = y.dispatch, z = y.pending, F = c.memoizedState;
        if (z !== null) {
          y.pending = null;
          var st = z = z.next;
          do
            F = l(F, st.action), st = st.next;
          while (st !== z);
          la(F, c.memoizedState) || (Ji = !0), c.memoizedState = F, c.baseQueue === null && (c.baseState = F), y.lastRenderedState = F;
        }
        return [F, w];
      }
      function no(l, c, y) {
        var w = Je, z = $e(), F = Nn;
        if (F) {
          if (y === void 0)
            throw Error(s(407));
          y = y();
        } else y = c();
        var st = !la(
          (Dn || z).memoizedState,
          y
        );
        if (st && (z.memoizedState = y, Ji = !0), z = z.queue, cr(Gd.bind(null, w, z, l), [
          l
        ]), z.getSnapshot !== c || st || bi !== null && bi.memoizedState.tag & 1) {
          if (w.flags |= 2048, Uo(
            9,
            El.bind(
              null,
              w,
              z,
              y,
              c
            ),
            { destroy: void 0 },
            null
          ), $n === null) throw Error(s(349));
          F || (ul & 60) !== 0 || Fu(w, c, y);
        }
        return y;
      }
      function Fu(l, c, y) {
        l.flags |= 16384, l = { getSnapshot: c, value: y }, c = Je.updateQueue, c === null ? (c = Wp(), Je.updateQueue = c, c.stores = [l]) : (y = c.stores, y === null ? c.stores = [l] : y.push(l));
      }
      function El(l, c, y, w) {
        c.value = y, c.getSnapshot = w, ln(c) && Al(l);
      }
      function Gd(l, c, y) {
        return y(function() {
          ln(c) && Al(l);
        });
      }
      function ln(l) {
        var c = l.getSnapshot;
        l = l.value;
        try {
          var y = c();
          return !la(l, y);
        } catch {
          return !0;
        }
      }
      function Al(l) {
        var c = re(l, 2);
        c !== null && si(c, l, 2);
      }
      function _a(l) {
        var c = wi();
        if (typeof l == "function") {
          var y = l;
          if (l = y(), lc) {
            Q(!0);
            try {
              y();
            } finally {
              Q(!1);
            }
          }
        }
        return c.memoizedState = c.baseState = l, c.queue = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: kr,
          lastRenderedState: l
        }, c;
      }
      function Ir(l, c, y, w) {
        return l.baseState = y, es(
          l,
          Dn,
          typeof w == "function" ? w : kr
        );
      }
      function Yn(l, c, y, w, z) {
        if (Hc(l)) throw Error(s(485));
        if (l = c.action, l !== null) {
          var F = {
            payload: z,
            action: l,
            next: null,
            isTransition: !0,
            status: "pending",
            value: null,
            reason: null,
            listeners: [],
            then: function(st) {
              F.listeners.push(st);
            }
          };
          Xe.T !== null ? y(!0) : F.isTransition = !1, w(F), y = c.pending, y === null ? (F.next = c.pending = F, Ml(c, F)) : (F.next = y.next, c.pending = y.next = F);
        }
      }
      function Ml(l, c) {
        var y = c.action, w = c.payload, z = l.state;
        if (c.isTransition) {
          var F = Xe.T, st = {};
          Xe.T = st;
          try {
            var yt = y(z, w), Pt = Xe.S;
            Pt !== null && Pt(st, yt), Ms(l, c, yt);
          } catch (Qt) {
            ro(l, c, Qt);
          } finally {
            Xe.T = F;
          }
        } else
          try {
            F = y(z, w), Ms(l, c, F);
          } catch (Qt) {
            ro(l, c, Qt);
          }
      }
      function Ms(l, c, y) {
        y !== null && typeof y == "object" && typeof y.then == "function" ? y.then(
          function(w) {
            io(l, c, w);
          },
          function(w) {
            return ro(l, c, w);
          }
        ) : io(l, c, y);
      }
      function io(l, c, y) {
        c.status = "fulfilled", c.value = y, qu(c), l.state = y, c = l.pending, c !== null && (y = c.next, y === c ? l.pending = null : (y = y.next, c.next = y, Ml(l, y)));
      }
      function ro(l, c, y) {
        var w = l.pending;
        if (l.pending = null, w !== null) {
          w = w.next;
          do
            c.status = "rejected", c.reason = y, qu(c), c = c.next;
          while (c !== w);
        }
        l.action = null;
      }
      function qu(l) {
        l = l.listeners;
        for (var c = 0; c < l.length; c++) (0, l[c])();
      }
      function Tr(l, c) {
        return c;
      }
      function jc(l, c) {
        if (Nn) {
          var y = $n.formState;
          if (y !== null) {
            t: {
              var w = Je;
              if (Nn) {
                if (Xn) {
                  var z = L0(
                    Xn,
                    Vs
                  );
                  if (z) {
                    Xn = nc(z), w = vo(z);
                    break t;
                  }
                }
                lt(w);
              }
              w = !1;
            }
            w && (c = y[0]);
          }
        }
        y = wi(), y.memoizedState = y.baseState = c, w = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: Tr,
          lastRenderedState: c
        }, y.queue = w, y = Lo.bind(
          null,
          Je,
          w
        ), w.dispatch = y, w = _a(!1);
        var F = Vo.bind(
          null,
          Je,
          !1,
          w.queue
        );
        return w = wi(), z = {
          state: c,
          dispatch: null,
          action: l,
          pending: null
        }, w.queue = z, y = Yn.bind(
          null,
          Je,
          z,
          F,
          y
        ), z.dispatch = y, w.memoizedState = l, [c, y, !1];
      }
      function Rl(l) {
        var c = $e();
        return Lc(c, Dn, l);
      }
      function Lc(l, c, y) {
        c = es(
          l,
          c,
          Tr
        )[0], l = na(kr)[0], c = typeof c == "object" && c !== null && typeof c.then == "function" ? xr(c) : c;
        var w = $e(), z = w.queue, F = z.dispatch;
        return y !== w.memoizedState && (Je.flags |= 2048, Uo(
          9,
          ns.bind(null, z, y),
          { destroy: void 0 },
          null
        )), [c, F, l];
      }
      function ns(l, c) {
        l.action = c;
      }
      function Gu(l) {
        var c = $e(), y = Dn;
        if (y !== null)
          return Lc(c, y, l);
        $e(), c = c.memoizedState, y = $e();
        var w = y.queue.dispatch;
        return y.memoizedState = l, [c, w, !1];
      }
      function Uo(l, c, y, w) {
        return l = { tag: l, create: c, inst: y, deps: w, next: null }, c = Je.updateQueue, c === null && (c = Wp(), Je.updateQueue = c), y = c.lastEffect, y === null ? c.lastEffect = l.next = l : (w = y.next, y.next = l, l.next = w, c.lastEffect = l), l;
      }
      function cn() {
        return $e().memoizedState;
      }
      function Ol(l, c, y, w) {
        var z = wi();
        Je.flags |= l, z.memoizedState = Uo(
          1 | c,
          y,
          { destroy: void 0 },
          w === void 0 ? null : w
        );
      }
      function Vc(l, c, y, w) {
        var z = $e();
        w = w === void 0 ? null : w;
        var F = z.memoizedState.inst;
        Dn !== null && w !== null && ea(w, Dn.memoizedState.deps) ? z.memoizedState = Uo(c, y, F, w) : (Je.flags |= l, z.memoizedState = Uo(1 | c, y, F, w));
      }
      function Hd(l, c) {
        Ol(8390656, 8, l, c);
      }
      function cr(l, c) {
        Vc(2048, 8, l, c);
      }
      function jo(l, c) {
        return Vc(4, 2, l, c);
      }
      function Ic(l, c) {
        return Vc(4, 4, l, c);
      }
      function Sa(l, c) {
        if (typeof c == "function") {
          l = l();
          var y = c(l);
          return function() {
            typeof y == "function" ? y() : c(null);
          };
        }
        if (c != null)
          return l = l(), c.current = l, function() {
            c.current = null;
          };
      }
      function Fc(l, c, y) {
        y = y != null ? y.concat([l]) : null, Vc(
          4,
          4,
          Sa.bind(null, c, l),
          y
        );
      }
      function Nl() {
      }
      function ni(l, c) {
        var y = $e();
        c = c === void 0 ? null : c;
        var w = y.memoizedState;
        return c !== null && ea(c, w[1]) ? w[0] : (y.memoizedState = [l, c], l);
      }
      function Cr(l, c) {
        var y = $e();
        c = c === void 0 ? null : c;
        var w = y.memoizedState;
        if (c !== null && ea(c, w[1]))
          return w[0];
        if (w = l(), lc) {
          Q(!0);
          try {
            l();
          } finally {
            Q(!1);
          }
        }
        return y.memoizedState = [w, c], w;
      }
      function ao(l, c, y) {
        return y === void 0 || (ul & 1073741824) !== 0 ? l.memoizedState = c : (l.memoizedState = y, l = $d(), Je.lanes |= l, ms |= l, y);
      }
      function so(l, c, y, w) {
        return la(y, c) ? y : Fs.current !== null ? (l = ao(l, y, w), la(l, c) || (Ji = !0), l) : (ul & 42) === 0 ? (Ji = !0, l.memoizedState = y) : (l = $d(), Je.lanes |= l, ms |= l, c);
      }
      function qc(l, c, y, w, z) {
        var F = ec();
        oa(
          F !== 0 && 8 > F ? F : 8
        );
        var st = Xe.T, yt = {};
        Xe.T = yt, Vo(l, !1, c, y);
        try {
          var Pt = z(), Qt = Xe.S;
          if (Qt !== null && Qt(yt, Pt), Pt !== null && typeof Pt == "object" && typeof Pt.then == "function") {
            var ye = Yt(
              Pt,
              w
            );
            is(
              l,
              c,
              ye,
              qr(l)
            );
          } else
            is(
              l,
              c,
              w,
              qr(l)
            );
        } catch (Oe) {
          is(
            l,
            c,
            { then: function() {
            }, status: "rejected", reason: Oe },
            qr()
          );
        } finally {
          oa(F), Xe.T = st;
        }
      }
      function ra(l) {
        var c = l.memoizedState;
        if (c !== null) return c;
        c = {
          memoizedState: uu,
          baseState: uu,
          baseQueue: null,
          queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: kr,
            lastRenderedState: uu
          },
          next: null
        };
        var y = {};
        return c.next = {
          memoizedState: y,
          baseState: y,
          baseQueue: null,
          queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: kr,
            lastRenderedState: y
          },
          next: null
        }, l.memoizedState = c, l = l.alternate, l !== null && (l.memoizedState = c), c;
      }
      function Gc() {
        return dr(al);
      }
      function Dr() {
        return $e().memoizedState;
      }
      function ja() {
        return $e().memoizedState;
      }
      function Hu(l) {
        for (var c = l.return; c !== null; ) {
          switch (c.tag) {
            case 24:
            case 3:
              var y = qr();
              l = fe(y);
              var w = Me(c, l, y);
              w !== null && (si(w, c, y), Te(w, c, y)), c = { cache: Ds() }, l.payload = c;
              return;
          }
          c = c.return;
        }
      }
      function kl(l, c, y) {
        var w = qr();
        y = {
          lane: w,
          revertLane: 0,
          action: y,
          hasEagerState: !1,
          eagerState: null,
          next: null
        }, Hc(l) ? Ui(c, y) : (y = se(l, c, y, w), y !== null && (si(y, l, w), oo(y, c, w)));
      }
      function Lo(l, c, y) {
        var w = qr();
        is(l, c, y, w);
      }
      function is(l, c, y, w) {
        var z = {
          lane: w,
          revertLane: 0,
          action: y,
          hasEagerState: !1,
          eagerState: null,
          next: null
        };
        if (Hc(l)) Ui(c, z);
        else {
          var F = l.alternate;
          if (l.lanes === 0 && (F === null || F.lanes === 0) && (F = c.lastRenderedReducer, F !== null))
            try {
              var st = c.lastRenderedState, yt = F(st, y);
              if (z.hasEagerState = !0, z.eagerState = yt, la(yt, st))
                return Ut(l, c, z, 0), $n === null && ce(), !1;
            } catch {
            } finally {
            }
          if (y = se(l, c, z, w), y !== null)
            return si(y, l, w), oo(y, c, w), !0;
        }
        return !1;
      }
      function Vo(l, c, y, w) {
        if (w = {
          lane: 2,
          revertLane: It(),
          action: w,
          hasEagerState: !1,
          eagerState: null,
          next: null
        }, Hc(l)) {
          if (c) throw Error(s(479));
        } else
          c = se(
            l,
            y,
            w,
            2
          ), c !== null && si(c, l, 2);
      }
      function Hc(l) {
        var c = l.alternate;
        return l === Je || c !== null && c === Je;
      }
      function Ui(l, c) {
        yu = dl = !0;
        var y = l.pending;
        y === null ? c.next = c : (c.next = y.next, y.next = c), l.pending = c;
      }
      function oo(l, c, y) {
        if ((y & 4194176) !== 0) {
          var w = c.lanes;
          w &= l.pendingLanes, y |= w, c.lanes = y, H(l, y);
        }
      }
      function Dl(l, c, y, w) {
        c = l.memoizedState, y = y(w, c), y = y == null ? c : Li({}, c, y), l.memoizedState = y, l.lanes === 0 && (l.updateQueue.baseState = y);
      }
      function Rs(l, c, y, w, z, F, st) {
        return l = l.stateNode, typeof l.shouldComponentUpdate == "function" ? l.shouldComponentUpdate(w, F, st) : c.prototype && c.prototype.isPureReactComponent ? !Xi(y, w) || !Xi(z, F) : !0;
      }
      function Kc(l, c, y, w) {
        l = c.state, typeof c.componentWillReceiveProps == "function" && c.componentWillReceiveProps(y, w), typeof c.UNSAFE_componentWillReceiveProps == "function" && c.UNSAFE_componentWillReceiveProps(y, w), c.state !== l && gd.enqueueReplaceState(c, c.state, null);
      }
      function La(l, c) {
        var y = c;
        if ("ref" in c) {
          y = {};
          for (var w in c)
            w !== "ref" && (y[w] = c[w]);
        }
        if (l = l.defaultProps) {
          y === c && (y = Li({}, y));
          for (var z in l)
            y[z] === void 0 && (y[z] = l[z]);
        }
        return y;
      }
      function Bl(l, c) {
        try {
          var y = l.onUncaughtError;
          y(c.value, { componentStack: c.stack });
        } catch (w) {
          setTimeout(function() {
            throw w;
          });
        }
      }
      function zl(l, c, y) {
        try {
          var w = l.onCaughtError;
          w(y.value, {
            componentStack: y.stack,
            errorBoundary: c.tag === 1 ? c.stateNode : null
          });
        } catch (z) {
          setTimeout(function() {
            throw z;
          });
        }
      }
      function Pl(l, c, y) {
        return y = fe(y), y.tag = 3, y.payload = { element: null }, y.callback = function() {
          Bl(l, c);
        }, y;
      }
      function Yc(l) {
        return l = fe(l), l.tag = 3, l;
      }
      function Ku(l, c, y, w) {
        var z = y.type.getDerivedStateFromError;
        if (typeof z == "function") {
          var F = w.value;
          l.payload = function() {
            return z(F);
          }, l.callback = function() {
            zl(c, y, w);
          };
        }
        var st = y.stateNode;
        st !== null && typeof st.componentDidCatch == "function" && (l.callback = function() {
          zl(c, y, w), typeof z != "function" && (wo === null ? wo = /* @__PURE__ */ new Set([this]) : wo.add(this));
          var yt = w.stack;
          this.componentDidCatch(w.value, {
            componentStack: yt !== null ? yt : ""
          });
        });
      }
      function Hh(l, c, y, w, z) {
        if (y.flags |= 32768, w !== null && typeof w == "object" && typeof w.then == "function") {
          if (c = y.alternate, c !== null && tu(
            c,
            y,
            z,
            !0
          ), y = Ma.current, y !== null) {
            switch (y.tag) {
              case 13:
                return us === null ? os() : y.alternate === null && _i === 0 && (_i = 3), y.flags &= -257, y.flags |= 65536, y.lanes = z, w === ca ? y.flags |= 16384 : (c = y.updateQueue, c === null ? y.updateQueue = /* @__PURE__ */ new Set([w]) : c.add(w), Kl(l, w, z)), !1;
              case 22:
                return y.flags |= 65536, w === ca ? y.flags |= 16384 : (c = y.updateQueue, c === null ? (c = {
                  transitions: null,
                  markerInstances: null,
                  retryQueue: /* @__PURE__ */ new Set([w])
                }, y.updateQueue = c) : (y = c.retryQueue, y === null ? c.retryQueue = /* @__PURE__ */ new Set([w]) : y.add(w)), Kl(l, w, z)), !1;
            }
            throw Error(s(435, y.tag));
          }
          return Kl(l, w, z), os(), !1;
        }
        if (Nn)
          return c = Ma.current, c !== null ? ((c.flags & 65536) === 0 && (c.flags |= 256), c.flags |= 65536, c.lanes = z, w !== dh && (l = Error(s(422), { cause: w }), ie(
            nt(l, y)
          ))) : (w !== dh && (c = Error(s(423), {
            cause: w
          }), ie(
            nt(c, y)
          )), l = l.current.alternate, l.flags |= 65536, z &= -z, l.lanes |= z, w = nt(w, y), z = Pl(
            l.stateNode,
            w,
            z
          ), ne(l, z), _i !== 4 && (_i = 2)), !1;
        var F = Error(s(520), { cause: w });
        if (F = nt(F, y), vd === null ? vd = [F] : vd.push(F), _i !== 4 && (_i = 2), c === null) return !0;
        w = nt(w, y), y = c;
        do {
          switch (y.tag) {
            case 3:
              return y.flags |= 65536, l = z & -z, y.lanes |= l, l = Pl(y.stateNode, w, l), ne(y, l), !1;
            case 1:
              if (c = y.type, F = y.stateNode, (y.flags & 128) === 0 && (typeof c.getDerivedStateFromError == "function" || F !== null && typeof F.componentDidCatch == "function" && (wo === null || !wo.has(
                F
              ))))
                return y.flags |= 65536, z &= -z, y.lanes |= z, z = Yc(z), Ku(
                  z,
                  l,
                  y,
                  w
                ), ne(y, z), !1;
          }
          y = y.return;
        } while (y !== null);
        return !1;
      }
      function Oi(l, c, y, w) {
        c.child = l === null ? xo(c, null, y, w) : oc(
          c,
          l.child,
          y,
          w
        );
      }
      function Io(l, c, y, w, z) {
        y = y.render;
        var F = c.ref;
        if ("ref" in w) {
          var st = {};
          for (var yt in w)
            yt !== "ref" && (st[yt] = w[yt]);
        } else st = w;
        return as(c), w = ba(
          l,
          c,
          y,
          st,
          F,
          z
        ), yt = eo(), l !== null && !Ji ? (Ua(l, c, z), Va(l, c, z)) : (Nn && yt && vt(c), c.flags |= 1, Oi(l, c, w, z), c.child);
      }
      function Xc(l, c, y, w, z) {
        if (l === null) {
          var F = y.type;
          return typeof F == "function" && !Zo(F) && F.defaultProps === void 0 && y.compare === null ? (c.tag = 15, c.type = F, Kd(
            l,
            c,
            F,
            w,
            z
          )) : (l = ou(
            y.type,
            null,
            w,
            c,
            c.mode,
            z
          ), l.ref = c.ref, l.return = c, c.child = l);
        }
        if (F = l.child, !Jc(l, z)) {
          var st = F.memoizedProps;
          if (y = y.compare, y = y !== null ? y : Xi, y(st, w) && l.ref === c.ref)
            return Va(
              l,
              c,
              z
            );
        }
        return c.flags |= 1, l = Jo(F, w), l.ref = c.ref, l.return = c, c.child = l;
      }
      function Kd(l, c, y, w, z) {
        if (l !== null) {
          var F = l.memoizedProps;
          if (Xi(F, w) && l.ref === c.ref)
            if (Ji = !1, c.pendingProps = w = F, Jc(l, z))
              (l.flags & 131072) !== 0 && (Ji = !0);
            else
              return c.lanes = l.lanes, Va(l, c, z);
        }
        return Ul(
          l,
          c,
          y,
          w,
          z
        );
      }
      function Kh(l, c, y) {
        var w = c.pendingProps, z = w.children, F = (c.stateNode._pendingVisibility & 2) !== 0, st = l !== null ? l.memoizedState : null;
        if (Fo(l, c), w.mode === "hidden" || F) {
          if ((c.flags & 128) !== 0) {
            if (w = st !== null ? st.baseLanes | y : y, l !== null) {
              for (z = c.child = l.child, F = 0; z !== null; )
                F = F | z.lanes | z.childLanes, z = z.sibling;
              c.childLanes = F & ~w;
            } else c.childLanes = 0, c.child = null;
            return Wc(
              l,
              c,
              w,
              y
            );
          }
          if ((y & 536870912) !== 0)
            c.memoizedState = { baseLanes: 0, cachePool: null }, l !== null && eu(
              c,
              st !== null ? st.cachePool : null
            ), st !== null ? zc(c, st) : Fn(), wl(c);
          else
            return c.lanes = c.childLanes = 536870912, Wc(
              l,
              c,
              st !== null ? st.baseLanes | y : y,
              y
            );
        } else
          st !== null ? (eu(c, st.cachePool), zc(c, st), Pa(), c.memoizedState = null) : (l !== null && eu(c, null), Fn(), Pa());
        return Oi(l, c, z, y), c.child;
      }
      function Wc(l, c, y, w) {
        var z = Wd();
        return z = z === null ? null : {
          parent: Ps ? ki._currentValue : ki._currentValue2,
          pool: z
        }, c.memoizedState = {
          baseLanes: y,
          cachePool: z
        }, l !== null && eu(c, null), Fn(), wl(c), l !== null && tu(l, c, w, !0), null;
      }
      function Fo(l, c) {
        var y = c.ref;
        if (y === null)
          l !== null && l.ref !== null && (c.flags |= 2097664);
        else {
          if (typeof y != "function" && typeof y != "object")
            throw Error(s(284));
          (l === null || l.ref !== y) && (c.flags |= 2097664);
        }
      }
      function Ul(l, c, y, w, z) {
        return as(c), y = ba(
          l,
          c,
          y,
          w,
          void 0,
          z
        ), w = eo(), l !== null && !Ji ? (Ua(l, c, z), Va(l, c, z)) : (Nn && w && vt(c), c.flags |= 1, Oi(l, c, y, z), c.child);
      }
      function Yu(l, c, y, w, z, F) {
        return as(c), c.updateQueue = null, y = Gh(
          c,
          w,
          y,
          z
        ), Pc(l), w = eo(), l !== null && !Ji ? (Ua(l, c, F), Va(l, c, F)) : (Nn && w && vt(c), c.flags |= 1, Oi(l, c, y, F), c.child);
      }
      function Xu(l, c, y, w, z) {
        if (as(c), c.stateNode === null) {
          var F = pu, st = y.contextType;
          typeof st == "object" && st !== null && (F = dr(st)), F = new y(w, F), c.memoizedState = F.state !== null && F.state !== void 0 ? F.state : null, F.updater = gd, c.stateNode = F, F._reactInternals = c, F = c.stateNode, F.props = w, F.state = c.memoizedState, F.refs = {}, ae(c), st = y.contextType, F.context = typeof st == "object" && st !== null ? dr(st) : pu, F.state = c.memoizedState, st = y.getDerivedStateFromProps, typeof st == "function" && (Dl(
            c,
            y,
            st,
            w
          ), F.state = c.memoizedState), typeof y.getDerivedStateFromProps == "function" || typeof F.getSnapshotBeforeUpdate == "function" || typeof F.UNSAFE_componentWillMount != "function" && typeof F.componentWillMount != "function" || (st = F.state, typeof F.componentWillMount == "function" && F.componentWillMount(), typeof F.UNSAFE_componentWillMount == "function" && F.UNSAFE_componentWillMount(), st !== F.state && gd.enqueueReplaceState(
            F,
            F.state,
            null
          ), fn(c, w, F, z), Ve(), F.state = c.memoizedState), typeof F.componentDidMount == "function" && (c.flags |= 4194308), w = !0;
        } else if (l === null) {
          F = c.stateNode;
          var yt = c.memoizedProps, Pt = La(y, yt);
          F.props = Pt;
          var Qt = F.context, ye = y.contextType;
          st = pu, typeof ye == "object" && ye !== null && (st = dr(ye));
          var Oe = y.getDerivedStateFromProps;
          ye = typeof Oe == "function" || typeof F.getSnapshotBeforeUpdate == "function", yt = c.pendingProps !== yt, ye || typeof F.UNSAFE_componentWillReceiveProps != "function" && typeof F.componentWillReceiveProps != "function" || (yt || Qt !== st) && Kc(
            c,
            F,
            w,
            st
          ), Yr = !1;
          var ge = c.memoizedState;
          F.state = ge, fn(c, w, F, z), Ve(), Qt = c.memoizedState, yt || ge !== Qt || Yr ? (typeof Oe == "function" && (Dl(
            c,
            y,
            Oe,
            w
          ), Qt = c.memoizedState), (Pt = Yr || Rs(
            c,
            y,
            Pt,
            w,
            ge,
            Qt,
            st
          )) ? (ye || typeof F.UNSAFE_componentWillMount != "function" && typeof F.componentWillMount != "function" || (typeof F.componentWillMount == "function" && F.componentWillMount(), typeof F.UNSAFE_componentWillMount == "function" && F.UNSAFE_componentWillMount()), typeof F.componentDidMount == "function" && (c.flags |= 4194308)) : (typeof F.componentDidMount == "function" && (c.flags |= 4194308), c.memoizedProps = w, c.memoizedState = Qt), F.props = w, F.state = Qt, F.context = st, w = Pt) : (typeof F.componentDidMount == "function" && (c.flags |= 4194308), w = !1);
        } else {
          F = c.stateNode, le(l, c), st = c.memoizedProps, ye = La(y, st), F.props = ye, Oe = c.pendingProps, ge = F.context, Qt = y.contextType, Pt = pu, typeof Qt == "object" && Qt !== null && (Pt = dr(Qt)), yt = y.getDerivedStateFromProps, (Qt = typeof yt == "function" || typeof F.getSnapshotBeforeUpdate == "function") || typeof F.UNSAFE_componentWillReceiveProps != "function" && typeof F.componentWillReceiveProps != "function" || (st !== Oe || ge !== Pt) && Kc(
            c,
            F,
            w,
            Pt
          ), Yr = !1, ge = c.memoizedState, F.state = ge, fn(c, w, F, z), Ve();
          var en = c.memoizedState;
          st !== Oe || ge !== en || Yr || l !== null && l.dependencies !== null && Ho(l.dependencies) ? (typeof yt == "function" && (Dl(
            c,
            y,
            yt,
            w
          ), en = c.memoizedState), (ye = Yr || Rs(
            c,
            y,
            ye,
            w,
            ge,
            en,
            Pt
          ) || l !== null && l.dependencies !== null && Ho(l.dependencies)) ? (Qt || typeof F.UNSAFE_componentWillUpdate != "function" && typeof F.componentWillUpdate != "function" || (typeof F.componentWillUpdate == "function" && F.componentWillUpdate(w, en, Pt), typeof F.UNSAFE_componentWillUpdate == "function" && F.UNSAFE_componentWillUpdate(
            w,
            en,
            Pt
          )), typeof F.componentDidUpdate == "function" && (c.flags |= 4), typeof F.getSnapshotBeforeUpdate == "function" && (c.flags |= 1024)) : (typeof F.componentDidUpdate != "function" || st === l.memoizedProps && ge === l.memoizedState || (c.flags |= 4), typeof F.getSnapshotBeforeUpdate != "function" || st === l.memoizedProps && ge === l.memoizedState || (c.flags |= 1024), c.memoizedProps = w, c.memoizedState = en), F.props = w, F.state = en, F.context = Pt, w = ye) : (typeof F.componentDidUpdate != "function" || st === l.memoizedProps && ge === l.memoizedState || (c.flags |= 4), typeof F.getSnapshotBeforeUpdate != "function" || st === l.memoizedProps && ge === l.memoizedState || (c.flags |= 1024), w = !1);
        }
        return F = w, Fo(l, c), w = (c.flags & 128) !== 0, F || w ? (F = c.stateNode, y = w && typeof y.getDerivedStateFromError != "function" ? null : F.render(), c.flags |= 1, l !== null && w ? (c.child = oc(
          c,
          l.child,
          null,
          z
        ), c.child = oc(
          c,
          null,
          y,
          z
        )) : Oi(l, c, y, z), c.memoizedState = F.state, l = c.child) : l = Va(
          l,
          c,
          z
        ), l;
      }
      function ur(l, c, y, w) {
        return Ot(), c.flags |= 256, Oi(l, c, y, w), c.child;
      }
      function qo(l) {
        return { baseLanes: l, cachePool: nu() };
      }
      function Os(l, c, y) {
        return l = l !== null ? l.childLanes & ~y : 0, c && (l |= Ya), l;
      }
      function Yd(l, c, y) {
        var w = c.pendingProps, z = !1, F = (c.flags & 128) !== 0, st;
        if ((st = F) || (st = l !== null && l.memoizedState === null ? !1 : (oi.current & 2) !== 0), st && (z = !0, c.flags &= -129), st = (c.flags & 32) !== 0, c.flags &= -33, l === null) {
          if (Nn) {
            if (z ? Es(c) : Pa(), Nn) {
              var yt = Xn, Pt;
              (Pt = yt) && (yt = I0(
                yt,
                Vs
              ), yt !== null ? (c.memoizedState = {
                dehydrated: yt,
                treeContext: Ls !== null ? { id: _o, overflow: So } : null,
                retryLane: 536870912
              }, Pt = n(18, null, null, 0), Pt.stateNode = yt, Pt.return = c, c.child = Pt, qi = c, Xn = null, Pt = !0) : Pt = !1), Pt || lt(c);
            }
            if (yt = c.memoizedState, yt !== null && (yt = yt.dehydrated, yt !== null))
              return oh(yt) ? c.lanes = 16 : c.lanes = 536870912, null;
            zi(c);
          }
          return yt = w.children, w = w.fallback, z ? (Pa(), z = c.mode, yt = Wu(
            { mode: "hidden", children: yt },
            z
          ), w = Yl(
            w,
            z,
            y,
            null
          ), yt.return = c, w.return = c, yt.sibling = w, c.child = yt, z = c.child, z.memoizedState = qo(y), z.childLanes = Os(
            l,
            st,
            y
          ), c.memoizedState = ph, w) : (Es(c), jl(c, yt));
        }
        if (Pt = l.memoizedState, Pt !== null && (yt = Pt.dehydrated, yt !== null)) {
          if (F)
            c.flags & 256 ? (Es(c), c.flags &= -257, c = $c(
              l,
              c,
              y
            )) : c.memoizedState !== null ? (Pa(), c.child = l.child, c.flags |= 128, c = null) : (Pa(), z = w.fallback, yt = c.mode, w = Wu(
              { mode: "visible", children: w.children },
              yt
            ), z = Yl(
              z,
              yt,
              y,
              null
            ), z.flags |= 2, w.return = c, z.return = c, w.sibling = z, c.child = w, oc(
              c,
              l.child,
              null,
              y
            ), w = c.child, w.memoizedState = qo(y), w.childLanes = Os(
              l,
              st,
              y
            ), c.memoizedState = ph, c = z);
          else if (Es(c), oh(yt))
            st = of(yt).digest, w = Error(s(419)), w.stack = "", w.digest = st, ie({ value: w, source: null, stack: null }), c = $c(
              l,
              c,
              y
            );
          else if (Ji || tu(
            l,
            c,
            y,
            !1
          ), st = (y & l.childLanes) !== 0, Ji || st) {
            if (st = $n, st !== null) {
              if (w = y & -y, (w & 42) !== 0) w = 1;
              else
                switch (w) {
                  case 2:
                    w = 1;
                    break;
                  case 8:
                    w = 4;
                    break;
                  case 32:
                    w = 16;
                    break;
                  case 128:
                  case 256:
                  case 512:
                  case 1024:
                  case 2048:
                  case 4096:
                  case 8192:
                  case 16384:
                  case 32768:
                  case 65536:
                  case 131072:
                  case 262144:
                  case 524288:
                  case 1048576:
                  case 2097152:
                  case 4194304:
                  case 8388608:
                  case 16777216:
                  case 33554432:
                    w = 64;
                    break;
                  case 268435456:
                    w = 134217728;
                    break;
                  default:
                    w = 0;
                }
              if (w = (w & (st.suspendedLanes | y)) !== 0 ? 0 : w, w !== 0 && w !== Pt.retryLane)
                throw Pt.retryLane = w, re(l, w), si(st, l, w), $p;
            }
            du(yt) || os(), c = $c(
              l,
              c,
              y
            );
          } else
            du(yt) ? (c.flags |= 128, c.child = l.child, c = nh.bind(
              null,
              l
            ), j0(yt, c), c = null) : (l = Pt.treeContext, wa && (Xn = zp(yt), qi = c, Nn = !0, cs = null, Vs = !1, l !== null && (Ea[Kr++] = _o, Ea[Kr++] = So, Ea[Kr++] = Ls, _o = l.id, So = l.overflow, Ls = c)), c = jl(
              c,
              w.children
            ), c.flags |= 4096);
          return c;
        }
        return z ? (Pa(), z = w.fallback, yt = c.mode, Pt = l.child, F = Pt.sibling, w = Jo(Pt, {
          mode: "hidden",
          children: w.children
        }), w.subtreeFlags = Pt.subtreeFlags & 31457280, F !== null ? z = Jo(F, z) : (z = Yl(
          z,
          yt,
          y,
          null
        ), z.flags |= 2), z.return = c, w.return = c, w.sibling = z, c.child = w, w = z, z = c.child, yt = l.child.memoizedState, yt === null ? yt = qo(y) : (Pt = yt.cachePool, Pt !== null ? (F = Ps ? ki._currentValue : ki._currentValue2, Pt = Pt.parent !== F ? { parent: F, pool: F } : Pt) : Pt = nu(), yt = {
          baseLanes: yt.baseLanes | y,
          cachePool: Pt
        }), z.memoizedState = yt, z.childLanes = Os(
          l,
          st,
          y
        ), c.memoizedState = ph, w) : (Es(c), y = l.child, l = y.sibling, y = Jo(y, {
          mode: "visible",
          children: w.children
        }), y.return = c, y.sibling = null, l !== null && (st = c.deletions, st === null ? (c.deletions = [l], c.flags |= 16) : st.push(l)), c.child = y, c.memoizedState = null, y);
      }
      function jl(l, c) {
        return c = Wu(
          { mode: "visible", children: c },
          l.mode
        ), c.return = l, l.child = c;
      }
      function Wu(l, c) {
        return Qh(l, c, 0, null);
      }
      function $c(l, c, y) {
        return oc(c, l.child, null, y), l = jl(
          c,
          c.pendingProps.children
        ), l.flags |= 2, c.memoizedState = null, l;
      }
      function Qc(l, c, y) {
        l.lanes |= c;
        var w = l.alternate;
        w !== null && (w.lanes |= c), Go(l.return, c, y);
      }
      function Zc(l, c, y, w, z) {
        var F = l.memoizedState;
        F === null ? l.memoizedState = {
          isBackwards: c,
          rendering: null,
          renderingStartTime: 0,
          last: w,
          tail: y,
          tailMode: z
        } : (F.isBackwards = c, F.rendering = null, F.renderingStartTime = 0, F.last = w, F.tail = y, F.tailMode = z);
      }
      function lo(l, c, y) {
        var w = c.pendingProps, z = w.revealOrder, F = w.tail;
        if (Oi(l, c, w.children, y), w = oi.current, (w & 2) !== 0)
          w = w & 1 | 2, c.flags |= 128;
        else {
          if (l !== null && (l.flags & 128) !== 0)
            t: for (l = c.child; l !== null; ) {
              if (l.tag === 13)
                l.memoizedState !== null && Qc(l, y, c);
              else if (l.tag === 19)
                Qc(l, y, c);
              else if (l.child !== null) {
                l.child.return = l, l = l.child;
                continue;
              }
              if (l === c) break t;
              for (; l.sibling === null; ) {
                if (l.return === null || l.return === c)
                  break t;
                l = l.return;
              }
              l.sibling.return = l.return, l = l.sibling;
            }
          w &= 1;
        }
        switch (M(oi, w), z) {
          case "forwards":
            for (y = c.child, z = null; y !== null; )
              l = y.alternate, l !== null && Pi(l) === null && (z = y), y = y.sibling;
            y = z, y === null ? (z = c.child, c.child = null) : (z = y.sibling, y.sibling = null), Zc(
              c,
              !1,
              z,
              y,
              F
            );
            break;
          case "backwards":
            for (y = null, z = c.child, c.child = null; z !== null; ) {
              if (l = z.alternate, l !== null && Pi(l) === null) {
                c.child = z;
                break;
              }
              l = z.sibling, z.sibling = y, y = z, z = l;
            }
            Zc(
              c,
              !0,
              y,
              null,
              F
            );
            break;
          case "together":
            Zc(c, !1, null, null, void 0);
            break;
          default:
            c.memoizedState = null;
        }
        return c.child;
      }
      function Va(l, c, y) {
        if (l !== null && (c.dependencies = l.dependencies), ms |= c.lanes, (y & c.childLanes) === 0)
          if (l !== null) {
            if (tu(
              l,
              c,
              y,
              !1
            ), (y & c.childLanes) === 0)
              return null;
          } else return null;
        if (l !== null && c.child !== l.child)
          throw Error(s(153));
        if (c.child !== null) {
          for (l = c.child, y = Jo(l, l.pendingProps), c.child = y, y.return = c; l.sibling !== null; )
            l = l.sibling, y = y.sibling = Jo(l, l.pendingProps), y.return = c;
          y.sibling = null;
        }
        return c.child;
      }
      function Jc(l, c) {
        return (l.lanes & c) !== 0 ? !0 : (l = l.dependencies, !!(l !== null && Ho(l)));
      }
      function $u(l, c, y) {
        switch (c.tag) {
          case 3:
            dt(
              c,
              c.stateNode.containerInfo
            ), Ns(c, ki, l.memoizedState.cache), Ot();
            break;
          case 27:
          case 5:
            Et(c);
            break;
          case 4:
            dt(
              c,
              c.stateNode.containerInfo
            );
            break;
          case 10:
            Ns(
              c,
              c.type,
              c.memoizedProps.value
            );
            break;
          case 13:
            var w = c.memoizedState;
            if (w !== null)
              return w.dehydrated !== null ? (Es(c), c.flags |= 128, null) : (y & c.child.childLanes) !== 0 ? Yd(
                l,
                c,
                y
              ) : (Es(c), l = Va(
                l,
                c,
                y
              ), l !== null ? l.sibling : null);
            Es(c);
            break;
          case 19:
            var z = (l.flags & 128) !== 0;
            if (w = (y & c.childLanes) !== 0, w || (tu(
              l,
              c,
              y,
              !1
            ), w = (y & c.childLanes) !== 0), z) {
              if (w)
                return lo(
                  l,
                  c,
                  y
                );
              c.flags |= 128;
            }
            if (z = c.memoizedState, z !== null && (z.rendering = null, z.tail = null, z.lastEffect = null), M(oi, oi.current), w) break;
            return null;
          case 22:
          case 23:
            return c.lanes = 0, Kh(l, c, y);
          case 24:
            Ns(c, ki, l.memoizedState.cache);
        }
        return Va(l, c, y);
      }
      function Qu(l, c, y) {
        if (l !== null)
          if (l.memoizedProps !== c.pendingProps)
            Ji = !0;
          else {
            if (!Jc(l, y) && (c.flags & 128) === 0)
              return Ji = !1, $u(
                l,
                c,
                y
              );
            Ji = (l.flags & 131072) !== 0;
          }
        else
          Ji = !1, Nn && (c.flags & 1048576) !== 0 && rt(c, hd, c.index);
        switch (c.lanes = 0, c.tag) {
          case 16:
            t: {
              l = c.pendingProps;
              var w = c.elementType, z = w._init;
              if (w = z(w._payload), c.type = w, typeof w == "function")
                Zo(w) ? (l = La(w, l), c.tag = 1, c = Xu(
                  null,
                  c,
                  w,
                  l,
                  y
                )) : (c.tag = 0, c = Ul(
                  null,
                  c,
                  w,
                  l,
                  y
                ));
              else {
                if (w != null) {
                  if (z = w.$$typeof, z === Zh) {
                    c.tag = 11, c = Io(
                      null,
                      c,
                      w,
                      l,
                      y
                    );
                    break t;
                  } else if (z === id) {
                    c.tag = 14, c = Xc(
                      null,
                      c,
                      w,
                      l,
                      y
                    );
                    break t;
                  }
                }
                throw c = u(w) || w, Error(s(306, c, ""));
              }
            }
            return c;
          case 0:
            return Ul(
              l,
              c,
              c.type,
              c.pendingProps,
              y
            );
          case 1:
            return w = c.type, z = La(
              w,
              c.pendingProps
            ), Xu(
              l,
              c,
              w,
              z,
              y
            );
          case 3:
            t: {
              if (dt(
                c,
                c.stateNode.containerInfo
              ), l === null) throw Error(s(387));
              var F = c.pendingProps;
              z = c.memoizedState, w = z.element, le(l, c), fn(c, F, null, y);
              var st = c.memoizedState;
              if (F = st.cache, Ns(c, ki, F), F !== z.cache && rs(
                c,
                [ki],
                y,
                !0
              ), Ve(), F = st.element, wa && z.isDehydrated)
                if (z = {
                  element: F,
                  isDehydrated: !1,
                  cache: st.cache
                }, c.updateQueue.baseState = z, c.memoizedState = z, c.flags & 256) {
                  c = ur(
                    l,
                    c,
                    F,
                    y
                  );
                  break t;
                } else if (F !== w) {
                  w = nt(
                    Error(s(424)),
                    c
                  ), ie(w), c = ur(
                    l,
                    c,
                    F,
                    y
                  );
                  break t;
                } else
                  for (wa && (Xn = hu(
                    c.stateNode.containerInfo
                  ), qi = c, Nn = !0, cs = null, Vs = !0), y = xo(
                    c,
                    null,
                    F,
                    y
                  ), c.child = y; y; )
                    y.flags = y.flags & -3 | 4096, y = y.sibling;
              else {
                if (Ot(), F === w) {
                  c = Va(
                    l,
                    c,
                    y
                  );
                  break t;
                }
                Oi(l, c, F, y);
              }
              c = c.child;
            }
            return c;
          case 26:
            if (qa)
              return Fo(l, c), l === null ? (y = Lp(
                c.type,
                null,
                c.pendingProps,
                null
              )) ? c.memoizedState = y : Nn || (c.stateNode = qp(
                c.type,
                c.pendingProps,
                ll.current,
                c
              )) : c.memoizedState = Lp(
                c.type,
                l.memoizedProps,
                c.pendingProps,
                l.memoizedState
              ), null;
          case 27:
            if (Er)
              return Et(c), l === null && Er && Nn && (w = c.stateNode = uf(
                c.type,
                c.pendingProps,
                ll.current,
                Fi.current,
                !1
              ), qi = c, Vs = !0, Xn = sl(w)), w = c.pendingProps.children, l !== null || Nn ? Oi(
                l,
                c,
                w,
                y
              ) : c.child = oc(
                c,
                null,
                w,
                y
              ), Fo(l, c), c.child;
          case 5:
            return l === null && Nn && (K0(
              c.type,
              c.pendingProps,
              Fi.current
            ), (z = w = Xn) && (w = Pp(
              w,
              c.type,
              c.pendingProps,
              Vs
            ), w !== null ? (c.stateNode = w, qi = c, Xn = sl(w), Vs = !1, z = !0) : z = !1), z || lt(c)), Et(c), z = c.type, F = c.pendingProps, st = l !== null ? l.memoizedProps : null, w = F.children, Pr(z, F) ? w = null : st !== null && Pr(z, st) && (c.flags |= 32), c.memoizedState !== null && (z = ba(
              l,
              c,
              As,
              null,
              null,
              y
            ), Ps ? al._currentValue = z : al._currentValue2 = z), Fo(l, c), Oi(l, c, w, y), c.child;
          case 6:
            return l === null && Nn && (xv(
              c.pendingProps,
              Fi.current
            ), (l = y = Xn) && (y = V0(
              y,
              c.pendingProps,
              Vs
            ), y !== null ? (c.stateNode = y, qi = c, Xn = null, l = !0) : l = !1), l || lt(c)), null;
          case 13:
            return Yd(l, c, y);
          case 4:
            return dt(
              c,
              c.stateNode.containerInfo
            ), w = c.pendingProps, l === null ? c.child = oc(
              c,
              null,
              w,
              y
            ) : Oi(
              l,
              c,
              w,
              y
            ), c.child;
          case 11:
            return Io(
              l,
              c,
              c.type,
              c.pendingProps,
              y
            );
          case 7:
            return Oi(
              l,
              c,
              c.pendingProps,
              y
            ), c.child;
          case 8:
            return Oi(
              l,
              c,
              c.pendingProps.children,
              y
            ), c.child;
          case 12:
            return Oi(
              l,
              c,
              c.pendingProps.children,
              y
            ), c.child;
          case 10:
            return w = c.pendingProps, Ns(
              c,
              c.type,
              w.value
            ), Oi(
              l,
              c,
              w.children,
              y
            ), c.child;
          case 9:
            return z = c.type._context, w = c.pendingProps.children, as(c), z = dr(z), w = w(z), c.flags |= 1, Oi(
              l,
              c,
              w,
              y
            ), c.child;
          case 14:
            return Xc(
              l,
              c,
              c.type,
              c.pendingProps,
              y
            );
          case 15:
            return Kd(
              l,
              c,
              c.type,
              c.pendingProps,
              y
            );
          case 19:
            return lo(
              l,
              c,
              y
            );
          case 22:
            return Kh(l, c, y);
          case 24:
            return as(c), w = dr(ki), l === null ? (z = Wd(), z === null && (z = $n, F = Ds(), z.pooledCache = F, F.refCount++, F !== null && (z.pooledCacheLanes |= y), z = F), c.memoizedState = {
              parent: w,
              cache: z
            }, ae(c), Ns(c, ki, z)) : ((l.lanes & y) !== 0 && (le(l, c), fn(c, null, null, y), Ve()), z = l.memoizedState, F = c.memoizedState, z.parent !== w ? (z = { parent: w, cache: w }, c.memoizedState = z, c.lanes === 0 && (c.memoizedState = c.updateQueue.baseState = z), Ns(c, ki, w)) : (w = F.cache, Ns(c, ki, w), w !== z.cache && rs(
              c,
              [ki],
              y,
              !0
            ))), Oi(
              l,
              c,
              c.pendingProps.children,
              y
            ), c.child;
          case 29:
            throw c.pendingProps;
        }
        throw Error(s(156, c.tag));
      }
      function Ns(l, c, y) {
        Ps ? (M(ds, c._currentValue), c._currentValue = y) : (M(ds, c._currentValue2), c._currentValue2 = y);
      }
      function ks(l) {
        var c = ds.current;
        Ps ? l._currentValue = c : l._currentValue2 = c, O(ds);
      }
      function Go(l, c, y) {
        for (; l !== null; ) {
          var w = l.alternate;
          if ((l.childLanes & c) !== c ? (l.childLanes |= c, w !== null && (w.childLanes |= c)) : w !== null && (w.childLanes & c) !== c && (w.childLanes |= c), l === y) break;
          l = l.return;
        }
      }
      function rs(l, c, y, w) {
        var z = l.child;
        for (z !== null && (z.return = l); z !== null; ) {
          var F = z.dependencies;
          if (F !== null) {
            var st = z.child;
            F = F.firstContext;
            t: for (; F !== null; ) {
              var yt = F;
              F = z;
              for (var Pt = 0; Pt < c.length; Pt++)
                if (yt.context === c[Pt]) {
                  F.lanes |= y, yt = F.alternate, yt !== null && (yt.lanes |= y), Go(
                    F.return,
                    y,
                    l
                  ), w || (st = null);
                  break t;
                }
              F = yt.next;
            }
          } else if (z.tag === 18) {
            if (st = z.return, st === null) throw Error(s(341));
            st.lanes |= y, F = st.alternate, F !== null && (F.lanes |= y), Go(st, y, l), st = null;
          } else st = z.child;
          if (st !== null) st.return = z;
          else
            for (st = z; st !== null; ) {
              if (st === l) {
                st = null;
                break;
              }
              if (z = st.sibling, z !== null) {
                z.return = st.return, st = z;
                break;
              }
              st = st.return;
            }
          z = st;
        }
      }
      function tu(l, c, y, w) {
        l = null;
        for (var z = c, F = !1; z !== null; ) {
          if (!F) {
            if ((z.flags & 524288) !== 0) F = !0;
            else if ((z.flags & 262144) !== 0) break;
          }
          if (z.tag === 10) {
            var st = z.alternate;
            if (st === null) throw Error(s(387));
            if (st = st.memoizedProps, st !== null) {
              var yt = z.type;
              la(z.pendingProps.value, st.value) || (l !== null ? l.push(yt) : l = [yt]);
            }
          } else if (z === uh.current) {
            if (st = z.alternate, st === null) throw Error(s(387));
            st.memoizedState.memoizedState !== z.memoizedState.memoizedState && (l !== null ? l.push(al) : l = [al]);
          }
          z = z.return;
        }
        l !== null && rs(
          c,
          l,
          y,
          w
        ), c.flags |= 262144;
      }
      function Ho(l) {
        for (l = l.firstContext; l !== null; ) {
          var c = l.context;
          if (!la(
            Ps ? c._currentValue : c._currentValue2,
            l.memoizedValue
          ))
            return !0;
          l = l.next;
        }
        return !1;
      }
      function as(l) {
        hc = l, hs = null, l = l.dependencies, l !== null && (l.firstContext = null);
      }
      function dr(l) {
        return Xd(hc, l);
      }
      function Ll(l, c) {
        return hc === null && as(l), Xd(l, c);
      }
      function Xd(l, c) {
        var y = Ps ? c._currentValue : c._currentValue2;
        if (c = { context: c, memoizedValue: y, next: null }, hs === null) {
          if (l === null) throw Error(s(308));
          hs = c, l.dependencies = { lanes: 0, firstContext: c }, l.flags |= 524288;
        } else hs = hs.next = c;
        return y;
      }
      function Ds() {
        return {
          controller: new mh(),
          data: /* @__PURE__ */ new Map(),
          refCount: 0
        };
      }
      function Vl(l) {
        l.refCount--, l.refCount === 0 && Ei(Cv, function() {
          l.controller.abort();
        });
      }
      function Wd() {
        var l = vu.current;
        return l !== null ? l : $n.pooledCache;
      }
      function eu(l, c) {
        c === null ? M(vu, vu.current) : M(vu, c.pool);
      }
      function nu() {
        var l = Wd();
        return l === null ? null : {
          parent: Ps ? ki._currentValue : ki._currentValue2,
          pool: l
        };
      }
      function Br(l) {
        l.flags |= 4;
      }
      function Ko(l, c) {
        if (l !== null && l.child === c.child) return !1;
        if ((c.flags & 16) !== 0) return !0;
        for (l = c.child; l !== null; ) {
          if ((l.flags & 13878) !== 0 || (l.subtreeFlags & 13878) !== 0)
            return !0;
          l = l.sibling;
        }
        return !1;
      }
      function Yo(l, c, y, w) {
        if (vi)
          for (y = c.child; y !== null; ) {
            if (y.tag === 5 || y.tag === 6)
              ah(l, y.stateNode);
            else if (!(y.tag === 4 || Er && y.tag === 27) && y.child !== null) {
              y.child.return = y, y = y.child;
              continue;
            }
            if (y === c) break;
            for (; y.sibling === null; ) {
              if (y.return === null || y.return === c)
                return;
              y = y.return;
            }
            y.sibling.return = y.return, y = y.sibling;
          }
        else if (Us)
          for (var z = c.child; z !== null; ) {
            if (z.tag === 5) {
              var F = z.stateNode;
              y && w && (F = U0(
                F,
                z.type,
                z.memoizedProps
              )), ah(l, F);
            } else if (z.tag === 6)
              F = z.stateNode, y && w && (F = Bp(
                F,
                z.memoizedProps
              )), ah(l, F);
            else if (z.tag !== 4) {
              if (z.tag === 22 && z.memoizedState !== null)
                F = z.child, F !== null && (F.return = z), Yo(l, z, !0, !0);
              else if (z.child !== null) {
                z.child.return = z, z = z.child;
                continue;
              }
            }
            if (z === c) break;
            for (; z.sibling === null; ) {
              if (z.return === null || z.return === c)
                return;
              z = z.return;
            }
            z.sibling.return = z.return, z = z.sibling;
          }
      }
      function Yh(l, c, y, w) {
        if (Us)
          for (var z = c.child; z !== null; ) {
            if (z.tag === 5) {
              var F = z.stateNode;
              y && w && (F = U0(
                F,
                z.type,
                z.memoizedProps
              )), Dp(l, F);
            } else if (z.tag === 6)
              F = z.stateNode, y && w && (F = Bp(
                F,
                z.memoizedProps
              )), Dp(l, F);
            else if (z.tag !== 4) {
              if (z.tag === 22 && z.memoizedState !== null)
                F = z.child, F !== null && (F.return = z), Yh(
                  l,
                  z,
                  !(z.memoizedProps !== null && z.memoizedProps.mode === "manual"),
                  !0
                );
              else if (z.child !== null) {
                z.child.return = z, z = z.child;
                continue;
              }
            }
            if (z === c) break;
            for (; z.sibling === null; ) {
              if (z.return === null || z.return === c) return;
              z = z.return;
            }
            z.sibling.return = z.return, z = z.sibling;
          }
      }
      function iu(l, c) {
        if (Us && Ko(l, c)) {
          l = c.stateNode;
          var y = l.containerInfo, w = sf();
          Yh(w, c, !1, !1), l.pendingChildren = w, Br(c), z0(y, w);
        }
      }
      function Xo(l, c, y, w) {
        if (vi)
          l.memoizedProps !== w && Br(c);
        else if (Us) {
          var z = l.stateNode, F = l.memoizedProps;
          if ((l = Ko(l, c)) || F !== w) {
            var st = Fi.current;
            F = B0(
              z,
              y,
              F,
              w,
              !l,
              null
            ), F === z ? c.stateNode = z : (Jh(
              F,
              y,
              w,
              st
            ) && Br(c), c.stateNode = F, l ? Yo(F, c, !1, !1) : Br(c));
          } else c.stateNode = z;
        }
      }
      function xa(l, c, y) {
        if (Ap(c, y)) {
          if (l.flags |= 16777216, !Mp(c, y))
            if (wr()) l.flags |= 8192;
            else
              throw Xr = ca, fh;
        } else l.flags &= -16777217;
      }
      function ii(l, c) {
        if (W0(c)) {
          if (l.flags |= 16777216, !Gp(c))
            if (wr()) l.flags |= 8192;
            else
              throw Xr = ca, fh;
        } else l.flags &= -16777217;
      }
      function Bs(l, c) {
        c !== null && (l.flags |= 4), l.flags & 16384 && (c = l.tag !== 22 ? V() : 536870912, l.lanes |= c, er |= c);
      }
      function hr(l, c) {
        if (!Nn)
          switch (l.tailMode) {
            case "hidden":
              c = l.tail;
              for (var y = null; c !== null; )
                c.alternate !== null && (y = c), c = c.sibling;
              y === null ? l.tail = null : y.sibling = null;
              break;
            case "collapsed":
              y = l.tail;
              for (var w = null; y !== null; )
                y.alternate !== null && (w = y), y = y.sibling;
              w === null ? c || l.tail === null ? l.tail = null : l.tail.sibling = null : w.sibling = null;
          }
      }
      function ri(l) {
        var c = l.alternate !== null && l.alternate.child === l.child, y = 0, w = 0;
        if (c)
          for (var z = l.child; z !== null; )
            y |= z.lanes | z.childLanes, w |= z.subtreeFlags & 31457280, w |= z.flags & 31457280, z.return = l, z = z.sibling;
        else
          for (z = l.child; z !== null; )
            y |= z.lanes | z.childLanes, w |= z.subtreeFlags, w |= z.flags, z.return = l, z = z.sibling;
        return l.subtreeFlags |= w, l.childLanes = y, c;
      }
      function Zu(l, c, y) {
        var w = c.pendingProps;
        switch (ct(c), c.tag) {
          case 16:
          case 15:
          case 0:
          case 11:
          case 7:
          case 8:
          case 12:
          case 9:
          case 14:
            return ri(c), null;
          case 1:
            return ri(c), null;
          case 3:
            return y = c.stateNode, w = null, l !== null && (w = l.memoizedState.cache), c.memoizedState.cache !== w && (c.flags |= 2048), ks(ki), ht(), y.pendingContext && (y.context = y.pendingContext, y.pendingContext = null), (l === null || l.child === null) && (Bt(c) ? Br(c) : l === null || l.memoizedState.isDehydrated && (c.flags & 256) === 0 || (c.flags |= 1024, cs !== null && ($o(cs), cs = null))), iu(l, c), ri(c), null;
          case 26:
            if (qa) {
              y = c.type;
              var z = c.memoizedState;
              return l === null ? (Br(c), z !== null ? (ri(c), ii(
                c,
                z
              )) : (ri(c), xa(
                c,
                y,
                w
              ))) : z ? z !== l.memoizedState ? (Br(c), ri(c), ii(
                c,
                z
              )) : (ri(c), c.flags &= -16777217) : (vi ? l.memoizedProps !== w && Br(c) : Xo(
                l,
                c,
                y,
                w
              ), ri(c), xa(
                c,
                y,
                w
              )), null;
            }
          case 27:
            if (Er) {
              if (ot(c), y = ll.current, z = c.type, l !== null && c.stateNode != null)
                vi ? l.memoizedProps !== w && Br(c) : Xo(
                  l,
                  c,
                  z,
                  w
                );
              else {
                if (!w) {
                  if (c.stateNode === null)
                    throw Error(s(166));
                  return ri(c), null;
                }
                l = Fi.current, Bt(c) ? ft(c, l) : (l = uf(
                  z,
                  w,
                  y,
                  l,
                  !0
                ), c.stateNode = l, Br(c));
              }
              return ri(c), null;
            }
          case 5:
            if (ot(c), y = c.type, l !== null && c.stateNode != null)
              Xo(l, c, y, w);
            else {
              if (!w) {
                if (c.stateNode === null)
                  throw Error(s(166));
                return ri(c), null;
              }
              l = Fi.current, Bt(c) ? ft(c, l) : (z = Ep(
                y,
                w,
                ll.current,
                l,
                c
              ), Yo(z, c, !1, !1), c.stateNode = z, Jh(
                z,
                y,
                w,
                l
              ) && Br(c));
            }
            return ri(c), xa(
              c,
              c.type,
              c.pendingProps
            ), null;
          case 6:
            if (l && c.stateNode != null)
              y = l.memoizedProps, vi ? y !== w && Br(c) : Us && (y !== w ? (c.stateNode = Vi(
                w,
                ll.current,
                Fi.current,
                c
              ), Br(c)) : c.stateNode = l.stateNode);
            else {
              if (typeof w != "string" && c.stateNode === null)
                throw Error(s(166));
              if (l = ll.current, y = Fi.current, Bt(c)) {
                if (!wa) throw Error(s(176));
                if (l = c.stateNode, y = c.memoizedProps, w = null, z = qi, z !== null)
                  switch (z.tag) {
                    case 27:
                    case 5:
                      w = z.memoizedProps;
                  }
                lf(
                  l,
                  y,
                  c,
                  w
                ) || lt(c);
              } else
                c.stateNode = Vi(
                  w,
                  l,
                  y,
                  c
                );
            }
            return ri(c), null;
          case 13:
            if (w = c.memoizedState, l === null || l.memoizedState !== null && l.memoizedState.dehydrated !== null) {
              if (z = Bt(c), w !== null && w.dehydrated !== null) {
                if (l === null) {
                  if (!z) throw Error(s(318));
                  if (!wa) throw Error(s(344));
                  if (z = c.memoizedState, z = z !== null ? z.dehydrated : null, !z) throw Error(s(317));
                  F0(z, c);
                } else
                  Ot(), (c.flags & 128) === 0 && (c.memoizedState = null), c.flags |= 4;
                ri(c), z = !1;
              } else
                cs !== null && ($o(cs), cs = null), z = !0;
              if (!z)
                return c.flags & 256 ? (zi(c), c) : (zi(c), null);
            }
            if (zi(c), (c.flags & 128) !== 0)
              return c.lanes = y, c;
            if (y = w !== null, l = l !== null && l.memoizedState !== null, y) {
              w = c.child, z = null, w.alternate !== null && w.alternate.memoizedState !== null && w.alternate.memoizedState.cachePool !== null && (z = w.alternate.memoizedState.cachePool.pool);
              var F = null;
              w.memoizedState !== null && w.memoizedState.cachePool !== null && (F = w.memoizedState.cachePool.pool), F !== z && (w.flags |= 2048);
            }
            return y !== l && y && (c.child.flags |= 8192), Bs(c, c.updateQueue), ri(c), null;
          case 4:
            return ht(), iu(l, c), l === null && f0(c.stateNode.containerInfo), ri(c), null;
          case 10:
            return ks(c.type), ri(c), null;
          case 19:
            if (O(oi), z = c.memoizedState, z === null)
              return ri(c), null;
            if (w = (c.flags & 128) !== 0, F = z.rendering, F === null)
              if (w) hr(z, !1);
              else {
                if (_i !== 0 || l !== null && (l.flags & 128) !== 0)
                  for (l = c.child; l !== null; ) {
                    if (F = Pi(l), F !== null) {
                      for (c.flags |= 128, hr(z, !1), l = F.updateQueue, c.updateQueue = l, Bs(c, l), c.subtreeFlags = 0, l = y, y = c.child; y !== null; )
                        su(y, l), y = y.sibling;
                      return M(
                        oi,
                        oi.current & 1 | 2
                      ), c.child;
                    }
                    l = l.sibling;
                  }
                z.tail !== null && Ga() > Xa && (c.flags |= 128, w = !0, hr(z, !1), c.lanes = 4194304);
              }
            else {
              if (!w)
                if (l = Pi(F), l !== null) {
                  if (c.flags |= 128, w = !0, l = l.updateQueue, c.updateQueue = l, Bs(c, l), hr(z, !0), z.tail === null && z.tailMode === "hidden" && !F.alternate && !Nn)
                    return ri(c), null;
                } else
                  2 * Ga() - z.renderingStartTime > Xa && y !== 536870912 && (c.flags |= 128, w = !0, hr(z, !1), c.lanes = 4194304);
              z.isBackwards ? (F.sibling = c.child, c.child = F) : (l = z.last, l !== null ? l.sibling = F : c.child = F, z.last = F);
            }
            return z.tail !== null ? (c = z.tail, z.rendering = c, z.tail = c.sibling, z.renderingStartTime = Ga(), c.sibling = null, l = oi.current, M(
              oi,
              w ? l & 1 | 2 : l & 1
            ), c) : (ri(c), null);
          case 22:
          case 23:
            return zi(c), Ci(), w = c.memoizedState !== null, l !== null ? l.memoizedState !== null !== w && (c.flags |= 8192) : w && (c.flags |= 8192), w ? (y & 536870912) !== 0 && (c.flags & 128) === 0 && (ri(c), c.subtreeFlags & 6 && (c.flags |= 8192)) : ri(c), y = c.updateQueue, y !== null && Bs(c, y.retryQueue), y = null, l !== null && l.memoizedState !== null && l.memoizedState.cachePool !== null && (y = l.memoizedState.cachePool.pool), w = null, c.memoizedState !== null && c.memoizedState.cachePool !== null && (w = c.memoizedState.cachePool.pool), w !== y && (c.flags |= 2048), l !== null && O(vu), null;
          case 24:
            return y = null, l !== null && (y = l.memoizedState.cache), c.memoizedState.cache !== y && (c.flags |= 2048), ks(ki), ri(c), null;
          case 25:
            return null;
        }
        throw Error(s(156, c.tag));
      }
      function Xh(l, c) {
        switch (ct(c), c.tag) {
          case 1:
            return l = c.flags, l & 65536 ? (c.flags = l & -65537 | 128, c) : null;
          case 3:
            return ks(ki), ht(), l = c.flags, (l & 65536) !== 0 && (l & 128) === 0 ? (c.flags = l & -65537 | 128, c) : null;
          case 26:
          case 27:
          case 5:
            return ot(c), null;
          case 13:
            if (zi(c), l = c.memoizedState, l !== null && l.dehydrated !== null) {
              if (c.alternate === null)
                throw Error(s(340));
              Ot();
            }
            return l = c.flags, l & 65536 ? (c.flags = l & -65537 | 128, c) : null;
          case 19:
            return O(oi), null;
          case 4:
            return ht(), null;
          case 10:
            return ks(c.type), null;
          case 22:
          case 23:
            return zi(c), Ci(), l !== null && O(vu), l = c.flags, l & 65536 ? (c.flags = l & -65537 | 128, c) : null;
          case 24:
            return ks(ki), null;
          case 25:
            return null;
          default:
            return null;
        }
      }
      function co(l, c) {
        switch (ct(c), c.tag) {
          case 3:
            ks(ki), ht();
            break;
          case 26:
          case 27:
          case 5:
            ot(c);
            break;
          case 4:
            ht();
            break;
          case 13:
            zi(c);
            break;
          case 19:
            O(oi);
            break;
          case 10:
            ks(c.type);
            break;
          case 22:
          case 23:
            zi(c), Ci(), l !== null && O(vu);
            break;
          case 24:
            ks(ki);
        }
      }
      function Wo(l, c) {
        try {
          var y = c.updateQueue, w = y !== null ? y.lastEffect : null;
          if (w !== null) {
            var z = w.next;
            y = z;
            do {
              if ((y.tag & l) === l) {
                w = void 0;
                var F = y.create, st = y.inst;
                w = F(), st.destroy = w;
              }
              y = y.next;
            } while (y !== z);
          }
        } catch (yt) {
          Ln(c, c.return, yt);
        }
      }
      function aa(l, c, y) {
        try {
          var w = c.updateQueue, z = w !== null ? w.lastEffect : null;
          if (z !== null) {
            var F = z.next;
            w = F;
            do {
              if ((w.tag & l) === l) {
                var st = w.inst, yt = st.destroy;
                if (yt !== void 0) {
                  st.destroy = void 0, z = c;
                  var Pt = y;
                  try {
                    yt();
                  } catch (Qt) {
                    Ln(
                      z,
                      Pt,
                      Qt
                    );
                  }
                }
              }
              w = w.next;
            } while (w !== F);
          }
        } catch (Qt) {
          Ln(c, c.return, Qt);
        }
      }
      function zs(l) {
        var c = l.updateQueue;
        if (c !== null) {
          var y = l.stateNode;
          try {
            Ce(c, y);
          } catch (w) {
            Ln(l, l.return, w);
          }
        }
      }
      function zr(l, c, y) {
        y.props = La(
          l.type,
          l.memoizedProps
        ), y.state = l.memoizedState;
        try {
          y.componentWillUnmount();
        } catch (w) {
          Ln(l, c, w);
        }
      }
      function S(l, c) {
        try {
          var y = l.ref;
          if (y !== null) {
            var w = l.stateNode;
            switch (l.tag) {
              case 26:
              case 27:
              case 5:
                var z = cu(w);
                break;
              default:
                z = w;
            }
            typeof y == "function" ? l.refCleanup = y(z) : y.current = z;
          }
        } catch (F) {
          Ln(l, c, F);
        }
      }
      function k(l, c) {
        var y = l.ref, w = l.refCleanup;
        if (y !== null)
          if (typeof w == "function")
            try {
              w();
            } catch (z) {
              Ln(l, c, z);
            } finally {
              l.refCleanup = null, l = l.alternate, l != null && (l.refCleanup = null);
            }
          else if (typeof y == "function")
            try {
              y(null);
            } catch (z) {
              Ln(l, c, z);
            }
          else y.current = null;
      }
      function L(l) {
        var c = l.type, y = l.memoizedProps, w = l.stateNode;
        try {
          E0(w, c, y, l);
        } catch (z) {
          Ln(l, l.return, z);
        }
      }
      function Y(l, c, y) {
        try {
          A0(
            l.stateNode,
            l.type,
            y,
            c,
            l
          );
        } catch (w) {
          Ln(l, l.return, w);
        }
      }
      function Z(l) {
        return l.tag === 5 || l.tag === 3 || (qa ? l.tag === 26 : !1) || (Er ? l.tag === 27 : !1) || l.tag === 4;
      }
      function et(l) {
        t: for (; ; ) {
          for (; l.sibling === null; ) {
            if (l.return === null || Z(l.return)) return null;
            l = l.return;
          }
          for (l.sibling.return = l.return, l = l.sibling; l.tag !== 5 && l.tag !== 6 && (!Er || l.tag !== 27) && l.tag !== 18; ) {
            if (l.flags & 2 || l.child === null || l.tag === 4) continue t;
            l.child.return = l, l = l.child;
          }
          if (!(l.flags & 2)) return l.stateNode;
        }
      }
      function ut(l, c, y) {
        var w = l.tag;
        if (w === 5 || w === 6)
          l = l.stateNode, c ? Np(y, l, c) : Op(y, l);
        else if (!(w === 4 || Er && w === 27) && (l = l.child, l !== null))
          for (ut(l, c, y), l = l.sibling; l !== null; )
            ut(l, c, y), l = l.sibling;
      }
      function mt(l, c, y) {
        var w = l.tag;
        if (w === 5 || w === 6)
          l = l.stateNode, c ? M0(y, l, c) : C0(y, l);
        else if (!(w === 4 || Er && w === 27) && (l = l.child, l !== null))
          for (mt(l, c, y), l = l.sibling; l !== null; )
            mt(l, c, y), l = l.sibling;
      }
      function bt(l, c, y) {
        l = l.containerInfo;
        try {
          P0(l, y);
        } catch (w) {
          Ln(c, c.return, w);
        }
      }
      function St(l, c) {
        for (h0(l.containerInfo), Ie = c; Ie !== null; )
          if (l = Ie, c = l.child, (l.subtreeFlags & 1028) !== 0 && c !== null)
            c.return = l, Ie = c;
          else
            for (; Ie !== null; ) {
              l = Ie;
              var y = l.alternate;
              switch (c = l.flags, l.tag) {
                case 0:
                  break;
                case 11:
                case 15:
                  break;
                case 1:
                  if ((c & 1024) !== 0 && y !== null) {
                    c = void 0;
                    var w = l, z = y.memoizedProps;
                    y = y.memoizedState;
                    var F = w.stateNode;
                    try {
                      var st = La(
                        w.type,
                        z,
                        w.elementType === w.type
                      );
                      c = F.getSnapshotBeforeUpdate(
                        st,
                        y
                      ), F.__reactInternalSnapshotBeforeUpdate = c;
                    } catch (yt) {
                      Ln(
                        w,
                        w.return,
                        yt
                      );
                    }
                  }
                  break;
                case 3:
                  (c & 1024) !== 0 && vi && D0(l.stateNode.containerInfo);
                  break;
                case 5:
                case 26:
                case 27:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  if ((c & 1024) !== 0)
                    throw Error(s(163));
              }
              if (c = l.sibling, c !== null) {
                c.return = l.return, Ie = c;
                break;
              }
              Ie = l.return;
            }
        return st = Jn, Jn = !1, st;
      }
      function At(l, c, y) {
        var w = y.flags;
        switch (y.tag) {
          case 0:
          case 11:
          case 15:
            de(l, y), w & 4 && Wo(5, y);
            break;
          case 1:
            if (de(l, y), w & 4)
              if (l = y.stateNode, c === null)
                try {
                  l.componentDidMount();
                } catch (yt) {
                  Ln(y, y.return, yt);
                }
              else {
                var z = La(
                  y.type,
                  c.memoizedProps
                );
                c = c.memoizedState;
                try {
                  l.componentDidUpdate(
                    z,
                    c,
                    l.__reactInternalSnapshotBeforeUpdate
                  );
                } catch (yt) {
                  Ln(
                    y,
                    y.return,
                    yt
                  );
                }
              }
            w & 64 && zs(y), w & 512 && S(y, y.return);
            break;
          case 3:
            if (de(l, y), w & 64 && (w = y.updateQueue, w !== null)) {
              if (l = null, y.child !== null)
                switch (y.child.tag) {
                  case 27:
                  case 5:
                    l = cu(y.child.stateNode);
                    break;
                  case 1:
                    l = y.child.stateNode;
                }
              try {
                Ce(w, l);
              } catch (yt) {
                Ln(y, y.return, yt);
              }
            }
            break;
          case 26:
            if (qa) {
              de(l, y), w & 512 && S(y, y.return);
              break;
            }
          case 27:
          case 5:
            de(l, y), c === null && w & 4 && L(y), w & 512 && S(y, y.return);
            break;
          case 12:
            de(l, y);
            break;
          case 13:
            de(l, y), w & 4 && wt(l, y);
            break;
          case 22:
            if (z = y.memoizedState !== null || pl, !z) {
              c = c !== null && c.memoizedState !== null || tn;
              var F = pl, st = tn;
              pl = z, (tn = c) && !st ? pe(
                l,
                y,
                (y.subtreeFlags & 8772) !== 0
              ) : de(l, y), pl = F, tn = st;
            }
            w & 512 && (y.memoizedProps.mode === "manual" ? S(y, y.return) : k(y, y.return));
            break;
          default:
            de(l, y);
        }
      }
      function gt(l) {
        var c = l.alternate;
        c !== null && (l.alternate = null, gt(c)), l.child = null, l.deletions = null, l.sibling = null, l.tag === 5 && (c = l.stateNode, c !== null && g0(c)), l.stateNode = null, l.return = null, l.dependencies = null, l.memoizedProps = null, l.memoizedState = null, l.pendingProps = null, l.stateNode = null, l.updateQueue = null;
      }
      function Rt(l, c, y) {
        for (y = y.child; y !== null; )
          _t(
            l,
            c,
            y
          ), y = y.sibling;
      }
      function _t(l, c, y) {
        if (Zi && typeof Zi.onCommitFiberUnmount == "function")
          try {
            Zi.onCommitFiberUnmount(dd, y);
          } catch {
          }
        switch (y.tag) {
          case 26:
            if (qa) {
              tn || k(y, c), Rt(
                l,
                c,
                y
              ), y.memoizedState ? Ip(y.memoizedState) : y.stateNode && ld(y.stateNode);
              break;
            }
          case 27:
            if (Er) {
              tn || k(y, c);
              var w = Bn, z = Ki;
              Bn = y.stateNode, Rt(
                l,
                c,
                y
              ), Yp(y.stateNode), Bn = w, Ki = z;
              break;
            }
          case 5:
            tn || k(y, c);
          case 6:
            if (vi) {
              if (w = Bn, z = Ki, Bn = null, Rt(
                l,
                c,
                y
              ), Bn = w, Ki = z, Bn !== null)
                if (Ki)
                  try {
                    O0(Bn, y.stateNode);
                  } catch (F) {
                    Ln(
                      y,
                      c,
                      F
                    );
                  }
                else
                  try {
                    R0(Bn, y.stateNode);
                  } catch (F) {
                    Ln(
                      y,
                      c,
                      F
                    );
                  }
            } else
              Rt(
                l,
                c,
                y
              );
            break;
          case 18:
            vi && Bn !== null && (Ki ? Up(
              Bn,
              y.stateNode
            ) : H0(Bn, y.stateNode));
            break;
          case 4:
            vi ? (w = Bn, z = Ki, Bn = y.stateNode.containerInfo, Ki = !0, Rt(
              l,
              c,
              y
            ), Bn = w, Ki = z) : (Us && bt(
              y.stateNode,
              y,
              sf()
            ), Rt(
              l,
              c,
              y
            ));
            break;
          case 0:
          case 11:
          case 14:
          case 15:
            tn || aa(2, y, c), tn || aa(4, y, c), Rt(
              l,
              c,
              y
            );
            break;
          case 1:
            tn || (k(y, c), w = y.stateNode, typeof w.componentWillUnmount == "function" && zr(
              y,
              c,
              w
            )), Rt(
              l,
              c,
              y
            );
            break;
          case 21:
            Rt(
              l,
              c,
              y
            );
            break;
          case 22:
            tn || k(y, c), tn = (w = tn) || y.memoizedState !== null, Rt(
              l,
              c,
              y
            ), tn = w;
            break;
          default:
            Rt(
              l,
              c,
              y
            );
        }
      }
      function wt(l, c) {
        if (wa && c.memoizedState === null && (l = c.alternate, l !== null && (l = l.memoizedState, l !== null && (l = l.dehydrated, l !== null))))
          try {
            cf(l);
          } catch (y) {
            Ln(c, c.return, y);
          }
      }
      function Nt(l) {
        switch (l.tag) {
          case 13:
          case 19:
            var c = l.stateNode;
            return c === null && (c = l.stateNode = new pn()), c;
          case 22:
            return l = l.stateNode, c = l._retryCache, c === null && (c = l._retryCache = new pn()), c;
          default:
            throw Error(s(435, l.tag));
        }
      }
      function xt(l, c) {
        var y = Nt(l);
        c.forEach(function(w) {
          var z = $h.bind(null, l, w);
          y.has(w) || (y.add(w), w.then(z, z));
        });
      }
      function Dt(l, c) {
        var y = c.deletions;
        if (y !== null)
          for (var w = 0; w < y.length; w++) {
            var z = y[w], F = l, st = c;
            if (vi) {
              var yt = st;
              t: for (; yt !== null; ) {
                switch (yt.tag) {
                  case 27:
                  case 5:
                    Bn = yt.stateNode, Ki = !1;
                    break t;
                  case 3:
                    Bn = yt.stateNode.containerInfo, Ki = !0;
                    break t;
                  case 4:
                    Bn = yt.stateNode.containerInfo, Ki = !0;
                    break t;
                }
                yt = yt.return;
              }
              if (Bn === null) throw Error(s(160));
              _t(F, st, z), Bn = null, Ki = !1;
            } else _t(F, st, z);
            F = z.alternate, F !== null && (F.return = null), z.return = null;
          }
        if (c.subtreeFlags & 13878)
          for (c = c.child; c !== null; )
            Ft(c, l), c = c.sibling;
      }
      function Ft(l, c) {
        var y = l.alternate, w = l.flags;
        switch (l.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            Dt(c, l), Lt(l), w & 4 && (aa(3, l, l.return), Wo(3, l), aa(5, l, l.return));
            break;
          case 1:
            Dt(c, l), Lt(l), w & 512 && (tn || y === null || k(y, y.return)), w & 64 && pl && (l = l.updateQueue, l !== null && (w = l.callbacks, w !== null && (y = l.shared.hiddenCallbacks, l.shared.hiddenCallbacks = y === null ? w : y.concat(w))));
            break;
          case 26:
            if (qa) {
              var z = $r;
              Dt(c, l), Lt(l), w & 512 && (tn || y === null || k(y, y.return)), w & 4 && (w = y !== null ? y.memoizedState : null, c = l.memoizedState, y === null ? c === null ? l.stateNode === null ? l.stateNode = Y0(
                z,
                l.type,
                l.memoizedProps,
                l
              ) : Fp(
                z,
                l.type,
                l.stateNode
              ) : l.stateNode = Vp(
                z,
                c,
                l.memoizedProps
              ) : w !== c ? (w === null ? y.stateNode !== null && ld(y.stateNode) : Ip(w), c === null ? Fp(
                z,
                l.type,
                l.stateNode
              ) : Vp(
                z,
                c,
                l.memoizedProps
              )) : c === null && l.stateNode !== null && Y(
                l,
                l.memoizedProps,
                y.memoizedProps
              ));
              break;
            }
          case 27:
            if (Er && w & 4 && l.alternate === null) {
              z = l.stateNode;
              var F = l.memoizedProps;
              try {
                $0(z), Kp(
                  l.type,
                  F,
                  z,
                  l
                );
              } catch (ye) {
                Ln(l, l.return, ye);
              }
            }
          case 5:
            if (Dt(c, l), Lt(l), w & 512 && (tn || y === null || k(y, y.return)), vi) {
              if (l.flags & 32) {
                c = l.stateNode;
                try {
                  af(c);
                } catch (ye) {
                  Ln(l, l.return, ye);
                }
              }
              w & 4 && l.stateNode != null && (c = l.memoizedProps, Y(
                l,
                c,
                y !== null ? y.memoizedProps : c
              )), w & 1024 && (Wn = !0);
            }
            break;
          case 6:
            if (Dt(c, l), Lt(l), w & 4 && vi) {
              if (l.stateNode === null)
                throw Error(s(162));
              w = l.memoizedProps, y = y !== null ? y.memoizedProps : w, c = l.stateNode;
              try {
                w0(c, y, w);
              } catch (ye) {
                Ln(l, l.return, ye);
              }
            }
            break;
          case 3:
            if (qa ? (X0(), z = $r, $r = mr(c.containerInfo), Dt(c, l), $r = z) : Dt(c, l), Lt(l), w & 4) {
              if (vi && wa && y !== null && y.memoizedState.isDehydrated)
                try {
                  G0(c.containerInfo);
                } catch (ye) {
                  Ln(l, l.return, ye);
                }
              if (Us) {
                w = c.containerInfo, y = c.pendingChildren;
                try {
                  P0(w, y);
                } catch (ye) {
                  Ln(l, l.return, ye);
                }
              }
            }
            Wn && (Wn = !1, Xt(l));
            break;
          case 4:
            qa ? (y = $r, $r = mr(
              l.stateNode.containerInfo
            ), Dt(c, l), Lt(l), $r = y) : (Dt(c, l), Lt(l)), w & 4 && Us && bt(
              l.stateNode,
              l,
              l.stateNode.pendingChildren
            );
            break;
          case 12:
            Dt(c, l), Lt(l);
            break;
          case 13:
            Dt(c, l), Lt(l), l.child.flags & 8192 && l.memoizedState !== null != (y !== null && y.memoizedState !== null) && (Zp = Ga()), w & 4 && (w = l.updateQueue, w !== null && (l.updateQueue = null, xt(l, w)));
            break;
          case 22:
            w & 512 && (tn || y === null || k(y, y.return)), z = l.memoizedState !== null;
            var st = y !== null && y.memoizedState !== null, yt = pl, Pt = tn;
            if (pl = yt || z, tn = Pt || st, Dt(c, l), tn = Pt, pl = yt, Lt(l), c = l.stateNode, c._current = l, c._visibility &= -3, c._visibility |= c._pendingVisibility & 2, w & 8192 && (c._visibility = z ? c._visibility & -2 : c._visibility | 1, z && (c = pl || tn, y === null || st || c || Se(l)), vi && (l.memoizedProps === null || l.memoizedProps.mode !== "manual"))) {
              t: if (y = null, vi)
                for (c = l; ; ) {
                  if (c.tag === 5 || qa && c.tag === 26 || Er && c.tag === 27) {
                    if (y === null) {
                      st = y = c;
                      try {
                        F = st.stateNode, z ? N0(F) : Sv(
                          st.stateNode,
                          st.memoizedProps
                        );
                      } catch (ye) {
                        Ln(st, st.return, ye);
                      }
                    }
                  } else if (c.tag === 6) {
                    if (y === null) {
                      st = c;
                      try {
                        var Qt = st.stateNode;
                        z ? k0(Qt) : kp(Qt, st.memoizedProps);
                      } catch (ye) {
                        Ln(st, st.return, ye);
                      }
                    }
                  } else if ((c.tag !== 22 && c.tag !== 23 || c.memoizedState === null || c === l) && c.child !== null) {
                    c.child.return = c, c = c.child;
                    continue;
                  }
                  if (c === l) break t;
                  for (; c.sibling === null; ) {
                    if (c.return === null || c.return === l)
                      break t;
                    y === c && (y = null), c = c.return;
                  }
                  y === c && (y = null), c.sibling.return = c.return, c = c.sibling;
                }
            }
            w & 4 && (w = l.updateQueue, w !== null && (y = w.retryQueue, y !== null && (w.retryQueue = null, xt(l, y))));
            break;
          case 19:
            Dt(c, l), Lt(l), w & 4 && (w = l.updateQueue, w !== null && (l.updateQueue = null, xt(l, w)));
            break;
          case 21:
            break;
          default:
            Dt(c, l), Lt(l);
        }
      }
      function Lt(l) {
        var c = l.flags;
        if (c & 2) {
          try {
            if (vi && (!Er || l.tag !== 27)) {
              t: {
                for (var y = l.return; y !== null; ) {
                  if (Z(y)) {
                    var w = y;
                    break t;
                  }
                  y = y.return;
                }
                throw Error(s(160));
              }
              switch (w.tag) {
                case 27:
                  if (Er) {
                    var z = w.stateNode, F = et(l);
                    mt(
                      l,
                      F,
                      z
                    );
                    break;
                  }
                case 5:
                  var st = w.stateNode;
                  w.flags & 32 && (af(st), w.flags &= -33);
                  var yt = et(l);
                  mt(l, yt, st);
                  break;
                case 3:
                case 4:
                  var Pt = w.stateNode.containerInfo, Qt = et(l);
                  ut(
                    l,
                    Qt,
                    Pt
                  );
                  break;
                default:
                  throw Error(s(161));
              }
            }
          } catch (ye) {
            Ln(l, l.return, ye);
          }
          l.flags &= -3;
        }
        c & 4096 && (l.flags &= -4097);
      }
      function Xt(l) {
        if (l.subtreeFlags & 1024)
          for (l = l.child; l !== null; ) {
            var c = l;
            Xt(c), c.tag === 5 && c.flags & 1024 && v0(c.stateNode), l = l.sibling;
          }
      }
      function de(l, c) {
        if (c.subtreeFlags & 8772)
          for (c = c.child; c !== null; )
            At(l, c.alternate, c), c = c.sibling;
      }
      function Se(l) {
        for (l = l.child; l !== null; ) {
          var c = l;
          switch (c.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              aa(4, c, c.return), Se(c);
              break;
            case 1:
              k(c, c.return);
              var y = c.stateNode;
              typeof y.componentWillUnmount == "function" && zr(
                c,
                c.return,
                y
              ), Se(c);
              break;
            case 26:
            case 27:
            case 5:
              k(c, c.return), Se(c);
              break;
            case 22:
              k(c, c.return), c.memoizedState === null && Se(c);
              break;
            default:
              Se(c);
          }
          l = l.sibling;
        }
      }
      function pe(l, c, y) {
        for (y = y && (c.subtreeFlags & 8772) !== 0, c = c.child; c !== null; ) {
          var w = c.alternate, z = l, F = c, st = F.flags;
          switch (F.tag) {
            case 0:
            case 11:
            case 15:
              pe(
                z,
                F,
                y
              ), Wo(4, F);
              break;
            case 1:
              if (pe(
                z,
                F,
                y
              ), w = F, z = w.stateNode, typeof z.componentDidMount == "function")
                try {
                  z.componentDidMount();
                } catch (Qt) {
                  Ln(w, w.return, Qt);
                }
              if (w = F, z = w.updateQueue, z !== null) {
                var yt = w.stateNode;
                try {
                  var Pt = z.shared.hiddenCallbacks;
                  if (Pt !== null)
                    for (z.shared.hiddenCallbacks = null, z = 0; z < Pt.length; z++)
                      _r(Pt[z], yt);
                } catch (Qt) {
                  Ln(w, w.return, Qt);
                }
              }
              y && st & 64 && zs(F), S(F, F.return);
              break;
            case 26:
            case 27:
            case 5:
              pe(
                z,
                F,
                y
              ), y && w === null && st & 4 && L(F), S(F, F.return);
              break;
            case 12:
              pe(
                z,
                F,
                y
              );
              break;
            case 13:
              pe(
                z,
                F,
                y
              ), y && st & 4 && wt(z, F);
              break;
            case 22:
              F.memoizedState === null && pe(
                z,
                F,
                y
              ), S(F, F.return);
              break;
            default:
              pe(
                z,
                F,
                y
              );
          }
          c = c.sibling;
        }
      }
      function _e(l, c) {
        var y = null;
        l !== null && l.memoizedState !== null && l.memoizedState.cachePool !== null && (y = l.memoizedState.cachePool.pool), l = null, c.memoizedState !== null && c.memoizedState.cachePool !== null && (l = c.memoizedState.cachePool.pool), l !== y && (l != null && l.refCount++, y != null && Vl(y));
      }
      function we(l, c) {
        l = null, c.alternate !== null && (l = c.alternate.memoizedState.cache), c = c.memoizedState.cache, c !== l && (c.refCount++, l != null && Vl(l));
      }
      function be(l, c, y, w) {
        if (c.subtreeFlags & 10256)
          for (c = c.child; c !== null; )
            Ee(
              l,
              c,
              y,
              w
            ), c = c.sibling;
      }
      function Ee(l, c, y, w) {
        var z = c.flags;
        switch (c.tag) {
          case 0:
          case 11:
          case 15:
            be(
              l,
              c,
              y,
              w
            ), z & 2048 && Wo(9, c);
            break;
          case 3:
            be(
              l,
              c,
              y,
              w
            ), z & 2048 && (l = null, c.alternate !== null && (l = c.alternate.memoizedState.cache), c = c.memoizedState.cache, c !== l && (c.refCount++, l != null && Vl(l)));
            break;
          case 12:
            if (z & 2048) {
              be(
                l,
                c,
                y,
                w
              ), l = c.stateNode;
              try {
                var F = c.memoizedProps, st = F.id, yt = F.onPostCommit;
                typeof yt == "function" && yt(
                  st,
                  c.alternate === null ? "mount" : "update",
                  l.passiveEffectDuration,
                  -0
                );
              } catch (Pt) {
                Ln(c, c.return, Pt);
              }
            } else
              be(
                l,
                c,
                y,
                w
              );
            break;
          case 23:
            break;
          case 22:
            F = c.stateNode, c.memoizedState !== null ? F._visibility & 4 ? be(
              l,
              c,
              y,
              w
            ) : qe(
              l,
              c
            ) : F._visibility & 4 ? be(
              l,
              c,
              y,
              w
            ) : (F._visibility |= 4, Be(
              l,
              c,
              y,
              w,
              (c.subtreeFlags & 10256) !== 0
            )), z & 2048 && _e(
              c.alternate,
              c
            );
            break;
          case 24:
            be(
              l,
              c,
              y,
              w
            ), z & 2048 && we(c.alternate, c);
            break;
          default:
            be(
              l,
              c,
              y,
              w
            );
        }
      }
      function Be(l, c, y, w, z) {
        for (z = z && (c.subtreeFlags & 10256) !== 0, c = c.child; c !== null; ) {
          var F = l, st = c, yt = y, Pt = w, Qt = st.flags;
          switch (st.tag) {
            case 0:
            case 11:
            case 15:
              Be(
                F,
                st,
                yt,
                Pt,
                z
              ), Wo(8, st);
              break;
            case 23:
              break;
            case 22:
              var ye = st.stateNode;
              st.memoizedState !== null ? ye._visibility & 4 ? Be(
                F,
                st,
                yt,
                Pt,
                z
              ) : qe(
                F,
                st
              ) : (ye._visibility |= 4, Be(
                F,
                st,
                yt,
                Pt,
                z
              )), z && Qt & 2048 && _e(
                st.alternate,
                st
              );
              break;
            case 24:
              Be(
                F,
                st,
                yt,
                Pt,
                z
              ), z && Qt & 2048 && we(st.alternate, st);
              break;
            default:
              Be(
                F,
                st,
                yt,
                Pt,
                z
              );
          }
          c = c.sibling;
        }
      }
      function qe(l, c) {
        if (c.subtreeFlags & 10256)
          for (c = c.child; c !== null; ) {
            var y = l, w = c, z = w.flags;
            switch (w.tag) {
              case 22:
                qe(y, w), z & 2048 && _e(
                  w.alternate,
                  w
                );
                break;
              case 24:
                qe(y, w), z & 2048 && we(
                  w.alternate,
                  w
                );
                break;
              default:
                qe(y, w);
            }
            c = c.sibling;
          }
      }
      function Ye(l) {
        if (l.subtreeFlags & fc)
          for (l = l.child; l !== null; )
            fr(l), l = l.sibling;
      }
      function fr(l) {
        switch (l.tag) {
          case 26:
            Ye(l), l.flags & fc && (l.memoizedState !== null ? Hp(
              $r,
              l.memoizedState,
              l.memoizedProps
            ) : Rp(l.type, l.memoizedProps));
            break;
          case 5:
            Ye(l), l.flags & fc && Rp(l.type, l.memoizedProps);
            break;
          case 3:
          case 4:
            if (qa) {
              var c = $r;
              $r = mr(
                l.stateNode.containerInfo
              ), Ye(l), $r = c;
            } else Ye(l);
            break;
          case 22:
            l.memoizedState === null && (c = l.alternate, c !== null && c.memoizedState !== null ? (c = fc, fc = 16777216, Ye(l), fc = c) : Ye(l));
            break;
          default:
            Ye(l);
        }
      }
      function Ge(l) {
        var c = l.alternate;
        if (c !== null && (l = c.child, l !== null)) {
          c.child = null;
          do
            c = l.sibling, l.sibling = null, l = c;
          while (l !== null);
        }
      }
      function yi(l) {
        var c = l.deletions;
        if ((l.flags & 16) !== 0) {
          if (c !== null)
            for (var y = 0; y < c.length; y++) {
              var w = c[y];
              Ie = w, ji(
                w,
                l
              );
            }
          Ge(l);
        }
        if (l.subtreeFlags & 10256)
          for (l = l.child; l !== null; )
            ai(l), l = l.sibling;
      }
      function ai(l) {
        switch (l.tag) {
          case 0:
          case 11:
          case 15:
            yi(l), l.flags & 2048 && aa(9, l, l.return);
            break;
          case 3:
            yi(l);
            break;
          case 12:
            yi(l);
            break;
          case 22:
            var c = l.stateNode;
            l.memoizedState !== null && c._visibility & 4 && (l.return === null || l.return.tag !== 13) ? (c._visibility &= -5, uo(l)) : yi(l);
            break;
          default:
            yi(l);
        }
      }
      function uo(l) {
        var c = l.deletions;
        if ((l.flags & 16) !== 0) {
          if (c !== null)
            for (var y = 0; y < c.length; y++) {
              var w = c[y];
              Ie = w, ji(
                w,
                l
              );
            }
          Ge(l);
        }
        for (l = l.child; l !== null; ) {
          switch (c = l, c.tag) {
            case 0:
            case 11:
            case 15:
              aa(8, c, c.return), uo(c);
              break;
            case 22:
              y = c.stateNode, y._visibility & 4 && (y._visibility &= -5, uo(c));
              break;
            default:
              uo(c);
          }
          l = l.sibling;
        }
      }
      function ji(l, c) {
        for (; Ie !== null; ) {
          var y = Ie;
          switch (y.tag) {
            case 0:
            case 11:
            case 15:
              aa(8, y, c);
              break;
            case 23:
            case 22:
              if (y.memoizedState !== null && y.memoizedState.cachePool !== null) {
                var w = y.memoizedState.cachePool.pool;
                w != null && w.refCount++;
              }
              break;
            case 24:
              Vl(y.memoizedState.cache);
          }
          if (w = y.child, w !== null) w.return = y, Ie = w;
          else
            t: for (y = l; Ie !== null; ) {
              w = Ie;
              var z = w.sibling, F = w.return;
              if (gt(w), w === y) {
                Ie = null;
                break t;
              }
              if (z !== null) {
                z.return = F, Ie = z;
                break t;
              }
              Ie = F;
            }
        }
      }
      function Fr(l) {
        var c = ef(l);
        if (c != null) {
          if (typeof c.memoizedProps["data-testname"] != "string")
            throw Error(s(364));
          return c;
        }
        if (l = S0(l), l === null) throw Error(s(362));
        return l.stateNode.current;
      }
      function Il(l, c) {
        var y = l.tag;
        switch (c.$$typeof) {
          case fi:
            if (l.type === c.value) return !0;
            break;
          case Gs:
            t: {
              for (c = c.value, l = [l, 0], y = 0; y < l.length; ) {
                var w = l[y++], z = w.tag, F = l[y++], st = c[F];
                if (z !== 5 && z !== 26 && z !== 27 || !yo(w)) {
                  for (; st != null && Il(w, st); )
                    F++, st = c[F];
                  if (F === c.length) {
                    c = !0;
                    break t;
                  } else
                    for (w = w.child; w !== null; )
                      l.push(w, F), w = w.sibling;
                }
              }
              c = !1;
            }
            return c;
          case To:
            if ((y === 5 || y === 26 || y === 27) && T0(l.stateNode, c.value))
              return !0;
            break;
          case da:
            if ((y === 5 || y === 6 || y === 26 || y === 27) && (l = x0(l), l !== null && 0 <= l.indexOf(c.value)))
              return !0;
            break;
          case yd:
            if ((y === 5 || y === 26 || y === 27) && (l = l.memoizedProps["data-testname"], typeof l == "string" && l.toLowerCase() === c.value.toLowerCase()))
              return !0;
            break;
          default:
            throw Error(s(365));
        }
        return !1;
      }
      function Ta(l) {
        switch (l.$$typeof) {
          case fi:
            return "<" + (u(l.value) || "Unknown") + ">";
          case Gs:
            return ":has(" + (Ta(l) || "") + ")";
          case To:
            return '[role="' + l.value + '"]';
          case da:
            return '"' + l.value + '"';
          case yd:
            return '[data-testname="' + l.value + '"]';
          default:
            throw Error(s(365));
        }
      }
      function ru(l, c) {
        var y = [];
        l = [l, 0];
        for (var w = 0; w < l.length; ) {
          var z = l[w++], F = z.tag, st = l[w++], yt = c[st];
          if (F !== 5 && F !== 26 && F !== 27 || !yo(z)) {
            for (; yt != null && Il(z, yt); )
              st++, yt = c[st];
            if (st === c.length) y.push(z);
            else
              for (z = z.child; z !== null; )
                l.push(z, st), z = z.sibling;
          }
        }
        return y;
      }
      function Fl(l, c) {
        if (!od) throw Error(s(363));
        l = Fr(l), l = ru(l, c), c = [], l = Array.from(l);
        for (var y = 0; y < l.length; ) {
          var w = l[y++], z = w.tag;
          if (z === 5 || z === 26 || z === 27)
            yo(w) || c.push(w.stateNode);
          else
            for (w = w.child; w !== null; )
              l.push(w), w = w.sibling;
        }
        return c;
      }
      function qr() {
        if ((yn & 2) !== 0 && vn !== 0)
          return vn & -vn;
        if (Xe.T !== null) {
          var l = hi;
          return l !== 0 ? l : It();
        }
        return p0();
      }
      function $d() {
        Ya === 0 && (Ya = (vn & 536870912) === 0 || Nn ? j() : 536870912);
        var l = Ma.current;
        return l !== null && (l.flags |= 32), Ya;
      }
      function si(l, c, y) {
        (l === $n && Gn === 2 || l.cancelPendingCommit !== null) && (ql(l, 0), sa(
          l,
          vn,
          Ya,
          !1
        )), G(l, y), ((yn & 2) === 0 || l !== $n) && (l === $n && ((yn & 2) === 0 && (gl |= y), _i === 4 && sa(
          l,
          vn,
          Ya,
          !1
        )), ve(l));
      }
      function Ia(l, c, y) {
        if ((yn & 6) !== 0) throw Error(s(327));
        var w = !y && (c & 60) === 0 && (c & l.expiredLanes) === 0 || U(l, c), z = w ? s0(l, c) : Zd(l, c, !0), F = w;
        do {
          if (z === 0) {
            ps && !w && sa(l, c, 0, !1);
            break;
          } else if (z === 6)
            sa(
              l,
              c,
              0,
              !fs
            );
          else {
            if (y = l.current.alternate, F && !Qo(y)) {
              z = Zd(l, c, !1), F = !1;
              continue;
            }
            if (z === 2) {
              if (F = c, l.errorRecoveryDisabledLanes & F)
                var st = 0;
              else
                st = l.pendingLanes & -536870913, st = st !== 0 ? st : st & 536870912 ? 536870912 : 0;
              if (st !== 0) {
                c = st;
                t: {
                  var yt = l;
                  z = vd;
                  var Pt = wa && yt.current.memoizedState.isDehydrated;
                  if (Pt && (ql(yt, st).flags |= 256), st = Zd(
                    yt,
                    st,
                    !1
                  ), st !== 2) {
                    if (bu && !Pt) {
                      yt.errorRecoveryDisabledLanes |= F, gl |= F, z = 4;
                      break t;
                    }
                    F = gs, gs = z, F !== null && $o(F);
                  }
                  z = st;
                }
                if (F = !1, z !== 2) continue;
              }
            }
            if (z === 1) {
              ql(l, 0), sa(l, c, 0, !0);
              break;
            }
            t: {
              switch (w = l, z) {
                case 0:
                case 1:
                  throw Error(s(345));
                case 4:
                  if ((c & 4194176) === c) {
                    sa(
                      w,
                      c,
                      Ya,
                      !fs
                    );
                    break t;
                  }
                  break;
                case 2:
                  gs = null;
                  break;
                case 3:
                case 5:
                  break;
                default:
                  throw Error(s(329));
              }
              if (w.finishedWork = y, w.finishedLanes = c, (c & 62914560) === c && (F = Zp + 300 - Ga(), 10 < F)) {
                if (sa(
                  w,
                  c,
                  Ya,
                  !fs
                ), N(w, 0) !== 0) break t;
                w.timeoutHandle = tf(
                  ho.bind(
                    null,
                    w,
                    y,
                    gs,
                    _u,
                    _f,
                    c,
                    Ya,
                    gl,
                    er,
                    fs,
                    2,
                    -0,
                    0
                  ),
                  F
                );
                break t;
              }
              ho(
                w,
                y,
                gs,
                _u,
                _f,
                c,
                Ya,
                gl,
                er,
                fs,
                0,
                -0,
                0
              );
            }
          }
          break;
        } while (!0);
        ve(l);
      }
      function $o(l) {
        gs === null ? gs = l : gs.push.apply(
          gs,
          l
        );
      }
      function ho(l, c, y, w, z, F, st, yt, Pt, Qt, ye, Oe, ge) {
        var en = c.subtreeFlags;
        if ((en & 8192 || (en & 16785408) === 16785408) && (bv(), fr(c), c = y0(), c !== null)) {
          l.cancelPendingCommit = c(
            Wh.bind(
              null,
              l,
              y,
              w,
              z,
              st,
              yt,
              Pt,
              1,
              Oe,
              ge
            )
          ), sa(l, F, st, !Qt);
          return;
        }
        Wh(
          l,
          y,
          w,
          z,
          st,
          yt,
          Pt,
          ye,
          Oe,
          ge
        );
      }
      function Qo(l) {
        for (var c = l; ; ) {
          var y = c.tag;
          if ((y === 0 || y === 11 || y === 15) && c.flags & 16384 && (y = c.updateQueue, y !== null && (y = y.stores, y !== null)))
            for (var w = 0; w < y.length; w++) {
              var z = y[w], F = z.getSnapshot;
              z = z.value;
              try {
                if (!la(F(), z)) return !1;
              } catch {
                return !1;
              }
            }
          if (y = c.child, c.subtreeFlags & 16384 && y !== null)
            y.return = c, c = y;
          else {
            if (c === l) break;
            for (; c.sibling === null; ) {
              if (c.return === null || c.return === l) return !0;
              c = c.return;
            }
            c.sibling.return = c.return, c = c.sibling;
          }
        }
        return !0;
      }
      function sa(l, c, y, w) {
        c &= ~ha, c &= ~gl, l.suspendedLanes |= c, l.pingedLanes &= ~c, w && (l.warmLanes |= c), w = l.expirationTimes;
        for (var z = c; 0 < z; ) {
          var F = 31 - Ii(z), st = 1 << F;
          w[F] = -1, z &= ~st;
        }
        y !== 0 && P(l, y, c);
      }
      function _p() {
        return (yn & 6) === 0 ? (Re(0), !1) : !0;
      }
      function Qd() {
        if (dn !== null) {
          if (Gn === 0)
            var l = dn.return;
          else
            l = dn, hs = hc = null, ts(l), gu = null, Wr = 0, l = dn;
          for (; l !== null; )
            co(l.alternate, l), l = l.return;
          dn = null;
        }
      }
      function ql(l, c) {
        l.finishedWork = null, l.finishedLanes = 0;
        var y = l.timeoutHandle;
        y !== sd && (l.timeoutHandle = sd, sh(y)), y = l.cancelPendingCommit, y !== null && (l.cancelPendingCommit = null, y()), Qd(), $n = l, dn = y = Jo(l.current, null), vn = c, Gn = 0, tr = null, fs = !1, ps = U(l, c), bu = !1, er = Ya = ha = gl = ms = _i = 0, gs = vd = null, _f = !1, (c & 8) !== 0 && (c |= c & 32);
        var w = l.entangledLanes;
        if (w !== 0)
          for (l = l.entanglements, w &= c; 0 < w; ) {
            var z = 31 - Ii(w), F = 1 << z;
            c |= l[z], w &= ~F;
          }
        return Hs = c, ce(), y;
      }
      function Gr(l, c) {
        Je = null, Xe.H = Hi, c === hh ? (c = Wi(), Gn = 3) : c === fh ? (c = Wi(), Gn = 4) : Gn = c === $p ? 8 : c !== null && typeof c == "object" && typeof c.then == "function" ? 6 : 1, tr = c, dn === null && (_i = 1, Bl(
          l,
          nt(c, l.current)
        ));
      }
      function wr() {
        var l = Ma.current;
        return l === null ? !0 : (vn & 4194176) === vn ? us === null : (vn & 62914560) === vn || (vn & 536870912) !== 0 ? l === us : !1;
      }
      function On() {
        var l = Xe.H;
        return Xe.H = Hi, l === null ? Hi : l;
      }
      function ss() {
        var l = Xe.A;
        return Xe.A = ml, l;
      }
      function os() {
        _i = 4, fs || (vn & 4194176) !== vn && Ma.current !== null || (ps = !0), (ms & 134217727) === 0 && (gl & 134217727) === 0 || $n === null || sa(
          $n,
          vn,
          Ya,
          !1
        );
      }
      function Zd(l, c, y) {
        var w = yn;
        yn |= 2;
        var z = On(), F = ss();
        ($n !== l || vn !== c) && (_u = null, ql(l, c)), c = !1;
        var st = _i;
        t: do
          try {
            if (Gn !== 0 && dn !== null) {
              var yt = dn, Pt = tr;
              switch (Gn) {
                case 8:
                  Qd(), st = 6;
                  break t;
                case 3:
                case 2:
                case 6:
                  Ma.current === null && (c = !0);
                  var Qt = Gn;
                  if (Gn = 0, tr = null, fo(l, yt, Pt, Qt), y && ps) {
                    st = 0;
                    break t;
                  }
                  break;
                default:
                  Qt = Gn, Gn = 0, tr = null, fo(l, yt, Pt, Qt);
              }
            }
            au(), st = _i;
            break;
          } catch (ye) {
            Gr(l, ye);
          }
        while (!0);
        return c && l.shellSuspendCounter++, hs = hc = null, yn = w, Xe.H = z, Xe.A = F, dn === null && ($n = null, vn = 0, ce()), st;
      }
      function au() {
        for (; dn !== null; ) Ju(dn);
      }
      function s0(l, c) {
        var y = yn;
        yn |= 2;
        var w = On(), z = ss();
        $n !== l || vn !== c ? (_u = null, Xa = Ga() + 500, ql(l, c)) : ps = U(
          l,
          c
        );
        t: do
          try {
            if (Gn !== 0 && dn !== null) {
              c = dn;
              var F = tr;
              e: switch (Gn) {
                case 1:
                  Gn = 0, tr = null, fo(l, c, F, 1);
                  break;
                case 2:
                  if (Rn(F)) {
                    Gn = 0, tr = null, td(c);
                    break;
                  }
                  c = function() {
                    Gn === 2 && $n === l && (Gn = 7), ve(l);
                  }, F.then(c, c);
                  break t;
                case 3:
                  Gn = 7;
                  break t;
                case 4:
                  Gn = 5;
                  break t;
                case 7:
                  Rn(F) ? (Gn = 0, tr = null, td(c)) : (Gn = 0, tr = null, fo(l, c, F, 7));
                  break;
                case 5:
                  var st = null;
                  switch (dn.tag) {
                    case 26:
                      st = dn.memoizedState;
                    case 5:
                    case 27:
                      var yt = dn, Pt = yt.type, Qt = yt.pendingProps;
                      if (st ? Gp(st) : Mp(Pt, Qt)) {
                        Gn = 0, tr = null;
                        var ye = yt.sibling;
                        if (ye !== null) dn = ye;
                        else {
                          var Oe = yt.return;
                          Oe !== null ? (dn = Oe, Gl(Oe)) : dn = null;
                        }
                        break e;
                      }
                  }
                  Gn = 0, tr = null, fo(l, c, F, 5);
                  break;
                case 6:
                  Gn = 0, tr = null, fo(l, c, F, 6);
                  break;
                case 8:
                  Qd(), _i = 6;
                  break t;
                default:
                  throw Error(s(462));
              }
            }
            o0();
            break;
          } catch (ge) {
            Gr(l, ge);
          }
        while (!0);
        return hs = hc = null, Xe.H = w, Xe.A = z, yn = y, dn !== null ? 0 : ($n = null, vn = 0, ce(), _i);
      }
      function o0() {
        for (; dn !== null && !rc(); )
          Ju(dn);
      }
      function Ju(l) {
        var c = Qu(
          l.alternate,
          l,
          Hs
        );
        l.memoizedProps = l.pendingProps, c === null ? Gl(l) : dn = c;
      }
      function td(l) {
        var c = l, y = c.alternate;
        switch (c.tag) {
          case 15:
          case 0:
            c = Yu(
              y,
              c,
              c.pendingProps,
              c.type,
              void 0,
              vn
            );
            break;
          case 11:
            c = Yu(
              y,
              c,
              c.pendingProps,
              c.type.render,
              c.ref,
              vn
            );
            break;
          case 5:
            ts(c);
          default:
            co(y, c), c = dn = su(c, Hs), c = Qu(y, c, Hs);
        }
        l.memoizedProps = l.pendingProps, c === null ? Gl(l) : dn = c;
      }
      function fo(l, c, y, w) {
        hs = hc = null, ts(c), gu = null, Wr = 0;
        var z = c.return;
        try {
          if (Hh(
            l,
            z,
            c,
            y,
            vn
          )) {
            _i = 1, Bl(
              l,
              nt(y, l.current)
            ), dn = null;
            return;
          }
        } catch (F) {
          if (z !== null) throw dn = z, F;
          _i = 1, Bl(
            l,
            nt(y, l.current)
          ), dn = null;
          return;
        }
        c.flags & 32768 ? (Nn || w === 1 ? l = !0 : ps || (vn & 536870912) !== 0 ? l = !1 : (fs = l = !0, (w === 2 || w === 3 || w === 6) && (w = Ma.current, w !== null && w.tag === 13 && (w.flags |= 16384))), Sp(c, l)) : Gl(c);
      }
      function Gl(l) {
        var c = l;
        do {
          if ((c.flags & 32768) !== 0) {
            Sp(
              c,
              fs
            );
            return;
          }
          l = c.return;
          var y = Zu(
            c.alternate,
            c,
            Hs
          );
          if (y !== null) {
            dn = y;
            return;
          }
          if (c = c.sibling, c !== null) {
            dn = c;
            return;
          }
          dn = c = l;
        } while (c !== null);
        _i === 0 && (_i = 5);
      }
      function Sp(l, c) {
        do {
          var y = Xh(l.alternate, l);
          if (y !== null) {
            y.flags &= 32767, dn = y;
            return;
          }
          if (y = l.return, y !== null && (y.flags |= 32768, y.subtreeFlags = 0, y.deletions = null), !c && (l = l.sibling, l !== null)) {
            dn = l;
            return;
          }
          dn = l = y;
        } while (l !== null);
        _i = 6, dn = null;
      }
      function Wh(l, c, y, w, z, F, st, yt, Pt, Qt) {
        var ye = Xe.T, Oe = ec();
        try {
          oa(2), Xe.T = null, l0(
            l,
            c,
            y,
            w,
            Oe,
            z,
            F,
            st,
            yt,
            Pt,
            Qt
          );
        } finally {
          Xe.T = ye, oa(Oe);
        }
      }
      function l0(l, c, y, w, z, F, st, yt) {
        do
          Hl();
        while (pc !== null);
        if ((yn & 6) !== 0) throw Error(s(327));
        var Pt = l.finishedWork;
        if (w = l.finishedLanes, Pt === null) return null;
        if (l.finishedWork = null, l.finishedLanes = 0, Pt === l.current) throw Error(s(177));
        l.callbackNode = null, l.callbackPriority = 0, l.cancelPendingCommit = null;
        var Qt = Pt.lanes | Pt.childLanes;
        if (Qt |= Is, W(
          l,
          w,
          Qt,
          F,
          st,
          yt
        ), l === $n && (dn = $n = null, vn = 0), (Pt.subtreeFlags & 10256) === 0 && (Pt.flags & 10256) === 0 || yl || (yl = !0, Sf = Qt, yh = y, c0(ud, function() {
          return Hl(), null;
        })), y = (Pt.flags & 15990) !== 0, (Pt.subtreeFlags & 15990) !== 0 || y ? (y = Xe.T, Xe.T = null, F = ec(), oa(2), st = yn, yn |= 4, St(l, Pt), Ft(Pt, l), vv(l.containerInfo), l.current = Pt, At(l, Pt.alternate, Pt), ol(), yn = st, oa(F), Xe.T = y) : l.current = Pt, yl ? (yl = !1, pc = l, bd = w) : Jd(l, Qt), Qt = l.pendingLanes, Qt === 0 && (wo = null), K(Pt.stateNode), ve(l), c !== null)
          for (z = l.onRecoverableError, Pt = 0; Pt < c.length; Pt++)
            Qt = c[Pt], z(Qt.value, {
              componentStack: Qt.stack
            });
        return (bd & 3) !== 0 && Hl(), Qt = l.pendingLanes, (w & 4194218) !== 0 && (Qt & 42) !== 0 ? l === Jp ? Su++ : (Su = 0, Jp = l) : Su = 0, Re(0), null;
      }
      function Jd(l, c) {
        (l.pooledCacheLanes &= c) === 0 && (c = l.pooledCache, c != null && (l.pooledCache = null, Vl(c)));
      }
      function Hl() {
        if (pc !== null) {
          var l = pc, c = Sf;
          Sf = 0;
          var y = I(bd), w = 32 > y ? 32 : y;
          y = Xe.T;
          var z = ec();
          try {
            if (oa(w), Xe.T = null, pc === null)
              var F = !1;
            else {
              w = yh, yh = null;
              var st = pc, yt = bd;
              if (pc = null, bd = 0, (yn & 6) !== 0)
                throw Error(s(331));
              var Pt = yn;
              if (yn |= 4, ai(st.current), Ee(
                st,
                st.current,
                yt,
                w
              ), yn = Pt, Re(0, !1), Zi && typeof Zi.onPostCommitFiberRoot == "function")
                try {
                  Zi.onPostCommitFiberRoot(dd, st);
                } catch {
                }
              F = !0;
            }
            return F;
          } finally {
            oa(z), Xe.T = y, Jd(l, c);
          }
        }
        return !1;
      }
      function ed(l, c, y) {
        c = nt(y, c), c = Pl(l.stateNode, c, 2), l = Me(l, c, 2), l !== null && (G(l, 2), ve(l));
      }
      function Ln(l, c, y) {
        if (l.tag === 3)
          ed(l, l, y);
        else
          for (; c !== null; ) {
            if (c.tag === 3) {
              ed(
                c,
                l,
                y
              );
              break;
            } else if (c.tag === 1) {
              var w = c.stateNode;
              if (typeof c.type.getDerivedStateFromError == "function" || typeof w.componentDidCatch == "function" && (wo === null || !wo.has(w))) {
                l = nt(y, l), y = Yc(2), w = Me(c, y, 2), w !== null && (Ku(
                  y,
                  w,
                  c,
                  l
                ), G(w, 2), ve(w));
                break;
              }
            }
            c = c.return;
          }
      }
      function Kl(l, c, y) {
        var w = l.pingCache;
        if (w === null) {
          w = l.pingCache = new gh();
          var z = /* @__PURE__ */ new Set();
          w.set(c, z);
        } else
          z = w.get(c), z === void 0 && (z = /* @__PURE__ */ new Set(), w.set(c, z));
        z.has(y) || (bu = !0, z.add(y), l = th.bind(null, l, c, y), c.then(l, l));
      }
      function th(l, c, y) {
        var w = l.pingCache;
        w !== null && w.delete(c), l.pingedLanes |= l.suspendedLanes & y, l.warmLanes &= ~y, $n === l && (vn & y) === y && (_i === 4 || _i === 3 && (vn & 62914560) === vn && 300 > Ga() - Zp ? (yn & 2) === 0 && ql(l, 0) : ha |= y, er === vn && (er = 0)), ve(l);
      }
      function eh(l, c) {
        c === 0 && (c = V()), l = re(l, c), l !== null && (G(l, c), ve(l));
      }
      function nh(l) {
        var c = l.memoizedState, y = 0;
        c !== null && (y = c.retryLane), eh(l, y);
      }
      function $h(l, c) {
        var y = 0;
        switch (l.tag) {
          case 13:
            var w = l.stateNode, z = l.memoizedState;
            z !== null && (y = z.retryLane);
            break;
          case 19:
            w = l.stateNode;
            break;
          case 22:
            w = l.stateNode._retryCache;
            break;
          default:
            throw Error(s(314));
        }
        w !== null && w.delete(c), eh(l, y);
      }
      function c0(l, c) {
        return bo(l, c);
      }
      function u0(l, c, y, w) {
        this.tag = l, this.key = y, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = c, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = w, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
      }
      function Zo(l) {
        return l = l.prototype, !(!l || !l.isReactComponent);
      }
      function Jo(l, c) {
        var y = l.alternate;
        return y === null ? (y = n(
          l.tag,
          c,
          l.key,
          l.mode
        ), y.elementType = l.elementType, y.type = l.type, y.stateNode = l.stateNode, y.alternate = l, l.alternate = y) : (y.pendingProps = c, y.type = l.type, y.flags = 0, y.subtreeFlags = 0, y.deletions = null), y.flags = l.flags & 31457280, y.childLanes = l.childLanes, y.lanes = l.lanes, y.child = l.child, y.memoizedProps = l.memoizedProps, y.memoizedState = l.memoizedState, y.updateQueue = l.updateQueue, c = l.dependencies, y.dependencies = c === null ? null : {
          lanes: c.lanes,
          firstContext: c.firstContext
        }, y.sibling = l.sibling, y.index = l.index, y.ref = l.ref, y.refCleanup = l.refCleanup, y;
      }
      function su(l, c) {
        l.flags &= 31457282;
        var y = l.alternate;
        return y === null ? (l.childLanes = 0, l.lanes = c, l.child = null, l.subtreeFlags = 0, l.memoizedProps = null, l.memoizedState = null, l.updateQueue = null, l.dependencies = null, l.stateNode = null) : (l.childLanes = y.childLanes, l.lanes = y.lanes, l.child = y.child, l.subtreeFlags = 0, l.deletions = null, l.memoizedProps = y.memoizedProps, l.memoizedState = y.memoizedState, l.updateQueue = y.updateQueue, l.type = y.type, c = y.dependencies, l.dependencies = c === null ? null : {
          lanes: c.lanes,
          firstContext: c.firstContext
        }), l;
      }
      function ou(l, c, y, w, z, F) {
        var st = 0;
        if (w = l, typeof l == "function") Zo(l) && (st = 1);
        else if (typeof l == "string")
          st = qa && Er ? pr(l, y, Fi.current) ? 26 : df(l) ? 27 : 5 : qa ? pr(
            l,
            y,
            Fi.current
          ) ? 26 : 5 : Er && df(l) ? 27 : 5;
        else
          t: switch (l) {
            case Wl:
              return Yl(
                y.children,
                z,
                F,
                c
              );
            case lu:
              st = 8, z |= 24;
              break;
            case $l:
              return l = n(12, y, c, z | 2), l.elementType = $l, l.lanes = F, l;
            case nl:
              return l = n(13, y, c, z), l.elementType = nl, l.lanes = F, l;
            case rh:
              return l = n(19, y, c, z), l.elementType = rh, l.lanes = F, l;
            case rl:
              return Qh(y, z, F, c);
            default:
              if (typeof l == "object" && l !== null)
                switch (l.$$typeof) {
                  case gv:
                  case Ql:
                    st = 10;
                    break t;
                  case Cp:
                    st = 9;
                    break t;
                  case Zh:
                    st = 11;
                    break t;
                  case id:
                    st = 14;
                    break t;
                  case il:
                    st = 16, w = null;
                    break t;
                }
              st = 29, y = Error(
                s(
                  130,
                  l === null ? "null" : typeof l,
                  ""
                )
              ), w = null;
          }
        return c = n(st, y, c, z), c.elementType = l, c.type = w, c.lanes = F, c;
      }
      function Yl(l, c, y, w) {
        return l = n(7, l, w, c), l.lanes = y, l;
      }
      function Qh(l, c, y, w) {
        l = n(22, l, w, c), l.elementType = rl, l.lanes = y;
        var z = {
          _visibility: 1,
          _pendingVisibility: 1,
          _pendingMarkers: null,
          _retryCache: null,
          _transitions: null,
          _current: null,
          detach: function() {
            var F = z._current;
            if (F === null) throw Error(s(456));
            if ((z._pendingVisibility & 2) === 0) {
              var st = re(F, 2);
              st !== null && (z._pendingVisibility |= 2, si(st, F, 2));
            }
          },
          attach: function() {
            var F = z._current;
            if (F === null) throw Error(s(456));
            if ((z._pendingVisibility & 2) !== 0) {
              var st = re(F, 2);
              st !== null && (z._pendingVisibility &= -3, si(st, F, 2));
            }
          }
        };
        return l.stateNode = z, l;
      }
      function ih(l, c, y) {
        return l = n(6, l, null, c), l.lanes = y, l;
      }
      function Ca(l, c, y) {
        return c = n(
          4,
          l.children !== null ? l.children : [],
          l.key,
          c
        ), c.lanes = y, c.stateNode = {
          containerInfo: l.containerInfo,
          pendingChildren: null,
          implementation: l.implementation
        }, c;
      }
      function po(l, c, y, w, z, F, st, yt) {
        this.tag = 1, this.containerInfo = l, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = sd, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = D(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.finishedLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = D(0), this.hiddenUpdates = D(null), this.identifierPrefix = w, this.onUncaughtError = z, this.onCaughtError = F, this.onRecoverableError = st, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = yt, this.incompleteTransitions = /* @__PURE__ */ new Map();
      }
      function tl(l, c, y, w, z, F, st, yt, Pt, Qt, ye, Oe) {
        return l = new po(
          l,
          c,
          y,
          st,
          yt,
          Pt,
          Qt,
          Oe
        ), c = 1, F === !0 && (c |= 24), F = n(3, null, null, c), l.current = F, F.stateNode = l, c = Ds(), c.refCount++, l.pooledCache = c, c.refCount++, F.memoizedState = {
          element: w,
          isDehydrated: y,
          cache: c
        }, ae(F), l;
      }
      function xp(l) {
        return l ? (l = pu, l) : pu;
      }
      function el(l) {
        var c = l._reactInternals;
        if (c === void 0)
          throw typeof l.render == "function" ? Error(s(188)) : (l = Object.keys(l).join(","), Error(s(268, l)));
        return l = b(c), l = l !== null ? _(l) : null, l === null ? null : cu(l.stateNode);
      }
      function mo(l, c, y, w, z, F) {
        z = xp(z), w.context === null ? w.context = z : w.pendingContext = z, w = fe(c), w.payload = { element: y }, F = F === void 0 ? null : F, F !== null && (w.callback = F), y = Me(l, w, c), y !== null && (si(y, l, c), Te(y, l, c));
      }
      function $i(l, c) {
        if (l = l.memoizedState, l !== null && l.dehydrated !== null) {
          var y = l.retryLane;
          l.retryLane = y !== 0 && y < c ? y : c;
        }
      }
      function nd(l, c) {
        $i(l, c), (l = l.alternate) && $i(l, c);
      }
      var gn = {}, mv = C1(), Fa = b2(), Li = Object.assign, Tp = Symbol.for("react.element"), Xl = Symbol.for("react.transitional.element"), go = Symbol.for("react.portal"), Wl = Symbol.for("react.fragment"), lu = Symbol.for("react.strict_mode"), $l = Symbol.for("react.profiler"), gv = Symbol.for("react.provider"), Cp = Symbol.for("react.consumer"), Ql = Symbol.for("react.context"), Zh = Symbol.for("react.forward_ref"), nl = Symbol.for("react.suspense"), rh = Symbol.for("react.suspense_list"), id = Symbol.for("react.memo"), il = Symbol.for("react.lazy"), rl = Symbol.for("react.offscreen"), un = Symbol.for("react.memo_cache_sentinel"), qn = Symbol.iterator, Qi = Symbol.for("react.client.reference"), Xe = mv.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, Zl, Jl, rd = !1, tc = Array.isArray, ad = t.rendererVersion, yv = t.rendererPackageName, Ni = t.extraDevToolsConfig, cu = t.getPublicInstance, wp = t.getRootHostContext, d0 = t.getChildHostContext, h0 = t.prepareForCommit, vv = t.resetAfterCommit, Ep = t.createInstance, ah = t.appendInitialChild, Jh = t.finalizeInitialChildren, Pr = t.shouldSetTextContent, Vi = t.createTextInstance, tf = t.scheduleTimeout, sh = t.cancelTimeout, sd = t.noTimeout, Ps = t.isPrimaryRenderer;
      t.warnsIfNotActing;
      var vi = t.supportsMutation, Us = t.supportsPersistence, wa = t.supportsHydration, ef = t.getInstanceFromNode;
      t.beforeActiveInstanceBlur, t.afterActiveInstanceBlur;
      var f0 = t.preparePortalMount;
      t.prepareScopeUpdate, t.getInstanceFromScope;
      var oa = t.setCurrentUpdatePriority, ec = t.getCurrentUpdatePriority, p0 = t.resolveUpdatePriority;
      t.resolveEventType, t.resolveEventTimeStamp;
      var m0 = t.shouldAttemptEagerTransition, g0 = t.detachDeletedInstance;
      t.requestPostPaintCallback;
      var Ap = t.maySuspendCommit, Mp = t.preloadInstance, bv = t.startSuspendingCommit, Rp = t.suspendInstance, y0 = t.waitForCommitToBeReady, uu = t.NotPendingTransition, al = t.HostTransitionContext, v0 = t.resetFormInstance;
      t.bindToConsole;
      var b0 = t.supportsMicrotasks, _0 = t.scheduleMicrotask, od = t.supportsTestSelectors, S0 = t.findFiberRoot, _v = t.getBoundingRect, x0 = t.getTextContent, yo = t.isHiddenSubtree, T0 = t.matchAccessibilityRole, nf = t.setFocusIfFocusable, rf = t.setupIntersectionObserver, C0 = t.appendChild, Op = t.appendChildToContainer, w0 = t.commitTextUpdate, E0 = t.commitMount, A0 = t.commitUpdate, M0 = t.insertBefore, Np = t.insertInContainerBefore, R0 = t.removeChild, O0 = t.removeChildFromContainer, af = t.resetTextContent, N0 = t.hideInstance, k0 = t.hideTextInstance, Sv = t.unhideInstance, kp = t.unhideTextInstance, D0 = t.clearContainer, B0 = t.cloneInstance, sf = t.createContainerChildSet, Dp = t.appendChildToContainerChildSet, z0 = t.finalizeContainerChildren, P0 = t.replaceContainerChildren, U0 = t.cloneHiddenInstance, Bp = t.cloneHiddenTextInstance, du = t.isSuspenseInstancePending, oh = t.isSuspenseInstanceFallback, of = t.getSuspenseInstanceFallbackErrorDetails, j0 = t.registerSuspenseInstanceRetry, L0 = t.canHydrateFormStateMarker, vo = t.isFormStateMarkerMatching, nc = t.getNextHydratableSibling, sl = t.getFirstHydratableChild, hu = t.getFirstHydratableChildWithinContainer, zp = t.getFirstHydratableChildWithinSuspenseInstance, Pp = t.canHydrateInstance, V0 = t.canHydrateTextInstance, I0 = t.canHydrateSuspenseInstance, fu = t.hydrateInstance, lf = t.hydrateTextInstance, F0 = t.hydrateSuspenseInstance, q0 = t.getNextHydratableInstanceAfterSuspenseInstance, G0 = t.commitHydratedContainer, cf = t.commitHydratedSuspenseInstance, H0 = t.clearSuspenseBoundary, Up = t.clearSuspenseBoundaryFromContainer, jp = t.shouldDeleteUnhydratedTailInstances;
      t.diffHydratedPropsForDevWarnings, t.diffHydratedTextForDevWarnings, t.describeHydratableInstanceForDevWarnings;
      var K0 = t.validateHydratableInstance, xv = t.validateHydratableTextInstance, qa = t.supportsResources, pr = t.isHostHoistableType, mr = t.getHoistableRoot, Lp = t.getResource, Vp = t.acquireResource, Ip = t.releaseResource, Y0 = t.hydrateHoistable, Fp = t.mountHoistable, ld = t.unmountHoistable, qp = t.createHoistableInstance, X0 = t.prepareToCommitHoistables, W0 = t.mayResourceSuspendCommit, Gp = t.preloadResource, Hp = t.suspendResource, Er = t.supportsSingletons, uf = t.resolveSingletonInstance, $0 = t.clearSingleton, Kp = t.acquireSingletonInstance, Yp = t.releaseSingletonInstance, df = t.isHostSingletonType, hf = [], ic = -1, pu = {}, Ii = Math.clz32 ? Math.clz32 : E, Xp = Math.log, Tv = Math.LN2, lh = 128, cd = 4194304, bo = Fa.unstable_scheduleCallback, js = Fa.unstable_cancelCallback, rc = Fa.unstable_shouldYield, ol = Fa.unstable_requestPaint, Ga = Fa.unstable_now, ff = Fa.unstable_ImmediatePriority, ch = Fa.unstable_UserBlockingPriority, ud = Fa.unstable_NormalPriority, mu = Fa.unstable_IdlePriority, Hr = Fa.log, pf = Fa.unstable_setDisableYieldValue, dd = null, Zi = null, la = typeof Object.is == "function" ? Object.is : it, mf = /* @__PURE__ */ new WeakMap(), Ha = [], Ka = 0, ac = null, hd = 0, Ea = [], Kr = 0, Ls = null, _o = 1, So = "", Fi = A(null), ls = A(null), ll = A(null), uh = A(null), qi = null, Xn = null, Nn = !1, cs = null, Vs = !1, dh = Error(s(519)), Aa = [], cl = 0, Is = 0, di = null, sc = null, gf = !1, Gi = !1, yf = !1, fd = 0, pd = null, vf = 0, hi = 0, Ar = null, Yr = !1, bf = !1, Q0 = Object.prototype.hasOwnProperty, hh = Error(s(460)), fh = Error(s(474)), ca = { then: function() {
      } }, Xr = null, gu = null, Wr = 0, oc = to(!0), xo = to(!1), Fs = A(null), qs = A(0), Ma = A(null), us = null, oi = A(0), ul = 0, Je = null, Dn = null, bi = null, dl = !1, yu = !1, lc = !1, cc = 0, md = 0, hl = null, Z0 = 0, Wp = function() {
        return { lastEffect: null, events: null, stores: null, memoCache: null };
      }, Hi = {
        readContext: dr,
        use: Pn,
        useCallback: rn,
        useContext: rn,
        useEffect: rn,
        useImperativeHandle: rn,
        useLayoutEffect: rn,
        useInsertionEffect: rn,
        useMemo: rn,
        useReducer: rn,
        useRef: rn,
        useState: rn,
        useDebugValue: rn,
        useDeferredValue: rn,
        useTransition: rn,
        useSyncExternalStore: rn,
        useId: rn
      };
      Hi.useCacheRefresh = rn, Hi.useMemoCache = rn, Hi.useHostTransitionStatus = rn, Hi.useFormState = rn, Hi.useActionState = rn, Hi.useOptimistic = rn;
      var fl = {
        readContext: dr,
        use: Pn,
        useCallback: function(l, c) {
          return wi().memoizedState = [
            l,
            c === void 0 ? null : c
          ], l;
        },
        useContext: dr,
        useEffect: Hd,
        useImperativeHandle: function(l, c, y) {
          y = y != null ? y.concat([l]) : null, Ol(
            4194308,
            4,
            Sa.bind(null, c, l),
            y
          );
        },
        useLayoutEffect: function(l, c) {
          return Ol(4194308, 4, l, c);
        },
        useInsertionEffect: function(l, c) {
          Ol(4, 2, l, c);
        },
        useMemo: function(l, c) {
          var y = wi();
          c = c === void 0 ? null : c;
          var w = l();
          if (lc) {
            Q(!0);
            try {
              l();
            } finally {
              Q(!1);
            }
          }
          return y.memoizedState = [w, c], w;
        },
        useReducer: function(l, c, y) {
          var w = wi();
          if (y !== void 0) {
            var z = y(c);
            if (lc) {
              Q(!0);
              try {
                y(c);
              } finally {
                Q(!1);
              }
            }
          } else z = c;
          return w.memoizedState = w.baseState = z, l = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: l,
            lastRenderedState: z
          }, w.queue = l, l = l.dispatch = kl.bind(
            null,
            Je,
            l
          ), [w.memoizedState, l];
        },
        useRef: function(l) {
          var c = wi();
          return l = { current: l }, c.memoizedState = l;
        },
        useState: function(l) {
          l = _a(l);
          var c = l.queue, y = Lo.bind(
            null,
            Je,
            c
          );
          return c.dispatch = y, [l.memoizedState, y];
        },
        useDebugValue: Nl,
        useDeferredValue: function(l, c) {
          var y = wi();
          return ao(y, l, c);
        },
        useTransition: function() {
          var l = _a(!1);
          return l = qc.bind(
            null,
            Je,
            l.queue,
            !0,
            !1
          ), wi().memoizedState = l, [!1, l];
        },
        useSyncExternalStore: function(l, c, y) {
          var w = Je, z = wi();
          if (Nn) {
            if (y === void 0)
              throw Error(s(407));
            y = y();
          } else {
            if (y = c(), $n === null)
              throw Error(s(349));
            (vn & 60) !== 0 || Fu(w, c, y);
          }
          z.memoizedState = y;
          var F = { value: y, getSnapshot: c };
          return z.queue = F, Hd(Gd.bind(null, w, F, l), [
            l
          ]), w.flags |= 2048, Uo(
            9,
            El.bind(
              null,
              w,
              F,
              y,
              c
            ),
            { destroy: void 0 },
            null
          ), y;
        },
        useId: function() {
          var l = wi(), c = $n.identifierPrefix;
          if (Nn) {
            var y = So, w = _o;
            y = (w & ~(1 << 32 - Ii(w) - 1)).toString(32) + y, c = ":" + c + "R" + y, y = cc++, 0 < y && (c += "H" + y.toString(32)), c += ":";
          } else
            y = Z0++, c = ":" + c + "r" + y.toString(32) + ":";
          return l.memoizedState = c;
        },
        useCacheRefresh: function() {
          return wi().memoizedState = Hu.bind(
            null,
            Je
          );
        }
      };
      fl.useMemoCache = Uc, fl.useHostTransitionStatus = Gc, fl.useFormState = jc, fl.useActionState = jc, fl.useOptimistic = function(l) {
        var c = wi();
        c.memoizedState = c.baseState = l;
        var y = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: null,
          lastRenderedState: null
        };
        return c.queue = y, c = Vo.bind(
          null,
          Je,
          !0,
          y
        ), y.dispatch = c, [l, c];
      };
      var ua = {
        readContext: dr,
        use: Pn,
        useCallback: ni,
        useContext: dr,
        useEffect: cr,
        useImperativeHandle: Fc,
        useInsertionEffect: jo,
        useLayoutEffect: Ic,
        useMemo: Cr,
        useReducer: na,
        useRef: cn,
        useState: function() {
          return na(kr);
        },
        useDebugValue: Nl,
        useDeferredValue: function(l, c) {
          var y = $e();
          return so(
            y,
            Dn.memoizedState,
            l,
            c
          );
        },
        useTransition: function() {
          var l = na(kr)[0], c = $e().memoizedState;
          return [
            typeof l == "boolean" ? l : xr(l),
            c
          ];
        },
        useSyncExternalStore: no,
        useId: Dr
      };
      ua.useCacheRefresh = ja, ua.useMemoCache = Uc, ua.useHostTransitionStatus = Gc, ua.useFormState = Rl, ua.useActionState = Rl, ua.useOptimistic = function(l, c) {
        var y = $e();
        return Ir(y, Dn, l, c);
      };
      var uc = {
        readContext: dr,
        use: Pn,
        useCallback: ni,
        useContext: dr,
        useEffect: cr,
        useImperativeHandle: Fc,
        useInsertionEffect: jo,
        useLayoutEffect: Ic,
        useMemo: Cr,
        useReducer: ia,
        useRef: cn,
        useState: function() {
          return ia(kr);
        },
        useDebugValue: Nl,
        useDeferredValue: function(l, c) {
          var y = $e();
          return Dn === null ? ao(y, l, c) : so(
            y,
            Dn.memoizedState,
            l,
            c
          );
        },
        useTransition: function() {
          var l = ia(kr)[0], c = $e().memoizedState;
          return [
            typeof l == "boolean" ? l : xr(l),
            c
          ];
        },
        useSyncExternalStore: no,
        useId: Dr
      };
      uc.useCacheRefresh = ja, uc.useMemoCache = Uc, uc.useHostTransitionStatus = Gc, uc.useFormState = Gu, uc.useActionState = Gu, uc.useOptimistic = function(l, c) {
        var y = $e();
        return Dn !== null ? Ir(y, Dn, l, c) : (y.baseState = l, [l, y.queue.dispatch]);
      };
      var gd = {
        isMounted: function(l) {
          return (l = l._reactInternals) ? v(l) === l : !1;
        },
        enqueueSetState: function(l, c, y) {
          l = l._reactInternals;
          var w = qr(), z = fe(w);
          z.payload = c, y != null && (z.callback = y), c = Me(l, z, w), c !== null && (si(c, l, w), Te(c, l, w));
        },
        enqueueReplaceState: function(l, c, y) {
          l = l._reactInternals;
          var w = qr(), z = fe(w);
          z.tag = 1, z.payload = c, y != null && (z.callback = y), c = Me(l, z, w), c !== null && (si(c, l, w), Te(c, l, w));
        },
        enqueueForceUpdate: function(l, c) {
          l = l._reactInternals;
          var y = qr(), w = fe(y);
          w.tag = 2, c != null && (w.callback = c), c = Me(l, w, y), c !== null && (si(c, l, y), Te(c, l, y));
        }
      }, dc = typeof reportError == "function" ? reportError : function(l) {
        if (typeof window == "object" && typeof window.ErrorEvent == "function") {
          var c = new window.ErrorEvent("error", {
            bubbles: !0,
            cancelable: !0,
            message: typeof l == "object" && l !== null && typeof l.message == "string" ? String(l.message) : String(l),
            error: l
          });
          if (!window.dispatchEvent(c)) return;
        } else if (typeof process == "object" && typeof process.emit == "function") {
          process.emit("uncaughtException", l);
          return;
        }
        console.error(l);
      }, $p = Error(s(461)), Ji = !1, ph = { dehydrated: null, treeContext: null, retryLane: 0 }, ds = A(null), hc = null, hs = null, mh = typeof AbortController < "u" ? AbortController : function() {
        var l = [], c = this.signal = {
          aborted: !1,
          addEventListener: function(y, w) {
            l.push(w);
          }
        };
        this.abort = function() {
          c.aborted = !0, l.forEach(function(y) {
            return y();
          });
        };
      }, Ei = Fa.unstable_scheduleCallback, Cv = Fa.unstable_NormalPriority, ki = {
        $$typeof: Ql,
        Consumer: null,
        Provider: null,
        _currentValue: null,
        _currentValue2: null,
        _threadCount: 0
      }, Qp = Xe.S;
      Xe.S = function(l, c) {
        typeof c == "object" && c !== null && typeof c.then == "function" && Ht(l, c), Qp !== null && Qp(l, c);
      };
      var vu = A(null), pl = !1, tn = !1, Wn = !1, pn = typeof WeakSet == "function" ? WeakSet : Set, Ie = null, Jn = !1, Bn = null, Ki = !1, $r = null, fc = 8192, ml = {
        getCacheForType: function(l) {
          var c = dr(ki), y = c.data.get(l);
          return y === void 0 && (y = l(), c.data.set(l, y)), y;
        }
      }, fi = 0, Gs = 1, To = 2, yd = 3, da = 4;
      if (typeof Symbol == "function" && Symbol.for) {
        var Co = Symbol.for;
        fi = Co("selector.component"), Gs = Co("selector.has_pseudo_class"), To = Co("selector.role"), yd = Co("selector.test_id"), da = Co("selector.text");
      }
      var gh = typeof WeakMap == "function" ? WeakMap : Map, yn = 0, $n = null, dn = null, vn = 0, Gn = 0, tr = null, fs = !1, ps = !1, bu = !1, Hs = 0, _i = 0, ms = 0, gl = 0, ha = 0, Ya = 0, er = 0, vd = null, gs = null, _f = !1, Zp = 0, Xa = 1 / 0, _u = null, wo = null, yl = !1, pc = null, bd = 0, Sf = 0, yh = null, Su = 0, Jp = null;
      return gn.attemptContinuousHydration = function(l) {
        if (l.tag === 13) {
          var c = re(l, 67108864);
          c !== null && si(c, l, 67108864), nd(l, 67108864);
        }
      }, gn.attemptHydrationAtCurrentPriority = function(l) {
        if (l.tag === 13) {
          var c = qr(), y = re(l, c);
          y !== null && si(y, l, c), nd(l, c);
        }
      }, gn.attemptSynchronousHydration = function(l) {
        switch (l.tag) {
          case 3:
            if (l = l.stateNode, l.current.memoizedState.isDehydrated) {
              var c = R(l.pendingLanes);
              if (c !== 0) {
                for (l.pendingLanes |= 2, l.entangledLanes |= 2; c; ) {
                  var y = 1 << 31 - Ii(c);
                  l.entanglements[1] |= y, c &= ~y;
                }
                ve(l), (yn & 6) === 0 && (Xa = Ga() + 500, Re(0));
              }
            }
            break;
          case 13:
            c = re(l, 2), c !== null && si(c, l, 2), _p(), nd(l, 2);
        }
      }, gn.batchedUpdates = function(l, c) {
        return l(c);
      }, gn.createComponentSelector = function(l) {
        return { $$typeof: fi, value: l };
      }, gn.createContainer = function(l, c, y, w, z, F, st, yt, Pt, Qt) {
        return tl(
          l,
          c,
          !1,
          null,
          y,
          w,
          F,
          st,
          yt,
          Pt,
          Qt,
          null
        );
      }, gn.createHasPseudoClassSelector = function(l) {
        return { $$typeof: Gs, value: l };
      }, gn.createHydrationContainer = function(l, c, y, w, z, F, st, yt, Pt, Qt, ye, Oe, ge) {
        return l = tl(
          y,
          w,
          !0,
          l,
          z,
          F,
          yt,
          Pt,
          Qt,
          ye,
          Oe,
          ge
        ), l.context = xp(null), y = l.current, w = qr(), z = fe(w), z.callback = c ?? null, Me(y, z, w), l.current.lanes = w, G(l, w), ve(l), l;
      }, gn.createPortal = function(l, c, y) {
        var w = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
        return {
          $$typeof: go,
          key: w == null ? null : "" + w,
          children: l,
          containerInfo: c,
          implementation: y
        };
      }, gn.createRoleSelector = function(l) {
        return { $$typeof: To, value: l };
      }, gn.createTestNameSelector = function(l) {
        return { $$typeof: yd, value: l };
      }, gn.createTextSelector = function(l) {
        return { $$typeof: da, value: l };
      }, gn.defaultOnCaughtError = function(l) {
        console.error(l);
      }, gn.defaultOnRecoverableError = function(l) {
        dc(l);
      }, gn.defaultOnUncaughtError = function(l) {
        dc(l);
      }, gn.deferredUpdates = function(l) {
        var c = Xe.T, y = ec();
        try {
          return oa(32), Xe.T = null, l();
        } finally {
          oa(y), Xe.T = c;
        }
      }, gn.discreteUpdates = function(l, c, y, w, z) {
        var F = Xe.T, st = ec();
        try {
          return oa(2), Xe.T = null, l(c, y, w, z);
        } finally {
          oa(st), Xe.T = F, yn === 0 && (Xa = Ga() + 500);
        }
      }, gn.findAllNodes = Fl, gn.findBoundingRects = function(l, c) {
        if (!od) throw Error(s(363));
        c = Fl(l, c), l = [];
        for (var y = 0; y < c.length; y++)
          l.push(_v(c[y]));
        for (c = l.length - 1; 0 < c; c--) {
          y = l[c];
          for (var w = y.x, z = w + y.width, F = y.y, st = F + y.height, yt = c - 1; 0 <= yt; yt--)
            if (c !== yt) {
              var Pt = l[yt], Qt = Pt.x, ye = Qt + Pt.width, Oe = Pt.y, ge = Oe + Pt.height;
              if (w >= Qt && F >= Oe && z <= ye && st <= ge) {
                l.splice(c, 1);
                break;
              } else if (w !== Qt || y.width !== Pt.width || ge < F || Oe > st) {
                if (!(F !== Oe || y.height !== Pt.height || ye < w || Qt > z)) {
                  Qt > w && (Pt.width += Qt - w, Pt.x = w), ye < z && (Pt.width = z - Qt), l.splice(c, 1);
                  break;
                }
              } else {
                Oe > F && (Pt.height += Oe - F, Pt.y = F), ge < st && (Pt.height = st - Oe), l.splice(c, 1);
                break;
              }
            }
        }
        return l;
      }, gn.findHostInstance = el, gn.findHostInstanceWithNoPortals = function(l) {
        return l = b(l), l = l !== null ? T(l) : null, l === null ? null : cu(l.stateNode);
      }, gn.findHostInstanceWithWarning = function(l) {
        return el(l);
      }, gn.flushPassiveEffects = Hl, gn.flushSyncFromReconciler = function(l) {
        var c = yn;
        yn |= 1;
        var y = Xe.T, w = ec();
        try {
          if (oa(2), Xe.T = null, l)
            return l();
        } finally {
          oa(w), Xe.T = y, yn = c, (yn & 6) === 0 && Re(0);
        }
      }, gn.flushSyncWork = _p, gn.focusWithin = function(l, c) {
        if (!od) throw Error(s(363));
        for (l = Fr(l), c = ru(l, c), c = Array.from(c), l = 0; l < c.length; ) {
          var y = c[l++], w = y.tag;
          if (!yo(y)) {
            if ((w === 5 || w === 26 || w === 27) && nf(y.stateNode))
              return !0;
            for (y = y.child; y !== null; )
              c.push(y), y = y.sibling;
          }
        }
        return !1;
      }, gn.getFindAllNodesFailureDescription = function(l, c) {
        if (!od) throw Error(s(363));
        var y = 0, w = [];
        l = [Fr(l), 0];
        for (var z = 0; z < l.length; ) {
          var F = l[z++], st = F.tag, yt = l[z++], Pt = c[yt];
          if ((st !== 5 && st !== 26 && st !== 27 || !yo(F)) && (Il(F, Pt) && (w.push(Ta(Pt)), yt++, yt > y && (y = yt)), yt < c.length))
            for (F = F.child; F !== null; )
              l.push(F, yt), F = F.sibling;
        }
        if (y < c.length) {
          for (l = []; y < c.length; y++)
            l.push(Ta(c[y]));
          return `findAllNodes was able to match part of the selector:
  ` + (w.join(" > ") + `

No matching component was found for:
  `) + l.join(" > ");
        }
        return null;
      }, gn.getPublicRootInstance = function(l) {
        if (l = l.current, !l.child) return null;
        switch (l.child.tag) {
          case 27:
          case 5:
            return cu(l.child.stateNode);
          default:
            return l.child.stateNode;
        }
      }, gn.injectIntoDevTools = function() {
        var l = {
          bundleType: 0,
          version: ad,
          rendererPackageName: yv,
          currentDispatcherRef: Xe,
          findFiberByHostInstance: ef,
          reconcilerVersion: "19.0.0"
        };
        if (Ni !== null && (l.rendererConfig = Ni), typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u") l = !1;
        else {
          var c = __REACT_DEVTOOLS_GLOBAL_HOOK__;
          if (c.isDisabled || !c.supportsFiber) l = !0;
          else {
            try {
              dd = c.inject(l), Zi = c;
            } catch {
            }
            l = !!c.checkDCE;
          }
        }
        return l;
      }, gn.isAlreadyRendering = function() {
        return !1;
      }, gn.observeVisibleRects = function(l, c, y, w) {
        if (!od) throw Error(s(363));
        l = Fl(l, c);
        var z = rf(
          l,
          y,
          w
        ).disconnect;
        return {
          disconnect: function() {
            z();
          }
        };
      }, gn.shouldError = function() {
        return null;
      }, gn.shouldSuspend = function() {
        return !1;
      }, gn.startHostTransition = function(l, c, y, w) {
        if (l.tag !== 5) throw Error(s(476));
        var z = ra(l).queue;
        qc(
          l,
          z,
          c,
          uu,
          y === null ? i : function() {
            var F = ra(l).next.queue;
            return is(
              l,
              F,
              {},
              qr()
            ), y(w);
          }
        );
      }, gn.updateContainer = function(l, c, y, w) {
        var z = c.current, F = qr();
        return mo(
          z,
          F,
          l,
          c,
          y,
          w
        ), F;
      }, gn.updateContainerSync = function(l, c, y, w) {
        return c.tag === 0 && Hl(), mo(
          c.current,
          2,
          l,
          c,
          y,
          w
        ), 2;
      }, gn;
    }, e.exports.default = e.exports, Object.defineProperty(e.exports, "__esModule", { value: !0 });
  }(kb)), kb.exports;
}
var n3;
function Tj() {
  return n3 || (n3 = 1, Nb.exports = xj()), Nb.exports;
}
var Cj = Tj();
const wj = /* @__PURE__ */ lp(Cj);
var Db = { exports: {} }, Ru = {};
/**
 * @license React
 * react-reconciler-constants.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var i3;
function Ej() {
  return i3 || (i3 = 1, Ru.ConcurrentRoot = 1, Ru.ContinuousEventPriority = 8, Ru.DefaultEventPriority = 32, Ru.DiscreteEventPriority = 2, Ru.IdleEventPriority = 268435456, Ru.LegacyRoot = 0, Ru.NoEventPriority = 0), Ru;
}
var r3;
function Aj() {
  return r3 || (r3 = 1, Db.exports = Ej()), Db.exports;
}
var fv = Aj(), Mj = Sn();
const a3 = {
  children: !0,
  ref: !0,
  key: !0,
  style: !0,
  forwardedRef: !0,
  unstable_applyCache: !0,
  unstable_applyDrawHitFromCache: !0
};
let s3 = !1, o3 = !1;
const Y_ = ".react-konva-event", Rj = `ReactKonva: You have a Konva node with draggable = true and position defined but no onDragMove or onDragEnd events are handled.
Position of a node will be changed during drag&drop, so you should update state of the react app as well.
Consider to add onDragMove or onDragEnd events.
For more info see: https://github.com/konvajs/react-konva/issues/256
`, Oj = `ReactKonva: You are using "zIndex" attribute for a Konva node.
react-konva may get confused with ordering. Just define correct order of elements in your render function of a component.
For more info see: https://github.com/konvajs/react-konva/issues/194
`, Nj = {};
function pv(e, t, n = Nj) {
  if (!s3 && "zIndex" in t && (console.warn(Oj), s3 = !0), !o3 && t.draggable) {
    var i = t.x !== void 0 || t.y !== void 0, s = t.onDragEnd || t.onDragMove;
    i && !s && (console.warn(Rj), o3 = !0);
  }
  for (var o in n)
    if (!a3[o]) {
      var u = o.slice(0, 2) === "on", h = n[o] !== t[o];
      if (u && h) {
        var f = o.substr(2).toLowerCase();
        f.substr(0, 7) === "content" && (f = "content" + f.substr(7, 1).toUpperCase() + f.substr(8)), e.off(f, n[o]);
      }
      var p = !t.hasOwnProperty(o);
      p && e.setAttr(o, void 0);
    }
  var g = t._useStrictMode, v = {}, x = !1;
  const b = {};
  for (var o in t)
    if (!a3[o]) {
      var u = o.slice(0, 2) === "on", _ = n[o] !== t[o];
      if (u && _) {
        var f = o.substr(2).toLowerCase();
        f.substr(0, 7) === "content" && (f = "content" + f.substr(7, 1).toUpperCase() + f.substr(8)), t[o] && (b[f] = t[o]);
      }
      !u && (t[o] !== n[o] || g && t[o] !== e.getAttr(o)) && (x = !0, v[o] = t[o]);
    }
  x && (e.setAttrs(v), qd(e));
  for (var f in b)
    e.on(f + Y_, b[f]);
}
function qd(e) {
  if (!Mj.Konva.autoDrawEnabled) {
    var t = e.getLayer() || e.getStage();
    t && t.batchDraw();
  }
}
var Bb = b2();
const J6 = {}, kj = {};
T1.Node.prototype._applyProps = pv;
let tC = fv.DefaultEventPriority;
function Dj(e, t) {
  if (typeof t == "string") {
    console.error(`Do not use plain text as child of Konva.Node. You are using text: ${t}`);
    return;
  }
  e.add(t), qd(e);
}
function Bj(e, t, n) {
  let i = T1[e];
  i || (console.error(`Konva has no node with the type ${e}. Group will be used instead. If you use minimal version of react-konva, just import required nodes into Konva: "import "konva/lib/shapes/${e}"  If you want to render DOM elements as part of canvas tree take a look into this demo: https://konvajs.github.io/docs/react/DOM_Portal.html`), i = T1.Group);
  const s = {}, o = {};
  for (var u in t) {
    var h = u.slice(0, 2) === "on";
    h ? o[u] = t[u] : s[u] = t[u];
  }
  const f = new i(s);
  return pv(f, o), f;
}
function zj(e, t, n) {
  console.error(`Text components are not supported for now in ReactKonva. Your text is: "${e}"`);
}
function Pj(e, t, n) {
  return !1;
}
function Uj(e) {
  return e;
}
function jj() {
  return null;
}
function Lj() {
  return null;
}
function Vj(e, t, n, i) {
  return kj;
}
function Ij() {
}
function Fj(e) {
}
function qj(e, t) {
  return !1;
}
function Gj() {
  return J6;
}
function Hj() {
  return J6;
}
const Kj = setTimeout, Yj = clearTimeout, Xj = !0, Wj = (e) => {
  e();
}, $j = -1;
function Qj(e, t) {
  return !1;
}
const Zj = !1, Jj = !1, tL = !0, eL = !1, nL = !1;
function iL(e, t) {
  t.parent === e ? t.moveToTop() : e.add(t), qd(e);
}
function rL(e, t) {
  t.parent === e ? t.moveToTop() : e.add(t), qd(e);
}
function eC(e, t, n) {
  t._remove(), e.add(t), t.setZIndex(n.getZIndex()), qd(e);
}
function aL(e, t, n) {
  eC(e, t, n);
}
function sL(e, t) {
  t.destroy(), t.off(Y_), qd(e);
}
function oL(e, t) {
  t.destroy(), t.off(Y_), qd(e);
}
function lL(e, t, n) {
  console.error(`Text components are not yet supported in ReactKonva. You text is: "${n}"`);
}
function cL(e, t, n) {
}
function uL(e, t, n, i) {
  pv(e, i, n);
}
function dL(e) {
  e.hide(), qd(e);
}
function hL(e) {
}
function fL(e, t) {
  (t.visible == null || t.visible) && e.show();
}
function pL(e, t) {
}
function mL(e) {
}
function gL() {
}
function yL() {
  return fv.DefaultEventPriority;
}
function vL() {
}
function bL() {
  return null;
}
function _L(e) {
  tC = e;
}
function SL() {
  return tC;
}
function xL() {
  return fv.DiscreteEventPriority;
}
function TL() {
  return !1;
}
function CL() {
}
function wL() {
  return !1;
}
function EL() {
  return !0;
}
function AL() {
}
function ML() {
}
function RL() {
  return null;
}
const OL = null;
function NL() {
}
const kL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  NotPendingTransition: OL,
  appendChild: iL,
  appendChildToContainer: rL,
  appendInitialChild: Dj,
  cancelTimeout: Yj,
  clearContainer: mL,
  commitMount: cL,
  commitTextUpdate: lL,
  commitUpdate: uL,
  createInstance: Bj,
  createTextInstance: zj,
  detachDeletedInstance: gL,
  finalizeInitialChildren: Pj,
  getChildHostContext: Hj,
  getCurrentEventPriority: yL,
  getCurrentUpdatePriority: SL,
  getInstanceFromScope: bL,
  getPublicInstance: Uj,
  getRootHostContext: Gj,
  hideInstance: dL,
  hideTextInstance: hL,
  idlePriority: Bb.unstable_IdlePriority,
  insertBefore: eC,
  insertInContainerBefore: aL,
  isPrimaryRenderer: Zj,
  maySuspendCommit: wL,
  noTimeout: $j,
  now: Bb.unstable_now,
  preloadInstance: EL,
  prepareForCommit: jj,
  preparePortalMount: Lj,
  prepareScopeUpdate: vL,
  prepareUpdate: Vj,
  removeChild: sL,
  removeChildFromContainer: oL,
  requestPostPaintCallback: CL,
  resetAfterCommit: Ij,
  resetFormInstance: NL,
  resetTextContent: Fj,
  resolveUpdatePriority: xL,
  run: Bb.unstable_runWithPriority,
  scheduleMicrotask: Wj,
  scheduleTimeout: Kj,
  setCurrentUpdatePriority: _L,
  shouldAttemptEagerTransition: TL,
  shouldDeprioritizeSubtree: qj,
  shouldSetTextContent: Qj,
  startSuspendingCommit: AL,
  supportsHydration: nL,
  supportsMicrotasks: Xj,
  supportsMutation: tL,
  supportsPersistence: eL,
  suspendInstance: ML,
  unhideInstance: fL,
  unhideTextInstance: pL,
  waitForCommitToBeReady: RL,
  warnsIfNotActing: Jj
}, Symbol.toStringTag, { value: "Module" }));
function nC(e, t, n) {
  if (!e) return;
  if (n(e) === !0) return e;
  let i = e.child;
  for (; i; ) {
    const s = nC(i, t, n);
    if (s) return s;
    i = i.sibling;
  }
}
function iC(e) {
  try {
    return Object.defineProperties(e, {
      _currentRenderer: {
        get() {
          return null;
        },
        set() {
        }
      },
      _currentRenderer2: {
        get() {
          return null;
        },
        set() {
        }
      }
    });
  } catch {
    return e;
  }
}
const X_ = /* @__PURE__ */ iC(/* @__PURE__ */ tt.createContext(null));
class rC extends tt.Component {
  render() {
    return /* @__PURE__ */ tt.createElement(X_.Provider, { value: this._reactInternals }, this.props.children);
  }
}
function DL() {
  const e = tt.useContext(X_);
  if (e === null) throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");
  const t = tt.useId();
  return tt.useMemo(() => {
    for (const n of [e, e == null ? void 0 : e.alternate]) {
      if (!n) continue;
      const i = nC(n, !1, (s) => {
        let o = s.memoizedState;
        for (; o; ) {
          if (o.memoizedState === t) return !0;
          o = o.next;
        }
      });
      if (i) return i;
    }
  }, [e, t]);
}
const BL = Symbol.for("react.context"), zL = (e) => e !== null && typeof e == "object" && "$$typeof" in e && e.$$typeof === BL;
function PL() {
  const e = DL(), [t] = tt.useState(() => /* @__PURE__ */ new Map());
  t.clear();
  let n = e;
  for (; n; ) {
    const i = n.type;
    zL(i) && i !== X_ && !t.has(i) && t.set(i, tt.use(iC(i))), n = n.return;
  }
  return t;
}
function UL() {
  const e = PL();
  return tt.useMemo(
    () => Array.from(e.keys()).reduce(
      (t, n) => (i) => /* @__PURE__ */ tt.createElement(t, null, /* @__PURE__ */ tt.createElement(n.Provider, { ...i, value: e.get(n) })),
      (t) => /* @__PURE__ */ tt.createElement(rC, { ...t })
    ),
    [e]
  );
}
if (an.version.indexOf("19") === -1)
  throw new Error("react-konva version 19 is only compatible with React 19. Make sure to have the last version of react-konva and react or downgrade react-konva to version 18.");
function jL(e) {
  const t = an.useRef({});
  return an.useLayoutEffect(() => {
    t.current = e;
  }), an.useLayoutEffect(() => () => {
    t.current = {};
  }, []), t.current;
}
const LL = (e) => {
  const t = an.useRef(null), n = an.useRef(null), i = an.useRef(null), s = jL(e), o = UL(), u = (h) => {
    const { forwardedRef: f } = e;
    f && (typeof f == "function" ? f(h) : f.current = h);
  };
  return an.useLayoutEffect(() => (n.current = new T1.Stage({
    width: e.width,
    height: e.height,
    container: t.current
  }), u(n.current), i.current = gg.createContainer(n.current, fv.ConcurrentRoot, null, !1, null, "", console.error, console.error, console.error, null), gg.updateContainer(an.createElement(o, {}, e.children), i.current, null, () => {
  }), () => {
    u(null), gg.updateContainer(null, i.current, null), n.current.destroy();
  }), []), an.useLayoutEffect(() => {
    u(n.current), pv(n.current, e, s), gg.updateContainer(an.createElement(o, {}, e.children), i.current, null);
  }), an.createElement("div", {
    ref: t,
    id: e.id,
    accessKey: e.accessKey,
    className: e.className,
    role: e.role,
    style: e.style,
    tabIndex: e.tabIndex,
    title: e.title
  });
}, jy = "Layer", Ly = "Group", Rd = "Rect", zb = "Line", VL = "Text", gg = wj(kL);
gg.injectIntoDevTools({
  // @ts-ignore
  findHostInstanceByFiber: () => null,
  bundleType: 0,
  version: an.version,
  rendererPackageName: "react-konva"
});
const IL = an.forwardRef((e, t) => an.createElement(rC, {}, an.createElement(LL, { ...e, forwardedRef: t }))), FL = ({ trackId: e, color: t }) => {
  const { notesByTrack: n, createNote: i, moveNote: s, resizeNote: o, playPreview: u, stopPreview: h } = qh(), f = n[e] || [], [p, g] = tt.useState(null), [v, x] = tt.useState(null), [b, _] = tt.useState({ x: 0, y: 0 }), [T, A] = tt.useState(!1), [O, M] = tt.useState(null), [E, R] = tt.useState(null), [N, U] = tt.useState(null), [q, j] = tt.useState(null), [V, D] = tt.useState(null), G = tt.useRef(null), W = tt.useRef(null), [P, H] = tt.useState({ width: 800, height: 600 }), Q = 10 * 12, it = 24, nt = 20, X = 64, rt = 32, [vt, ct] = tt.useState(rt), dt = vt * it, ht = Q * nt, Et = X + dt, [ot, lt] = tt.useState([]), [ft, Tt] = tt.useState([]), [Bt, Ot] = tt.useState({ x: 0, y: 0 });
  tt.useEffect(() => {
    lt(f);
  }, [f]);
  const ie = (It) => Q - 1 - It, ce = (It) => Q - 1 - It, Ut = (It) => {
    const Ht = It % 12;
    return [1, 3, 6, 8, 10].includes(Ht);
  };
  tt.useEffect(() => {
    if (!G.current) return;
    const It = () => {
      if (!G.current) return;
      const { clientWidth: Jt, clientHeight: Yt } = G.current;
      H({
        width: Jt,
        height: Yt
      });
      const ae = Jt - X, le = Math.floor(ae / it), fe = Math.ceil(le * 1.2), Me = ae * 0.2, Te = vt * it;
      Math.abs(Te - ae) < Me && ct(Math.max(rt, fe));
    };
    It();
    const Ht = new ResizeObserver(It);
    return Ht.observe(G.current), () => Ht.disconnect();
  }, [vt, it, rt, X]), tt.useEffect(() => {
    const It = Math.floor(Bt.x / it), Ht = It + Math.ceil(P.width / it), Jt = Math.floor(Bt.y / nt), Yt = Jt + Math.ceil(P.height / nt), ae = ot.filter((le) => {
      const fe = ce(le.row);
      return le.column + le.length >= It && le.column <= Ht && fe >= Jt && fe <= Yt;
    });
    Tt(ae);
  }, [ot, Bt, P, it, nt]);
  const se = tt.useCallback((It) => {
    const Ht = It.target;
    if (Ot({
      x: Ht.scrollLeft,
      y: Ht.scrollTop
    }), T) return;
    const { scrollLeft: Jt, scrollWidth: Yt, clientWidth: ae } = Ht;
    (Jt + ae) / Yt > 0.8 && ct((Me) => Me + 1);
  }, [T]), re = tt.useCallback((It) => {
    if (T) return;
    const Ht = It.target, { column: Jt, row: Yt } = Ht.attrs.gridPosition, ae = ie(Yt);
    if (!ot.some(
      (fe) => fe.row === ae && fe.column === Jt
    )) {
      const fe = {
        id: Date.now(),
        // Use timestamp as unique ID
        row: ae,
        column: Jt,
        length: 1,
        velocity: 100,
        trackId: e
      };
      lt((Me) => [...Me, fe]), i(e, fe), u(ae), setTimeout(() => h(ae), 300);
    }
  }, [T, ot, i, e, ie, u, h]), ue = tt.useCallback((It, Ht) => {
    It.evt.stopPropagation();
    const Jt = ot.find((fe) => fe.id === Ht);
    if (!Jt) return;
    A(!0), g(Ht), x({ row: Jt.row, column: Jt.column });
    const Yt = W.current.getPointerPosition(), ae = X + Jt.column * it, le = ce(Jt.row) * nt;
    _({
      x: Yt.x - ae,
      y: Yt.y - le
    }), u(Jt.row);
  }, [ot, u, X, it, nt, ce]), Ae = tt.useCallback((It, Ht, Jt) => {
    It.evt.stopPropagation();
    const Yt = ot.find((ae) => ae.id === Ht);
    Yt && (M(Ht), j(Jt), R(Yt.length), U(Yt.column), A(!0));
  }, [ot]), ve = tt.useCallback((It) => {
    if (!W.current) return;
    const Jt = W.current.getPointerPosition();
    if (O !== null) {
      const Yt = ot.find((Me) => Me.id === O);
      if (!Yt) return;
      const le = Jt.x - X + Bt.x, fe = Math.floor(le / it);
      if (q === "right") {
        const Me = Math.max(1, fe - Yt.column + 1), Te = vt - Yt.column, ne = Math.min(Me, Te);
        lt((Ve) => Ve.map(
          (fn) => fn.id === O ? { ...fn, length: ne } : fn
        ));
      } else {
        const Me = Yt.column + Yt.length - 1, Te = Math.max(0, Math.min(fe, Me)), ne = Me - Te + 1;
        lt((Ve) => Ve.map(
          (fn) => fn.id === O ? { ...fn, column: Te, length: ne } : fn
        ));
      }
    } else if (p !== null) {
      const Yt = Jt.x - b.x, ae = Jt.y - b.y, le = Yt - X + Bt.x, fe = ae + Bt.y, Me = Math.floor(Bt.x / it), Te = Math.ceil(P.width / it), ne = Me + Te, fn = Math.min(ne + 32, vt - 1), _r = Math.max(0, Math.min(Math.floor(le / it), fn)), Ce = Math.max(0, Math.min(Math.floor(fe / nt), Q - 1)), Xi = ie(Ce), Rn = ot.map((Ze) => {
        if (Ze.id === p) {
          const Vr = Math.min(fn - Ze.length, vt - Ze.length), Wi = Math.min(_r, Vr);
          if (Ze.row !== Xi || Ze.column !== Wi)
            return Ze.row !== Xi && (h(Ze.row), u(Xi)), { ...Ze, row: Xi, column: Wi };
        }
        return Ze;
      });
      lt(Rn);
    }
  }, [O, p, ot, vt, Bt, b, it, nt, u, h, ie]), Re = tt.useCallback(async () => {
    if (p !== null && v) {
      const It = ot.find((Ht) => Ht.id === p);
      It && (h(It.row), (It.column !== v.column || It.row !== v.row) && await s(
        e,
        p,
        { x: v.column, y: v.row },
        { x: It.column, y: It.row }
      ));
    }
    if (O !== null && E !== null) {
      const It = ot.find((Ht) => Ht.id === O);
      if (It) {
        const Ht = It.length !== E, Jt = q === "left" && N !== null && It.column !== N;
        (Ht || Jt) && await o(
          e,
          O,
          E,
          It.length,
          q === "left" ? N : void 0,
          q === "left" ? It.column : void 0
        );
      }
    }
    g(null), x(null), M(null), R(null), U(null), j(null), setTimeout(() => {
      A(!1);
    }, 10);
  }, [p, v, O, E, N, q, ot, e, s, o, h]), oe = tt.useCallback((It, Ht) => {
    It.evt.stopPropagation();
    const Jt = ot.find((Yt) => Yt.id === Ht);
    Jt && (u(Jt.row), setTimeout(() => h(Jt.row), 300));
  }, [ot, u, h]), Le = tt.useCallback(() => {
    const It = [];
    for (let Ht = 0; Ht <= Q; Ht++) {
      const ae = ie(Ht) % 12 === 0;
      It.push(
        /* @__PURE__ */ J.jsx(
          zb,
          {
            points: [X, Ht * nt, X + dt, Ht * nt],
            stroke: ae ? "rgba(100, 100, 100, 0.5)" : "rgba(50, 50, 50, 0.5)",
            strokeWidth: 1,
            listening: !1,
            perfectDrawEnabled: !0
          },
          `h-line-${Ht}`
        )
      );
    }
    for (let Ht = 0; Ht <= vt; Ht++)
      It.push(
        /* @__PURE__ */ J.jsx(
          zb,
          {
            points: [X + Ht * it, 0, X + Ht * it, ht],
            stroke: Ht % 4 === 0 ? "rgba(100, 100, 100, 0.5)" : "rgba(50, 50, 50, 0.5)",
            strokeWidth: 1,
            listening: !1,
            perfectDrawEnabled: !0
          },
          `v-line-${Ht}`
        )
      );
    return It;
  }, [dt, ht, vt, it, nt, Q, ie, X]), De = tt.useCallback(() => {
    const It = [], Ht = Math.floor(Bt.y / nt), Jt = Math.min(Q, Ht + Math.ceil(P.height / nt) + 1), Yt = Math.floor(Bt.x / it), ae = Math.min(vt, Yt + Math.ceil(P.width / it) + 1);
    for (let le = Ht; le < Jt; le++)
      for (let fe = Yt; fe < ae; fe++)
        It.push(
          /* @__PURE__ */ J.jsx(
            Rd,
            {
              x: fe * it,
              y: le * nt,
              width: it,
              height: nt,
              fill: "transparent",
              gridPosition: { row: le, column: fe },
              onClick: re
            },
            `cell-${le}-${fe}`
          )
        );
    return It;
  }, [
    it,
    nt,
    vt,
    Q,
    re,
    Bt,
    P
  ]), Kt = tt.useCallback(() => {
    const It = [];
    for (let Ht = 0; Ht < Q; Ht++) {
      const Jt = ie(Ht), Yt = Math.floor(Jt / 12), ae = Jt % 12, le = Ut(Jt), fe = ae === 0;
      It.push(
        /* @__PURE__ */ J.jsxs(Ly, { children: [
          /* @__PURE__ */ J.jsx(
            Rd,
            {
              x: 0,
              y: Ht * nt,
              width: X,
              height: nt,
              fill: le ? "#222" : "#333",
              stroke: "#444",
              strokeWidth: 1,
              onClick: () => u(Jt),
              onMouseDown: () => u(Jt),
              onMouseUp: () => h(Jt)
            }
          ),
          fe && /* @__PURE__ */ J.jsx(
            VL,
            {
              x: 5,
              y: Ht * nt + 5,
              text: `C${Yt}`,
              fontSize: 11,
              fill: "#aaa"
            }
          )
        ] }, `key-${Ht}`)
      );
    }
    return It;
  }, [nt, Q, ie, u, h]), te = tt.useCallback(() => ft.map((It) => {
    const Ht = p === It.id, Jt = O === It.id, Yt = V === It.id, ae = ce(It.row);
    return /* @__PURE__ */ J.jsxs(
      Ly,
      {
        x: It.column * it,
        y: ae * nt,
        onClick: (le) => oe(le, It.id),
        onMouseDown: (le) => ue(le, It.id),
        onMouseEnter: () => {
          document.body.style.cursor = "pointer", D(It.id);
        },
        onMouseLeave: () => {
          document.body.style.cursor = "default", D(null);
        },
        children: [
          /* @__PURE__ */ J.jsx(
            Rd,
            {
              width: It.length * it - 1,
              height: nt - 1,
              fill: t,
              cornerRadius: 3,
              opacity: Ht || Jt ? 0.75 : 1,
              shadowColor: "rgba(0,0,0,0.5)",
              shadowBlur: Ht || Jt || Yt ? 5 : 0,
              shadowOffset: Yt && !Ht && !Jt ? { x: 0, y: 2 } : { x: 0, y: 0 },
              perfectDrawEnabled: !0
            }
          ),
          /* @__PURE__ */ J.jsx(
            Rd,
            {
              x: 0,
              y: 0,
              width: 4,
              height: nt - 1,
              fill: "rgba(0,0,0,0.3)",
              onMouseDown: (le) => Ae(le, It.id, "left"),
              onMouseOver: (le) => {
                document.body.style.cursor = "ew-resize", le.target.opacity(1);
              },
              onMouseOut: (le) => {
                document.body.style.cursor = "default", le.target.opacity(0.5);
              },
              opacity: 0.5
            }
          ),
          /* @__PURE__ */ J.jsx(
            Rd,
            {
              x: It.length * it - 5,
              y: 0,
              width: 4,
              height: nt - 1,
              fill: "rgba(0,0,0,0.3)",
              onMouseDown: (le) => Ae(le, It.id, "right"),
              onMouseOver: (le) => {
                document.body.style.cursor = "ew-resize", le.target.opacity(1);
              },
              onMouseOut: (le) => {
                document.body.style.cursor = "default", le.target.opacity(0.5);
              },
              opacity: 0.5
            }
          )
        ]
      },
      `note-${It.id}`
    );
  }), [ft, it, nt, p, O, oe, ue, Ae, ce]);
  return /* @__PURE__ */ J.jsx(
    xe,
    {
      ref: G,
      sx: {
        display: "flex",
        height: "100%",
        bgcolor: "#111",
        overflow: "auto",
        "&::-webkit-scrollbar": {
          width: 10,
          height: 10,
          backgroundColor: "#222"
        },
        "&::-webkit-scrollbar-thumb": {
          backgroundColor: "#444",
          borderRadius: 2,
          "&:hover": {
            backgroundColor: "#555"
          }
        },
        "&::-webkit-scrollbar-corner": {
          backgroundColor: "#222"
        }
      },
      onScroll: se,
      children: /* @__PURE__ */ J.jsxs(
        IL,
        {
          ref: W,
          width: Et,
          height: ht,
          onMouseMove: ve,
          onMouseUp: Re,
          onMouseLeave: Re,
          children: [
            /* @__PURE__ */ J.jsxs(jy, { children: [
              /* @__PURE__ */ J.jsx(
                Rd,
                {
                  x: X,
                  y: 0,
                  width: dt,
                  height: ht,
                  fill: "#181818",
                  perfectDrawEnabled: !0,
                  listening: !1
                }
              ),
              /* @__PURE__ */ J.jsx(
                Rd,
                {
                  x: 0,
                  y: 0,
                  width: X,
                  height: ht,
                  fill: "#111",
                  perfectDrawEnabled: !0,
                  listening: !1
                }
              ),
              [...Array(Q)].map((It, Ht) => {
                const Jt = ie(Ht);
                return Ut(Jt) ? /* @__PURE__ */ J.jsx(
                  Rd,
                  {
                    x: X,
                    y: Ht * nt,
                    width: dt,
                    height: nt,
                    fill: "rgba(0, 0, 0, 0.2)",
                    perfectDrawEnabled: !0,
                    listening: !1
                  },
                  `row-bg-${Ht}`
                ) : null;
              }),
              Le(),
              /* @__PURE__ */ J.jsx(
                zb,
                {
                  points: [X, 0, X, ht],
                  stroke: "rgba(100, 100, 100, 0.8)",
                  strokeWidth: 2,
                  listening: !1,
                  perfectDrawEnabled: !0
                }
              )
            ] }),
            /* @__PURE__ */ J.jsx(jy, { children: /* @__PURE__ */ J.jsx(Ly, { x: X, children: De() }) }),
            /* @__PURE__ */ J.jsx(jy, { children: Kt() }),
            /* @__PURE__ */ J.jsx(jy, { children: /* @__PURE__ */ J.jsx(Ly, { x: X, children: te() }) })
          ]
        }
      )
    }
  );
}, l3 = {
  36: "Kick",
  38: "Snare",
  42: "Hi-Hat Closed",
  46: "Hi-Hat Open",
  41: "Tom 1",
  43: "Tom 2",
  45: "Tom 3",
  49: "Crash",
  51: "Ride",
  39: "Clap"
}, qL = ({ trackId: e }) => {
  const { notesByTrack: t, createNote: n, moveNote: i, resizeNote: s, playPreview: o, stopPreview: u } = qh(), h = t[e] || [], [f, p] = tt.useState(null), [g, v] = tt.useState(null), [x, b] = tt.useState(!1), [_, T] = tt.useState(null), [A, O] = tt.useState(null), [M, E] = tt.useState(null), R = tt.useRef(null), N = tt.useRef(null), U = 24, q = 30, j = 32, [V, D] = tt.useState(j), G = 0.8, W = Object.keys(l3).map(Number).sort((ct, dt) => ct - dt), P = W.length, H = () => {
    if (!N.current || !R.current) return;
    const { scrollLeft: ct, scrollWidth: dt, clientWidth: ht } = N.current;
    (ct + ht) / dt > G && D((ot) => ot + j);
  };
  tt.useEffect(() => {
    const ct = () => {
      if (!R.current) return;
      const ht = R.current.clientWidth;
      D(Math.max(j, Math.floor(ht / U)));
    }, dt = new ResizeObserver(ct);
    return R.current && dt.observe(R.current), () => dt.disconnect();
  }, []);
  const I = (ct) => W[ct] || 36, K = (ct) => W.indexOf(ct), Q = async (ct) => {
    if (!R.current || x) return;
    const dt = R.current.getBoundingClientRect(), ht = ct.clientX - dt.left, Et = ct.clientY - dt.top, ot = Math.floor(ht / U), lt = Math.floor(Et / q);
    if (lt < 0 || lt >= P) return;
    const ft = I(lt);
    if (!h.some((Bt) => Bt.row === ft && Bt.column === ot)) {
      const Bt = {
        id: Date.now(),
        // Use timestamp as unique ID
        row: ft,
        column: ot,
        length: 1,
        velocity: 100,
        trackId: e
      };
      await n(e, Bt), o(ft), setTimeout(() => u(ft), 300);
    }
  }, it = (ct, dt) => {
    ct.stopPropagation();
    const ht = h.find((Et) => Et.id === dt);
    ht && (b(!0), p(dt), v({ row: ht.row, column: ht.column }), o(ht.row));
  }, nt = (ct, dt, ht) => {
    ct.stopPropagation();
    const Et = h.find((ot) => ot.id === dt);
    Et && (T(dt), E(ht), O(Et.length), b(!0));
  }, X = (ct) => {
    if (!R.current) return;
    const dt = R.current.getBoundingClientRect();
    if (_ !== null) {
      const ht = h.find((lt) => lt.id === _);
      if (!ht) return;
      const Et = ct.clientX - dt.left, ot = Math.floor(Et / U);
      if (M === "right") {
        const lt = Math.max(1, ot - ht.column + 1), ft = V - ht.column, Tt = Math.min(lt, ft), Bt = h.map(
          (Ot) => Ot.id === _ ? { ...Ot, length: Tt } : Ot
        );
        t[e] = Bt;
      } else {
        const lt = ht.column + ht.length - 1, ft = Math.max(0, Math.min(ot, lt)), Tt = lt - ft + 1, Bt = h.map(
          (Ot) => Ot.id === _ ? { ...Ot, column: ft, length: Tt } : Ot
        );
        t[e] = Bt;
      }
    } else if (f !== null) {
      const ht = h.find((Tt) => Tt.id === f);
      if (!ht) return;
      const Et = ct.clientX - dt.left, ot = ct.clientY - dt.top, lt = Math.max(0, Math.min(Math.floor(Et / U), V - 1)), ft = Math.floor(ot / q);
      if (ft >= 0 && ft < P) {
        const Tt = I(ft), Bt = h.map((Ot) => {
          if (Ot.id === f) {
            const ie = V - Ot.length, ce = Math.min(lt, ie);
            return { ...Ot, row: Tt, column: ce };
          }
          return Ot;
        });
        t[e] = Bt, ht.row !== Tt && (u(ht.row), o(Tt));
      }
    }
  }, rt = async () => {
    if (f !== null && g) {
      const ct = h.find((dt) => dt.id === f);
      ct && (u(ct.row), (ct.column !== g.column || ct.row !== g.row) && await i(
        e,
        f,
        { x: g.column, y: g.row },
        { x: ct.column, y: ct.row }
      ));
    }
    if (_ !== null && A !== null) {
      const ct = h.find((dt) => dt.id === _);
      ct && ct.length !== A && await s(
        e,
        _,
        A,
        ct.length
      );
    }
    p(null), v(null), T(null), O(null), E(null), setTimeout(() => {
      b(!1);
    }, 10);
  }, vt = (ct, dt) => {
    ct.stopPropagation();
    const ht = h.find((Et) => Et.id === dt);
    ht && (o(ht.row), setTimeout(() => u(ht.row), 300));
  };
  return /* @__PURE__ */ J.jsx(xe, { sx: {
    display: "flex",
    height: "100%",
    bgcolor: "#111",
    overflow: "hidden"
  }, children: /* @__PURE__ */ J.jsx(
    xe,
    {
      ref: N,
      sx: {
        display: "flex",
        width: "100%",
        height: "100%",
        position: "relative",
        overflow: "auto",
        "&::-webkit-scrollbar": {
          width: 10,
          height: 10,
          backgroundColor: "#222"
        },
        "&::-webkit-scrollbar-thumb": {
          backgroundColor: "#444",
          borderRadius: 2,
          "&:hover": {
            backgroundColor: "#555"
          }
        },
        "&::-webkit-scrollbar-corner": {
          backgroundColor: "#222"
        }
      },
      onScroll: H,
      children: /* @__PURE__ */ J.jsxs(xe, { sx: {
        display: "flex",
        minWidth: "100%",
        height: "fit-content"
      }, children: [
        /* @__PURE__ */ J.jsx(xe, { sx: {
          width: "120px",
          flexShrink: 0,
          display: "flex",
          flexDirection: "column",
          borderRight: 1,
          borderColor: "#333",
          position: "sticky",
          left: 0,
          zIndex: 3,
          backgroundColor: "#111"
        }, children: W.map((ct, dt) => {
          const ht = l3[ct] || `Note ${ct}`;
          return /* @__PURE__ */ J.jsx(
            xe,
            {
              sx: {
                height: `${q}px`,
                bgcolor: dt % 2 === 0 ? "#222" : "#1A1A1A",
                color: "#aaa",
                display: "flex",
                alignItems: "center",
                pl: 1,
                fontSize: "12px",
                borderBottom: 1,
                borderColor: "#333",
                cursor: "pointer",
                "&:hover": {
                  bgcolor: "#2a2a2a"
                }
              },
              onClick: () => {
                o(ct), setTimeout(() => u(ct), 300);
              },
              children: ht
            },
            `drum-${ct}`
          );
        }) }),
        /* @__PURE__ */ J.jsx(
          xe,
          {
            ref: R,
            sx: {
              position: "relative",
              overflow: "visible",
              display: "flex"
            },
            onClick: Q,
            onMouseMove: X,
            onMouseUp: rt,
            onMouseLeave: rt,
            children: /* @__PURE__ */ J.jsxs(
              xe,
              {
                sx: {
                  position: "relative",
                  height: `${P * q}px`,
                  width: `${V * U}px`,
                  minWidth: "100%",
                  backgroundColor: "#181818",
                  flexShrink: 0
                },
                children: [
                  /* @__PURE__ */ J.jsx(xe, { sx: {
                    position: "absolute",
                    top: 0,
                    left: 0,
                    right: 0,
                    height: `${P * q}px`,
                    zIndex: 0
                  }, children: [...Array(P)].map((ct, dt) => /* @__PURE__ */ J.jsx(
                    xe,
                    {
                      sx: {
                        position: "absolute",
                        width: "100%",
                        height: `${q}px`,
                        top: `${dt * q}px`,
                        bgcolor: dt % 2 === 0 ? "rgba(255, 255, 255, 0.02)" : "transparent",
                        borderBottom: 1,
                        borderColor: "rgba(50, 50, 50, 0.5)",
                        boxSizing: "border-box"
                      }
                    },
                    `row-bg-${dt}`
                  )) }),
                  [...Array(V + 1)].map((ct, dt) => /* @__PURE__ */ J.jsx(
                    xe,
                    {
                      sx: {
                        position: "absolute",
                        height: "100%",
                        width: "1px",
                        left: `${dt * U}px`,
                        bgcolor: dt % 4 === 0 ? "rgba(100, 100, 100, 0.5)" : "rgba(50, 50, 50, 0.5)",
                        zIndex: 1
                      }
                    },
                    `gridline-${dt}`
                  )),
                  h.map((ct) => {
                    const dt = K(ct.row);
                    return dt === -1 ? null : /* @__PURE__ */ J.jsxs(
                      xe,
                      {
                        sx: {
                          position: "absolute",
                          top: `${dt * q + 2}px`,
                          left: `${ct.column * U}px`,
                          width: `${ct.length * U - 1}px`,
                          height: `${q - 4}px`,
                          bgcolor: "#ff9800",
                          backgroundImage: "linear-gradient(to bottom, rgba(255,255,255,0.1) 0%, rgba(0,0,0,0.1) 100%)",
                          borderRadius: "3px",
                          cursor: "move",
                          opacity: f === ct.id || _ === ct.id ? 0.75 : 1,
                          "&:hover": {
                            boxShadow: "0 0 0 1px rgba(255,255,255,0.5)",
                            "& .resize-handle": {
                              opacity: 1
                            }
                          },
                          zIndex: 2
                        },
                        onClick: (ht) => vt(ht, ct.id),
                        onMouseDown: (ht) => it(ht, ct.id),
                        children: [
                          /* @__PURE__ */ J.jsx(
                            xe,
                            {
                              className: "resize-handle",
                              sx: {
                                position: "absolute",
                                left: 0,
                                top: 0,
                                bottom: 0,
                                width: "4px",
                                cursor: "ew-resize",
                                bgcolor: "rgba(0,0,0,0.3)",
                                opacity: 0,
                                transition: "opacity 0.2s",
                                borderTopLeftRadius: "3px",
                                borderBottomLeftRadius: "3px",
                                "&:hover": {
                                  opacity: 1,
                                  bgcolor: "rgba(0,0,0,0.5)"
                                }
                              },
                              onMouseDown: (ht) => nt(ht, ct.id, "left")
                            }
                          ),
                          /* @__PURE__ */ J.jsx(
                            xe,
                            {
                              className: "resize-handle",
                              sx: {
                                position: "absolute",
                                right: 0,
                                top: 0,
                                bottom: 0,
                                width: "4px",
                                cursor: "ew-resize",
                                bgcolor: "rgba(0,0,0,0.3)",
                                opacity: 0,
                                transition: "opacity 0.2s",
                                borderTopRightRadius: "3px",
                                borderBottomRightRadius: "3px",
                                "&:hover": {
                                  opacity: 1,
                                  bgcolor: "rgba(0,0,0,0.5)"
                                }
                              },
                              onMouseDown: (ht) => nt(ht, ct.id, "right")
                            }
                          )
                        ]
                      },
                      ct.id
                    );
                  })
                ]
              }
            )
          }
        )
      ] })
    }
  ) });
}, GL = ({ trackId: e }) => {
  const { openedPianoRolls: t, closePianoRoll: n } = qh(), i = t[e] || !1, { tracks: s } = op(), o = s.find((g) => g.id === e), u = () => {
    n(e);
  };
  if (!o) return null;
  const h = o.type === "drum", f = `${h ? "Drum Editor" : "Piano Roll"} - ${o.name}`, p = an.useMemo(() => {
    const g = window.innerWidth, v = window.innerHeight;
    return {
      x: Math.max(0, (g - 840) / 2),
      y: Math.max(0, (v - 500) / 3)
      // Position slightly above center
    };
  }, []);
  return /* @__PURE__ */ J.jsx(
    BU,
    {
      isOpen: i,
      onClose: u,
      title: f,
      initialPosition: p,
      initialSize: { width: 840, height: 500 },
      children: /* @__PURE__ */ J.jsxs(xe, { sx: { height: "100%", display: "flex", flexDirection: "column" }, children: [
        /* @__PURE__ */ J.jsx(xe, { sx: {
          height: "40px",
          bgcolor: "#222",
          borderBottom: "1px solid #333",
          display: "flex",
          alignItems: "center",
          px: 1
        }, children: /* @__PURE__ */ J.jsxs(Wa, { variant: "body2", sx: { color: "#aaa", mr: 2 }, children: [
          "Track: ",
          o.name
        ] }) }),
        /* @__PURE__ */ J.jsx(xe, { sx: { flex: 1, overflow: "hidden" }, children: h ? /* @__PURE__ */ J.jsx(qL, { trackId: e }) : /* @__PURE__ */ J.jsx(FL, { trackId: e, color: a_(s.findIndex((g) => g.id === e)) }) })
      ] })
    }
  );
}, c3 = ({
  trackId: e,
  width: t,
  height: n,
  trackColor: i
}) => {
  const { notesByTrack: s } = qh(), o = s[e] || [];
  let u = 127, h = 0;
  if (o.length > 0 ? o.forEach((b) => {
    b.row < u && (u = b.row), b.row > h && (h = b.row), b.column + b.length;
  }) : (u = 60, h = 72), h - u < 6) {
    const b = Math.floor((h + u) / 2);
    u = b - 3, h = b + 3;
  }
  u = Math.max(0, u - 2), h = Math.min(127, h + 2);
  const f = h - u + 1, g = n / f, x = t / 64;
  return /* @__PURE__ */ J.jsxs(
    xe,
    {
      sx: {
        width: "100%",
        // Extend width to fit notes
        height: "100%",
        position: "relative",
        overflow: "hidden"
        // Allow content to extend beyond container
      },
      children: [
        o.map((b) => {
          const _ = b.column * x, A = (h - b.row) * g, O = b.length * x, M = g * 0.9;
          return /* @__PURE__ */ J.jsx(
            xe,
            {
              sx: {
                position: "absolute",
                left: `${_}px`,
                top: `${A}px`,
                width: `${O}px`,
                height: `${M}px`,
                bgcolor: "white",
                opacity: 1,
                borderRadius: "2px",
                boxSizing: "border-box",
                boxShadow: "0 0 3px rgba(255,255,255,0.7)"
              }
            },
            b.id
          );
        }),
        o.length === 0 && /* @__PURE__ */ J.jsx(xe, { sx: {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          width: "100%",
          height: "100%",
          opacity: 0.6,
          fontSize: "10px",
          color: "#fff"
        }, children: Array.from({ length: 12 }).map((b, _) => /* @__PURE__ */ J.jsx(
          xe,
          {
            sx: {
              height: Math.random() * 12 + 4,
              width: 4,
              mx: 0.5,
              bgcolor: "white",
              borderRadius: "2px"
            }
          },
          _
        )) })
      ]
    }
  );
}, HL = ({ children: e }) => /* @__PURE__ */ J.jsx(DU, { children: e }), KL = () => {
  const { openedPianoRolls: e } = qh();
  console.log("Rendering PianoRollWindows with state:", e);
  const t = Object.entries(e).filter(([n, i]) => i);
  return t.length === 0 ? null : /* @__PURE__ */ J.jsx(J.Fragment, { children: t.map(([n, i]) => /* @__PURE__ */ J.jsx(GL, { trackId: n }, `piano-roll-${n}`)) });
}, YL = ({
  track: e,
  isPlaying: t,
  currentTime: n,
  measureCount: i,
  gridLineStyle: s,
  onPositionChange: o,
  bpm: u,
  timeSignature: h = [4, 4],
  trackIndex: f = 0
}) => {
  const p = an.useRef(null), [g, v] = an.useState(!1), [x, b] = an.useState({ x: 0, y: 0 }), [_, T] = an.useState({ x: 0, y: 0 }), A = an.useRef(e.position), O = an.useMemo(() => e._calculatedWidth || 500, [e._calculatedWidth]), M = a_(f), E = {
    display: "flex",
    height: bn.trackHeight,
    position: "absolute",
    boxSizing: "border-box",
    borderBottom: `1px solid ${bn.borderColor}`,
    borderRadius: "6px",
    left: `${e.position.x}px`,
    top: `${e.position.y}px`,
    cursor: g ? "grabbing" : "grab",
    zIndex: g ? 1001 : 1e3,
    transition: g ? "none" : "width 0.2s ease",
    "&:hover": {
      boxShadow: `0 0 12px ${M}`,
      zIndex: 9999
    },
    bgcolor: "rgba(26, 26, 26, 0.8)",
    margin: 0,
    padding: 0,
    width: typeof O == "number" ? `${O}px` : "100%",
    overflow: "hidden"
  }, R = (q) => {
    var V;
    if (!p.current) {
      console.error("TrackPreview: trackRef is null in mouseDown");
      return;
    }
    if (q.target.closest(".track-control")) {
      console.log("TrackPreview: Clicked on control - not dragging");
      return;
    }
    const j = p.current.closest(".timeline-container") || p.current.closest(".MuiBox-root") || ((V = p.current.parentElement) == null ? void 0 : V.parentElement);
    if (!j) {
      console.error("TrackPreview: Could not find container element for drag");
      return;
    }
    console.log("TrackPreview: Starting drag", {
      trackId: e.id,
      initialPosition: e.position,
      containerFound: !!j,
      containerElement: j,
      scrollLeft: j.scrollLeft,
      scrollTop: j.scrollTop
    }), b({
      x: q.clientX + (j.scrollLeft || 0),
      y: q.clientY + (j.scrollTop || 0)
    }), T({
      x: e.position.x,
      y: e.position.y
    }), A.current = e.position, p.current && (p.current.style.left = `${e.position.x}px`, p.current.style.top = `${e.position.y}px`, p.current.style.transition = "none"), v(!0), q.preventDefault();
  }, N = an.useCallback((q) => {
    var ct;
    if (!g)
      return;
    if (!p.current) {
      console.error("TrackPreview: trackRef is null in mouseMove");
      return;
    }
    const j = p.current.closest(".timeline-container") || p.current.closest(".MuiBox-root") || ((ct = p.current.parentElement) == null ? void 0 : ct.parentElement);
    if (!j) {
      console.error("TrackPreview: Could not find container element in mouseMove");
      return;
    }
    console.log("TrackPreview: Mouse move", {
      isDragging: g,
      mousePosition: { x: q.clientX, y: q.clientY },
      scrollOffset: { left: j.scrollLeft, top: j.scrollTop },
      startDragMousePosition: x,
      startDragTrackPosition: _
    });
    const V = q.clientX + j.scrollLeft, D = q.clientY + j.scrollTop, G = V - x.x, W = D - x.y, P = _.x + G, H = _.y + W, I = (dt, ht) => Math.round(dt / ht) * ht, K = h[0], Q = h[1], it = K * Q, nt = bn.measureWidth / it, X = I(P, nt), rt = I(H, bn.trackHeight), vt = {
      x: Math.max(0, X),
      // Prevent negative X
      y: Math.max(0, rt)
      // Prevent negative Y
    };
    p.current && (p.current.style.left = `${vt.x}px`, p.current.style.top = `${vt.y}px`), console.log("TrackPreview: Visual update during drag", {
      trackId: e.id,
      visualPosition: vt,
      styleUpdated: !!p.current
    }), A.current = vt;
  }, [g, x, _, e.id, h]), U = an.useCallback(() => {
    console.log("TrackPreview: Mouse up", {
      isDragging: g,
      trackId: e.id,
      lastPosition: A.current
    }), g && p.current && (console.log("TrackPreview: Final position update", {
      trackId: e.id,
      finalPosition: A.current,
      isDragEnd: !0
    }), o(e.id, A.current, !0)), p.current && (p.current.style.transition = "left 0.2s ease, top 0.2s ease"), v(!1);
  }, [g, e.id, o]);
  return an.useEffect(() => (g && (window.addEventListener("mousemove", N), window.addEventListener("mouseup", U)), () => {
    window.removeEventListener("mousemove", N), window.removeEventListener("mouseup", U);
  }), [g, N, U]), an.useEffect(() => {
    p.current && !g && (console.log("Track position sync effect:", {
      trackId: e.id,
      x: e.position.x,
      y: e.position.y
    }), p.current.style.left = `${e.position.x}px`, p.current.style.top = `${e.position.y}px`);
  }, [e.position.x, e.position.y, e.id, g]), /* @__PURE__ */ J.jsx(
    xe,
    {
      ref: p,
      onMouseDown: R,
      className: "track",
      sx: E,
      children: /* @__PURE__ */ J.jsxs(xe, { sx: {
        display: "flex",
        flex: 1,
        position: "relative",
        overflow: "hidden",
        height: "100%",
        width: typeof O == "number" ? `${O}px` : "100%",
        margin: 0,
        padding: 0,
        boxSizing: "border-box",
        borderLeft: "none",
        borderRight: "none",
        background: `linear-gradient(180deg, ${M}80 0%, ${M} 100%)`,
        opacity: e.muted ? 0.4 : 0.85,
        "&:hover": {
          opacity: e.muted ? 0.5 : 1,
          boxShadow: "inset 0 0 10px rgba(255,255,255,0.3)"
        },
        transition: "opacity 0.2s ease"
      }, children: [
        /* @__PURE__ */ J.jsx(xe, { sx: {
          position: "absolute",
          right: 10,
          top: 5,
          bgcolor: e.type === "audio" ? "#4caf50" : e.type === "midi" ? "#2196f3" : e.type === "drum" ? "#ff9800" : "#9c27b0",
          color: "white",
          fontSize: "10px",
          fontWeight: "bold",
          padding: "2px 6px",
          borderRadius: "3px",
          textTransform: "uppercase",
          opacity: 0.7
        }, children: e.type }),
        /* @__PURE__ */ J.jsxs(xe, { sx: {
          position: "absolute",
          top: "0",
          left: "0",
          width: "100%",
          height: "100%",
          display: "flex",
          alignItems: "center",
          justifyContent: "flex-start",
          opacity: 0.8,
          // Full opacity for all track types
          pointerEvents: "none"
          // Don't interfere with drag events
        }, children: [
          e.type === "audio" && e.audioFile && /* @__PURE__ */ J.jsx(
            eN,
            {
              audioFile: e.audioFile,
              trackColor: M,
              duration: e.duration || 0,
              width: typeof O == "number" ? O : 500
            }
          ),
          e.type === "audio" && !e.audioFile && Array.from({ length: 40 }).map((q, j) => /* @__PURE__ */ J.jsx(
            xe,
            {
              sx: {
                height: Math.sin(j * 0.3) * 10 + 10,
                width: 2,
                bgcolor: "rgba(255,255,255,0.7)",
                mx: 0.2
              }
            },
            j
          )),
          e.type === "midi" && /* @__PURE__ */ J.jsxs(J.Fragment, { children: [
            /* @__PURE__ */ J.jsx(
              xe,
              {
                className: "piano-roll-trigger",
                "data-testid": "piano-roll-trigger",
                "data-track-id": e.id,
                "data-track-type": e.type,
                sx: {
                  position: "absolute",
                  top: 0,
                  left: 0,
                  width: "100%",
                  height: "100%",
                  cursor: "pointer",
                  zIndex: 100,
                  // Increased zIndex to ensure it's on top
                  opacity: 0.3,
                  // Make more visible for debugging
                  backgroundColor: "rgba(0, 100, 255, 0.1)",
                  // Add background color
                  "&:hover": {
                    bgcolor: "rgba(255,255,255,0.3)"
                  }
                }
              }
            ),
            /* @__PURE__ */ J.jsx(
              c3,
              {
                trackId: e.id,
                width: typeof O == "number" ? O : 500,
                height: bn.trackHeight - 6,
                trackColor: M
              }
            )
          ] }),
          e.type === "drum" && /* @__PURE__ */ J.jsxs(J.Fragment, { children: [
            /* @__PURE__ */ J.jsx(
              xe,
              {
                className: "piano-roll-trigger",
                "data-testid": "piano-roll-trigger",
                "data-track-id": e.id,
                "data-track-type": e.type,
                sx: {
                  position: "absolute",
                  top: 0,
                  left: 0,
                  width: "100%",
                  height: "100%",
                  cursor: "pointer",
                  zIndex: 10,
                  opacity: 0.1,
                  // Make slightly visible for debugging
                  "&:hover": {
                    bgcolor: "rgba(255,255,255,0.15)"
                  }
                }
              }
            ),
            /* @__PURE__ */ J.jsx(
              c3,
              {
                trackId: e.id,
                width: typeof O == "number" ? O : 500,
                height: bn.trackHeight - 6,
                trackColor: M
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ J.jsx(xe, { sx: {
          position: "absolute",
          left: 10,
          top: 6,
          color: "white",
          fontSize: "12px",
          fontWeight: "bold",
          textShadow: "1px 1px 2px rgba(0,0,0,0.7)"
        }, children: e.name }),
        e.muted && /* @__PURE__ */ J.jsx(xe, { sx: {
          position: "absolute",
          width: "100%",
          height: "100%",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          backgroundColor: "rgba(0,0,0,0.4)",
          color: "white",
          fontSize: "14px",
          fontWeight: "bold"
        }, children: "MUTED" })
      ] })
    }
  );
}, XL = an.memo(YL, (e, t) => !(e.track.position.x !== t.track.position.x || e.track.position.y !== t.track.position.y || e.track.muted !== t.track.muted || e.track._calculatedWidth !== t.track._calculatedWidth || e.isPlaying !== t.isPlaying || e.currentTime !== t.currentTime || e.measureCount !== t.measureCount || e.bpm !== t.bpm));
function WL(e) {
  var U;
  const {
    name: t,
    id: n,
    type: i,
    audioFile: s,
    isPlaying: o,
    currentTime: u,
    measureCount: h,
    gridLineStyle: f,
    position: p,
    onPositionChange: g,
    bpm: v,
    duration: x,
    _calculatedWidth: b,
    index: _,
    timeSignature: T = [4, 4]
  } = e, A = op((q) => q.store), O = (U = A == null ? void 0 : A.getTrackById) == null ? void 0 : U.call(A, n), { openPianoRoll: M } = qh(), E = {
    name: t,
    id: n,
    type: i,
    audioFile: s,
    position: p,
    duration: x,
    _calculatedWidth: b,
    // Get actual values from the store if available, otherwise use defaults
    muted: (O == null ? void 0 : O.muted) ?? !1,
    soloed: (O == null ? void 0 : O.soloed) ?? !1,
    volume: (O == null ? void 0 : O.volume) ?? 80,
    pan: (O == null ? void 0 : O.pan) ?? 0,
    channel: (O == null ? void 0 : O.channel) ?? {}
  }, R = (q) => {
    console.log("Track clicked", {
      target: q.target,
      trackId: n,
      type: i,
      eventType: q.type
    }), i === "midi" || i === "drum" ? (q.stopPropagation(), console.log("Opening piano roll for track:", {
      trackId: n,
      type: i
    }), M(n)) : console.log("Not opening piano roll - track type is not midi or drum:", i);
  }, N = (q, j, V) => {
    console.log("Track: Position change called", {
      trackId: q,
      newPosition: j,
      oldPosition: p,
      isDragEnd: V
    }), g(j, V);
  };
  return /* @__PURE__ */ J.jsx(
    xe,
    {
      onClick: R,
      sx: {
        position: "relative",
        cursor: "pointer"
      },
      "data-track-id": n,
      "data-track-type": i,
      children: /* @__PURE__ */ J.jsx(
        XL,
        {
          track: E,
          isPlaying: o,
          currentTime: u,
          measureCount: h,
          gridLineStyle: f,
          onPositionChange: N,
          bpm: v,
          timeSignature: T,
          trackIndex: _
        }
      )
    }
  );
}
function aC({ currentTime: e, isPlaying: t = !1, bpm: n = 120, timeSignature: i = [4, 4] }) {
  const s = ZO(e, n, i), o = bn.cursorColor, u = bn.cursorColorInactive;
  return /* @__PURE__ */ J.jsx(
    xe,
    {
      sx: {
        position: "absolute",
        left: `${s}px`,
        top: 0,
        bottom: 0,
        width: "2px",
        bgcolor: t ? o : u,
        // Red when playing, gray when paused
        zIndex: 1500,
        // Higher z-index to stay on top
        pointerEvents: "none",
        transition: t ? "none" : "left 0.1s ease-out",
        // Smooth transition when manually positioning
        boxShadow: t ? "0 0 8px rgba(255, 85, 85, 0.6)" : "none",
        // Glow effect when playing
        "&::before": {
          content: '""',
          position: "absolute",
          top: 0,
          left: "-4px",
          width: 0,
          height: 0,
          borderLeft: "5px solid transparent",
          borderRight: "5px solid transparent",
          borderTop: `8px solid ${t ? o : u}`,
          zIndex: 1501
        }
      }
    }
  );
}
const $L = tt.forwardRef(({
  tracks: e,
  currentTime: t = 0,
  isPlaying: n = !1,
  measureCount: i = bn.measureCount,
  zoomLevel: s = 1,
  bpm: o = 120,
  timeSignature: u = [4, 4],
  onTrackPositionChange: h = () => {
  },
  onTimeChange: f = () => {
  },
  gridLineStyle: p = {
    borderRight: `${bn.borderWidth} solid ${bn.borderColor}`
  }
}, g) => {
  const v = i * bn.measureWidth;
  return /* @__PURE__ */ J.jsxs(
    xe,
    {
      ref: g,
      className: "timeline-container",
      sx: {
        flex: 1,
        position: "relative",
        overflow: "auto"
      },
      children: [
        /* @__PURE__ */ J.jsx(
          aC,
          {
            currentTime: t,
            isPlaying: n,
            bpm: o,
            timeSignature: u
          }
        ),
        /* @__PURE__ */ J.jsx(
          QL,
          {
            measureCount: i,
            zoomLevel: s,
            gridLineStyle: p,
            bpm: o,
            timeSignature: u,
            onTimeChange: f,
            totalWidth: v
          }
        ),
        e.length > -1 ? /* @__PURE__ */ J.jsx(
          ZL,
          {
            tracks: e,
            measureCount: i,
            zoomLevel: s,
            currentTime: t,
            isPlaying: n,
            bpm: o,
            timeSignature: u,
            gridLineStyle: p,
            onTrackPositionChange: h,
            onTimeChange: f,
            totalWidth: v
          }
        ) : /* @__PURE__ */ J.jsx(tV, { onTimeChange: f, bpm: o, timeSignature: u })
      ]
    }
  );
});
function QL({ measureCount: e, zoomLevel: t, bpm: n = 120, timeSignature: i = [4, 4], onTimeChange: s = () => {
}, gridLineStyle: o, totalWidth: u }) {
  const h = i[0], f = bn.measureWidth / h, p = (g) => {
    const v = g.currentTarget.getBoundingClientRect(), x = g.clientX - v.left, b = x / t, _ = r_(b, n, i);
    console.log("Timeline ruler clicked!", {
      clickX: x,
      adjustedX: b,
      newTime: _,
      zoomLevel: t,
      bpm: n,
      timeSignature: i
    }), s(_);
  };
  return /* @__PURE__ */ J.jsx(
    xe,
    {
      sx: {
        display: "flex",
        position: "sticky",
        top: 0,
        bgcolor: "#111",
        zIndex: 2,
        height: bn.headerHeight,
        boxSizing: "border-box",
        transform: `scaleX(${t})`,
        willChange: "transform",
        imageRendering: "crisp-edges",
        transformOrigin: "top left",
        borderBottom: "1px solid #444",
        boxShadow: `
          inset 0 12px 12px -10px rgba(255,255,255,0.12),
          0 1px 6px rgba(0,0,0,0.4)
        `,
        background: `
          linear-gradient(180deg, 
            rgba(255,255,255,0.08) 0%, 
            rgba(17,17,17,1) 30%
          )
        `,
        "& > div > div > div": {
          "&:first-of-type": {
            top: "8px",
            fontSize: "14px"
          }
        }
      },
      style: {
        width: u ? `${u}px` : "100%"
      },
      children: /* @__PURE__ */ J.jsxs(
        xe,
        {
          sx: {
            display: "flex",
            position: "relative",
            width: "100%",
            // Ensure it fills the full width
            cursor: "pointer"
            // Show pointer cursor to indicate clickable
          },
          onClick: p,
          children: [
            Array.from({ length: e }).map((g, v) => /* @__PURE__ */ J.jsxs(
              xe,
              {
                sx: {
                  position: "relative",
                  width: bn.measureWidth,
                  height: "100%",
                  display: "flex"
                },
                children: [
                  /* @__PURE__ */ J.jsx(xe, { sx: {
                    position: "absolute",
                    top: "8px",
                    left: "6px",
                    fontSize: "14px",
                    fontWeight: "bold",
                    color: "#999",
                    userSelect: "none"
                  }, children: v + 1 }),
                  Array.from({ length: h }).map((x, b) => /* @__PURE__ */ J.jsxs(
                    xe,
                    {
                      sx: {
                        position: "relative",
                        width: f,
                        height: "100%",
                        borderLeft: b === 0 ? "1px solid #555" : "1px solid #333",
                        // Lighter line for beats
                        "&:first-of-type": {
                          borderLeft: "1px solid #555"
                          // Ensure first beat has stronger line
                        }
                      },
                      children: [
                        b !== 0 && /* @__PURE__ */ J.jsx(xe, { sx: {
                          position: "absolute",
                          bottom: "6px",
                          left: "4px",
                          width: "100%",
                          textAlign: "left",
                          fontSize: "8px",
                          color: "#777",
                          userSelect: "none"
                        }, children: b + 1 }),
                        b !== h && (() => {
                          const _ = i[1], T = _ - 1;
                          return T <= 0 ? null : Array.from({ length: T }).map((A, O) => {
                            const M = (O + 1) * (f / _), R = O === Math.floor(T / 2) - 1 ? "#444" : "#333";
                            return /* @__PURE__ */ J.jsx(
                              xe,
                              {
                                sx: {
                                  position: "absolute",
                                  top: "95%",
                                  left: `${M}px`,
                                  height: "4px",
                                  width: "1px",
                                  bgcolor: R,
                                  transform: "translateY(-2px)"
                                }
                              },
                              `sub-${v}-${b}-${O}`
                            );
                          });
                        })()
                      ]
                    },
                    `beat-${v}-${b}`
                  ))
                ]
              },
              `measure-${v}`
            )),
            /* @__PURE__ */ J.jsx(
              xe,
              {
                sx: {
                  position: "absolute",
                  right: 0,
                  top: 0,
                  bottom: 0,
                  width: "1px",
                  bgcolor: "#555"
                }
              }
            )
          ]
        }
      )
    }
  );
}
function ZL({
  tracks: e,
  measureCount: t,
  zoomLevel: n,
  currentTime: i,
  isPlaying: s,
  bpm: o,
  timeSignature: u,
  gridLineStyle: h,
  onTrackPositionChange: f,
  onTimeChange: p,
  totalWidth: g
}) {
  const v = (x) => {
    if (x.target.closest(".track")) {
      console.log("Click on track - ignoring for timeline click");
      return;
    }
    const b = x.currentTarget.getBoundingClientRect(), _ = x.clientX - b.left, T = _ / n, A = r_(T, o, u);
    console.log("Timeline content clicked!", {
      clickX: _,
      adjustedX: T,
      newTime: A,
      zoomLevel: n,
      bpm: o,
      timeSignature: u,
      target: x.target,
      currentTarget: x.currentTarget
    }), p(A);
  };
  return /* @__PURE__ */ J.jsxs(
    xe,
    {
      sx: {
        minHeight: "100%",
        position: "relative",
        transform: `scaleX(${n})`,
        willChange: "transform",
        imageRendering: "crisp-edges",
        transformOrigin: "top left",
        cursor: "pointer"
        // Show pointer cursor to indicate clickable
      },
      style: {
        width: g ? `${g}px` : "100%"
      },
      onClick: v,
      children: [
        /* @__PURE__ */ J.jsx(JL, { measureCount: t, timeSignature: u }),
        e.map((x, b) => /* @__PURE__ */ J.jsx(
          WL,
          {
            id: x.id,
            name: x.name,
            index: b,
            type: x.type,
            audioFile: x.audioFile,
            isPlaying: s,
            currentTime: i,
            gridLineStyle: h,
            measureCount: bn.measureCount,
            position: x.position,
            onPositionChange: (_, T) => f(x.id, _, T),
            bpm: o,
            duration: x.duration,
            _calculatedWidth: x._calculatedWidth,
            timeSignature: u
          },
          x.id
        ))
      ]
    }
  );
}
function JL({ measureCount: e, timeSignature: t = [4, 4] }) {
  const n = an.useRef(null), i = an.useRef(null), s = t[0], o = bn.measureWidth / s;
  return an.useEffect(() => {
    const u = n.current, h = i.current;
    if (!u || !h) return;
    const f = new ResizeObserver((g) => {
      for (const v of g)
        v.target === h && (u.width = h.clientWidth, u.height = h.clientHeight, p());
    });
    f.observe(h), u.width = h.clientWidth, u.height = h.clientHeight;
    function p() {
      const g = u.getContext("2d");
      if (!g) return;
      const v = window.devicePixelRatio || 1;
      u.width = h.clientWidth * v, u.height = h.clientHeight * v, g.scale(v, v), g.clearRect(0, 0, h.clientWidth, h.clientHeight), t[1];
      const x = "rgba(85, 85, 85, 0.9)", b = "rgba(51, 51, 51, 0.7)", _ = (M, E, R) => {
        const N = Math.round(M) + 0.5;
        g.beginPath(), g.moveTo(N, 0), g.lineTo(N, h.clientHeight), g.strokeStyle = R || `rgba(34, 34, 34, ${E})`, g.lineWidth = 1, g.stroke();
      };
      console.log(`Drawing grid with time signature ${t[0]}/${t[1]}`);
      const T = t[1], A = e * s, O = o / T;
      console.log("Grid subdivision calculation:", {
        measureWidth: bn.measureWidth,
        beatsPerMeasure: s,
        beatWidth: o,
        denominator: t[1],
        subdivisionsPerBeat: T,
        subdivisionWidth: O,
        expectedSubdivisionsPerMeasure: s * T
      });
      for (let M = 0; M < A; M++) {
        const E = M * o;
        for (let R = 1; R < T; R++) {
          const N = E + R * O;
          let U = 0.15;
          const q = R === Math.floor(T / 2), j = R === Math.floor(T / 4) || R === Math.floor(3 * T / 4);
          q ? U = 0.7 : j ? U = 0.5 : U = 0.35, _(N, U);
        }
      }
      for (let M = 0; M <= A; M++)
        if (M % s !== 0) {
          const E = M * o;
          _(E, 0.7, b);
        }
      for (let M = 0; M <= e; M++) {
        const E = M * bn.measureWidth;
        _(E, 0.9, x);
      }
    }
    return p(), () => {
      f.disconnect();
    };
  }, [e, s, o, t]), /* @__PURE__ */ J.jsx(
    xe,
    {
      ref: i,
      sx: {
        position: "absolute",
        top: 0,
        left: 0,
        bottom: 0,
        width: "100%",
        // Fill the full width of the parent container
        pointerEvents: "none",
        // Important: this makes the grid not catch any mouse events
        zIndex: 1e3
      },
      children: /* @__PURE__ */ J.jsx(
        "canvas",
        {
          ref: n,
          style: {
            position: "absolute",
            top: 0,
            left: 0,
            width: "100%",
            height: "100%",
            display: "block"
          }
        }
      )
    }
  );
}
function tV({ onTimeChange: e = () => {
}, bpm: t = 120, timeSignature: n = [4, 4] }) {
  return /* @__PURE__ */ J.jsxs(xe, { sx: {
    flex: 1,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    flexDirection: "column",
    color: "#666",
    height: "100%",
    border: "2px dashed #333",
    m: 2,
    borderRadius: 2,
    position: "relative"
    // For positioning the cursor inside
  }, children: [
    /* @__PURE__ */ J.jsx(xe, { sx: { fontSize: 24, mb: 1 }, children: "♫" }),
    /* @__PURE__ */ J.jsx(xe, { children: "Drop a loop or an audio/MIDI/Video file" }),
    /* @__PURE__ */ J.jsx(aC, { currentTime: 0, isPlaying: !1, bpm: t, timeSignature: n })
  ] });
}
const eV = Ba(/* @__PURE__ */ J.jsx("path", {
  d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2m-5 11.5h.25V19h-4.5v-4.5H10c.55 0 1-.45 1-1V5h2v8.5c0 .55.45 1 1 1M5 5h2v8.5c0 .55.45 1 1 1h.25V19H5zm14 14h-3.25v-4.5H16c.55 0 1-.45 1-1V5h2z"
}), "Piano"), nV = Ba(/* @__PURE__ */ J.jsx("path", {
  d: "M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8zm2 11h-3v3.75c0 1.24-1.01 2.25-2.25 2.25S8.5 17.99 8.5 16.75s1.01-2.25 2.25-2.25c.46 0 .89.14 1.25.38V11h4zm-3-4V3.5L18.5 9z"
}), "AudioFile"), iV = Ba(/* @__PURE__ */ J.jsx("path", {
  d: "M7 18h2V6H7zm4 4h2V2h-2zm-8-8h2v-4H3zm12 4h2V6h-2zm4-8v4h2v-4z"
}), "GraphicEq"), rV = ({
  isOpen: e,
  anchorEl: t,
  onClose: n,
  onAddTrack: i,
  onFileUpload: s
}) => {
  const o = (u) => {
    const h = u.target.files;
    if (h && h.length > 0) {
      const f = h[0];
      s && s(f), n();
    }
  };
  return /* @__PURE__ */ J.jsxs(
    J2,
    {
      open: e,
      anchorEl: t,
      onClose: n,
      PaperProps: {
        sx: { bgcolor: "#222", color: "white", minWidth: 180 }
      },
      children: [
        /* @__PURE__ */ J.jsxs(
          Sc,
          {
            onClick: () => {
              i("midi"), n();
            },
            sx: {
              fontSize: "13px",
              py: 1,
              "&:hover": {
                bgcolor: "rgba(33, 150, 243, 0.2)"
              }
            },
            children: [
              /* @__PURE__ */ J.jsx(db, { children: /* @__PURE__ */ J.jsx(eV, { sx: { color: "#2196f3" } }) }),
              /* @__PURE__ */ J.jsx(hb, { primary: "MIDI Track" })
            ]
          }
        ),
        /* @__PURE__ */ J.jsxs(
          Sc,
          {
            onClick: () => {
              i("drum"), n();
            },
            sx: {
              fontSize: "13px",
              py: 1,
              "&:hover": {
                bgcolor: "rgba(255, 152, 0, 0.2)"
              }
            },
            children: [
              /* @__PURE__ */ J.jsx(db, { children: /* @__PURE__ */ J.jsx(iV, { sx: { color: "#ff9800" } }) }),
              /* @__PURE__ */ J.jsx(hb, { primary: "Drum Machine" })
            ]
          }
        ),
        /* @__PURE__ */ J.jsx(e2, { sx: { bgcolor: "#444" } }),
        /* @__PURE__ */ J.jsx(
          Sc,
          {
            sx: {
              fontSize: "13px",
              py: 1,
              "&:hover": {
                bgcolor: "rgba(76, 175, 80, 0.2)"
              }
            },
            children: /* @__PURE__ */ J.jsxs("label", { style: { display: "flex", alignItems: "center", width: "100%", cursor: "pointer" }, children: [
              /* @__PURE__ */ J.jsx(db, { children: /* @__PURE__ */ J.jsx(nV, { sx: { color: "#4caf50" } }) }),
              /* @__PURE__ */ J.jsx(hb, { primary: "Import Audio" }),
              /* @__PURE__ */ J.jsx(
                "input",
                {
                  type: "file",
                  accept: "audio/*",
                  style: { display: "none" },
                  onChange: o
                }
              )
            ] })
          }
        )
      ]
    }
  );
};
function aV() {
  const { openPianoRoll: e } = qh(), { tracks: t } = op(), n = () => {
    const i = t.find((s) => s.type === "midi" || s.type === "drum");
    i ? (console.log("TEST: Opening piano roll for track:", i.id), e(i.id)) : (console.log("TEST: No MIDI or drum tracks found to open piano roll"), op.getState().handleAddTrack("midi"));
  };
  return /* @__PURE__ */ J.jsx(
    Gf,
    {
      variant: "contained",
      color: "error",
      onClick: n,
      sx: { fontSize: "10px" },
      children: "Test Piano Roll"
    }
  );
}
function sV() {
  const {
    store: e,
    tracks: t,
    isPlaying: n,
    currentTime: i,
    bpm: s,
    timeSignature: o,
    keySignature: u,
    zoomLevel: h,
    projectTitle: f,
    canUndo: p,
    canRedo: g,
    measureCount: v,
    isInitialized: x,
    addMenuAnchor: b,
    // Actions
    initializeAudio: _,
    setZoomLevel: T,
    setProjectTitle: A,
    setTimeSignature: O,
    setKeySignature: M,
    playPause: E,
    stop: R,
    setCurrentTime: N,
    setMeasureCount: U,
    undo: q,
    redo: j,
    handleTrackVolumeChange: V,
    handleTrackPanChange: D,
    handleTrackMuteToggle: G,
    handleTrackSoloToggle: W,
    handleTrackDelete: P,
    handleAddTrack: H,
    handleTrackPositionChange: I,
    handleTrackNameChange: K,
    uploadAudioFile: Q,
    setBpm: it,
    setAddMenuAnchor: nt
  } = op(), X = tt.useRef(null), rt = tt.useRef(null);
  tt.useEffect(() => (_(), () => {
    delete window.storeInstance;
  }), [_]);
  const vt = (lt) => {
    const ft = parseInt(lt.target.value, 10);
    !isNaN(ft) && ft > 0 && ft <= 999 && it(ft);
  }, ct = (lt, ft) => {
    const [Tt, Bt] = o;
    O(
      lt ?? Tt,
      ft ?? Bt
    );
  }, dt = () => {
    T(Math.min(h + 0.1, 4));
  }, ht = () => {
    T(Math.max(h - 0.1, 0.3));
  }, Et = (lt) => {
    A(lt.target.value);
  };
  tt.useEffect(() => {
    if (!n || !e) return;
    const lt = () => {
      const ft = e.getTransport();
      ft && (N(ft.position), rt.current = requestAnimationFrame(lt));
    };
    return rt.current = requestAnimationFrame(lt), () => {
      rt.current && cancelAnimationFrame(rt.current);
    };
  }, [n, e, N]);
  const ot = an.useCallback(() => {
    if (!X.current) return;
    const { scrollLeft: lt, scrollWidth: ft, clientWidth: Tt } = X.current;
    lt + Tt >= ft - 100 && U(v + 20);
  }, [v, U]);
  return tt.useEffect(() => {
    const lt = X.current;
    if (!lt) return;
    const ft = () => requestAnimationFrame(ot);
    return lt.addEventListener("scroll", ft), () => lt.removeEventListener("scroll", ft);
  }, [ot]), /* @__PURE__ */ J.jsxs(xe, { sx: {
    height: "100vh",
    bgcolor: "#000000",
    color: "white",
    display: "flex",
    flexDirection: "column"
  }, children: [
    /* @__PURE__ */ J.jsxs(xe, { sx: {
      display: "flex",
      alignItems: "center",
      p: 1,
      borderBottom: "1px solid #333",
      gap: 2,
      paddingLeft: 2,
      position: "relative",
      zIndex: 1300
    }, children: [
      /* @__PURE__ */ J.jsxs(xe, { sx: { display: "flex", gap: 1 }, children: [
        /* @__PURE__ */ J.jsx(
          Od,
          {
            size: "small",
            sx: { color: p ? "white" : "#666" },
            onClick: q,
            disabled: !p,
            title: "Undo",
            children: /* @__PURE__ */ J.jsx(VO, {})
          }
        ),
        /* @__PURE__ */ J.jsx(
          Od,
          {
            size: "small",
            sx: { color: g ? "white" : "#666" },
            onClick: j,
            disabled: !g,
            title: "Redo",
            children: /* @__PURE__ */ J.jsx(IO, {})
          }
        )
      ] }),
      /* @__PURE__ */ J.jsx(xe, { sx: {
        display: "flex",
        alignItems: "center",
        bgcolor: "#1E1E1E",
        borderRadius: 1,
        px: 2,
        py: 0.5,
        gap: 1
      }, children: /* @__PURE__ */ J.jsx(qO, { bpm: s, onBpmChange: vt }) }),
      /* @__PURE__ */ J.jsx(
        GO,
        {
          topNumber: o[0],
          bottomNumber: o[1],
          onTopNumberChange: (lt) => ct(lt, void 0),
          onBottomNumberChange: (lt) => ct(void 0, lt)
        }
      ),
      /* @__PURE__ */ J.jsx(
        YO,
        {
          selectedKey: u,
          onKeyChange: M
        }
      ),
      /* @__PURE__ */ J.jsxs(xe, { sx: { display: "flex", gap: 1 }, children: [
        /* @__PURE__ */ J.jsx(
          Od,
          {
            size: "small",
            sx: { color: "white" },
            onClick: E,
            children: n ? /* @__PURE__ */ J.jsx(PO, {}) : /* @__PURE__ */ J.jsx(zO, {})
          }
        ),
        /* @__PURE__ */ J.jsx(
          Od,
          {
            size: "small",
            sx: { color: "white" },
            onClick: R,
            children: /* @__PURE__ */ J.jsx(UO, {})
          }
        )
      ] }),
      /* @__PURE__ */ J.jsx(xe, { sx: {
        position: "absolute",
        left: "50%",
        top: "50%",
        transform: "translate(-50%, -50%)",
        zIndex: 1
      }, children: /* @__PURE__ */ J.jsx(
        i_,
        {
          variant: "standard",
          value: f,
          onChange: Et,
          sx: {
            "& input": {
              color: "white",
              textAlign: "center",
              fontSize: "1rem",
              fontWeight: 500,
              padding: "4px 8px",
              "&:hover": {
                backgroundColor: "rgba(255, 255, 255, 0.05)"
              }
            },
            "& .MuiInput-underline:before": {
              borderBottom: "none"
            },
            "& .MuiInput-underline:hover:before": {
              borderBottom: "1px solid rgba(255, 255, 255, 0.2)"
            },
            "& .MuiInput-underline:after": {
              borderBottom: "2px solid white"
            }
          }
        }
      ) }),
      /* @__PURE__ */ J.jsx(xe, { sx: {
        marginLeft: "auto",
        display: "flex",
        alignItems: "center",
        gap: 2,
        pr: 2
      }, children: /* @__PURE__ */ J.jsxs(xe, { sx: {
        display: "flex",
        alignItems: "center",
        gap: 1
      }, children: [
        /* @__PURE__ */ J.jsx(Od, { size: "small", sx: { color: "white" }, onClick: dt, children: /* @__PURE__ */ J.jsx(jO, {}) }),
        /* @__PURE__ */ J.jsxs(xe, { sx: { color: "white", fontWeight: "bold", backgroundColor: "#333", minWidth: 40, textAlign: "center", border: "1px solid rgba(255, 255, 255, 0.2)", padding: "4px 4px", borderRadius: "6px" }, children: [
          h.toFixed(1),
          "x"
        ] }),
        /* @__PURE__ */ J.jsx(Od, { size: "small", sx: { color: "white" }, onClick: ht, children: /* @__PURE__ */ J.jsx(LO, {}) })
      ] }) })
    ] }),
    /* @__PURE__ */ J.jsxs(xe, { sx: {
      display: "flex",
      flex: 1,
      overflow: "hidden",
      position: "relative"
    }, children: [
      /* @__PURE__ */ J.jsx(xe, { sx: {
        position: "absolute",
        top: 10,
        right: 10,
        zIndex: 9999
      }, children: /* @__PURE__ */ J.jsx(aV, {}) }),
      /* @__PURE__ */ J.jsxs(xe, { sx: {
        width: bn.sidebarWidth,
        borderRight: `${bn.borderWidth} solid ${bn.borderColor}`,
        bgcolor: "#1A1A1A",
        display: "flex",
        flexDirection: "column"
      }, children: [
        /* @__PURE__ */ J.jsx(xe, { sx: {
          height: bn.headerHeight,
          borderBottom: `${bn.borderWidth} solid ${bn.borderColor}`,
          display: "flex",
          alignItems: "center",
          p: 0.3,
          boxSizing: "border-box"
        }, children: /* @__PURE__ */ J.jsxs(xe, { sx: {
          position: "relative",
          display: "flex",
          width: "100%"
        }, children: [
          /* @__PURE__ */ J.jsx(
            Gf,
            {
              startIcon: /* @__PURE__ */ J.jsx(FO, {}),
              variant: "contained",
              onClick: (lt) => nt(lt.currentTarget),
              sx: {
                bgcolor: "#1A1A1A",
                color: "white",
                "&:hover": { bgcolor: "#444" },
                height: 24,
                textTransform: "none",
                width: "100%",
                mx: "auto",
                display: "flex",
                fontSize: "12px",
                fontWeight: "bold"
              },
              children: "Add Track"
            }
          ),
          /* @__PURE__ */ J.jsx(
            rV,
            {
              isOpen: !!b,
              anchorEl: b,
              onClose: () => nt(null),
              onAddTrack: H,
              onFileUpload: Q
            }
          )
        ] }) }),
        /* @__PURE__ */ J.jsx(xe, { sx: {
          flex: 1,
          overflow: "auto"
        }, children: /* @__PURE__ */ J.jsx(
          JO,
          {
            tracks: t,
            onVolumeChange: V,
            onPanChange: D,
            onMuteToggle: G,
            onSoloToggle: W,
            onTrackDelete: P,
            onTrackNameChange: K
          }
        ) })
      ] }),
      /* @__PURE__ */ J.jsx(
        $L,
        {
          tracks: t,
          currentTime: i,
          isPlaying: n,
          measureCount: v,
          zoomLevel: h,
          bpm: s,
          timeSignature: o,
          onTrackPositionChange: I,
          onTimeChange: (lt) => {
            N(lt), e && e.getTransport() && e.getTransport().setPosition(lt);
          },
          gridLineStyle: {
            borderRight: `${bn.borderWidth} solid ${bn.borderColor}`
          },
          ref: X
        }
      )
    ] })
  ] });
}
const oV = () => /* @__PURE__ */ J.jsxs(HL, { children: [
  /* @__PURE__ */ J.jsx(sV, {}),
  /* @__PURE__ */ J.jsx(KL, {})
] }), sC = () => (tt.useEffect(() => {
  document.getElementById("studio-vite-root") && (document.body.style.overflow = "hidden", document.body.style.margin = "0", document.body.style.padding = "0");
}, []), /* @__PURE__ */ J.jsx(oV, {})), oC = j1({
  typography: {
    fontFamily: '"Sen", sans-serif'
  },
  palette: {
    mode: "dark",
    background: {
      default: "#000000"
    }
  }
});
document.getElementById("root") && d3.createRoot(document.getElementById("root")).render(
  /* @__PURE__ */ J.jsx(an.StrictMode, { children: /* @__PURE__ */ J.jsx(eT, { theme: oC, children: /* @__PURE__ */ J.jsx(sC, {}) }) })
);
const ku = {}, lC = (e) => {
  if (ku[e])
    try {
      console.log(`Unmounting existing root for ${e}`), ku[e].unmount(), delete ku[e];
    } catch (n) {
      console.error(`Error unmounting root for ${e}:`, n);
    }
  const t = document.getElementById(e);
  if (t)
    try {
      console.log(`Creating new root for ${e}`);
      const n = d3.createRoot(t);
      return ku[e] = n, n.render(
        // Using StrictMode in production can cause double-mounting, which might 
        // contribute to cleanup issues
        /* @__PURE__ */ J.jsx(eT, { theme: oC, children: /* @__PURE__ */ J.jsx(sC, {}) })
      ), console.log(`Successfully mounted to ${e}`), !0;
    } catch (n) {
      return console.error(`Error mounting to ${e}:`, n), !1;
    }
  return console.warn(`Element with ID ${e} not found`), !1;
}, lV = (e) => {
  if (ku[e])
    try {
      return ku[e].unmount(), delete ku[e], !0;
    } catch (t) {
      return console.error(`Error unmounting from ${e}:`, t), !1;
    }
  return !1;
};
console.log("Exposing mountStudioVite and unmountStudioVite functions to window object");
window.mountStudioVite = lC;
window.unmountStudioVite = lV;
window.addEventListener("beforeunload", () => {
  Object.keys(ku).forEach((e) => {
    try {
      ku[e].unmount();
    } catch (t) {
      console.error(`Error unmounting ${e} during page unload:`, t);
    }
  });
});
document.getElementById("studio-vite-root") && (console.log("Auto-mounting to studio-vite-root"), lC("studio-vite-root"));
export {
  lC as mountStudioVite,
  lV as unmountStudioVite
};
//# sourceMappingURL=main.js.map
